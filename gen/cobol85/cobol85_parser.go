// Code generated from java-escape by ANTLR 4.11.1. DO NOT EDIT.

package cobol85 // Cobol85
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr/antlr4/runtime/Go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type Cobol85Parser struct {
	*antlr.BaseParser
}

var cobol85ParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	literalNames           []string
	symbolicNames          []string
	ruleNames              []string
	predictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func cobol85ParserInit() {
	staticData := &cobol85ParserStaticData
	staticData.literalNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "'&'", "'*'",
		"'**'", "':'", "','", "'*>CE'", "'*>'", "'$'", "'\"'", "", "'.'", "'='",
		"'*>EXECCICS'", "'*>EXECSQL'", "'*>EXECSQLIMS'", "'<'", "'<='", "'('",
		"'-'", "'>'", "'>='", "'<>'", "'+'", "'''", "')'", "'/'", "", "'66'",
		"'77'", "'88'", "", "", "", "", "", "", "", "", "", "", "', '",
	}
	staticData.symbolicNames = []string{
		"", "ABORT", "ACCEPT", "ACCESS", "ADD", "ADDRESS", "ADVANCING", "AFTER",
		"ALIGNED", "ALL", "ALPHABET", "ALPHABETIC", "ALPHABETIC_LOWER", "ALPHABETIC_UPPER",
		"ALPHANUMERIC", "ALPHANUMERIC_EDITED", "ALSO", "ALTER", "ALTERNATE",
		"AND", "ANY", "ARE", "AREA", "AREAS", "AS", "ASCENDING", "ASCII", "ASSIGN",
		"ASSOCIATED_DATA", "ASSOCIATED_DATA_LENGTH", "AT", "ATTRIBUTE", "AUTHOR",
		"AUTO", "AUTO_SKIP", "BACKGROUND_COLOR", "BACKGROUND_COLOUR", "BASIS",
		"BEEP", "BEFORE", "BEGINNING", "BELL", "BINARY", "BIT", "BLANK", "BLINK",
		"BLOCK", "BOUNDS", "BOTTOM", "BY", "BYFUNCTION", "BYTITLE", "CALL",
		"CANCEL", "CAPABLE", "CCSVERSION", "CD", "CF", "CH", "CHAINING", "CHANGED",
		"CHANNEL", "CHARACTER", "CHARACTERS", "CLASS", "CLASS_ID", "CLOCK_UNITS",
		"CLOSE", "CLOSE_DISPOSITION", "COBOL", "CODE", "CODE_SET", "COLLATING",
		"COL", "COLUMN", "COM_REG", "COMMA", "COMMITMENT", "COMMON", "COMMUNICATION",
		"COMP", "COMP_1", "COMP_2", "COMP_3", "COMP_4", "COMP_5", "COMPUTATIONAL",
		"COMPUTATIONAL_1", "COMPUTATIONAL_2", "COMPUTATIONAL_3", "COMPUTATIONAL_4",
		"COMPUTATIONAL_5", "COMPUTE", "CONFIGURATION", "CONTAINS", "CONTENT",
		"CONTINUE", "CONTROL", "CONTROL_POINT", "CONTROLS", "CONVENTION", "CONVERTING",
		"COPY", "CORR", "CORRESPONDING", "COUNT", "CRUNCH", "CURRENCY", "CURSOR",
		"DATA", "DATA_BASE", "DATE", "DATE_COMPILED", "DATE_WRITTEN", "DAY",
		"DAY_OF_WEEK", "DBCS", "DE", "DEBUG_CONTENTS", "DEBUG_ITEM", "DEBUG_LINE",
		"DEBUG_NAME", "DEBUG_SUB_1", "DEBUG_SUB_2", "DEBUG_SUB_3", "DEBUGGING",
		"DECIMAL_POINT", "DECLARATIVES", "DEFAULT", "DEFAULT_DISPLAY", "DEFINITION",
		"DELETE", "DELIMITED", "DELIMITER", "DEPENDING", "DESCENDING", "DESTINATION",
		"DETAIL", "DFHRESP", "DFHVALUE", "DISABLE", "DISK", "DISPLAY", "DISPLAY_1",
		"DIVIDE", "DIVISION", "DONTCARE", "DOUBLE", "DOWN", "DUPLICATES", "DYNAMIC",
		"EBCDIC", "EGCS", "EGI", "ELSE", "EMI", "EMPTY_CHECK", "ENABLE", "END",
		"END_ACCEPT", "END_ADD", "END_CALL", "END_COMPUTE", "END_DELETE", "END_DIVIDE",
		"END_EVALUATE", "END_IF", "END_MULTIPLY", "END_OF_PAGE", "END_PERFORM",
		"END_READ", "END_RECEIVE", "END_RETURN", "END_REWRITE", "END_SEARCH",
		"END_START", "END_STRING", "END_SUBTRACT", "END_UNSTRING", "END_WRITE",
		"ENDING", "ENTER", "ENTRY", "ENTRY_PROCEDURE", "ENVIRONMENT", "EOP",
		"EQUAL", "ERASE", "ERROR", "EOL", "EOS", "ESCAPE", "ESI", "EVALUATE",
		"EVENT", "EVERY", "EXCEPTION", "EXCLUSIVE", "EXHIBIT", "EXIT", "EXPORT",
		"EXTEND", "EXTENDED", "EXTERNAL", "FALSE", "FD", "FILE", "FILE_CONTROL",
		"FILLER", "FINAL", "FIRST", "FOOTING", "FOR", "FOREGROUND_COLOR", "FOREGROUND_COLOUR",
		"FROM", "FULL", "FUNCTION", "FUNCTIONNAME", "FUNCTION_POINTER", "GENERATE",
		"GOBACK", "GIVING", "GLOBAL", "GO", "GREATER", "GRID", "GROUP", "HEADING",
		"HIGHLIGHT", "HIGH_VALUE", "HIGH_VALUES", "I_O", "I_O_CONTROL", "ID",
		"IDENTIFICATION", "IF", "IMPLICIT", "IMPORT", "IN", "INDEX", "INDEXED",
		"INDICATE", "INITIAL", "INITIALIZE", "INITIATE", "INPUT", "INPUT_OUTPUT",
		"INSPECT", "INSTALLATION", "INTEGER", "INTO", "INVALID", "INVOKE", "IS",
		"JUST", "JUSTIFIED", "KANJI", "KEPT", "KEY", "KEYBOARD", "LABEL", "LANGUAGE",
		"LAST", "LB", "LD", "LEADING", "LEFT", "LEFTLINE", "LENGTH", "LENGTH_CHECK",
		"LESS", "LIBACCESS", "LIBPARAMETER", "LIBRARY", "LIMIT", "LIMITS", "LINAGE",
		"LINAGE_COUNTER", "LINE", "LINES", "LINE_COUNTER", "LINKAGE", "LIST",
		"LOCAL", "LOCAL_STORAGE", "LOCK", "LONG_DATE", "LONG_TIME", "LOWER",
		"LOWLIGHT", "LOW_VALUE", "LOW_VALUES", "MEMORY", "MERGE", "MESSAGE",
		"MMDDYYYY", "MODE", "MODULES", "MORE_LABELS", "MOVE", "MULTIPLE", "MULTIPLY",
		"NAMED", "NATIONAL", "NATIONAL_EDITED", "NATIVE", "NEGATIVE", "NETWORK",
		"NEXT", "NO", "NO_ECHO", "NOT", "NULL_", "NULLS", "NUMBER", "NUMERIC",
		"NUMERIC_DATE", "NUMERIC_EDITED", "NUMERIC_TIME", "OBJECT_COMPUTER",
		"OCCURS", "ODT", "OF", "OFF", "OMITTED", "ON", "OPEN", "OPTIONAL", "OR",
		"ORDER", "ORDERLY", "ORGANIZATION", "OTHER", "OUTPUT", "OVERFLOW", "OVERLINE",
		"OWN", "PACKED_DECIMAL", "PADDING", "PAGE", "PAGE_COUNTER", "PASSWORD",
		"PERFORM", "PF", "PH", "PIC", "PICTURE", "PLUS", "POINTER", "POSITION",
		"POSITIVE", "PORT", "PRINTER", "PRINTING", "PRIVATE", "PROCEDURE", "PROCEDURE_POINTER",
		"PROCEDURES", "PROCEED", "PROCESS", "PROGRAM", "PROGRAM_ID", "PROGRAM_LIBRARY",
		"PROMPT", "PURGE", "QUEUE", "QUOTE", "QUOTES", "RANDOM", "READER", "REMOTE",
		"RD", "REAL", "READ", "RECEIVE", "RECEIVED", "RECORD", "RECORDING",
		"RECORDS", "RECURSIVE", "REDEFINES", "REEL", "REF", "REFERENCE", "REFERENCES",
		"RELATIVE", "RELEASE", "REMAINDER", "REMARKS", "REMOVAL", "REMOVE",
		"RENAMES", "REPLACE", "REPLACING", "REPORT", "REPORTING", "REPORTS",
		"REQUIRED", "RERUN", "RESERVE", "REVERSE_VIDEO", "RESET", "RETURN",
		"RETURN_CODE", "RETURNING", "REVERSED", "REWIND", "REWRITE", "RF", "RH",
		"RIGHT", "ROUNDED", "RUN", "SAME", "SAVE", "SCREEN", "SD", "SEARCH",
		"SECTION", "SECURE", "SECURITY", "SEGMENT", "SEGMENT_LIMIT", "SELECT",
		"SEND", "SENTENCE", "SEPARATE", "SEQUENCE", "SEQUENTIAL", "SET", "SHARED",
		"SHAREDBYALL", "SHAREDBYRUNUNIT", "SHARING", "SHIFT_IN", "SHIFT_OUT",
		"SHORT_DATE", "SIGN", "SIZE", "SORT", "SORT_CONTROL", "SORT_CORE_SIZE",
		"SORT_FILE_SIZE", "SORT_MERGE", "SORT_MESSAGE", "SORT_MODE_SIZE", "SORT_RETURN",
		"SOURCE", "SOURCE_COMPUTER", "SPACE", "SPACES", "SPECIAL_NAMES", "STANDARD",
		"STANDARD_1", "STANDARD_2", "START", "STATUS", "STOP", "STRING", "SUB_QUEUE_1",
		"SUB_QUEUE_2", "SUB_QUEUE_3", "SUBTRACT", "SUM", "SUPPRESS", "SYMBOL",
		"SYMBOLIC", "SYNC", "SYNCHRONIZED", "TABLE", "TALLY", "TALLYING", "TASK",
		"TAPE", "TERMINAL", "TERMINATE", "TEST", "TEXT", "THAN", "THEN", "THREAD",
		"THREAD_LOCAL", "THROUGH", "THRU", "TIME", "TIMER", "TIMES", "TITLE",
		"TO", "TODAYS_DATE", "TODAYS_NAME", "TOP", "TRAILING", "TRUE", "TRUNCATED",
		"TYPE", "TYPEDEF", "UNDERLINE", "UNIT", "UNSTRING", "UNTIL", "UP", "UPON",
		"USAGE", "USE", "USING", "VALUE", "VALUES", "VARYING", "VIRTUAL", "WAIT",
		"WHEN", "WHEN_COMPILED", "WITH", "WORDS", "WORKING_STORAGE", "WRITE",
		"YEAR", "YYYYMMDD", "YYYYDDD", "ZERO", "ZERO_FILL", "ZEROS", "ZEROES",
		"AMPCHAR", "ASTERISKCHAR", "DOUBLEASTERISKCHAR", "COLONCHAR", "COMMACHAR",
		"COMMENTENTRYTAG", "COMMENTTAG", "DOLLARCHAR", "DOUBLEQUOTE", "DOT_FS",
		"DOT", "EQUALCHAR", "EXECCICSTAG", "EXECSQLTAG", "EXECSQLIMSTAG", "LESSTHANCHAR",
		"LESSTHANOREQUAL", "LPARENCHAR", "MINUSCHAR", "MORETHANCHAR", "MORETHANOREQUAL",
		"NOTEQUALCHAR", "PLUSCHAR", "SINGLEQUOTE", "RPARENCHAR", "SLASHCHAR",
		"NONNUMERICLITERAL", "LEVEL_NUMBER_66", "LEVEL_NUMBER_77", "LEVEL_NUMBER_88",
		"INTEGERLITERAL", "NUMERICLITERAL", "IDENTIFIER", "NEWLINE", "EXECCICSLINE",
		"EXECSQLIMSLINE", "EXECSQLLINE", "COMMENTENTRYLINE", "COMMENTLINE",
		"WS", "SEPARATOR",
	}
	staticData.ruleNames = []string{
		"startRule", "compilationUnit", "programUnit", "endProgramStatement",
		"identificationDivision", "identificationDivisionBody", "programIdParagraph",
		"authorParagraph", "installationParagraph", "dateWrittenParagraph",
		"dateCompiledParagraph", "securityParagraph", "remarksParagraph", "environmentDivision",
		"environmentDivisionBody", "configurationSection", "configurationSectionParagraph",
		"sourceComputerParagraph", "objectComputerParagraph", "objectComputerClause",
		"memorySizeClause", "diskSizeClause", "collatingSequenceClause", "collatingSequenceClauseAlphanumeric",
		"collatingSequenceClauseNational", "segmentLimitClause", "characterSetClause",
		"specialNamesParagraph", "specialNameClause", "alphabetClause", "alphabetClauseFormat1",
		"alphabetLiterals", "alphabetThrough", "alphabetAlso", "alphabetClauseFormat2",
		"channelClause", "classClause", "classClauseThrough", "classClauseFrom",
		"classClauseTo", "currencySignClause", "decimalPointClause", "defaultComputationalSignClause",
		"defaultDisplaySignClause", "environmentSwitchNameClause", "environmentSwitchNameSpecialNamesStatusPhrase",
		"odtClause", "reserveNetworkClause", "symbolicCharactersClause", "symbolicCharacters",
		"inputOutputSection", "inputOutputSectionParagraph", "fileControlParagraph",
		"fileControlEntry", "selectClause", "fileControlClause", "assignClause",
		"reserveClause", "organizationClause", "paddingCharacterClause", "recordDelimiterClause",
		"accessModeClause", "recordKeyClause", "alternateRecordKeyClause", "passwordClause",
		"fileStatusClause", "relativeKeyClause", "ioControlParagraph", "ioControlClause",
		"rerunClause", "rerunEveryRecords", "rerunEveryOf", "rerunEveryClock",
		"sameClause", "multipleFileClause", "multipleFilePosition", "commitmentControlClause",
		"dataDivision", "dataDivisionSection", "fileSection", "fileDescriptionEntry",
		"fileDescriptionEntryClause", "externalClause", "globalClause", "blockContainsClause",
		"blockContainsTo", "recordContainsClause", "recordContainsClauseFormat1",
		"recordContainsClauseFormat2", "recordContainsClauseFormat3", "recordContainsTo",
		"labelRecordsClause", "valueOfClause", "valuePair", "dataRecordsClause",
		"linageClause", "linageAt", "linageFootingAt", "linageLinesAtTop", "linageLinesAtBottom",
		"recordingModeClause", "modeStatement", "codeSetClause", "reportClause",
		"dataBaseSection", "dataBaseSectionEntry", "workingStorageSection",
		"linkageSection", "communicationSection", "communicationDescriptionEntry",
		"communicationDescriptionEntryFormat1", "communicationDescriptionEntryFormat2",
		"communicationDescriptionEntryFormat3", "destinationCountClause", "destinationTableClause",
		"endKeyClause", "errorKeyClause", "messageCountClause", "messageDateClause",
		"messageTimeClause", "statusKeyClause", "symbolicDestinationClause",
		"symbolicQueueClause", "symbolicSourceClause", "symbolicTerminalClause",
		"symbolicSubQueueClause", "textLengthClause", "localStorageSection",
		"screenSection", "screenDescriptionEntry", "screenDescriptionBlankClause",
		"screenDescriptionBellClause", "screenDescriptionBlinkClause", "screenDescriptionEraseClause",
		"screenDescriptionLightClause", "screenDescriptionGridClause", "screenDescriptionReverseVideoClause",
		"screenDescriptionUnderlineClause", "screenDescriptionSizeClause", "screenDescriptionLineClause",
		"screenDescriptionColumnClause", "screenDescriptionForegroundColorClause",
		"screenDescriptionBackgroundColorClause", "screenDescriptionControlClause",
		"screenDescriptionValueClause", "screenDescriptionPictureClause", "screenDescriptionFromClause",
		"screenDescriptionToClause", "screenDescriptionUsingClause", "screenDescriptionUsageClause",
		"screenDescriptionBlankWhenZeroClause", "screenDescriptionJustifiedClause",
		"screenDescriptionSignClause", "screenDescriptionAutoClause", "screenDescriptionSecureClause",
		"screenDescriptionRequiredClause", "screenDescriptionPromptClause",
		"screenDescriptionPromptOccursClause", "screenDescriptionFullClause",
		"screenDescriptionZeroFillClause", "reportSection", "reportDescription",
		"reportDescriptionEntry", "reportDescriptionGlobalClause", "reportDescriptionPageLimitClause",
		"reportDescriptionHeadingClause", "reportDescriptionFirstDetailClause",
		"reportDescriptionLastDetailClause", "reportDescriptionFootingClause",
		"reportGroupDescriptionEntry", "reportGroupDescriptionEntryFormat1",
		"reportGroupDescriptionEntryFormat2", "reportGroupDescriptionEntryFormat3",
		"reportGroupBlankWhenZeroClause", "reportGroupColumnNumberClause", "reportGroupIndicateClause",
		"reportGroupJustifiedClause", "reportGroupLineNumberClause", "reportGroupLineNumberNextPage",
		"reportGroupLineNumberPlus", "reportGroupNextGroupClause", "reportGroupNextGroupPlus",
		"reportGroupNextGroupNextPage", "reportGroupPictureClause", "reportGroupResetClause",
		"reportGroupSignClause", "reportGroupSourceClause", "reportGroupSumClause",
		"reportGroupTypeClause", "reportGroupTypeReportHeading", "reportGroupTypePageHeading",
		"reportGroupTypeControlHeading", "reportGroupTypeDetail", "reportGroupTypeControlFooting",
		"reportGroupUsageClause", "reportGroupTypePageFooting", "reportGroupTypeReportFooting",
		"reportGroupValueClause", "programLibrarySection", "libraryDescriptionEntry",
		"libraryDescriptionEntryFormat1", "libraryDescriptionEntryFormat2",
		"libraryAttributeClauseFormat1", "libraryAttributeClauseFormat2", "libraryAttributeFunction",
		"libraryAttributeParameter", "libraryAttributeTitle", "libraryEntryProcedureClauseFormat1",
		"libraryEntryProcedureClauseFormat2", "libraryEntryProcedureForClause",
		"libraryEntryProcedureGivingClause", "libraryEntryProcedureUsingClause",
		"libraryEntryProcedureUsingName", "libraryEntryProcedureWithClause",
		"libraryEntryProcedureWithName", "libraryIsCommonClause", "libraryIsGlobalClause",
		"dataDescriptionEntry", "dataDescriptionEntryFormat1", "dataDescriptionEntryFormat2",
		"dataDescriptionEntryFormat3", "dataDescriptionEntryExecSql", "dataAlignedClause",
		"dataBlankWhenZeroClause", "dataCommonOwnLocalClause", "dataExternalClause",
		"dataGlobalClause", "dataIntegerStringClause", "dataJustifiedClause",
		"dataOccursClause", "dataOccursTo", "dataOccursSort", "dataPictureClause",
		"pictureString", "pictureChars", "pictureCardinality", "dataReceivedByClause",
		"dataRecordAreaClause", "dataRedefinesClause", "dataRenamesClause",
		"dataSignClause", "dataSynchronizedClause", "dataThreadLocalClause",
		"dataTypeClause", "dataTypeDefClause", "dataUsageClause", "dataUsingClause",
		"dataValueClause", "dataValueInterval", "dataValueIntervalFrom", "dataValueIntervalTo",
		"dataWithLowerBoundsClause", "procedureDivision", "procedureDivisionUsingClause",
		"procedureDivisionGivingClause", "procedureDivisionUsingParameter",
		"procedureDivisionByReferencePhrase", "procedureDivisionByReference",
		"procedureDivisionByValuePhrase", "procedureDivisionByValue", "procedureDeclaratives",
		"procedureDeclarative", "procedureSectionHeader", "procedureDivisionBody",
		"procedureSection", "paragraphs", "paragraph", "sentence", "statement",
		"acceptStatement", "acceptFromDateStatement", "acceptFromMnemonicStatement",
		"acceptFromEscapeKeyStatement", "acceptMessageCountStatement", "addStatement",
		"addToStatement", "addToGivingStatement", "addCorrespondingStatement",
		"addFrom", "addTo", "addToGiving", "addGiving", "alteredGoTo", "alterStatement",
		"alterProceedTo", "callStatement", "callUsingPhrase", "callUsingParameter",
		"callByReferencePhrase", "callByReference", "callByValuePhrase", "callByValue",
		"callByContentPhrase", "callByContent", "callGivingPhrase", "cancelStatement",
		"cancelCall", "closeStatement", "closeFile", "closeReelUnitStatement",
		"closeRelativeStatement", "closePortFileIOStatement", "closePortFileIOUsing",
		"closePortFileIOUsingCloseDisposition", "closePortFileIOUsingAssociatedData",
		"closePortFileIOUsingAssociatedDataLength", "computeStatement", "computeStore",
		"continueStatement", "deleteStatement", "disableStatement", "displayStatement",
		"displayOperand", "displayAt", "displayUpon", "displayWith", "divideStatement",
		"divideIntoStatement", "divideIntoGivingStatement", "divideByGivingStatement",
		"divideGivingPhrase", "divideInto", "divideGiving", "divideRemainder",
		"enableStatement", "entryStatement", "evaluateStatement", "evaluateSelect",
		"evaluateAlsoSelect", "evaluateWhenPhrase", "evaluateWhen", "evaluateCondition",
		"evaluateThrough", "evaluateAlsoCondition", "evaluateWhenOther", "evaluateValue",
		"execCicsStatement", "execSqlStatement", "execSqlImsStatement", "exhibitStatement",
		"exhibitOperand", "exitStatement", "generateStatement", "gobackStatement",
		"goToStatement", "goToStatementSimple", "goToDependingOnStatement",
		"ifStatement", "ifThen", "ifElse", "initializeStatement", "initializeReplacingPhrase",
		"initializeReplacingBy", "initiateStatement", "inspectStatement", "inspectTallyingPhrase",
		"inspectReplacingPhrase", "inspectTallyingReplacingPhrase", "inspectConvertingPhrase",
		"inspectFor", "inspectCharacters", "inspectReplacingCharacters", "inspectAllLeadings",
		"inspectReplacingAllLeadings", "inspectAllLeading", "inspectReplacingAllLeading",
		"inspectBy", "inspectTo", "inspectBeforeAfter", "mergeStatement", "mergeOnKeyClause",
		"mergeCollatingSequencePhrase", "mergeCollatingAlphanumeric", "mergeCollatingNational",
		"mergeUsing", "mergeOutputProcedurePhrase", "mergeOutputThrough", "mergeGivingPhrase",
		"mergeGiving", "moveStatement", "moveToStatement", "moveToSendingArea",
		"moveCorrespondingToStatement", "moveCorrespondingToSendingArea", "multiplyStatement",
		"multiplyRegular", "multiplyRegularOperand", "multiplyGiving", "multiplyGivingOperand",
		"multiplyGivingResult", "openStatement", "openInputStatement", "openInput",
		"openOutputStatement", "openOutput", "openIOStatement", "openExtendStatement",
		"performStatement", "performInlineStatement", "performProcedureStatement",
		"performType", "performTimes", "performUntil", "performVarying", "performVaryingClause",
		"performVaryingPhrase", "performAfter", "performFrom", "performBy",
		"performTestClause", "purgeStatement", "readStatement", "readInto",
		"readWith", "readKey", "receiveStatement", "receiveFromStatement", "receiveFrom",
		"receiveIntoStatement", "receiveNoData", "receiveWithData", "receiveBefore",
		"receiveWith", "receiveThread", "receiveSize", "receiveStatus", "releaseStatement",
		"returnStatement", "returnInto", "rewriteStatement", "rewriteFrom",
		"searchStatement", "searchVarying", "searchWhen", "sendStatement", "sendStatementSync",
		"sendStatementAsync", "sendFromPhrase", "sendWithPhrase", "sendReplacingPhrase",
		"sendAdvancingPhrase", "sendAdvancingPage", "sendAdvancingLines", "sendAdvancingMnemonic",
		"setStatement", "setToStatement", "setUpDownByStatement", "setTo", "setToValue",
		"setByValue", "sortStatement", "sortOnKeyClause", "sortDuplicatesPhrase",
		"sortCollatingSequencePhrase", "sortCollatingAlphanumeric", "sortCollatingNational",
		"sortInputProcedurePhrase", "sortInputThrough", "sortUsing", "sortOutputProcedurePhrase",
		"sortOutputThrough", "sortGivingPhrase", "sortGiving", "startStatement",
		"startKey", "stopStatement", "stringStatement", "stringSendingPhrase",
		"stringSending", "stringDelimitedByPhrase", "stringForPhrase", "stringIntoPhrase",
		"stringWithPointerPhrase", "subtractStatement", "subtractFromStatement",
		"subtractFromGivingStatement", "subtractCorrespondingStatement", "subtractSubtrahend",
		"subtractMinuend", "subtractMinuendGiving", "subtractGiving", "subtractMinuendCorresponding",
		"terminateStatement", "unstringStatement", "unstringSendingPhrase",
		"unstringDelimitedByPhrase", "unstringOrAllPhrase", "unstringIntoPhrase",
		"unstringInto", "unstringDelimiterIn", "unstringCountIn", "unstringWithPointerPhrase",
		"unstringTallyingPhrase", "useStatement", "useAfterClause", "useAfterOn",
		"useDebugClause", "useDebugOn", "writeStatement", "writeFromPhrase",
		"writeAdvancingPhrase", "writeAdvancingPage", "writeAdvancingLines",
		"writeAdvancingMnemonic", "writeAtEndOfPagePhrase", "writeNotAtEndOfPagePhrase",
		"atEndPhrase", "notAtEndPhrase", "invalidKeyPhrase", "notInvalidKeyPhrase",
		"onOverflowPhrase", "notOnOverflowPhrase", "onSizeErrorPhrase", "notOnSizeErrorPhrase",
		"onExceptionClause", "notOnExceptionClause", "arithmeticExpression",
		"plusMinus", "multDivs", "multDiv", "powers", "power", "basis", "condition",
		"andOrCondition", "combinableCondition", "simpleCondition", "classCondition",
		"conditionNameReference", "conditionNameSubscriptReference", "relationCondition",
		"relationSignCondition", "relationArithmeticComparison", "relationCombinedComparison",
		"relationCombinedCondition", "relationalOperator", "abbreviation", "identifier",
		"tableCall", "functionCall", "referenceModifier", "characterPosition",
		"length", "subscript_", "argument", "qualifiedDataName", "qualifiedDataNameFormat1",
		"qualifiedDataNameFormat2", "qualifiedDataNameFormat3", "qualifiedDataNameFormat4",
		"qualifiedInData", "inData", "inFile", "inMnemonic", "inSection", "inLibrary",
		"inTable", "alphabetName", "assignmentName", "basisName", "cdName",
		"className", "computerName", "conditionName", "dataName", "dataDescName",
		"environmentName", "fileName", "functionName", "indexName", "languageName",
		"libraryName", "localName", "mnemonicName", "paragraphName", "procedureName",
		"programName", "recordName", "reportName", "routineName", "screenName",
		"sectionName", "systemName", "symbolicCharacter", "textName", "cobolWord",
		"literal", "booleanLiteral", "numericLiteral", "integerLiteral", "cicsDfhRespLiteral",
		"cicsDfhValueLiteral", "figurativeConstant", "specialRegister", "commentEntry",
	}
	staticData.predictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 565, 6288, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 2, 418, 7, 418, 2,
		419, 7, 419, 2, 420, 7, 420, 2, 421, 7, 421, 2, 422, 7, 422, 2, 423, 7,
		423, 2, 424, 7, 424, 2, 425, 7, 425, 2, 426, 7, 426, 2, 427, 7, 427, 2,
		428, 7, 428, 2, 429, 7, 429, 2, 430, 7, 430, 2, 431, 7, 431, 2, 432, 7,
		432, 2, 433, 7, 433, 2, 434, 7, 434, 2, 435, 7, 435, 2, 436, 7, 436, 2,
		437, 7, 437, 2, 438, 7, 438, 2, 439, 7, 439, 2, 440, 7, 440, 2, 441, 7,
		441, 2, 442, 7, 442, 2, 443, 7, 443, 2, 444, 7, 444, 2, 445, 7, 445, 2,
		446, 7, 446, 2, 447, 7, 447, 2, 448, 7, 448, 2, 449, 7, 449, 2, 450, 7,
		450, 2, 451, 7, 451, 2, 452, 7, 452, 2, 453, 7, 453, 2, 454, 7, 454, 2,
		455, 7, 455, 2, 456, 7, 456, 2, 457, 7, 457, 2, 458, 7, 458, 2, 459, 7,
		459, 2, 460, 7, 460, 2, 461, 7, 461, 2, 462, 7, 462, 2, 463, 7, 463, 2,
		464, 7, 464, 2, 465, 7, 465, 2, 466, 7, 466, 2, 467, 7, 467, 2, 468, 7,
		468, 2, 469, 7, 469, 2, 470, 7, 470, 2, 471, 7, 471, 2, 472, 7, 472, 2,
		473, 7, 473, 2, 474, 7, 474, 2, 475, 7, 475, 2, 476, 7, 476, 2, 477, 7,
		477, 2, 478, 7, 478, 2, 479, 7, 479, 2, 480, 7, 480, 2, 481, 7, 481, 2,
		482, 7, 482, 2, 483, 7, 483, 2, 484, 7, 484, 2, 485, 7, 485, 2, 486, 7,
		486, 2, 487, 7, 487, 2, 488, 7, 488, 2, 489, 7, 489, 2, 490, 7, 490, 2,
		491, 7, 491, 2, 492, 7, 492, 2, 493, 7, 493, 2, 494, 7, 494, 2, 495, 7,
		495, 2, 496, 7, 496, 2, 497, 7, 497, 2, 498, 7, 498, 2, 499, 7, 499, 2,
		500, 7, 500, 2, 501, 7, 501, 2, 502, 7, 502, 2, 503, 7, 503, 2, 504, 7,
		504, 2, 505, 7, 505, 2, 506, 7, 506, 2, 507, 7, 507, 2, 508, 7, 508, 2,
		509, 7, 509, 2, 510, 7, 510, 2, 511, 7, 511, 2, 512, 7, 512, 2, 513, 7,
		513, 2, 514, 7, 514, 2, 515, 7, 515, 2, 516, 7, 516, 2, 517, 7, 517, 2,
		518, 7, 518, 2, 519, 7, 519, 2, 520, 7, 520, 2, 521, 7, 521, 2, 522, 7,
		522, 2, 523, 7, 523, 2, 524, 7, 524, 2, 525, 7, 525, 2, 526, 7, 526, 2,
		527, 7, 527, 2, 528, 7, 528, 2, 529, 7, 529, 2, 530, 7, 530, 2, 531, 7,
		531, 2, 532, 7, 532, 2, 533, 7, 533, 2, 534, 7, 534, 2, 535, 7, 535, 2,
		536, 7, 536, 2, 537, 7, 537, 2, 538, 7, 538, 2, 539, 7, 539, 2, 540, 7,
		540, 2, 541, 7, 541, 2, 542, 7, 542, 2, 543, 7, 543, 2, 544, 7, 544, 2,
		545, 7, 545, 2, 546, 7, 546, 2, 547, 7, 547, 2, 548, 7, 548, 2, 549, 7,
		549, 2, 550, 7, 550, 2, 551, 7, 551, 2, 552, 7, 552, 2, 553, 7, 553, 2,
		554, 7, 554, 2, 555, 7, 555, 2, 556, 7, 556, 2, 557, 7, 557, 2, 558, 7,
		558, 2, 559, 7, 559, 2, 560, 7, 560, 2, 561, 7, 561, 2, 562, 7, 562, 2,
		563, 7, 563, 2, 564, 7, 564, 2, 565, 7, 565, 2, 566, 7, 566, 2, 567, 7,
		567, 2, 568, 7, 568, 2, 569, 7, 569, 2, 570, 7, 570, 2, 571, 7, 571, 2,
		572, 7, 572, 2, 573, 7, 573, 2, 574, 7, 574, 2, 575, 7, 575, 2, 576, 7,
		576, 2, 577, 7, 577, 2, 578, 7, 578, 2, 579, 7, 579, 2, 580, 7, 580, 2,
		581, 7, 581, 2, 582, 7, 582, 2, 583, 7, 583, 2, 584, 7, 584, 2, 585, 7,
		585, 2, 586, 7, 586, 2, 587, 7, 587, 2, 588, 7, 588, 2, 589, 7, 589, 2,
		590, 7, 590, 2, 591, 7, 591, 2, 592, 7, 592, 2, 593, 7, 593, 2, 594, 7,
		594, 1, 0, 1, 0, 1, 0, 1, 1, 4, 1, 1195, 8, 1, 11, 1, 12, 1, 1196, 1, 2,
		1, 2, 3, 2, 1201, 8, 2, 1, 2, 3, 2, 1204, 8, 2, 1, 2, 3, 2, 1207, 8, 2,
		1, 2, 5, 2, 1210, 8, 2, 10, 2, 12, 2, 1213, 9, 2, 1, 2, 3, 2, 1216, 8,
		2, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 4, 1, 4, 1, 4, 1, 4, 1, 4, 5, 4, 1228,
		8, 4, 10, 4, 12, 4, 1231, 9, 4, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 1, 5, 3,
		5, 1239, 8, 5, 1, 6, 1, 6, 1, 6, 1, 6, 3, 6, 1245, 8, 6, 1, 6, 1, 6, 3,
		6, 1249, 8, 6, 3, 6, 1251, 8, 6, 1, 6, 3, 6, 1254, 8, 6, 1, 6, 3, 6, 1257,
		8, 6, 1, 7, 1, 7, 1, 7, 3, 7, 1262, 8, 7, 1, 8, 1, 8, 1, 8, 3, 8, 1267,
		8, 8, 1, 9, 1, 9, 1, 9, 3, 9, 1272, 8, 9, 1, 10, 1, 10, 1, 10, 3, 10, 1277,
		8, 10, 1, 11, 1, 11, 1, 11, 3, 11, 1282, 8, 11, 1, 12, 1, 12, 1, 12, 3,
		12, 1287, 8, 12, 1, 13, 1, 13, 1, 13, 1, 13, 5, 13, 1293, 8, 13, 10, 13,
		12, 13, 1296, 9, 13, 1, 14, 1, 14, 1, 14, 3, 14, 1301, 8, 14, 1, 15, 1,
		15, 1, 15, 1, 15, 5, 15, 1307, 8, 15, 10, 15, 12, 15, 1310, 9, 15, 1, 16,
		1, 16, 1, 16, 3, 16, 1315, 8, 16, 1, 17, 1, 17, 1, 17, 1, 17, 3, 17, 1321,
		8, 17, 1, 17, 1, 17, 3, 17, 1325, 8, 17, 1, 17, 1, 17, 1, 18, 1, 18, 1,
		18, 1, 18, 5, 18, 1333, 8, 18, 10, 18, 12, 18, 1336, 9, 18, 1, 18, 1, 18,
		1, 19, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1345, 8, 19, 1, 20, 1, 20, 3,
		20, 1349, 8, 20, 1, 20, 1, 20, 3, 20, 1353, 8, 20, 1, 20, 3, 20, 1356,
		8, 20, 1, 21, 1, 21, 3, 21, 1360, 8, 21, 1, 21, 3, 21, 1363, 8, 21, 1,
		21, 1, 21, 3, 21, 1367, 8, 21, 1, 21, 3, 21, 1370, 8, 21, 1, 22, 3, 22,
		1373, 8, 22, 1, 22, 3, 22, 1376, 8, 22, 1, 22, 1, 22, 3, 22, 1380, 8, 22,
		1, 22, 4, 22, 1383, 8, 22, 11, 22, 12, 22, 1384, 1, 22, 3, 22, 1388, 8,
		22, 1, 22, 3, 22, 1391, 8, 22, 1, 23, 3, 23, 1394, 8, 23, 1, 23, 1, 23,
		3, 23, 1398, 8, 23, 1, 23, 1, 23, 1, 24, 3, 24, 1403, 8, 24, 1, 24, 1,
		24, 3, 24, 1407, 8, 24, 1, 24, 1, 24, 1, 25, 1, 25, 3, 25, 1413, 8, 25,
		1, 25, 1, 25, 1, 26, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 4, 27, 1424,
		8, 27, 11, 27, 12, 27, 1425, 1, 27, 1, 27, 3, 27, 1430, 8, 27, 1, 28, 1,
		28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 1, 28, 3, 28,
		1443, 8, 28, 1, 29, 1, 29, 3, 29, 1447, 8, 29, 1, 30, 1, 30, 1, 30, 1,
		30, 3, 30, 1453, 8, 30, 1, 30, 3, 30, 1456, 8, 30, 1, 30, 1, 30, 1, 30,
		1, 30, 1, 30, 1, 30, 1, 30, 4, 30, 1465, 8, 30, 11, 30, 12, 30, 1466, 3,
		30, 1469, 8, 30, 1, 31, 1, 31, 1, 31, 4, 31, 1474, 8, 31, 11, 31, 12, 31,
		1475, 3, 31, 1478, 8, 31, 1, 32, 1, 32, 1, 32, 1, 33, 1, 33, 4, 33, 1485,
		8, 33, 11, 33, 12, 33, 1486, 1, 34, 1, 34, 1, 34, 3, 34, 1492, 8, 34, 1,
		34, 1, 34, 3, 34, 1496, 8, 34, 1, 34, 1, 34, 1, 34, 3, 34, 1501, 8, 34,
		1, 35, 1, 35, 1, 35, 3, 35, 1506, 8, 35, 1, 35, 1, 35, 1, 36, 1, 36, 1,
		36, 3, 36, 1513, 8, 36, 1, 36, 3, 36, 1516, 8, 36, 1, 36, 3, 36, 1519,
		8, 36, 1, 36, 4, 36, 1522, 8, 36, 11, 36, 12, 36, 1523, 1, 37, 1, 37, 1,
		37, 3, 37, 1529, 8, 37, 1, 38, 1, 38, 3, 38, 1533, 8, 38, 1, 39, 1, 39,
		3, 39, 1537, 8, 39, 1, 40, 1, 40, 3, 40, 1541, 8, 40, 1, 40, 3, 40, 1544,
		8, 40, 1, 40, 1, 40, 3, 40, 1548, 8, 40, 1, 40, 1, 40, 1, 40, 3, 40, 1553,
		8, 40, 1, 41, 1, 41, 3, 41, 1557, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 3,
		42, 1563, 8, 42, 1, 42, 1, 42, 3, 42, 1567, 8, 42, 3, 42, 1569, 8, 42,
		1, 42, 3, 42, 1572, 8, 42, 1, 42, 1, 42, 3, 42, 1576, 8, 42, 1, 43, 1,
		43, 1, 43, 3, 43, 1581, 8, 43, 3, 43, 1583, 8, 43, 1, 43, 1, 43, 1, 43,
		3, 43, 1588, 8, 43, 3, 43, 1590, 8, 43, 1, 44, 1, 44, 3, 44, 1594, 8, 44,
		1, 44, 1, 44, 3, 44, 1598, 8, 44, 1, 44, 3, 44, 1601, 8, 44, 1, 45, 1,
		45, 3, 45, 1605, 8, 45, 1, 45, 3, 45, 1608, 8, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 1613, 8, 45, 1, 45, 3, 45, 1616, 8, 45, 1, 45, 3, 45, 1619, 8, 45,
		1, 45, 1, 45, 3, 45, 1623, 8, 45, 1, 45, 3, 45, 1626, 8, 45, 1, 45, 1,
		45, 1, 45, 3, 45, 1631, 8, 45, 1, 45, 3, 45, 1634, 8, 45, 1, 45, 3, 45,
		1637, 8, 45, 3, 45, 1639, 8, 45, 1, 46, 1, 46, 3, 46, 1643, 8, 46, 1, 46,
		1, 46, 1, 47, 1, 47, 3, 47, 1649, 8, 47, 1, 47, 3, 47, 1652, 8, 47, 1,
		47, 3, 47, 1655, 8, 47, 1, 47, 1, 47, 3, 47, 1659, 8, 47, 1, 48, 1, 48,
		3, 48, 1663, 8, 48, 1, 48, 3, 48, 1666, 8, 48, 1, 48, 3, 48, 1669, 8, 48,
		1, 48, 4, 48, 1672, 8, 48, 11, 48, 12, 48, 1673, 1, 48, 1, 48, 3, 48, 1678,
		8, 48, 1, 49, 4, 49, 1681, 8, 49, 11, 49, 12, 49, 1682, 1, 49, 3, 49, 1686,
		8, 49, 1, 49, 4, 49, 1689, 8, 49, 11, 49, 12, 49, 1690, 1, 50, 1, 50, 1,
		50, 1, 50, 5, 50, 1697, 8, 50, 10, 50, 12, 50, 1700, 9, 50, 1, 51, 1, 51,
		3, 51, 1704, 8, 51, 1, 52, 1, 52, 3, 52, 1708, 8, 52, 1, 52, 5, 52, 1711,
		8, 52, 10, 52, 12, 52, 1714, 9, 52, 1, 52, 1, 52, 1, 53, 1, 53, 5, 53,
		1720, 8, 53, 10, 53, 12, 53, 1723, 9, 53, 1, 54, 1, 54, 3, 54, 1727, 8,
		54, 1, 54, 1, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55,
		1, 55, 1, 55, 1, 55, 3, 55, 1742, 8, 55, 1, 56, 1, 56, 3, 56, 1746, 8,
		56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 3, 56, 1759, 8, 56, 1, 57, 1, 57, 1, 57, 3, 57, 1764, 8, 57, 1,
		57, 3, 57, 1767, 8, 57, 1, 57, 3, 57, 1770, 8, 57, 1, 58, 1, 58, 3, 58,
		1774, 8, 58, 3, 58, 1776, 8, 58, 1, 58, 1, 58, 1, 58, 1, 58, 1, 58, 3,
		58, 1783, 8, 58, 1, 58, 1, 58, 1, 59, 1, 59, 3, 59, 1789, 8, 59, 1, 59,
		3, 59, 1792, 8, 59, 1, 59, 1, 59, 3, 59, 1796, 8, 59, 1, 60, 1, 60, 1,
		60, 3, 60, 1801, 8, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1806, 8, 60, 1, 61,
		1, 61, 3, 61, 1810, 8, 61, 1, 61, 3, 61, 1813, 8, 61, 1, 61, 1, 61, 1,
		62, 1, 62, 3, 62, 1819, 8, 62, 1, 62, 3, 62, 1822, 8, 62, 1, 62, 1, 62,
		3, 62, 1826, 8, 62, 1, 62, 3, 62, 1829, 8, 62, 1, 62, 3, 62, 1832, 8, 62,
		1, 63, 1, 63, 1, 63, 3, 63, 1837, 8, 63, 1, 63, 3, 63, 1840, 8, 63, 1,
		63, 1, 63, 3, 63, 1844, 8, 63, 1, 63, 3, 63, 1847, 8, 63, 1, 63, 3, 63,
		1850, 8, 63, 1, 64, 1, 64, 3, 64, 1854, 8, 64, 1, 64, 1, 64, 1, 65, 3,
		65, 1859, 8, 65, 1, 65, 1, 65, 3, 65, 1863, 8, 65, 1, 65, 1, 65, 3, 65,
		1867, 8, 65, 1, 66, 1, 66, 3, 66, 1871, 8, 66, 1, 66, 3, 66, 1874, 8, 66,
		1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1883, 8, 67, 1,
		67, 5, 67, 1886, 8, 67, 10, 67, 12, 67, 1889, 9, 67, 1, 67, 3, 67, 1892,
		8, 67, 1, 68, 1, 68, 1, 68, 1, 68, 3, 68, 1898, 8, 68, 1, 69, 1, 69, 1,
		69, 1, 69, 3, 69, 1904, 8, 69, 3, 69, 1906, 8, 69, 1, 69, 1, 69, 1, 69,
		1, 69, 3, 69, 1912, 8, 69, 1, 70, 1, 70, 1, 70, 1, 71, 3, 71, 1918, 8,
		71, 1, 71, 3, 71, 1921, 8, 71, 1, 71, 1, 71, 1, 71, 1, 71, 1, 72, 1, 72,
		3, 72, 1929, 8, 72, 1, 73, 1, 73, 3, 73, 1933, 8, 73, 1, 73, 3, 73, 1936,
		8, 73, 1, 73, 3, 73, 1939, 8, 73, 1, 73, 4, 73, 1942, 8, 73, 11, 73, 12,
		73, 1943, 1, 74, 1, 74, 1, 74, 3, 74, 1949, 8, 74, 1, 74, 3, 74, 1952,
		8, 74, 1, 74, 4, 74, 1955, 8, 74, 11, 74, 12, 74, 1956, 1, 75, 1, 75, 1,
		75, 3, 75, 1962, 8, 75, 1, 76, 1, 76, 1, 76, 3, 76, 1967, 8, 76, 1, 76,
		1, 76, 1, 77, 1, 77, 1, 77, 1, 77, 5, 77, 1975, 8, 77, 10, 77, 12, 77,
		1978, 9, 77, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1, 78, 1,
		78, 3, 78, 1989, 8, 78, 1, 79, 1, 79, 1, 79, 1, 79, 5, 79, 1995, 8, 79,
		10, 79, 12, 79, 1998, 9, 79, 1, 80, 1, 80, 1, 80, 3, 80, 2003, 8, 80, 1,
		80, 5, 80, 2006, 8, 80, 10, 80, 12, 80, 2009, 9, 80, 1, 80, 1, 80, 5, 80,
		2013, 8, 80, 10, 80, 12, 80, 2016, 9, 80, 1, 81, 1, 81, 1, 81, 1, 81, 1,
		81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 1, 81, 3, 81, 2029, 8, 81, 1, 82,
		3, 82, 2032, 8, 82, 1, 82, 1, 82, 1, 83, 3, 83, 2037, 8, 83, 1, 83, 1,
		83, 1, 84, 1, 84, 3, 84, 2043, 8, 84, 1, 84, 1, 84, 3, 84, 2047, 8, 84,
		1, 84, 3, 84, 2050, 8, 84, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1,
		86, 3, 86, 2059, 8, 86, 1, 87, 3, 87, 2062, 8, 87, 1, 87, 1, 87, 3, 87,
		2066, 8, 87, 1, 88, 3, 88, 2069, 8, 88, 1, 88, 1, 88, 3, 88, 2073, 8, 88,
		1, 88, 3, 88, 2076, 8, 88, 1, 88, 3, 88, 2079, 8, 88, 1, 88, 1, 88, 3,
		88, 2083, 8, 88, 1, 88, 3, 88, 2086, 8, 88, 3, 88, 2088, 8, 88, 1, 88,
		1, 88, 3, 88, 2092, 8, 88, 1, 88, 3, 88, 2095, 8, 88, 1, 89, 3, 89, 2098,
		8, 89, 1, 89, 1, 89, 1, 89, 3, 89, 2103, 8, 89, 1, 90, 1, 90, 1, 90, 1,
		91, 1, 91, 1, 91, 3, 91, 2111, 8, 91, 1, 91, 1, 91, 3, 91, 2115, 8, 91,
		3, 91, 2117, 8, 91, 1, 91, 1, 91, 1, 91, 4, 91, 2122, 8, 91, 11, 91, 12,
		91, 2123, 3, 91, 2126, 8, 91, 1, 92, 1, 92, 1, 92, 4, 92, 2131, 8, 92,
		11, 92, 12, 92, 2132, 1, 93, 1, 93, 3, 93, 2137, 8, 93, 1, 93, 1, 93, 3,
		93, 2141, 8, 93, 1, 94, 1, 94, 1, 94, 3, 94, 2146, 8, 94, 1, 94, 1, 94,
		3, 94, 2150, 8, 94, 3, 94, 2152, 8, 94, 1, 94, 4, 94, 2155, 8, 94, 11,
		94, 12, 94, 2156, 1, 95, 1, 95, 3, 95, 2161, 8, 95, 1, 95, 1, 95, 3, 95,
		2165, 8, 95, 1, 95, 3, 95, 2168, 8, 95, 1, 95, 5, 95, 2171, 8, 95, 10,
		95, 12, 95, 2174, 9, 95, 1, 96, 1, 96, 1, 96, 3, 96, 2179, 8, 96, 1, 97,
		3, 97, 2182, 8, 97, 1, 97, 1, 97, 3, 97, 2186, 8, 97, 1, 97, 1, 97, 3,
		97, 2190, 8, 97, 1, 98, 3, 98, 2193, 8, 98, 1, 98, 3, 98, 2196, 8, 98,
		1, 98, 1, 98, 1, 98, 3, 98, 2201, 8, 98, 1, 99, 3, 99, 2204, 8, 99, 1,
		99, 3, 99, 2207, 8, 99, 1, 99, 1, 99, 1, 99, 3, 99, 2212, 8, 99, 1, 100,
		1, 100, 3, 100, 2216, 8, 100, 1, 100, 3, 100, 2219, 8, 100, 1, 100, 1,
		100, 1, 101, 1, 101, 1, 102, 1, 102, 3, 102, 2227, 8, 102, 1, 102, 1, 102,
		1, 103, 1, 103, 3, 103, 2233, 8, 103, 1, 103, 1, 103, 3, 103, 2237, 8,
		103, 3, 103, 2239, 8, 103, 1, 103, 4, 103, 2242, 8, 103, 11, 103, 12, 103,
		2243, 1, 104, 1, 104, 1, 104, 1, 104, 5, 104, 2250, 8, 104, 10, 104, 12,
		104, 2253, 9, 104, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 106, 1, 106,
		1, 106, 1, 106, 5, 106, 2264, 8, 106, 10, 106, 12, 106, 2267, 9, 106, 1,
		107, 1, 107, 1, 107, 1, 107, 5, 107, 2273, 8, 107, 10, 107, 12, 107, 2276,
		9, 107, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 5, 108, 2283, 8, 108, 10,
		108, 12, 108, 2286, 9, 108, 1, 109, 1, 109, 1, 109, 3, 109, 2291, 8, 109,
		1, 110, 1, 110, 1, 110, 3, 110, 2296, 8, 110, 1, 110, 3, 110, 2299, 8,
		110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1, 110, 1,
		110, 1, 110, 3, 110, 2311, 8, 110, 1, 110, 5, 110, 2314, 8, 110, 10, 110,
		12, 110, 2317, 9, 110, 1, 110, 1, 110, 1, 111, 1, 111, 1, 111, 3, 111,
		2324, 8, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 1, 111, 5,
		111, 2333, 8, 111, 10, 111, 12, 111, 2336, 9, 111, 1, 111, 1, 111, 1, 112,
		1, 112, 1, 112, 3, 112, 2343, 8, 112, 1, 112, 1, 112, 1, 112, 1, 112, 1,
		112, 1, 112, 1, 112, 1, 112, 3, 112, 2353, 8, 112, 1, 112, 5, 112, 2356,
		8, 112, 10, 112, 12, 112, 2359, 9, 112, 1, 112, 1, 112, 1, 113, 1, 113,
		1, 113, 3, 113, 2366, 8, 113, 1, 113, 1, 113, 1, 114, 1, 114, 1, 114, 1,
		114, 1, 114, 1, 114, 1, 114, 1, 114, 4, 114, 2378, 8, 114, 11, 114, 12,
		114, 2379, 3, 114, 2382, 8, 114, 1, 115, 1, 115, 1, 115, 3, 115, 2387,
		8, 115, 1, 115, 1, 115, 1, 116, 1, 116, 1, 116, 3, 116, 2394, 8, 116, 1,
		116, 1, 116, 1, 117, 3, 117, 2399, 8, 117, 1, 117, 1, 117, 3, 117, 2403,
		8, 117, 1, 117, 1, 117, 1, 118, 1, 118, 1, 118, 3, 118, 2410, 8, 118, 1,
		118, 1, 118, 1, 119, 1, 119, 1, 119, 3, 119, 2417, 8, 119, 1, 119, 1, 119,
		1, 120, 1, 120, 1, 120, 3, 120, 2424, 8, 120, 1, 120, 1, 120, 1, 121, 3,
		121, 2429, 8, 121, 1, 121, 1, 121, 3, 121, 2433, 8, 121, 1, 121, 1, 121,
		1, 122, 3, 122, 2438, 8, 122, 1, 122, 1, 122, 3, 122, 2442, 8, 122, 1,
		122, 1, 122, 1, 123, 3, 123, 2447, 8, 123, 1, 123, 1, 123, 3, 123, 2451,
		8, 123, 1, 123, 1, 123, 1, 124, 3, 124, 2456, 8, 124, 1, 124, 1, 124, 3,
		124, 2460, 8, 124, 1, 124, 1, 124, 1, 125, 3, 125, 2465, 8, 125, 1, 125,
		1, 125, 3, 125, 2469, 8, 125, 1, 125, 1, 125, 1, 126, 1, 126, 1, 126, 3,
		126, 2476, 8, 126, 1, 126, 1, 126, 1, 127, 1, 127, 1, 127, 1, 127, 1, 127,
		1, 127, 1, 127, 3, 127, 2487, 8, 127, 1, 127, 5, 127, 2490, 8, 127, 10,
		127, 12, 127, 2493, 9, 127, 1, 128, 1, 128, 1, 128, 1, 128, 5, 128, 2499,
		8, 128, 10, 128, 12, 128, 2502, 9, 128, 1, 129, 1, 129, 1, 129, 3, 129,
		2507, 8, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1,
		129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1,
		129, 1, 129, 3, 129, 2527, 8, 129, 1, 129, 1, 129, 1, 129, 1, 129, 1, 129,
		1, 129, 1, 129, 1, 129, 1, 129, 1, 129, 5, 129, 2539, 8, 129, 10, 129,
		12, 129, 2542, 9, 129, 1, 129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 131,
		1, 131, 1, 132, 1, 132, 1, 133, 1, 133, 1, 133, 1, 134, 1, 134, 1, 135,
		1, 135, 1, 136, 1, 136, 1, 137, 1, 137, 1, 138, 1, 138, 3, 138, 2566, 8,
		138, 1, 138, 1, 138, 3, 138, 2570, 8, 138, 1, 139, 1, 139, 3, 139, 2574,
		8, 139, 1, 139, 3, 139, 2577, 8, 139, 1, 139, 3, 139, 2580, 8, 139, 1,
		139, 1, 139, 3, 139, 2584, 8, 139, 1, 140, 1, 140, 3, 140, 2588, 8, 140,
		1, 140, 3, 140, 2591, 8, 140, 1, 140, 3, 140, 2594, 8, 140, 1, 140, 1,
		140, 3, 140, 2598, 8, 140, 1, 141, 1, 141, 3, 141, 2602, 8, 141, 1, 141,
		1, 141, 3, 141, 2606, 8, 141, 1, 142, 1, 142, 3, 142, 2610, 8, 142, 1,
		142, 1, 142, 3, 142, 2614, 8, 142, 1, 143, 1, 143, 3, 143, 2618, 8, 143,
		1, 143, 1, 143, 1, 144, 1, 144, 3, 144, 2624, 8, 144, 1, 144, 1, 144, 1,
		145, 1, 145, 3, 145, 2630, 8, 145, 1, 145, 1, 145, 1, 146, 1, 146, 1, 146,
		3, 146, 2637, 8, 146, 1, 146, 3, 146, 2640, 8, 146, 1, 147, 1, 147, 1,
		147, 1, 148, 1, 148, 1, 148, 1, 149, 1, 149, 3, 149, 2650, 8, 149, 1, 149,
		1, 149, 1, 150, 1, 150, 3, 150, 2656, 8, 150, 1, 150, 1, 150, 1, 151, 1,
		151, 3, 151, 2662, 8, 151, 1, 152, 1, 152, 3, 152, 2666, 8, 152, 3, 152,
		2668, 8, 152, 1, 152, 1, 152, 1, 152, 3, 152, 2673, 8, 152, 3, 152, 2675,
		8, 152, 1, 153, 1, 153, 1, 154, 1, 154, 1, 155, 1, 155, 1, 156, 1, 156,
		3, 156, 2685, 8, 156, 1, 156, 3, 156, 2688, 8, 156, 1, 156, 1, 156, 3,
		156, 2692, 8, 156, 1, 156, 3, 156, 2695, 8, 156, 1, 157, 1, 157, 1, 157,
		3, 157, 2700, 8, 157, 1, 158, 1, 158, 1, 159, 1, 159, 1, 160, 1, 160, 1,
		160, 1, 160, 5, 160, 2710, 8, 160, 10, 160, 12, 160, 2713, 9, 160, 1, 161,
		1, 161, 4, 161, 2717, 8, 161, 11, 161, 12, 161, 2718, 1, 162, 1, 162, 1,
		162, 3, 162, 2724, 8, 162, 1, 162, 1, 162, 3, 162, 2728, 8, 162, 1, 162,
		3, 162, 2731, 8, 162, 1, 162, 3, 162, 2734, 8, 162, 1, 162, 3, 162, 2737,
		8, 162, 3, 162, 2739, 8, 162, 1, 162, 1, 162, 1, 163, 3, 163, 2744, 8,
		163, 1, 163, 1, 163, 1, 164, 1, 164, 1, 164, 3, 164, 2751, 8, 164, 1, 164,
		1, 164, 3, 164, 2755, 8, 164, 3, 164, 2757, 8, 164, 1, 164, 1, 164, 3,
		164, 2761, 8, 164, 1, 165, 1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166,
		1, 167, 1, 167, 1, 167, 1, 167, 1, 168, 1, 168, 1, 168, 1, 169, 1, 169,
		1, 169, 3, 169, 2780, 8, 169, 1, 170, 1, 170, 1, 170, 3, 170, 2785, 8,
		170, 1, 170, 3, 170, 2788, 8, 170, 1, 170, 1, 170, 3, 170, 2792, 8, 170,
		1, 170, 1, 170, 1, 171, 1, 171, 3, 171, 2798, 8, 171, 1, 171, 3, 171, 2801,
		8, 171, 1, 171, 1, 171, 1, 171, 1, 172, 1, 172, 3, 172, 2808, 8, 172, 1,
		172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1, 172, 1,
		172, 1, 172, 3, 172, 2821, 8, 172, 1, 172, 5, 172, 2824, 8, 172, 10, 172,
		12, 172, 2827, 9, 172, 1, 172, 1, 172, 1, 173, 1, 173, 3, 173, 2833, 8,
		173, 1, 173, 1, 173, 1, 174, 1, 174, 3, 174, 2839, 8, 174, 1, 174, 3, 174,
		2842, 8, 174, 1, 174, 1, 174, 1, 175, 1, 175, 3, 175, 2848, 8, 175, 1,
		176, 1, 176, 3, 176, 2852, 8, 176, 1, 177, 3, 177, 2855, 8, 177, 1, 177,
		3, 177, 2858, 8, 177, 1, 177, 3, 177, 2861, 8, 177, 1, 177, 1, 177, 3,
		177, 2865, 8, 177, 1, 178, 1, 178, 3, 178, 2869, 8, 178, 1, 178, 1, 178,
		3, 178, 2873, 8, 178, 1, 179, 1, 179, 1, 179, 1, 180, 1, 180, 1, 180, 3,
		180, 2881, 8, 180, 1, 180, 1, 180, 1, 180, 3, 180, 2886, 8, 180, 1, 181,
		1, 181, 1, 181, 1, 182, 1, 182, 1, 182, 1, 183, 1, 183, 3, 183, 2896, 8,
		183, 1, 183, 1, 183, 1, 184, 1, 184, 3, 184, 2902, 8, 184, 1, 184, 1, 184,
		3, 184, 2906, 8, 184, 1, 185, 1, 185, 3, 185, 2910, 8, 185, 1, 185, 1,
		185, 1, 185, 3, 185, 2915, 8, 185, 1, 186, 1, 186, 3, 186, 2919, 8, 186,
		1, 186, 1, 186, 1, 187, 1, 187, 1, 187, 3, 187, 2926, 8, 187, 1, 187, 5,
		187, 2929, 8, 187, 10, 187, 12, 187, 2932, 9, 187, 1, 187, 1, 187, 1, 187,
		3, 187, 2937, 8, 187, 1, 187, 5, 187, 2940, 8, 187, 10, 187, 12, 187, 2943,
		9, 187, 3, 187, 2945, 8, 187, 1, 188, 1, 188, 3, 188, 2949, 8, 188, 1,
		188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 1, 188, 3, 188, 2958, 8, 188,
		1, 189, 1, 189, 1, 189, 3, 189, 2963, 8, 189, 1, 190, 1, 190, 1, 190, 3,
		190, 2968, 8, 190, 1, 191, 1, 191, 1, 191, 3, 191, 2973, 8, 191, 1, 191,
		1, 191, 3, 191, 2977, 8, 191, 1, 192, 1, 192, 1, 193, 1, 193, 1, 193, 3,
		193, 2984, 8, 193, 1, 193, 1, 193, 3, 193, 2988, 8, 193, 1, 194, 1, 194,
		3, 194, 2992, 8, 194, 3, 194, 2994, 8, 194, 1, 194, 1, 194, 1, 195, 1,
		195, 1, 195, 3, 195, 3001, 8, 195, 1, 196, 1, 196, 1, 196, 3, 196, 3006,
		8, 196, 1, 197, 1, 197, 3, 197, 3010, 8, 197, 1, 197, 1, 197, 1, 198, 1,
		198, 1, 198, 1, 198, 5, 198, 3018, 8, 198, 10, 198, 12, 198, 3021, 9, 198,
		1, 199, 1, 199, 3, 199, 3025, 8, 199, 1, 200, 1, 200, 1, 200, 1, 200, 3,
		200, 3031, 8, 200, 1, 200, 3, 200, 3034, 8, 200, 1, 201, 1, 201, 1, 201,
		1, 201, 3, 201, 3040, 8, 201, 1, 201, 3, 201, 3043, 8, 201, 1, 201, 1,
		201, 5, 201, 3047, 8, 201, 10, 201, 12, 201, 3050, 9, 201, 1, 202, 1, 202,
		1, 202, 3, 202, 3055, 8, 202, 1, 202, 3, 202, 3058, 8, 202, 1, 203, 1,
		203, 3, 203, 3062, 8, 203, 1, 203, 1, 203, 3, 203, 3066, 8, 203, 1, 203,
		3, 203, 3069, 8, 203, 1, 203, 3, 203, 3072, 8, 203, 1, 203, 3, 203, 3075,
		8, 203, 1, 204, 1, 204, 1, 204, 1, 204, 1, 205, 1, 205, 3, 205, 3083, 8,
		205, 1, 205, 1, 205, 1, 206, 1, 206, 3, 206, 3089, 8, 206, 1, 206, 1, 206,
		1, 207, 1, 207, 1, 207, 3, 207, 3096, 8, 207, 1, 208, 1, 208, 1, 208, 3,
		208, 3101, 8, 208, 1, 208, 3, 208, 3104, 8, 208, 1, 208, 3, 208, 3107,
		8, 208, 1, 208, 3, 208, 3110, 8, 208, 1, 209, 1, 209, 1, 209, 1, 210, 1,
		210, 1, 210, 1, 211, 1, 211, 4, 211, 3120, 8, 211, 11, 211, 12, 211, 3121,
		1, 212, 1, 212, 3, 212, 3126, 8, 212, 1, 213, 1, 213, 4, 213, 3130, 8,
		213, 11, 213, 12, 213, 3131, 1, 214, 1, 214, 3, 214, 3136, 8, 214, 1, 215,
		3, 215, 3139, 8, 215, 1, 215, 1, 215, 1, 216, 3, 216, 3144, 8, 216, 1,
		216, 1, 216, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 3152, 8, 217, 1, 218,
		1, 218, 1, 218, 3, 218, 3157, 8, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1,
		218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1,
		218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 1, 218, 5, 218, 3180,
		8, 218, 10, 218, 12, 218, 3183, 9, 218, 1, 218, 1, 218, 1, 219, 1, 219,
		1, 219, 1, 219, 1, 219, 1, 220, 1, 220, 1, 220, 1, 220, 1, 220, 1, 221,
		4, 221, 3198, 8, 221, 11, 221, 12, 221, 3199, 1, 221, 3, 221, 3203, 8,
		221, 1, 222, 1, 222, 1, 223, 1, 223, 3, 223, 3209, 8, 223, 1, 223, 1, 223,
		1, 224, 1, 224, 1, 225, 3, 225, 3216, 8, 225, 1, 225, 1, 225, 1, 225, 3,
		225, 3221, 8, 225, 1, 226, 3, 226, 3224, 8, 226, 1, 226, 1, 226, 1, 227,
		1, 227, 1, 228, 1, 228, 3, 228, 3232, 8, 228, 1, 229, 1, 229, 1, 229, 3,
		229, 3237, 8, 229, 1, 229, 3, 229, 3240, 8, 229, 1, 229, 1, 229, 3, 229,
		3244, 8, 229, 1, 229, 3, 229, 3247, 8, 229, 1, 229, 5, 229, 3250, 8, 229,
		10, 229, 12, 229, 3253, 9, 229, 1, 229, 1, 229, 3, 229, 3257, 8, 229, 1,
		229, 3, 229, 3260, 8, 229, 1, 229, 4, 229, 3263, 8, 229, 11, 229, 12, 229,
		3264, 3, 229, 3267, 8, 229, 1, 230, 1, 230, 1, 230, 1, 231, 1, 231, 3,
		231, 3274, 8, 231, 1, 231, 3, 231, 3277, 8, 231, 1, 231, 4, 231, 3280,
		8, 231, 11, 231, 12, 231, 3281, 1, 232, 1, 232, 3, 232, 3286, 8, 232, 1,
		232, 1, 232, 1, 233, 4, 233, 3291, 8, 233, 11, 233, 12, 233, 3292, 1, 233,
		3, 233, 3296, 8, 233, 4, 233, 3298, 8, 233, 11, 233, 12, 233, 3299, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1,
		234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 1, 234, 3, 234, 3318, 8, 234,
		1, 235, 1, 235, 1, 235, 1, 235, 1, 236, 3, 236, 3325, 8, 236, 1, 236, 3,
		236, 3328, 8, 236, 1, 236, 1, 236, 1, 237, 1, 237, 1, 237, 1, 238, 1, 238,
		1, 238, 1, 239, 1, 239, 1, 239, 1, 239, 3, 239, 3342, 8, 239, 1, 240, 1,
		240, 3, 240, 3346, 8, 240, 3, 240, 3348, 8, 240, 1, 240, 1, 240, 1, 240,
		3, 240, 3353, 8, 240, 3, 240, 3355, 8, 240, 1, 241, 1, 241, 3, 241, 3359,
		8, 241, 1, 242, 3, 242, 3362, 8, 242, 1, 242, 1, 242, 1, 243, 1, 243, 3,
		243, 3368, 8, 243, 1, 243, 1, 243, 1, 244, 3, 244, 3373, 8, 244, 1, 244,
		1, 244, 1, 245, 1, 245, 3, 245, 3379, 8, 245, 3, 245, 3381, 8, 245, 1,
		245, 1, 245, 3, 245, 3385, 8, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245,
		1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245,
		1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245,
		1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 1, 245, 3, 245, 3416, 8, 245, 1,
		246, 1, 246, 1, 246, 3, 246, 3421, 8, 246, 1, 246, 1, 246, 3, 246, 3425,
		8, 246, 1, 247, 1, 247, 3, 247, 3429, 8, 247, 1, 247, 1, 247, 3, 247, 3433,
		8, 247, 3, 247, 3435, 8, 247, 1, 247, 1, 247, 3, 247, 3439, 8, 247, 1,
		247, 5, 247, 3442, 8, 247, 10, 247, 12, 247, 3445, 9, 247, 1, 248, 1, 248,
		3, 248, 3449, 8, 248, 1, 249, 1, 249, 3, 249, 3453, 8, 249, 1, 250, 1,
		250, 1, 250, 1, 251, 3, 251, 3459, 8, 251, 1, 251, 1, 251, 1, 251, 1, 252,
		1, 252, 1, 252, 3, 252, 3467, 8, 252, 1, 252, 3, 252, 3470, 8, 252, 1,
		252, 1, 252, 3, 252, 3474, 8, 252, 1, 252, 1, 252, 1, 253, 1, 253, 4, 253,
		3480, 8, 253, 11, 253, 12, 253, 3481, 1, 254, 1, 254, 1, 254, 1, 255, 1,
		255, 3, 255, 3489, 8, 255, 1, 256, 3, 256, 3492, 8, 256, 1, 256, 3, 256,
		3495, 8, 256, 1, 256, 4, 256, 3498, 8, 256, 11, 256, 12, 256, 3499, 1,
		257, 3, 257, 3503, 8, 257, 1, 257, 1, 257, 3, 257, 3507, 8, 257, 1, 257,
		3, 257, 3510, 8, 257, 1, 258, 3, 258, 3513, 8, 258, 1, 258, 1, 258, 4,
		258, 3517, 8, 258, 11, 258, 12, 258, 3518, 1, 259, 1, 259, 1, 259, 3, 259,
		3524, 8, 259, 1, 260, 1, 260, 1, 260, 4, 260, 3529, 8, 260, 11, 260, 12,
		260, 3530, 1, 260, 1, 260, 1, 260, 1, 260, 1, 261, 1, 261, 1, 261, 1, 261,
		1, 261, 1, 261, 1, 262, 1, 262, 1, 262, 3, 262, 3546, 8, 262, 1, 263, 1,
		263, 5, 263, 3550, 8, 263, 10, 263, 12, 263, 3553, 9, 263, 1, 264, 1, 264,
		1, 264, 1, 264, 1, 265, 5, 265, 3560, 8, 265, 10, 265, 12, 265, 3563, 9,
		265, 1, 265, 5, 265, 3566, 8, 265, 10, 265, 12, 265, 3569, 9, 265, 1, 266,
		1, 266, 1, 266, 1, 266, 5, 266, 3575, 8, 266, 10, 266, 12, 266, 3578, 9,
		266, 3, 266, 3580, 8, 266, 1, 267, 5, 267, 3583, 8, 267, 10, 267, 12, 267,
		3586, 9, 267, 1, 267, 1, 267, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1,
		268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1,
		268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1,
		268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1,
		268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1,
		268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 1, 268, 3, 268, 3639,
		8, 268, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269, 1, 269, 3, 269, 3647, 8,
		269, 1, 269, 3, 269, 3650, 8, 269, 1, 269, 3, 269, 3653, 8, 269, 1, 269,
		3, 269, 3656, 8, 269, 1, 270, 1, 270, 1, 270, 3, 270, 3661, 8, 270, 1,
		270, 1, 270, 3, 270, 3665, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 1, 270,
		3, 270, 3672, 8, 270, 1, 270, 1, 270, 1, 270, 1, 270, 3, 270, 3678, 8,
		270, 1, 271, 1, 271, 1, 271, 1, 272, 1, 272, 1, 272, 1, 272, 1, 273, 3,
		273, 3688, 8, 273, 1, 273, 1, 273, 1, 274, 1, 274, 1, 274, 1, 274, 3, 274,
		3696, 8, 274, 1, 274, 3, 274, 3699, 8, 274, 1, 274, 3, 274, 3702, 8, 274,
		1, 274, 3, 274, 3705, 8, 274, 1, 275, 4, 275, 3708, 8, 275, 11, 275, 12,
		275, 3709, 1, 275, 1, 275, 4, 275, 3714, 8, 275, 11, 275, 12, 275, 3715,
		1, 276, 4, 276, 3719, 8, 276, 11, 276, 12, 276, 3720, 1, 276, 1, 276, 4,
		276, 3725, 8, 276, 11, 276, 12, 276, 3726, 3, 276, 3729, 8, 276, 1, 276,
		1, 276, 4, 276, 3733, 8, 276, 11, 276, 12, 276, 3734, 1, 277, 1, 277, 1,
		277, 1, 277, 1, 277, 1, 278, 1, 278, 3, 278, 3744, 8, 278, 1, 279, 1, 279,
		3, 279, 3748, 8, 279, 1, 280, 1, 280, 3, 280, 3752, 8, 280, 1, 281, 1,
		281, 3, 281, 3756, 8, 281, 1, 282, 1, 282, 3, 282, 3760, 8, 282, 1, 282,
		1, 282, 1, 283, 1, 283, 4, 283, 3766, 8, 283, 11, 283, 12, 283, 3767, 1,
		284, 1, 284, 1, 284, 1, 284, 3, 284, 3774, 8, 284, 1, 284, 1, 284, 1, 285,
		1, 285, 1, 285, 3, 285, 3781, 8, 285, 1, 285, 3, 285, 3784, 8, 285, 1,
		285, 3, 285, 3787, 8, 285, 1, 285, 3, 285, 3790, 8, 285, 1, 285, 3, 285,
		3793, 8, 285, 1, 285, 3, 285, 3796, 8, 285, 1, 285, 3, 285, 3799, 8, 285,
		1, 286, 1, 286, 4, 286, 3803, 8, 286, 11, 286, 12, 286, 3804, 1, 287, 1,
		287, 1, 287, 3, 287, 3810, 8, 287, 1, 288, 3, 288, 3813, 8, 288, 1, 288,
		3, 288, 3816, 8, 288, 1, 288, 4, 288, 3819, 8, 288, 11, 288, 12, 288, 3820,
		1, 289, 1, 289, 1, 289, 1, 289, 3, 289, 3827, 8, 289, 1, 289, 1, 289, 1,
		289, 3, 289, 3832, 8, 289, 1, 289, 3, 289, 3835, 8, 289, 1, 290, 3, 290,
		3838, 8, 290, 1, 290, 1, 290, 4, 290, 3842, 8, 290, 11, 290, 12, 290, 3843,
		1, 291, 1, 291, 1, 291, 1, 291, 3, 291, 3850, 8, 291, 3, 291, 3852, 8,
		291, 1, 291, 1, 291, 3, 291, 3856, 8, 291, 1, 292, 3, 292, 3859, 8, 292,
		1, 292, 1, 292, 4, 292, 3863, 8, 292, 11, 292, 12, 292, 3864, 1, 293, 1,
		293, 1, 293, 1, 293, 3, 293, 3871, 8, 293, 3, 293, 3873, 8, 293, 1, 293,
		1, 293, 1, 293, 3, 293, 3878, 8, 293, 1, 294, 1, 294, 1, 294, 1, 295, 1,
		295, 4, 295, 3885, 8, 295, 11, 295, 12, 295, 3886, 1, 296, 1, 296, 1, 296,
		1, 296, 1, 296, 3, 296, 3894, 8, 296, 1, 297, 1, 297, 4, 297, 3898, 8,
		297, 11, 297, 12, 297, 3899, 1, 298, 1, 298, 1, 298, 1, 298, 3, 298, 3906,
		8, 298, 1, 299, 1, 299, 3, 299, 3910, 8, 299, 1, 299, 3, 299, 3913, 8,
		299, 1, 299, 3, 299, 3916, 8, 299, 1, 299, 1, 299, 1, 299, 3, 299, 3921,
		8, 299, 3, 299, 3923, 8, 299, 1, 300, 3, 300, 3926, 8, 300, 1, 300, 1,
		300, 1, 300, 3, 300, 3931, 8, 300, 1, 301, 3, 301, 3934, 8, 301, 1, 301,
		1, 301, 1, 301, 1, 301, 3, 301, 3940, 8, 301, 1, 301, 1, 301, 4, 301, 3944,
		8, 301, 11, 301, 12, 301, 3945, 3, 301, 3948, 8, 301, 1, 302, 1, 302, 1,
		302, 3, 302, 3953, 8, 302, 1, 303, 1, 303, 3, 303, 3957, 8, 303, 1, 303,
		1, 303, 1, 304, 1, 304, 1, 304, 3, 304, 3964, 8, 304, 1, 305, 1, 305, 3,
		305, 3968, 8, 305, 1, 305, 1, 305, 3, 305, 3972, 8, 305, 1, 306, 1, 306,
		4, 306, 3976, 8, 306, 11, 306, 12, 306, 3977, 1, 306, 1, 306, 1, 306, 3,
		306, 3983, 8, 306, 1, 306, 3, 306, 3986, 8, 306, 1, 306, 3, 306, 3989,
		8, 306, 1, 307, 1, 307, 3, 307, 3993, 8, 307, 1, 308, 1, 308, 1, 309, 1,
		309, 1, 309, 3, 309, 4000, 8, 309, 1, 309, 3, 309, 4003, 8, 309, 1, 309,
		3, 309, 4006, 8, 309, 1, 309, 3, 309, 4009, 8, 309, 1, 310, 1, 310, 1,
		310, 3, 310, 4014, 8, 310, 1, 310, 1, 310, 1, 310, 3, 310, 4019, 8, 310,
		1, 310, 1, 310, 3, 310, 4023, 8, 310, 1, 310, 1, 310, 1, 310, 3, 310, 4028,
		8, 310, 1, 311, 1, 311, 4, 311, 4032, 8, 311, 11, 311, 12, 311, 4033, 1,
		311, 3, 311, 4037, 8, 311, 1, 311, 3, 311, 4040, 8, 311, 1, 311, 3, 311,
		4043, 8, 311, 1, 312, 1, 312, 3, 312, 4047, 8, 312, 1, 313, 1, 313, 1,
		313, 3, 313, 4052, 8, 313, 1, 314, 1, 314, 1, 314, 3, 314, 4057, 8, 314,
		1, 315, 3, 315, 4060, 8, 315, 1, 315, 1, 315, 1, 315, 1, 316, 1, 316, 1,
		316, 3, 316, 4068, 8, 316, 1, 316, 1, 316, 1, 316, 3, 316, 4073, 8, 316,
		1, 316, 3, 316, 4076, 8, 316, 1, 316, 3, 316, 4079, 8, 316, 1, 316, 3,
		316, 4082, 8, 316, 1, 316, 3, 316, 4085, 8, 316, 1, 317, 1, 317, 4, 317,
		4089, 8, 317, 11, 317, 12, 317, 4090, 1, 318, 1, 318, 1, 318, 3, 318, 4096,
		8, 318, 1, 318, 3, 318, 4099, 8, 318, 1, 319, 1, 319, 1, 319, 3, 319, 4104,
		8, 319, 1, 319, 3, 319, 4107, 8, 319, 1, 320, 1, 320, 4, 320, 4111, 8,
		320, 11, 320, 12, 320, 4112, 1, 321, 1, 321, 3, 321, 4117, 8, 321, 1, 322,
		1, 322, 3, 322, 4121, 8, 322, 1, 323, 1, 323, 1, 323, 1, 324, 1, 324, 1,
		324, 3, 324, 4129, 8, 324, 1, 324, 1, 324, 1, 324, 3, 324, 4134, 8, 324,
		1, 324, 1, 324, 3, 324, 4138, 8, 324, 1, 324, 1, 324, 1, 324, 3, 324, 4143,
		8, 324, 1, 325, 1, 325, 1, 325, 1, 325, 4, 325, 4149, 8, 325, 11, 325,
		12, 325, 4150, 3, 325, 4153, 8, 325, 1, 326, 1, 326, 1, 326, 5, 326, 4158,
		8, 326, 10, 326, 12, 326, 4161, 9, 326, 1, 326, 4, 326, 4164, 8, 326, 11,
		326, 12, 326, 4165, 1, 326, 3, 326, 4169, 8, 326, 1, 326, 3, 326, 4172,
		8, 326, 1, 327, 1, 327, 1, 327, 1, 327, 3, 327, 4178, 8, 327, 1, 328, 1,
		328, 1, 328, 1, 329, 4, 329, 4184, 8, 329, 11, 329, 12, 329, 4185, 1, 329,
		5, 329, 4189, 8, 329, 10, 329, 12, 329, 4192, 9, 329, 1, 330, 1, 330, 1,
		330, 5, 330, 4197, 8, 330, 10, 330, 12, 330, 4200, 9, 330, 1, 331, 1, 331,
		3, 331, 4204, 8, 331, 1, 331, 1, 331, 3, 331, 4208, 8, 331, 1, 331, 1,
		331, 3, 331, 4212, 8, 331, 1, 332, 1, 332, 1, 332, 1, 333, 1, 333, 1, 333,
		1, 334, 1, 334, 1, 334, 5, 334, 4223, 8, 334, 10, 334, 12, 334, 4226, 9,
		334, 1, 335, 1, 335, 1, 335, 3, 335, 4231, 8, 335, 1, 336, 4, 336, 4234,
		8, 336, 11, 336, 12, 336, 4235, 1, 337, 4, 337, 4239, 8, 337, 11, 337,
		12, 337, 4240, 1, 338, 4, 338, 4244, 8, 338, 11, 338, 12, 338, 4245, 1,
		339, 1, 339, 3, 339, 4250, 8, 339, 1, 339, 3, 339, 4253, 8, 339, 1, 339,
		4, 339, 4256, 8, 339, 11, 339, 12, 339, 4257, 1, 340, 1, 340, 3, 340, 4262,
		8, 340, 1, 341, 1, 341, 3, 341, 4266, 8, 341, 1, 342, 1, 342, 1, 342, 1,
		343, 1, 343, 1, 344, 1, 344, 3, 344, 4275, 8, 344, 1, 344, 1, 344, 3, 344,
		4279, 8, 344, 1, 345, 1, 345, 1, 346, 1, 346, 4, 346, 4285, 8, 346, 11,
		346, 12, 346, 4286, 1, 346, 1, 346, 3, 346, 4291, 8, 346, 1, 346, 3, 346,
		4294, 8, 346, 3, 346, 4296, 8, 346, 1, 347, 1, 347, 1, 347, 1, 347, 3,
		347, 4302, 8, 347, 1, 347, 3, 347, 4305, 8, 347, 1, 348, 3, 348, 4308,
		8, 348, 1, 348, 1, 348, 1, 348, 5, 348, 4313, 8, 348, 10, 348, 12, 348,
		4316, 9, 348, 3, 348, 4318, 8, 348, 1, 349, 1, 349, 1, 349, 1, 349, 5,
		349, 4324, 8, 349, 10, 349, 12, 349, 4327, 9, 349, 3, 349, 4329, 8, 349,
		1, 350, 1, 350, 4, 350, 4333, 8, 350, 11, 350, 12, 350, 4334, 1, 350, 3,
		350, 4338, 8, 350, 1, 351, 1, 351, 4, 351, 4342, 8, 351, 11, 351, 12, 351,
		4343, 1, 352, 1, 352, 3, 352, 4348, 8, 352, 1, 352, 1, 352, 1, 352, 3,
		352, 4353, 8, 352, 1, 353, 1, 353, 4, 353, 4357, 8, 353, 11, 353, 12, 353,
		4358, 1, 354, 1, 354, 1, 354, 1, 354, 1, 354, 1, 354, 3, 354, 4367, 8,
		354, 1, 355, 1, 355, 4, 355, 4371, 8, 355, 11, 355, 12, 355, 4372, 1, 356,
		1, 356, 1, 356, 4, 356, 4378, 8, 356, 11, 356, 12, 356, 4379, 1, 357, 1,
		357, 4, 357, 4384, 8, 357, 11, 357, 12, 357, 4385, 1, 357, 4, 357, 4389,
		8, 357, 11, 357, 12, 357, 4390, 1, 358, 1, 358, 1, 358, 3, 358, 4396, 8,
		358, 1, 358, 1, 358, 5, 358, 4400, 8, 358, 10, 358, 12, 358, 4403, 9, 358,
		1, 359, 1, 359, 1, 359, 1, 359, 4, 359, 4409, 8, 359, 11, 359, 12, 359,
		4410, 1, 360, 1, 360, 5, 360, 4415, 8, 360, 10, 360, 12, 360, 4418, 9,
		360, 1, 361, 1, 361, 1, 361, 5, 361, 4423, 8, 361, 10, 361, 12, 361, 4426,
		9, 361, 1, 362, 1, 362, 4, 362, 4430, 8, 362, 11, 362, 12, 362, 4431, 1,
		363, 1, 363, 4, 363, 4436, 8, 363, 11, 363, 12, 363, 4437, 1, 364, 1, 364,
		3, 364, 4442, 8, 364, 1, 364, 5, 364, 4445, 8, 364, 10, 364, 12, 364, 4448,
		9, 364, 1, 365, 1, 365, 3, 365, 4452, 8, 365, 1, 365, 1, 365, 5, 365, 4456,
		8, 365, 10, 365, 12, 365, 4459, 9, 365, 1, 366, 1, 366, 1, 366, 3, 366,
		4464, 8, 366, 1, 367, 1, 367, 1, 367, 3, 367, 4469, 8, 367, 1, 368, 1,
		368, 3, 368, 4473, 8, 368, 1, 368, 1, 368, 3, 368, 4477, 8, 368, 1, 369,
		1, 369, 1, 369, 4, 369, 4482, 8, 369, 11, 369, 12, 369, 4483, 1, 369, 3,
		369, 4487, 8, 369, 1, 369, 5, 369, 4490, 8, 369, 10, 369, 12, 369, 4493,
		9, 369, 1, 369, 3, 369, 4496, 8, 369, 1, 369, 5, 369, 4499, 8, 369, 10,
		369, 12, 369, 4502, 9, 369, 1, 370, 3, 370, 4505, 8, 370, 1, 370, 1, 370,
		3, 370, 4509, 8, 370, 1, 370, 4, 370, 4512, 8, 370, 11, 370, 12, 370, 4513,
		1, 371, 3, 371, 4517, 8, 371, 1, 371, 1, 371, 3, 371, 4521, 8, 371, 1,
		371, 4, 371, 4524, 8, 371, 11, 371, 12, 371, 4525, 1, 371, 3, 371, 4529,
		8, 371, 1, 371, 3, 371, 4532, 8, 371, 1, 372, 3, 372, 4535, 8, 372, 1,
		372, 1, 372, 1, 372, 1, 372, 1, 373, 3, 373, 4542, 8, 373, 1, 373, 1, 373,
		3, 373, 4546, 8, 373, 1, 373, 1, 373, 1, 374, 1, 374, 4, 374, 4552, 8,
		374, 11, 374, 12, 374, 4553, 1, 375, 1, 375, 1, 375, 3, 375, 4559, 8, 375,
		1, 375, 1, 375, 3, 375, 4563, 8, 375, 1, 376, 1, 376, 1, 376, 1, 377, 1,
		377, 4, 377, 4570, 8, 377, 11, 377, 12, 377, 4571, 1, 378, 1, 378, 1, 378,
		1, 378, 1, 378, 1, 378, 1, 378, 1, 378, 1, 378, 1, 378, 3, 378, 4584, 8,
		378, 1, 379, 1, 379, 3, 379, 4588, 8, 379, 1, 379, 1, 379, 3, 379, 4592,
		8, 379, 1, 380, 1, 380, 1, 380, 4, 380, 4597, 8, 380, 11, 380, 12, 380,
		4598, 1, 381, 1, 381, 3, 381, 4603, 8, 381, 1, 382, 1, 382, 1, 382, 1,
		382, 4, 382, 4609, 8, 382, 11, 382, 12, 382, 4610, 1, 383, 1, 383, 1, 384,
		1, 384, 1, 384, 3, 384, 4618, 8, 384, 1, 384, 1, 384, 1, 384, 3, 384, 4623,
		8, 384, 1, 384, 3, 384, 4626, 8, 384, 1, 384, 3, 384, 4629, 8, 384, 1,
		384, 3, 384, 4632, 8, 384, 1, 385, 4, 385, 4635, 8, 385, 11, 385, 12, 385,
		4636, 1, 386, 1, 386, 3, 386, 4641, 8, 386, 1, 387, 1, 387, 1, 387, 4,
		387, 4646, 8, 387, 11, 387, 12, 387, 4647, 1, 388, 1, 388, 3, 388, 4652,
		8, 388, 1, 389, 1, 389, 3, 389, 4656, 8, 389, 1, 390, 1, 390, 1, 390, 1,
		390, 1, 390, 4, 390, 4663, 8, 390, 11, 390, 12, 390, 4664, 1, 391, 1, 391,
		4, 391, 4669, 8, 391, 11, 391, 12, 391, 4670, 1, 392, 1, 392, 1, 392, 3,
		392, 4676, 8, 392, 1, 392, 1, 392, 3, 392, 4680, 8, 392, 1, 393, 1, 393,
		4, 393, 4684, 8, 393, 11, 393, 12, 393, 4685, 1, 394, 1, 394, 3, 394, 4690,
		8, 394, 1, 394, 1, 394, 3, 394, 4694, 8, 394, 1, 395, 1, 395, 4, 395, 4698,
		8, 395, 11, 395, 12, 395, 4699, 1, 396, 1, 396, 4, 396, 4704, 8, 396, 11,
		396, 12, 396, 4705, 1, 397, 1, 397, 1, 397, 3, 397, 4711, 8, 397, 1, 398,
		3, 398, 4714, 8, 398, 1, 398, 5, 398, 4717, 8, 398, 10, 398, 12, 398, 4720,
		9, 398, 1, 398, 1, 398, 1, 399, 1, 399, 1, 399, 3, 399, 4727, 8, 399, 1,
		399, 3, 399, 4730, 8, 399, 1, 400, 1, 400, 1, 400, 3, 400, 4735, 8, 400,
		1, 401, 1, 401, 3, 401, 4739, 8, 401, 1, 401, 1, 401, 1, 402, 3, 402, 4744,
		8, 402, 1, 402, 1, 402, 1, 402, 1, 403, 1, 403, 1, 403, 1, 403, 1, 403,
		3, 403, 4754, 8, 403, 3, 403, 4756, 8, 403, 1, 404, 1, 404, 1, 404, 5,
		404, 4761, 8, 404, 10, 404, 12, 404, 4764, 9, 404, 1, 405, 1, 405, 3, 405,
		4768, 8, 405, 1, 405, 1, 405, 1, 405, 1, 405, 1, 406, 1, 406, 1, 406, 1,
		407, 1, 407, 1, 407, 1, 407, 3, 407, 4781, 8, 407, 1, 408, 1, 408, 1, 408,
		1, 408, 3, 408, 4787, 8, 408, 1, 409, 3, 409, 4790, 8, 409, 1, 409, 1,
		409, 1, 409, 1, 410, 1, 410, 4, 410, 4797, 8, 410, 11, 410, 12, 410, 4798,
		1, 411, 1, 411, 1, 411, 3, 411, 4804, 8, 411, 1, 411, 3, 411, 4807, 8,
		411, 1, 411, 3, 411, 4810, 8, 411, 1, 411, 3, 411, 4813, 8, 411, 1, 411,
		3, 411, 4816, 8, 411, 1, 411, 3, 411, 4819, 8, 411, 1, 411, 3, 411, 4822,
		8, 411, 1, 411, 3, 411, 4825, 8, 411, 1, 411, 3, 411, 4828, 8, 411, 1,
		411, 3, 411, 4831, 8, 411, 1, 412, 1, 412, 1, 412, 1, 413, 3, 413, 4837,
		8, 413, 1, 413, 1, 413, 1, 413, 3, 413, 4842, 8, 413, 1, 414, 1, 414, 3,
		414, 4846, 8, 414, 1, 414, 1, 414, 1, 415, 1, 415, 1, 415, 3, 415, 4853,
		8, 415, 1, 415, 3, 415, 4856, 8, 415, 1, 415, 3, 415, 4859, 8, 415, 1,
		415, 3, 415, 4862, 8, 415, 1, 416, 1, 416, 1, 416, 1, 416, 1, 416, 1, 416,
		1, 416, 1, 416, 5, 416, 4872, 8, 416, 10, 416, 12, 416, 4875, 9, 416, 1,
		417, 1, 417, 1, 417, 1, 417, 1, 417, 1, 417, 3, 417, 4883, 8, 417, 1, 418,
		1, 418, 1, 418, 3, 418, 4888, 8, 418, 1, 418, 1, 418, 3, 418, 4892, 8,
		418, 1, 418, 3, 418, 4895, 8, 418, 1, 419, 1, 419, 1, 419, 5, 419, 4900,
		8, 419, 10, 419, 12, 419, 4903, 9, 419, 1, 420, 1, 420, 1, 420, 5, 420,
		4908, 8, 420, 10, 420, 12, 420, 4911, 9, 420, 1, 421, 1, 421, 3, 421, 4915,
		8, 421, 1, 421, 1, 421, 3, 421, 4919, 8, 421, 1, 422, 3, 422, 4922, 8,
		422, 1, 422, 1, 422, 1, 422, 1, 423, 1, 423, 3, 423, 4929, 8, 423, 1, 423,
		1, 423, 1, 424, 1, 424, 3, 424, 4935, 8, 424, 1, 424, 1, 424, 3, 424, 4939,
		8, 424, 1, 425, 1, 425, 3, 425, 4943, 8, 425, 1, 425, 1, 425, 1, 426, 1,
		426, 1, 426, 1, 426, 3, 426, 4951, 8, 426, 1, 427, 1, 427, 1, 427, 3, 427,
		4956, 8, 427, 1, 427, 3, 427, 4959, 8, 427, 1, 427, 1, 427, 3, 427, 4963,
		8, 427, 1, 427, 3, 427, 4966, 8, 427, 1, 428, 1, 428, 1, 428, 1, 429, 1,
		429, 1, 429, 3, 429, 4974, 8, 429, 1, 429, 3, 429, 4977, 8, 429, 1, 429,
		3, 429, 4980, 8, 429, 1, 429, 3, 429, 4983, 8, 429, 1, 430, 1, 430, 1,
		430, 1, 431, 1, 431, 3, 431, 4990, 8, 431, 1, 431, 1, 431, 3, 431, 4994,
		8, 431, 1, 431, 3, 431, 4997, 8, 431, 1, 431, 4, 431, 5000, 8, 431, 11,
		431, 12, 431, 5001, 1, 431, 3, 431, 5005, 8, 431, 1, 432, 1, 432, 1, 432,
		1, 433, 1, 433, 1, 433, 1, 433, 1, 433, 5, 433, 5015, 8, 433, 10, 433,
		12, 433, 5018, 9, 433, 3, 433, 5020, 8, 433, 1, 434, 1, 434, 1, 434, 3,
		434, 5025, 8, 434, 1, 434, 3, 434, 5028, 8, 434, 1, 434, 3, 434, 5031,
		8, 434, 1, 435, 1, 435, 3, 435, 5035, 8, 435, 1, 435, 3, 435, 5038, 8,
		435, 1, 435, 3, 435, 5041, 8, 435, 1, 435, 3, 435, 5044, 8, 435, 1, 435,
		3, 435, 5047, 8, 435, 1, 436, 1, 436, 1, 436, 1, 436, 1, 437, 1, 437, 1,
		437, 1, 438, 1, 438, 1, 438, 1, 438, 1, 438, 3, 438, 5061, 8, 438, 1, 439,
		1, 439, 3, 439, 5065, 8, 439, 1, 440, 1, 440, 3, 440, 5069, 8, 440, 1,
		440, 1, 440, 1, 440, 3, 440, 5074, 8, 440, 1, 441, 1, 441, 1, 442, 1, 442,
		3, 442, 5080, 8, 442, 1, 442, 3, 442, 5083, 8, 442, 1, 443, 1, 443, 1,
		444, 1, 444, 4, 444, 5089, 8, 444, 11, 444, 12, 444, 5090, 1, 444, 3, 444,
		5094, 8, 444, 1, 445, 4, 445, 5097, 8, 445, 11, 445, 12, 445, 5098, 1,
		445, 1, 445, 4, 445, 5103, 8, 445, 11, 445, 12, 445, 5104, 1, 446, 4, 446,
		5108, 8, 446, 11, 446, 12, 446, 5109, 1, 446, 1, 446, 1, 446, 1, 446, 3,
		446, 5116, 8, 446, 1, 446, 1, 446, 1, 447, 1, 447, 1, 448, 1, 448, 1, 448,
		1, 448, 1, 448, 3, 448, 5127, 8, 448, 1, 448, 1, 448, 3, 448, 5131, 8,
		448, 1, 449, 1, 449, 3, 449, 5135, 8, 449, 1, 450, 1, 450, 1, 450, 4, 450,
		5140, 8, 450, 11, 450, 12, 450, 5141, 1, 450, 3, 450, 5145, 8, 450, 1,
		450, 3, 450, 5148, 8, 450, 1, 450, 3, 450, 5151, 8, 450, 1, 450, 5, 450,
		5154, 8, 450, 10, 450, 12, 450, 5157, 9, 450, 1, 450, 3, 450, 5160, 8,
		450, 1, 450, 5, 450, 5163, 8, 450, 10, 450, 12, 450, 5166, 9, 450, 1, 451,
		3, 451, 5169, 8, 451, 1, 451, 1, 451, 3, 451, 5173, 8, 451, 1, 451, 4,
		451, 5176, 8, 451, 11, 451, 12, 451, 5177, 1, 452, 3, 452, 5181, 8, 452,
		1, 452, 1, 452, 3, 452, 5185, 8, 452, 1, 452, 3, 452, 5188, 8, 452, 1,
		453, 3, 453, 5191, 8, 453, 1, 453, 1, 453, 3, 453, 5195, 8, 453, 1, 453,
		4, 453, 5198, 8, 453, 11, 453, 12, 453, 5199, 1, 453, 3, 453, 5203, 8,
		453, 1, 453, 3, 453, 5206, 8, 453, 1, 454, 3, 454, 5209, 8, 454, 1, 454,
		1, 454, 1, 454, 1, 454, 1, 455, 3, 455, 5216, 8, 455, 1, 455, 1, 455, 3,
		455, 5220, 8, 455, 1, 455, 1, 455, 1, 456, 1, 456, 1, 456, 3, 456, 5227,
		8, 456, 1, 456, 1, 456, 3, 456, 5231, 8, 456, 1, 457, 1, 457, 1, 457, 1,
		458, 1, 458, 4, 458, 5238, 8, 458, 11, 458, 12, 458, 5239, 1, 459, 1, 459,
		1, 459, 3, 459, 5245, 8, 459, 1, 459, 1, 459, 3, 459, 5249, 8, 459, 1,
		460, 1, 460, 1, 460, 1, 461, 1, 461, 4, 461, 5256, 8, 461, 11, 461, 12,
		461, 5257, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462, 1, 462,
		1, 462, 1, 462, 3, 462, 5270, 8, 462, 1, 463, 1, 463, 1, 463, 3, 463, 5275,
		8, 463, 1, 463, 3, 463, 5278, 8, 463, 1, 463, 3, 463, 5281, 8, 463, 1,
		463, 3, 463, 5284, 8, 463, 1, 464, 1, 464, 3, 464, 5288, 8, 464, 1, 464,
		1, 464, 3, 464, 5292, 8, 464, 1, 464, 1, 464, 1, 464, 3, 464, 5297, 8,
		464, 1, 464, 1, 464, 1, 464, 1, 464, 3, 464, 5303, 8, 464, 1, 464, 1, 464,
		1, 464, 1, 464, 3, 464, 5309, 8, 464, 1, 464, 1, 464, 1, 464, 3, 464, 5314,
		8, 464, 1, 464, 3, 464, 5317, 8, 464, 1, 464, 1, 464, 1, 465, 1, 465, 1,
		465, 3, 465, 5324, 8, 465, 1, 466, 1, 466, 4, 466, 5328, 8, 466, 11, 466,
		12, 466, 5329, 1, 466, 1, 466, 3, 466, 5334, 8, 466, 1, 466, 3, 466, 5337,
		8, 466, 1, 466, 3, 466, 5340, 8, 466, 1, 466, 3, 466, 5343, 8, 466, 1,
		467, 4, 467, 5346, 8, 467, 11, 467, 12, 467, 5347, 1, 467, 1, 467, 3, 467,
		5352, 8, 467, 1, 468, 1, 468, 3, 468, 5356, 8, 468, 1, 469, 1, 469, 3,
		469, 5360, 8, 469, 1, 469, 1, 469, 1, 469, 3, 469, 5365, 8, 469, 1, 470,
		1, 470, 1, 470, 3, 470, 5370, 8, 470, 1, 471, 1, 471, 1, 471, 1, 472, 3,
		472, 5376, 8, 472, 1, 472, 1, 472, 1, 472, 1, 473, 1, 473, 1, 473, 1, 473,
		3, 473, 5385, 8, 473, 1, 473, 3, 473, 5388, 8, 473, 1, 473, 3, 473, 5391,
		8, 473, 1, 473, 3, 473, 5394, 8, 473, 1, 474, 4, 474, 5397, 8, 474, 11,
		474, 12, 474, 5398, 1, 474, 1, 474, 4, 474, 5403, 8, 474, 11, 474, 12,
		474, 5404, 1, 475, 4, 475, 5408, 8, 475, 11, 475, 12, 475, 5409, 1, 475,
		1, 475, 1, 475, 1, 475, 4, 475, 5416, 8, 475, 11, 475, 12, 475, 5417, 1,
		476, 1, 476, 1, 476, 1, 476, 1, 476, 1, 477, 1, 477, 3, 477, 5427, 8, 477,
		1, 478, 1, 478, 3, 478, 5431, 8, 478, 1, 479, 1, 479, 3, 479, 5435, 8,
		479, 1, 480, 1, 480, 3, 480, 5439, 8, 480, 1, 481, 1, 481, 3, 481, 5443,
		8, 481, 1, 482, 1, 482, 1, 482, 1, 483, 1, 483, 1, 483, 1, 483, 3, 483,
		5452, 8, 483, 1, 483, 3, 483, 5455, 8, 483, 1, 483, 3, 483, 5458, 8, 483,
		1, 483, 3, 483, 5461, 8, 483, 1, 483, 3, 483, 5464, 8, 483, 1, 484, 1,
		484, 1, 484, 5, 484, 5469, 8, 484, 10, 484, 12, 484, 5472, 9, 484, 3, 484,
		5474, 8, 484, 1, 485, 1, 485, 3, 485, 5478, 8, 485, 1, 485, 3, 485, 5481,
		8, 485, 1, 485, 1, 485, 3, 485, 5485, 8, 485, 1, 486, 1, 486, 3, 486, 5489,
		8, 486, 1, 486, 1, 486, 3, 486, 5493, 8, 486, 1, 487, 1, 487, 4, 487, 5497,
		8, 487, 11, 487, 12, 487, 5498, 1, 488, 1, 488, 3, 488, 5503, 8, 488, 1,
		488, 3, 488, 5506, 8, 488, 1, 489, 1, 489, 3, 489, 5510, 8, 489, 1, 489,
		1, 489, 1, 490, 1, 490, 3, 490, 5516, 8, 490, 1, 490, 1, 490, 1, 491, 3,
		491, 5521, 8, 491, 1, 491, 1, 491, 1, 491, 1, 492, 1, 492, 3, 492, 5528,
		8, 492, 1, 492, 1, 492, 1, 493, 1, 493, 1, 493, 3, 493, 5535, 8, 493, 1,
		494, 3, 494, 5538, 8, 494, 1, 494, 1, 494, 3, 494, 5542, 8, 494, 1, 494,
		1, 494, 1, 494, 3, 494, 5547, 8, 494, 1, 494, 1, 494, 1, 495, 1, 495, 1,
		495, 1, 495, 1, 495, 4, 495, 5556, 8, 495, 11, 495, 12, 495, 5557, 3, 495,
		5560, 8, 495, 1, 496, 3, 496, 5563, 8, 496, 1, 496, 1, 496, 3, 496, 5567,
		8, 496, 1, 496, 4, 496, 5570, 8, 496, 11, 496, 12, 496, 5571, 1, 497, 1,
		497, 1, 497, 1, 497, 3, 497, 5578, 8, 497, 1, 497, 3, 497, 5581, 8, 497,
		1, 497, 1, 497, 1, 497, 3, 497, 5586, 8, 497, 1, 498, 1, 498, 1, 498, 3,
		498, 5591, 8, 498, 1, 498, 3, 498, 5594, 8, 498, 1, 498, 3, 498, 5597,
		8, 498, 1, 498, 3, 498, 5600, 8, 498, 1, 498, 3, 498, 5603, 8, 498, 1,
		498, 3, 498, 5606, 8, 498, 1, 498, 3, 498, 5609, 8, 498, 1, 499, 1, 499,
		1, 499, 3, 499, 5614, 8, 499, 1, 500, 1, 500, 3, 500, 5618, 8, 500, 1,
		500, 1, 500, 1, 500, 3, 500, 5623, 8, 500, 1, 501, 1, 501, 1, 502, 1, 502,
		3, 502, 5629, 8, 502, 1, 502, 3, 502, 5632, 8, 502, 1, 503, 1, 503, 1,
		504, 3, 504, 5637, 8, 504, 1, 504, 1, 504, 5, 504, 5641, 8, 504, 10, 504,
		12, 504, 5644, 9, 504, 1, 505, 1, 505, 3, 505, 5648, 8, 505, 1, 505, 1,
		505, 5, 505, 5652, 8, 505, 10, 505, 12, 505, 5655, 9, 505, 1, 506, 3, 506,
		5658, 8, 506, 1, 506, 1, 506, 5, 506, 5662, 8, 506, 10, 506, 12, 506, 5665,
		9, 506, 1, 507, 1, 507, 3, 507, 5669, 8, 507, 1, 507, 1, 507, 5, 507, 5673,
		8, 507, 10, 507, 12, 507, 5676, 9, 507, 1, 508, 1, 508, 3, 508, 5680, 8,
		508, 1, 508, 5, 508, 5683, 8, 508, 10, 508, 12, 508, 5686, 9, 508, 1, 509,
		1, 509, 1, 509, 3, 509, 5691, 8, 509, 1, 509, 5, 509, 5694, 8, 509, 10,
		509, 12, 509, 5697, 9, 509, 1, 510, 3, 510, 5700, 8, 510, 1, 510, 1, 510,
		5, 510, 5704, 8, 510, 10, 510, 12, 510, 5707, 9, 510, 1, 511, 1, 511, 3,
		511, 5711, 8, 511, 1, 511, 1, 511, 5, 511, 5715, 8, 511, 10, 511, 12, 511,
		5718, 9, 511, 1, 512, 3, 512, 5721, 8, 512, 1, 512, 1, 512, 1, 512, 5,
		512, 5726, 8, 512, 10, 512, 12, 512, 5729, 9, 512, 1, 513, 1, 513, 3, 513,
		5733, 8, 513, 1, 513, 1, 513, 1, 513, 5, 513, 5738, 8, 513, 10, 513, 12,
		513, 5741, 9, 513, 1, 514, 3, 514, 5744, 8, 514, 1, 514, 1, 514, 5, 514,
		5748, 8, 514, 10, 514, 12, 514, 5751, 9, 514, 1, 515, 1, 515, 3, 515, 5755,
		8, 515, 1, 515, 1, 515, 5, 515, 5759, 8, 515, 10, 515, 12, 515, 5762, 9,
		515, 1, 516, 1, 516, 5, 516, 5766, 8, 516, 10, 516, 12, 516, 5769, 9, 516,
		1, 517, 1, 517, 1, 517, 1, 518, 1, 518, 5, 518, 5776, 8, 518, 10, 518,
		12, 518, 5779, 9, 518, 1, 519, 1, 519, 1, 519, 1, 520, 3, 520, 5785, 8,
		520, 1, 520, 1, 520, 5, 520, 5789, 8, 520, 10, 520, 12, 520, 5792, 9, 520,
		1, 521, 1, 521, 1, 521, 1, 522, 1, 522, 1, 522, 1, 522, 1, 522, 1, 522,
		3, 522, 5803, 8, 522, 1, 523, 1, 523, 5, 523, 5807, 8, 523, 10, 523, 12,
		523, 5810, 9, 523, 1, 524, 1, 524, 1, 524, 4, 524, 5815, 8, 524, 11, 524,
		12, 524, 5816, 3, 524, 5819, 8, 524, 1, 525, 3, 525, 5822, 8, 525, 1, 525,
		1, 525, 1, 526, 1, 526, 1, 526, 1, 526, 1, 526, 1, 526, 1, 526, 3, 526,
		5833, 8, 526, 1, 527, 1, 527, 3, 527, 5837, 8, 527, 1, 527, 3, 527, 5840,
		8, 527, 1, 527, 1, 527, 1, 527, 1, 527, 1, 527, 1, 527, 1, 527, 3, 527,
		5849, 8, 527, 1, 528, 1, 528, 5, 528, 5853, 8, 528, 10, 528, 12, 528, 5856,
		9, 528, 1, 528, 3, 528, 5859, 8, 528, 1, 528, 5, 528, 5862, 8, 528, 10,
		528, 12, 528, 5865, 9, 528, 1, 528, 5, 528, 5868, 8, 528, 10, 528, 12,
		528, 5871, 9, 528, 3, 528, 5873, 8, 528, 1, 529, 1, 529, 1, 529, 3, 529,
		5878, 8, 529, 1, 529, 5, 529, 5881, 8, 529, 10, 529, 12, 529, 5884, 9,
		529, 1, 529, 1, 529, 1, 530, 1, 530, 1, 530, 3, 530, 5891, 8, 530, 1, 531,
		1, 531, 3, 531, 5895, 8, 531, 1, 531, 3, 531, 5898, 8, 531, 1, 531, 1,
		531, 1, 532, 1, 532, 1, 532, 1, 532, 1, 533, 1, 533, 1, 533, 1, 533, 1,
		533, 1, 533, 1, 534, 1, 534, 1, 534, 4, 534, 5915, 8, 534, 11, 534, 12,
		534, 5916, 1, 535, 3, 535, 5920, 8, 535, 1, 535, 3, 535, 5923, 8, 535,
		1, 535, 1, 535, 3, 535, 5927, 8, 535, 1, 535, 1, 535, 1, 535, 3, 535, 5932,
		8, 535, 1, 535, 1, 535, 1, 535, 3, 535, 5937, 8, 535, 1, 535, 3, 535, 5940,
		8, 535, 1, 535, 1, 535, 1, 535, 3, 535, 5945, 8, 535, 1, 535, 1, 535, 1,
		535, 3, 535, 5950, 8, 535, 1, 535, 1, 535, 1, 535, 3, 535, 5955, 8, 535,
		1, 535, 1, 535, 1, 535, 3, 535, 5960, 8, 535, 1, 535, 3, 535, 5963, 8,
		535, 1, 536, 3, 536, 5966, 8, 536, 1, 536, 3, 536, 5969, 8, 536, 1, 536,
		1, 536, 1, 536, 1, 536, 1, 536, 1, 536, 3, 536, 5977, 8, 536, 1, 537, 1,
		537, 1, 537, 1, 537, 3, 537, 5983, 8, 537, 1, 538, 1, 538, 1, 538, 1, 538,
		3, 538, 5989, 8, 538, 1, 538, 5, 538, 5992, 8, 538, 10, 538, 12, 538, 5995,
		9, 538, 1, 538, 1, 538, 5, 538, 5999, 8, 538, 10, 538, 12, 538, 6002, 9,
		538, 1, 538, 3, 538, 6005, 8, 538, 1, 539, 1, 539, 1, 539, 1, 539, 1, 539,
		3, 539, 6012, 8, 539, 1, 539, 5, 539, 6015, 8, 539, 10, 539, 12, 539, 6018,
		9, 539, 1, 539, 1, 539, 5, 539, 6022, 8, 539, 10, 539, 12, 539, 6025, 9,
		539, 1, 539, 3, 539, 6028, 8, 539, 1, 540, 1, 540, 1, 540, 1, 540, 3, 540,
		6034, 8, 540, 1, 540, 1, 540, 1, 541, 1, 541, 1, 542, 1, 542, 1, 543, 1,
		543, 1, 543, 1, 543, 3, 543, 6046, 8, 543, 1, 543, 1, 543, 3, 543, 6050,
		8, 543, 1, 543, 3, 543, 6053, 8, 543, 1, 544, 1, 544, 1, 544, 1, 544, 3,
		544, 6059, 8, 544, 1, 544, 1, 544, 3, 544, 6063, 8, 544, 1, 544, 3, 544,
		6066, 8, 544, 1, 545, 1, 545, 1, 545, 1, 545, 3, 545, 6072, 8, 545, 1,
		546, 1, 546, 3, 546, 6076, 8, 546, 1, 546, 4, 546, 6079, 8, 546, 11, 546,
		12, 546, 6080, 1, 546, 3, 546, 6084, 8, 546, 1, 546, 3, 546, 6087, 8, 546,
		1, 547, 1, 547, 1, 547, 1, 548, 1, 548, 1, 548, 1, 549, 1, 549, 1, 549,
		1, 550, 1, 550, 3, 550, 6100, 8, 550, 1, 551, 1, 551, 1, 551, 1, 552, 1,
		552, 1, 552, 1, 553, 1, 553, 1, 553, 1, 554, 1, 554, 1, 554, 1, 555, 1,
		555, 1, 555, 1, 556, 1, 556, 1, 556, 1, 557, 1, 557, 1, 558, 1, 558, 1,
		559, 1, 559, 1, 560, 1, 560, 1, 561, 1, 561, 1, 562, 1, 562, 1, 563, 1,
		563, 1, 564, 1, 564, 1, 565, 1, 565, 1, 565, 3, 565, 6139, 8, 565, 1, 566,
		1, 566, 1, 567, 1, 567, 1, 568, 1, 568, 1, 568, 1, 568, 1, 568, 1, 568,
		3, 568, 6151, 8, 568, 1, 569, 1, 569, 1, 570, 1, 570, 1, 571, 1, 571, 1,
		572, 1, 572, 1, 573, 1, 573, 1, 574, 1, 574, 3, 574, 6165, 8, 574, 1, 575,
		1, 575, 3, 575, 6169, 8, 575, 1, 575, 3, 575, 6172, 8, 575, 1, 576, 1,
		576, 3, 576, 6176, 8, 576, 1, 577, 1, 577, 1, 578, 1, 578, 1, 579, 1, 579,
		1, 580, 1, 580, 1, 581, 1, 581, 3, 581, 6188, 8, 581, 1, 582, 1, 582, 1,
		583, 1, 583, 1, 584, 1, 584, 1, 585, 1, 585, 1, 586, 1, 586, 1, 586, 1,
		586, 1, 586, 1, 586, 3, 586, 6204, 8, 586, 1, 587, 1, 587, 1, 588, 1, 588,
		1, 588, 3, 588, 6211, 8, 588, 1, 589, 1, 589, 1, 590, 1, 590, 1, 590, 1,
		590, 3, 590, 6219, 8, 590, 1, 590, 1, 590, 1, 591, 1, 591, 1, 591, 1, 591,
		3, 591, 6227, 8, 591, 1, 591, 1, 591, 1, 592, 1, 592, 1, 592, 1, 592, 1,
		592, 1, 592, 1, 592, 1, 592, 1, 592, 1, 592, 1, 592, 1, 592, 1, 592, 1,
		592, 1, 592, 3, 592, 6246, 8, 592, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593,
		1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593,
		1, 593, 3, 593, 6263, 8, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1,
		593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1, 593, 1,
		593, 1, 593, 3, 593, 6281, 8, 593, 1, 594, 4, 594, 6284, 8, 594, 11, 594,
		12, 594, 6285, 1, 594, 0, 0, 595, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20,
		22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56,
		58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92,
		94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122,
		124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152,
		154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182,
		184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212,
		214, 216, 218, 220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242,
		244, 246, 248, 250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272,
		274, 276, 278, 280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302,
		304, 306, 308, 310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332,
		334, 336, 338, 340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362,
		364, 366, 368, 370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392,
		394, 396, 398, 400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422,
		424, 426, 428, 430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452,
		454, 456, 458, 460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482,
		484, 486, 488, 490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512,
		514, 516, 518, 520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542,
		544, 546, 548, 550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572,
		574, 576, 578, 580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602,
		604, 606, 608, 610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632,
		634, 636, 638, 640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662,
		664, 666, 668, 670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692,
		694, 696, 698, 700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722,
		724, 726, 728, 730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752,
		754, 756, 758, 760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782,
		784, 786, 788, 790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812,
		814, 816, 818, 820, 822, 824, 826, 828, 830, 832, 834, 836, 838, 840, 842,
		844, 846, 848, 850, 852, 854, 856, 858, 860, 862, 864, 866, 868, 870, 872,
		874, 876, 878, 880, 882, 884, 886, 888, 890, 892, 894, 896, 898, 900, 902,
		904, 906, 908, 910, 912, 914, 916, 918, 920, 922, 924, 926, 928, 930, 932,
		934, 936, 938, 940, 942, 944, 946, 948, 950, 952, 954, 956, 958, 960, 962,
		964, 966, 968, 970, 972, 974, 976, 978, 980, 982, 984, 986, 988, 990, 992,
		994, 996, 998, 1000, 1002, 1004, 1006, 1008, 1010, 1012, 1014, 1016, 1018,
		1020, 1022, 1024, 1026, 1028, 1030, 1032, 1034, 1036, 1038, 1040, 1042,
		1044, 1046, 1048, 1050, 1052, 1054, 1056, 1058, 1060, 1062, 1064, 1066,
		1068, 1070, 1072, 1074, 1076, 1078, 1080, 1082, 1084, 1086, 1088, 1090,
		1092, 1094, 1096, 1098, 1100, 1102, 1104, 1106, 1108, 1110, 1112, 1114,
		1116, 1118, 1120, 1122, 1124, 1126, 1128, 1130, 1132, 1134, 1136, 1138,
		1140, 1142, 1144, 1146, 1148, 1150, 1152, 1154, 1156, 1158, 1160, 1162,
		1164, 1166, 1168, 1170, 1172, 1174, 1176, 1178, 1180, 1182, 1184, 1186,
		1188, 0, 70, 1, 0, 234, 235, 5, 0, 78, 78, 130, 130, 243, 243, 274, 274,
		380, 380, 3, 0, 63, 63, 298, 298, 515, 515, 2, 0, 298, 298, 515, 515, 1,
		0, 483, 484, 2, 0, 14, 14, 304, 304, 2, 0, 80, 80, 86, 86, 2, 0, 266, 266,
		493, 493, 2, 0, 21, 21, 254, 254, 1, 0, 22, 23, 3, 0, 241, 241, 386, 386,
		429, 429, 4, 0, 150, 150, 197, 197, 369, 369, 429, 429, 2, 0, 382, 382,
		499, 499, 3, 0, 377, 377, 440, 440, 444, 444, 2, 0, 205, 205, 417, 417,
		2, 0, 63, 63, 379, 379, 1, 0, 460, 462, 2, 0, 279, 279, 416, 416, 2, 0,
		38, 38, 41, 41, 1, 0, 189, 190, 2, 0, 229, 229, 290, 290, 3, 0, 226, 226,
		268, 268, 336, 336, 3, 0, 348, 348, 543, 543, 547, 547, 1, 0, 73, 74, 1,
		0, 213, 214, 1, 0, 35, 36, 1, 0, 346, 347, 1, 0, 142, 143, 1, 0, 255, 256,
		1, 0, 33, 34, 2, 0, 311, 311, 420, 420, 2, 0, 156, 156, 398, 398, 2, 0,
		216, 216, 270, 270, 1, 0, 279, 280, 2, 0, 117, 117, 137, 137, 3, 0, 146,
		146, 355, 355, 432, 433, 1, 0, 50, 51, 2, 0, 553, 553, 555, 555, 2, 0,
		521, 521, 523, 524, 3, 0, 78, 78, 284, 284, 337, 337, 2, 0, 250, 250, 459,
		459, 2, 0, 25, 25, 135, 135, 2, 0, 95, 95, 383, 384, 1, 0, 468, 469, 2,
		0, 267, 267, 411, 411, 4, 0, 287, 288, 317, 317, 319, 319, 437, 437, 2,
		0, 202, 202, 495, 495, 2, 0, 100, 100, 262, 262, 2, 0, 59, 59, 506, 506,
		2, 0, 222, 222, 405, 405, 1, 0, 103, 104, 2, 0, 1, 1, 331, 331, 2, 0, 186,
		186, 536, 536, 7, 0, 11, 11, 14, 15, 116, 116, 152, 152, 304, 305, 316,
		316, 318, 318, 2, 0, 9, 9, 266, 266, 3, 0, 9, 9, 210, 210, 266, 266, 2,
		0, 7, 7, 39, 39, 2, 0, 258, 258, 310, 310, 2, 0, 295, 295, 422, 422, 2,
		0, 48, 48, 492, 492, 2, 0, 188, 188, 196, 196, 2, 0, 168, 168, 185, 185,
		2, 0, 543, 543, 547, 547, 2, 0, 526, 526, 550, 550, 2, 0, 19, 19, 329,
		329, 3, 0, 307, 307, 351, 351, 521, 521, 2, 0, 239, 239, 323, 323, 85,
		0, 1, 1, 24, 24, 26, 26, 28, 29, 31, 31, 33, 36, 38, 38, 41, 43, 45, 45,
		47, 47, 54, 55, 60, 61, 68, 69, 77, 77, 98, 98, 100, 100, 106, 106, 108,
		108, 128, 130, 138, 139, 141, 141, 146, 147, 151, 151, 156, 156, 181, 181,
		183, 183, 187, 187, 189, 191, 194, 194, 197, 197, 200, 200, 202, 202, 213,
		214, 216, 216, 218, 219, 226, 226, 229, 229, 237, 238, 250, 250, 258, 258,
		260, 260, 262, 262, 264, 265, 268, 268, 270, 270, 272, 274, 283, 284, 287,
		290, 296, 296, 303, 305, 308, 308, 311, 311, 317, 317, 319, 319, 322, 322,
		331, 331, 336, 337, 342, 342, 352, 353, 355, 355, 360, 361, 364, 364, 370,
		371, 373, 373, 376, 376, 380, 380, 383, 383, 391, 391, 398, 398, 401, 401,
		415, 415, 420, 420, 431, 434, 437, 437, 466, 466, 473, 473, 481, 482, 486,
		486, 490, 491, 495, 495, 497, 498, 510, 511, 518, 520, 522, 522, 557, 557,
		2, 0, 204, 204, 494, 494, 1, 0, 552, 555, 7059, 0, 1190, 1, 0, 0, 0, 2,
		1194, 1, 0, 0, 0, 4, 1198, 1, 0, 0, 0, 6, 1217, 1, 0, 0, 0, 8, 1222, 1,
		0, 0, 0, 10, 1238, 1, 0, 0, 0, 12, 1240, 1, 0, 0, 0, 14, 1258, 1, 0, 0,
		0, 16, 1263, 1, 0, 0, 0, 18, 1268, 1, 0, 0, 0, 20, 1273, 1, 0, 0, 0, 22,
		1278, 1, 0, 0, 0, 24, 1283, 1, 0, 0, 0, 26, 1288, 1, 0, 0, 0, 28, 1300,
		1, 0, 0, 0, 30, 1302, 1, 0, 0, 0, 32, 1314, 1, 0, 0, 0, 34, 1316, 1, 0,
		0, 0, 36, 1328, 1, 0, 0, 0, 38, 1344, 1, 0, 0, 0, 40, 1346, 1, 0, 0, 0,
		42, 1357, 1, 0, 0, 0, 44, 1372, 1, 0, 0, 0, 46, 1393, 1, 0, 0, 0, 48, 1402,
		1, 0, 0, 0, 50, 1410, 1, 0, 0, 0, 52, 1416, 1, 0, 0, 0, 54, 1420, 1, 0,
		0, 0, 56, 1442, 1, 0, 0, 0, 58, 1446, 1, 0, 0, 0, 60, 1448, 1, 0, 0, 0,
		62, 1470, 1, 0, 0, 0, 64, 1479, 1, 0, 0, 0, 66, 1482, 1, 0, 0, 0, 68, 1488,
		1, 0, 0, 0, 70, 1502, 1, 0, 0, 0, 72, 1509, 1, 0, 0, 0, 74, 1525, 1, 0,
		0, 0, 76, 1532, 1, 0, 0, 0, 78, 1536, 1, 0, 0, 0, 80, 1538, 1, 0, 0, 0,
		82, 1554, 1, 0, 0, 0, 84, 1560, 1, 0, 0, 0, 86, 1577, 1, 0, 0, 0, 88, 1600,
		1, 0, 0, 0, 90, 1638, 1, 0, 0, 0, 92, 1640, 1, 0, 0, 0, 94, 1646, 1, 0,
		0, 0, 96, 1660, 1, 0, 0, 0, 98, 1680, 1, 0, 0, 0, 100, 1692, 1, 0, 0, 0,
		102, 1703, 1, 0, 0, 0, 104, 1705, 1, 0, 0, 0, 106, 1717, 1, 0, 0, 0, 108,
		1724, 1, 0, 0, 0, 110, 1741, 1, 0, 0, 0, 112, 1743, 1, 0, 0, 0, 114, 1760,
		1, 0, 0, 0, 116, 1775, 1, 0, 0, 0, 118, 1786, 1, 0, 0, 0, 120, 1797, 1,
		0, 0, 0, 122, 1807, 1, 0, 0, 0, 124, 1816, 1, 0, 0, 0, 126, 1833, 1, 0,
		0, 0, 128, 1851, 1, 0, 0, 0, 130, 1858, 1, 0, 0, 0, 132, 1868, 1, 0, 0,
		0, 134, 1877, 1, 0, 0, 0, 136, 1897, 1, 0, 0, 0, 138, 1899, 1, 0, 0, 0,
		140, 1913, 1, 0, 0, 0, 142, 1917, 1, 0, 0, 0, 144, 1926, 1, 0, 0, 0, 146,
		1930, 1, 0, 0, 0, 148, 1945, 1, 0, 0, 0, 150, 1958, 1, 0, 0, 0, 152, 1963,
		1, 0, 0, 0, 154, 1970, 1, 0, 0, 0, 156, 1988, 1, 0, 0, 0, 158, 1990, 1,
		0, 0, 0, 160, 1999, 1, 0, 0, 0, 162, 2028, 1, 0, 0, 0, 164, 2031, 1, 0,
		0, 0, 166, 2036, 1, 0, 0, 0, 168, 2040, 1, 0, 0, 0, 170, 2051, 1, 0, 0,
		0, 172, 2054, 1, 0, 0, 0, 174, 2061, 1, 0, 0, 0, 176, 2068, 1, 0, 0, 0,
		178, 2097, 1, 0, 0, 0, 180, 2104, 1, 0, 0, 0, 182, 2107, 1, 0, 0, 0, 184,
		2127, 1, 0, 0, 0, 186, 2134, 1, 0, 0, 0, 188, 2142, 1, 0, 0, 0, 190, 2158,
		1, 0, 0, 0, 192, 2178, 1, 0, 0, 0, 194, 2181, 1, 0, 0, 0, 196, 2192, 1,
		0, 0, 0, 198, 2203, 1, 0, 0, 0, 200, 2213, 1, 0, 0, 0, 202, 2222, 1, 0,
		0, 0, 204, 2224, 1, 0, 0, 0, 206, 2238, 1, 0, 0, 0, 208, 2245, 1, 0, 0,
		0, 210, 2254, 1, 0, 0, 0, 212, 2259, 1, 0, 0, 0, 214, 2268, 1, 0, 0, 0,
		216, 2277, 1, 0, 0, 0, 218, 2290, 1, 0, 0, 0, 220, 2292, 1, 0, 0, 0, 222,
		2320, 1, 0, 0, 0, 224, 2339, 1, 0, 0, 0, 226, 2362, 1, 0, 0, 0, 228, 2369,
		1, 0, 0, 0, 230, 2383, 1, 0, 0, 0, 232, 2390, 1, 0, 0, 0, 234, 2398, 1,
		0, 0, 0, 236, 2406, 1, 0, 0, 0, 238, 2413, 1, 0, 0, 0, 240, 2420, 1, 0,
		0, 0, 242, 2428, 1, 0, 0, 0, 244, 2437, 1, 0, 0, 0, 246, 2446, 1, 0, 0,
		0, 248, 2455, 1, 0, 0, 0, 250, 2464, 1, 0, 0, 0, 252, 2472, 1, 0, 0, 0,
		254, 2479, 1, 0, 0, 0, 256, 2494, 1, 0, 0, 0, 258, 2503, 1, 0, 0, 0, 260,
		2545, 1, 0, 0, 0, 262, 2548, 1, 0, 0, 0, 264, 2550, 1, 0, 0, 0, 266, 2552,
		1, 0, 0, 0, 268, 2555, 1, 0, 0, 0, 270, 2557, 1, 0, 0, 0, 272, 2559, 1,
		0, 0, 0, 274, 2561, 1, 0, 0, 0, 276, 2563, 1, 0, 0, 0, 278, 2571, 1, 0,
		0, 0, 280, 2585, 1, 0, 0, 0, 282, 2599, 1, 0, 0, 0, 284, 2607, 1, 0, 0,
		0, 286, 2615, 1, 0, 0, 0, 288, 2621, 1, 0, 0, 0, 290, 2627, 1, 0, 0, 0,
		292, 2633, 1, 0, 0, 0, 294, 2641, 1, 0, 0, 0, 296, 2644, 1, 0, 0, 0, 298,
		2647, 1, 0, 0, 0, 300, 2653, 1, 0, 0, 0, 302, 2659, 1, 0, 0, 0, 304, 2667,
		1, 0, 0, 0, 306, 2676, 1, 0, 0, 0, 308, 2678, 1, 0, 0, 0, 310, 2680, 1,
		0, 0, 0, 312, 2682, 1, 0, 0, 0, 314, 2696, 1, 0, 0, 0, 316, 2701, 1, 0,
		0, 0, 318, 2703, 1, 0, 0, 0, 320, 2705, 1, 0, 0, 0, 322, 2714, 1, 0, 0,
		0, 324, 2720, 1, 0, 0, 0, 326, 2743, 1, 0, 0, 0, 328, 2747, 1, 0, 0, 0,
		330, 2762, 1, 0, 0, 0, 332, 2765, 1, 0, 0, 0, 334, 2769, 1, 0, 0, 0, 336,
		2773, 1, 0, 0, 0, 338, 2779, 1, 0, 0, 0, 340, 2781, 1, 0, 0, 0, 342, 2795,
		1, 0, 0, 0, 344, 2805, 1, 0, 0, 0, 346, 2830, 1, 0, 0, 0, 348, 2836, 1,
		0, 0, 0, 350, 2845, 1, 0, 0, 0, 352, 2849, 1, 0, 0, 0, 354, 2854, 1, 0,
		0, 0, 356, 2866, 1, 0, 0, 0, 358, 2874, 1, 0, 0, 0, 360, 2877, 1, 0, 0,
		0, 362, 2887, 1, 0, 0, 0, 364, 2890, 1, 0, 0, 0, 366, 2893, 1, 0, 0, 0,
		368, 2899, 1, 0, 0, 0, 370, 2907, 1, 0, 0, 0, 372, 2916, 1, 0, 0, 0, 374,
		2922, 1, 0, 0, 0, 376, 2946, 1, 0, 0, 0, 378, 2962, 1, 0, 0, 0, 380, 2967,
		1, 0, 0, 0, 382, 2972, 1, 0, 0, 0, 384, 2978, 1, 0, 0, 0, 386, 2983, 1,
		0, 0, 0, 388, 2993, 1, 0, 0, 0, 390, 3000, 1, 0, 0, 0, 392, 3005, 1, 0,
		0, 0, 394, 3007, 1, 0, 0, 0, 396, 3013, 1, 0, 0, 0, 398, 3024, 1, 0, 0,
		0, 400, 3026, 1, 0, 0, 0, 402, 3035, 1, 0, 0, 0, 404, 3051, 1, 0, 0, 0,
		406, 3059, 1, 0, 0, 0, 408, 3076, 1, 0, 0, 0, 410, 3080, 1, 0, 0, 0, 412,
		3086, 1, 0, 0, 0, 414, 3092, 1, 0, 0, 0, 416, 3097, 1, 0, 0, 0, 418, 3111,
		1, 0, 0, 0, 420, 3114, 1, 0, 0, 0, 422, 3117, 1, 0, 0, 0, 424, 3125, 1,
		0, 0, 0, 426, 3127, 1, 0, 0, 0, 428, 3135, 1, 0, 0, 0, 430, 3138, 1, 0,
		0, 0, 432, 3143, 1, 0, 0, 0, 434, 3151, 1, 0, 0, 0, 436, 3153, 1, 0, 0,
		0, 438, 3186, 1, 0, 0, 0, 440, 3191, 1, 0, 0, 0, 442, 3197, 1, 0, 0, 0,
		444, 3204, 1, 0, 0, 0, 446, 3206, 1, 0, 0, 0, 448, 3212, 1, 0, 0, 0, 450,
		3215, 1, 0, 0, 0, 452, 3223, 1, 0, 0, 0, 454, 3227, 1, 0, 0, 0, 456, 3229,
		1, 0, 0, 0, 458, 3233, 1, 0, 0, 0, 460, 3268, 1, 0, 0, 0, 462, 3271, 1,
		0, 0, 0, 464, 3283, 1, 0, 0, 0, 466, 3297, 1, 0, 0, 0, 468, 3317, 1, 0,
		0, 0, 470, 3319, 1, 0, 0, 0, 472, 3324, 1, 0, 0, 0, 474, 3331, 1, 0, 0,
		0, 476, 3334, 1, 0, 0, 0, 478, 3337, 1, 0, 0, 0, 480, 3347, 1, 0, 0, 0,
		482, 3356, 1, 0, 0, 0, 484, 3361, 1, 0, 0, 0, 486, 3365, 1, 0, 0, 0, 488,
		3372, 1, 0, 0, 0, 490, 3380, 1, 0, 0, 0, 492, 3417, 1, 0, 0, 0, 494, 3434,
		1, 0, 0, 0, 496, 3446, 1, 0, 0, 0, 498, 3452, 1, 0, 0, 0, 500, 3454, 1,
		0, 0, 0, 502, 3458, 1, 0, 0, 0, 504, 3463, 1, 0, 0, 0, 506, 3477, 1, 0,
		0, 0, 508, 3483, 1, 0, 0, 0, 510, 3488, 1, 0, 0, 0, 512, 3494, 1, 0, 0,
		0, 514, 3509, 1, 0, 0, 0, 516, 3512, 1, 0, 0, 0, 518, 3523, 1, 0, 0, 0,
		520, 3525, 1, 0, 0, 0, 522, 3536, 1, 0, 0, 0, 524, 3542, 1, 0, 0, 0, 526,
		3547, 1, 0, 0, 0, 528, 3554, 1, 0, 0, 0, 530, 3561, 1, 0, 0, 0, 532, 3570,
		1, 0, 0, 0, 534, 3584, 1, 0, 0, 0, 536, 3638, 1, 0, 0, 0, 538, 3640, 1,
		0, 0, 0, 540, 3657, 1, 0, 0, 0, 542, 3679, 1, 0, 0, 0, 544, 3682, 1, 0,
		0, 0, 546, 3687, 1, 0, 0, 0, 548, 3691, 1, 0, 0, 0, 550, 3707, 1, 0, 0,
		0, 552, 3718, 1, 0, 0, 0, 554, 3736, 1, 0, 0, 0, 556, 3743, 1, 0, 0, 0,
		558, 3745, 1, 0, 0, 0, 560, 3751, 1, 0, 0, 0, 562, 3753, 1, 0, 0, 0, 564,
		3757, 1, 0, 0, 0, 566, 3763, 1, 0, 0, 0, 568, 3769, 1, 0, 0, 0, 570, 3777,
		1, 0, 0, 0, 572, 3800, 1, 0, 0, 0, 574, 3809, 1, 0, 0, 0, 576, 3815, 1,
		0, 0, 0, 578, 3834, 1, 0, 0, 0, 580, 3837, 1, 0, 0, 0, 582, 3851, 1, 0,
		0, 0, 584, 3858, 1, 0, 0, 0, 586, 3877, 1, 0, 0, 0, 588, 3879, 1, 0, 0,
		0, 590, 3882, 1, 0, 0, 0, 592, 3893, 1, 0, 0, 0, 594, 3895, 1, 0, 0, 0,
		596, 3901, 1, 0, 0, 0, 598, 3907, 1, 0, 0, 0, 600, 3925, 1, 0, 0, 0, 602,
		3939, 1, 0, 0, 0, 604, 3952, 1, 0, 0, 0, 606, 3954, 1, 0, 0, 0, 608, 3960,
		1, 0, 0, 0, 610, 3965, 1, 0, 0, 0, 612, 3973, 1, 0, 0, 0, 614, 3990, 1,
		0, 0, 0, 616, 3994, 1, 0, 0, 0, 618, 3996, 1, 0, 0, 0, 620, 4010, 1, 0,
		0, 0, 622, 4029, 1, 0, 0, 0, 624, 4046, 1, 0, 0, 0, 626, 4048, 1, 0, 0,
		0, 628, 4053, 1, 0, 0, 0, 630, 4059, 1, 0, 0, 0, 632, 4064, 1, 0, 0, 0,
		634, 4086, 1, 0, 0, 0, 636, 4092, 1, 0, 0, 0, 638, 4100, 1, 0, 0, 0, 640,
		4108, 1, 0, 0, 0, 642, 4114, 1, 0, 0, 0, 644, 4118, 1, 0, 0, 0, 646, 4122,
		1, 0, 0, 0, 648, 4125, 1, 0, 0, 0, 650, 4144, 1, 0, 0, 0, 652, 4154, 1,
		0, 0, 0, 654, 4177, 1, 0, 0, 0, 656, 4179, 1, 0, 0, 0, 658, 4183, 1, 0,
		0, 0, 660, 4193, 1, 0, 0, 0, 662, 4211, 1, 0, 0, 0, 664, 4213, 1, 0, 0,
		0, 666, 4216, 1, 0, 0, 0, 668, 4219, 1, 0, 0, 0, 670, 4230, 1, 0, 0, 0,
		672, 4233, 1, 0, 0, 0, 674, 4238, 1, 0, 0, 0, 676, 4243, 1, 0, 0, 0, 678,
		4247, 1, 0, 0, 0, 680, 4261, 1, 0, 0, 0, 682, 4263, 1, 0, 0, 0, 684, 4267,
		1, 0, 0, 0, 686, 4270, 1, 0, 0, 0, 688, 4272, 1, 0, 0, 0, 690, 4280, 1,
		0, 0, 0, 692, 4295, 1, 0, 0, 0, 694, 4297, 1, 0, 0, 0, 696, 4307, 1, 0,
		0, 0, 698, 4319, 1, 0, 0, 0, 700, 4330, 1, 0, 0, 0, 702, 4339, 1, 0, 0,
		0, 704, 4345, 1, 0, 0, 0, 706, 4354, 1, 0, 0, 0, 708, 4360, 1, 0, 0, 0,
		710, 4368, 1, 0, 0, 0, 712, 4374, 1, 0, 0, 0, 714, 4381, 1, 0, 0, 0, 716,
		4392, 1, 0, 0, 0, 718, 4404, 1, 0, 0, 0, 720, 4412, 1, 0, 0, 0, 722, 4419,
		1, 0, 0, 0, 724, 4427, 1, 0, 0, 0, 726, 4433, 1, 0, 0, 0, 728, 4441, 1,
		0, 0, 0, 730, 4451, 1, 0, 0, 0, 732, 4460, 1, 0, 0, 0, 734, 4465, 1, 0,
		0, 0, 736, 4470, 1, 0, 0, 0, 738, 4478, 1, 0, 0, 0, 740, 4504, 1, 0, 0,
		0, 742, 4516, 1, 0, 0, 0, 744, 4534, 1, 0, 0, 0, 746, 4541, 1, 0, 0, 0,
		748, 4549, 1, 0, 0, 0, 750, 4555, 1, 0, 0, 0, 752, 4564, 1, 0, 0, 0, 754,
		4567, 1, 0, 0, 0, 756, 4573, 1, 0, 0, 0, 758, 4585, 1, 0, 0, 0, 760, 4593,
		1, 0, 0, 0, 762, 4602, 1, 0, 0, 0, 764, 4604, 1, 0, 0, 0, 766, 4612, 1,
		0, 0, 0, 768, 4614, 1, 0, 0, 0, 770, 4634, 1, 0, 0, 0, 772, 4638, 1, 0,
		0, 0, 774, 4642, 1, 0, 0, 0, 776, 4651, 1, 0, 0, 0, 778, 4653, 1, 0, 0,
		0, 780, 4657, 1, 0, 0, 0, 782, 4666, 1, 0, 0, 0, 784, 4672, 1, 0, 0, 0,
		786, 4681, 1, 0, 0, 0, 788, 4687, 1, 0, 0, 0, 790, 4695, 1, 0, 0, 0, 792,
		4701, 1, 0, 0, 0, 794, 4707, 1, 0, 0, 0, 796, 4713, 1, 0, 0, 0, 798, 4723,
		1, 0, 0, 0, 800, 4734, 1, 0, 0, 0, 802, 4738, 1, 0, 0, 0, 804, 4743, 1,
		0, 0, 0, 806, 4755, 1, 0, 0, 0, 808, 4757, 1, 0, 0, 0, 810, 4767, 1, 0,
		0, 0, 812, 4773, 1, 0, 0, 0, 814, 4776, 1, 0, 0, 0, 816, 4782, 1, 0, 0,
		0, 818, 4789, 1, 0, 0, 0, 820, 4794, 1, 0, 0, 0, 822, 4800, 1, 0, 0, 0,
		824, 4832, 1, 0, 0, 0, 826, 4836, 1, 0, 0, 0, 828, 4843, 1, 0, 0, 0, 830,
		4849, 1, 0, 0, 0, 832, 4863, 1, 0, 0, 0, 834, 4882, 1, 0, 0, 0, 836, 4884,
		1, 0, 0, 0, 838, 4896, 1, 0, 0, 0, 840, 4904, 1, 0, 0, 0, 842, 4912, 1,
		0, 0, 0, 844, 4921, 1, 0, 0, 0, 846, 4926, 1, 0, 0, 0, 848, 4932, 1, 0,
		0, 0, 850, 4940, 1, 0, 0, 0, 852, 4946, 1, 0, 0, 0, 854, 4952, 1, 0, 0,
		0, 856, 4967, 1, 0, 0, 0, 858, 4970, 1, 0, 0, 0, 860, 4984, 1, 0, 0, 0,
		862, 4987, 1, 0, 0, 0, 864, 5006, 1, 0, 0, 0, 866, 5009, 1, 0, 0, 0, 868,
		5021, 1, 0, 0, 0, 870, 5034, 1, 0, 0, 0, 872, 5048, 1, 0, 0, 0, 874, 5052,
		1, 0, 0, 0, 876, 5055, 1, 0, 0, 0, 878, 5062, 1, 0, 0, 0, 880, 5066, 1,
		0, 0, 0, 882, 5075, 1, 0, 0, 0, 884, 5079, 1, 0, 0, 0, 886, 5084, 1, 0,
		0, 0, 888, 5086, 1, 0, 0, 0, 890, 5096, 1, 0, 0, 0, 892, 5107, 1, 0, 0,
		0, 894, 5119, 1, 0, 0, 0, 896, 5130, 1, 0, 0, 0, 898, 5134, 1, 0, 0, 0,
		900, 5136, 1, 0, 0, 0, 902, 5168, 1, 0, 0, 0, 904, 5180, 1, 0, 0, 0, 906,
		5190, 1, 0, 0, 0, 908, 5208, 1, 0, 0, 0, 910, 5215, 1, 0, 0, 0, 912, 5223,
		1, 0, 0, 0, 914, 5232, 1, 0, 0, 0, 916, 5235, 1, 0, 0, 0, 918, 5241, 1,
		0, 0, 0, 920, 5250, 1, 0, 0, 0, 922, 5253, 1, 0, 0, 0, 924, 5259, 1, 0,
		0, 0, 926, 5271, 1, 0, 0, 0, 928, 5285, 1, 0, 0, 0, 930, 5320, 1, 0, 0,
		0, 932, 5325, 1, 0, 0, 0, 934, 5345, 1, 0, 0, 0, 936, 5355, 1, 0, 0, 0,
		938, 5357, 1, 0, 0, 0, 940, 5366, 1, 0, 0, 0, 942, 5371, 1, 0, 0, 0, 944,
		5375, 1, 0, 0, 0, 946, 5380, 1, 0, 0, 0, 948, 5396, 1, 0, 0, 0, 950, 5407,
		1, 0, 0, 0, 952, 5419, 1, 0, 0, 0, 954, 5426, 1, 0, 0, 0, 956, 5428, 1,
		0, 0, 0, 958, 5434, 1, 0, 0, 0, 960, 5436, 1, 0, 0, 0, 962, 5440, 1, 0,
		0, 0, 964, 5444, 1, 0, 0, 0, 966, 5447, 1, 0, 0, 0, 968, 5465, 1, 0, 0,
		0, 970, 5475, 1, 0, 0, 0, 972, 5486, 1, 0, 0, 0, 974, 5494, 1, 0, 0, 0,
		976, 5500, 1, 0, 0, 0, 978, 5507, 1, 0, 0, 0, 980, 5513, 1, 0, 0, 0, 982,
		5520, 1, 0, 0, 0, 984, 5525, 1, 0, 0, 0, 986, 5531, 1, 0, 0, 0, 988, 5537,
		1, 0, 0, 0, 990, 5559, 1, 0, 0, 0, 992, 5562, 1, 0, 0, 0, 994, 5585, 1,
		0, 0, 0, 996, 5587, 1, 0, 0, 0, 998, 5610, 1, 0, 0, 0, 1000, 5615, 1, 0,
		0, 0, 1002, 5624, 1, 0, 0, 0, 1004, 5628, 1, 0, 0, 0, 1006, 5633, 1, 0,
		0, 0, 1008, 5636, 1, 0, 0, 0, 1010, 5645, 1, 0, 0, 0, 1012, 5657, 1, 0,
		0, 0, 1014, 5666, 1, 0, 0, 0, 1016, 5677, 1, 0, 0, 0, 1018, 5687, 1, 0,
		0, 0, 1020, 5699, 1, 0, 0, 0, 1022, 5708, 1, 0, 0, 0, 1024, 5720, 1, 0,
		0, 0, 1026, 5730, 1, 0, 0, 0, 1028, 5743, 1, 0, 0, 0, 1030, 5752, 1, 0,
		0, 0, 1032, 5763, 1, 0, 0, 0, 1034, 5770, 1, 0, 0, 0, 1036, 5773, 1, 0,
		0, 0, 1038, 5780, 1, 0, 0, 0, 1040, 5784, 1, 0, 0, 0, 1042, 5793, 1, 0,
		0, 0, 1044, 5802, 1, 0, 0, 0, 1046, 5804, 1, 0, 0, 0, 1048, 5811, 1, 0,
		0, 0, 1050, 5821, 1, 0, 0, 0, 1052, 5832, 1, 0, 0, 0, 1054, 5834, 1, 0,
		0, 0, 1056, 5850, 1, 0, 0, 0, 1058, 5874, 1, 0, 0, 0, 1060, 5890, 1, 0,
		0, 0, 1062, 5892, 1, 0, 0, 0, 1064, 5901, 1, 0, 0, 0, 1066, 5905, 1, 0,
		0, 0, 1068, 5911, 1, 0, 0, 0, 1070, 5919, 1, 0, 0, 0, 1072, 5965, 1, 0,
		0, 0, 1074, 5982, 1, 0, 0, 0, 1076, 5984, 1, 0, 0, 0, 1078, 6006, 1, 0,
		0, 0, 1080, 6029, 1, 0, 0, 0, 1082, 6037, 1, 0, 0, 0, 1084, 6039, 1, 0,
		0, 0, 1086, 6052, 1, 0, 0, 0, 1088, 6065, 1, 0, 0, 0, 1090, 6071, 1, 0,
		0, 0, 1092, 6075, 1, 0, 0, 0, 1094, 6088, 1, 0, 0, 0, 1096, 6091, 1, 0,
		0, 0, 1098, 6094, 1, 0, 0, 0, 1100, 6099, 1, 0, 0, 0, 1102, 6101, 1, 0,
		0, 0, 1104, 6104, 1, 0, 0, 0, 1106, 6107, 1, 0, 0, 0, 1108, 6110, 1, 0,
		0, 0, 1110, 6113, 1, 0, 0, 0, 1112, 6116, 1, 0, 0, 0, 1114, 6119, 1, 0,
		0, 0, 1116, 6121, 1, 0, 0, 0, 1118, 6123, 1, 0, 0, 0, 1120, 6125, 1, 0,
		0, 0, 1122, 6127, 1, 0, 0, 0, 1124, 6129, 1, 0, 0, 0, 1126, 6131, 1, 0,
		0, 0, 1128, 6133, 1, 0, 0, 0, 1130, 6138, 1, 0, 0, 0, 1132, 6140, 1, 0,
		0, 0, 1134, 6142, 1, 0, 0, 0, 1136, 6150, 1, 0, 0, 0, 1138, 6152, 1, 0,
		0, 0, 1140, 6154, 1, 0, 0, 0, 1142, 6156, 1, 0, 0, 0, 1144, 6158, 1, 0,
		0, 0, 1146, 6160, 1, 0, 0, 0, 1148, 6164, 1, 0, 0, 0, 1150, 6171, 1, 0,
		0, 0, 1152, 6175, 1, 0, 0, 0, 1154, 6177, 1, 0, 0, 0, 1156, 6179, 1, 0,
		0, 0, 1158, 6181, 1, 0, 0, 0, 1160, 6183, 1, 0, 0, 0, 1162, 6187, 1, 0,
		0, 0, 1164, 6189, 1, 0, 0, 0, 1166, 6191, 1, 0, 0, 0, 1168, 6193, 1, 0,
		0, 0, 1170, 6195, 1, 0, 0, 0, 1172, 6203, 1, 0, 0, 0, 1174, 6205, 1, 0,
		0, 0, 1176, 6210, 1, 0, 0, 0, 1178, 6212, 1, 0, 0, 0, 1180, 6214, 1, 0,
		0, 0, 1182, 6222, 1, 0, 0, 0, 1184, 6245, 1, 0, 0, 0, 1186, 6280, 1, 0,
		0, 0, 1188, 6283, 1, 0, 0, 0, 1190, 1191, 3, 2, 1, 0, 1191, 1192, 5, 0,
		0, 1, 1192, 1, 1, 0, 0, 0, 1193, 1195, 3, 4, 2, 0, 1194, 1193, 1, 0, 0,
		0, 1195, 1196, 1, 0, 0, 0, 1196, 1194, 1, 0, 0, 0, 1196, 1197, 1, 0, 0,
		0, 1197, 3, 1, 0, 0, 0, 1198, 1200, 3, 8, 4, 0, 1199, 1201, 3, 26, 13,
		0, 1200, 1199, 1, 0, 0, 0, 1200, 1201, 1, 0, 0, 0, 1201, 1203, 1, 0, 0,
		0, 1202, 1204, 3, 154, 77, 0, 1203, 1202, 1, 0, 0, 0, 1203, 1204, 1, 0,
		0, 0, 1204, 1206, 1, 0, 0, 0, 1205, 1207, 3, 504, 252, 0, 1206, 1205, 1,
		0, 0, 0, 1206, 1207, 1, 0, 0, 0, 1207, 1211, 1, 0, 0, 0, 1208, 1210, 3,
		4, 2, 0, 1209, 1208, 1, 0, 0, 0, 1210, 1213, 1, 0, 0, 0, 1211, 1209, 1,
		0, 0, 0, 1211, 1212, 1, 0, 0, 0, 1212, 1215, 1, 0, 0, 0, 1213, 1211, 1,
		0, 0, 0, 1214, 1216, 3, 6, 3, 0, 1215, 1214, 1, 0, 0, 0, 1215, 1216, 1,
		0, 0, 0, 1216, 5, 1, 0, 0, 0, 1217, 1218, 5, 158, 0, 0, 1218, 1219, 5,
		361, 0, 0, 1219, 1220, 3, 1152, 576, 0, 1220, 1221, 5, 534, 0, 0, 1221,
		7, 1, 0, 0, 0, 1222, 1223, 7, 0, 0, 0, 1223, 1224, 5, 145, 0, 0, 1224,
		1225, 5, 534, 0, 0, 1225, 1229, 3, 12, 6, 0, 1226, 1228, 3, 10, 5, 0, 1227,
		1226, 1, 0, 0, 0, 1228, 1231, 1, 0, 0, 0, 1229, 1227, 1, 0, 0, 0, 1229,
		1230, 1, 0, 0, 0, 1230, 9, 1, 0, 0, 0, 1231, 1229, 1, 0, 0, 0, 1232, 1239,
		3, 14, 7, 0, 1233, 1239, 3, 16, 8, 0, 1234, 1239, 3, 18, 9, 0, 1235, 1239,
		3, 20, 10, 0, 1236, 1239, 3, 22, 11, 0, 1237, 1239, 3, 24, 12, 0, 1238,
		1232, 1, 0, 0, 0, 1238, 1233, 1, 0, 0, 0, 1238, 1234, 1, 0, 0, 0, 1238,
		1235, 1, 0, 0, 0, 1238, 1236, 1, 0, 0, 0, 1238, 1237, 1, 0, 0, 0, 1239,
		11, 1, 0, 0, 0, 1240, 1241, 5, 362, 0, 0, 1241, 1242, 5, 534, 0, 0, 1242,
		1250, 3, 1152, 576, 0, 1243, 1245, 5, 254, 0, 0, 1244, 1243, 1, 0, 0, 0,
		1244, 1245, 1, 0, 0, 0, 1245, 1246, 1, 0, 0, 0, 1246, 1248, 7, 1, 0, 0,
		1247, 1249, 5, 361, 0, 0, 1248, 1247, 1, 0, 0, 0, 1248, 1249, 1, 0, 0,
		0, 1249, 1251, 1, 0, 0, 0, 1250, 1244, 1, 0, 0, 0, 1250, 1251, 1, 0, 0,
		0, 1251, 1253, 1, 0, 0, 0, 1252, 1254, 5, 534, 0, 0, 1253, 1252, 1, 0,
		0, 0, 1253, 1254, 1, 0, 0, 0, 1254, 1256, 1, 0, 0, 0, 1255, 1257, 3, 1188,
		594, 0, 1256, 1255, 1, 0, 0, 0, 1256, 1257, 1, 0, 0, 0, 1257, 13, 1, 0,
		0, 0, 1258, 1259, 5, 32, 0, 0, 1259, 1261, 5, 534, 0, 0, 1260, 1262, 3,
		1188, 594, 0, 1261, 1260, 1, 0, 0, 0, 1261, 1262, 1, 0, 0, 0, 1262, 15,
		1, 0, 0, 0, 1263, 1264, 5, 249, 0, 0, 1264, 1266, 5, 534, 0, 0, 1265, 1267,
		3, 1188, 594, 0, 1266, 1265, 1, 0, 0, 0, 1266, 1267, 1, 0, 0, 0, 1267,
		17, 1, 0, 0, 0, 1268, 1269, 5, 113, 0, 0, 1269, 1271, 5, 534, 0, 0, 1270,
		1272, 3, 1188, 594, 0, 1271, 1270, 1, 0, 0, 0, 1271, 1272, 1, 0, 0, 0,
		1272, 19, 1, 0, 0, 0, 1273, 1274, 5, 112, 0, 0, 1274, 1276, 5, 534, 0,
		0, 1275, 1277, 3, 1188, 594, 0, 1276, 1275, 1, 0, 0, 0, 1276, 1277, 1,
		0, 0, 0, 1277, 21, 1, 0, 0, 0, 1278, 1279, 5, 421, 0, 0, 1279, 1281, 5,
		534, 0, 0, 1280, 1282, 3, 1188, 594, 0, 1281, 1280, 1, 0, 0, 0, 1281, 1282,
		1, 0, 0, 0, 1282, 23, 1, 0, 0, 0, 1283, 1284, 5, 389, 0, 0, 1284, 1286,
		5, 534, 0, 0, 1285, 1287, 3, 1188, 594, 0, 1286, 1285, 1, 0, 0, 0, 1286,
		1287, 1, 0, 0, 0, 1287, 25, 1, 0, 0, 0, 1288, 1289, 5, 184, 0, 0, 1289,
		1290, 5, 145, 0, 0, 1290, 1294, 5, 534, 0, 0, 1291, 1293, 3, 28, 14, 0,
		1292, 1291, 1, 0, 0, 0, 1293, 1296, 1, 0, 0, 0, 1294, 1292, 1, 0, 0, 0,
		1294, 1295, 1, 0, 0, 0, 1295, 27, 1, 0, 0, 0, 1296, 1294, 1, 0, 0, 0, 1297,
		1301, 3, 30, 15, 0, 1298, 1301, 3, 54, 27, 0, 1299, 1301, 3, 100, 50, 0,
		1300, 1297, 1, 0, 0, 0, 1300, 1298, 1, 0, 0, 0, 1300, 1299, 1, 0, 0, 0,
		1301, 29, 1, 0, 0, 0, 1302, 1303, 5, 93, 0, 0, 1303, 1304, 5, 419, 0, 0,
		1304, 1308, 5, 534, 0, 0, 1305, 1307, 3, 32, 16, 0, 1306, 1305, 1, 0, 0,
		0, 1307, 1310, 1, 0, 0, 0, 1308, 1306, 1, 0, 0, 0, 1308, 1309, 1, 0, 0,
		0, 1309, 31, 1, 0, 0, 0, 1310, 1308, 1, 0, 0, 0, 1311, 1315, 3, 34, 17,
		0, 1312, 1315, 3, 36, 18, 0, 1313, 1315, 3, 54, 27, 0, 1314, 1311, 1, 0,
		0, 0, 1314, 1312, 1, 0, 0, 0, 1314, 1313, 1, 0, 0, 0, 1315, 33, 1, 0, 0,
		0, 1316, 1317, 5, 449, 0, 0, 1317, 1318, 5, 534, 0, 0, 1318, 1324, 3, 1124,
		562, 0, 1319, 1321, 5, 514, 0, 0, 1320, 1319, 1, 0, 0, 0, 1320, 1321, 1,
		0, 0, 0, 1321, 1322, 1, 0, 0, 0, 1322, 1323, 5, 125, 0, 0, 1323, 1325,
		5, 297, 0, 0, 1324, 1320, 1, 0, 0, 0, 1324, 1325, 1, 0, 0, 0, 1325, 1326,
		1, 0, 0, 0, 1326, 1327, 5, 534, 0, 0, 1327, 35, 1, 0, 0, 0, 1328, 1329,
		5, 320, 0, 0, 1329, 1330, 5, 534, 0, 0, 1330, 1334, 3, 1124, 562, 0, 1331,
		1333, 3, 38, 19, 0, 1332, 1331, 1, 0, 0, 0, 1333, 1336, 1, 0, 0, 0, 1334,
		1332, 1, 0, 0, 0, 1334, 1335, 1, 0, 0, 0, 1335, 1337, 1, 0, 0, 0, 1336,
		1334, 1, 0, 0, 0, 1337, 1338, 5, 534, 0, 0, 1338, 37, 1, 0, 0, 0, 1339,
		1345, 3, 40, 20, 0, 1340, 1345, 3, 42, 21, 0, 1341, 1345, 3, 44, 22, 0,
		1342, 1345, 3, 50, 25, 0, 1343, 1345, 3, 52, 26, 0, 1344, 1339, 1, 0, 0,
		0, 1344, 1340, 1, 0, 0, 0, 1344, 1341, 1, 0, 0, 0, 1344, 1342, 1, 0, 0,
		0, 1344, 1343, 1, 0, 0, 0, 1345, 39, 1, 0, 0, 0, 1346, 1348, 5, 293, 0,
		0, 1347, 1349, 5, 439, 0, 0, 1348, 1347, 1, 0, 0, 0, 1348, 1349, 1, 0,
		0, 0, 1349, 1352, 1, 0, 0, 0, 1350, 1353, 3, 1178, 589, 0, 1351, 1353,
		3, 1170, 585, 0, 1352, 1350, 1, 0, 0, 0, 1352, 1351, 1, 0, 0, 0, 1353,
		1355, 1, 0, 0, 0, 1354, 1356, 7, 2, 0, 0, 1355, 1354, 1, 0, 0, 0, 1355,
		1356, 1, 0, 0, 0, 1356, 41, 1, 0, 0, 0, 1357, 1359, 5, 141, 0, 0, 1358,
		1360, 5, 439, 0, 0, 1359, 1358, 1, 0, 0, 0, 1359, 1360, 1, 0, 0, 0, 1360,
		1362, 1, 0, 0, 0, 1361, 1363, 5, 254, 0, 0, 1362, 1361, 1, 0, 0, 0, 1362,
		1363, 1, 0, 0, 0, 1363, 1366, 1, 0, 0, 0, 1364, 1367, 3, 1178, 589, 0,
		1365, 1367, 3, 1170, 585, 0, 1366, 1364, 1, 0, 0, 0, 1366, 1365, 1, 0,
		0, 0, 1367, 1369, 1, 0, 0, 0, 1368, 1370, 7, 3, 0, 0, 1369, 1368, 1, 0,
		0, 0, 1369, 1370, 1, 0, 0, 0, 1370, 43, 1, 0, 0, 0, 1371, 1373, 5, 361,
		0, 0, 1372, 1371, 1, 0, 0, 0, 1372, 1373, 1, 0, 0, 0, 1373, 1375, 1, 0,
		0, 0, 1374, 1376, 5, 72, 0, 0, 1375, 1374, 1, 0, 0, 0, 1375, 1376, 1, 0,
		0, 0, 1376, 1377, 1, 0, 0, 0, 1377, 1379, 5, 428, 0, 0, 1378, 1380, 5,
		254, 0, 0, 1379, 1378, 1, 0, 0, 0, 1379, 1380, 1, 0, 0, 0, 1380, 1382,
		1, 0, 0, 0, 1381, 1383, 3, 1114, 557, 0, 1382, 1381, 1, 0, 0, 0, 1383,
		1384, 1, 0, 0, 0, 1384, 1382, 1, 0, 0, 0, 1384, 1385, 1, 0, 0, 0, 1385,
		1387, 1, 0, 0, 0, 1386, 1388, 3, 46, 23, 0, 1387, 1386, 1, 0, 0, 0, 1387,
		1388, 1, 0, 0, 0, 1388, 1390, 1, 0, 0, 0, 1389, 1391, 3, 48, 24, 0, 1390,
		1389, 1, 0, 0, 0, 1390, 1391, 1, 0, 0, 0, 1391, 45, 1, 0, 0, 0, 1392, 1394,
		5, 212, 0, 0, 1393, 1392, 1, 0, 0, 0, 1393, 1394, 1, 0, 0, 0, 1394, 1395,
		1, 0, 0, 0, 1395, 1397, 5, 14, 0, 0, 1396, 1398, 5, 254, 0, 0, 1397, 1396,
		1, 0, 0, 0, 1397, 1398, 1, 0, 0, 0, 1398, 1399, 1, 0, 0, 0, 1399, 1400,
		3, 1114, 557, 0, 1400, 47, 1, 0, 0, 0, 1401, 1403, 5, 212, 0, 0, 1402,
		1401, 1, 0, 0, 0, 1402, 1403, 1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404,
		1406, 5, 304, 0, 0, 1405, 1407, 5, 254, 0, 0, 1406, 1405, 1, 0, 0, 0, 1406,
		1407, 1, 0, 0, 0, 1407, 1408, 1, 0, 0, 0, 1408, 1409, 3, 1114, 557, 0,
		1409, 49, 1, 0, 0, 0, 1410, 1412, 5, 423, 0, 0, 1411, 1413, 5, 254, 0,
		0, 1412, 1411, 1, 0, 0, 0, 1412, 1413, 1, 0, 0, 0, 1413, 1414, 1, 0, 0,
		0, 1414, 1415, 3, 1178, 589, 0, 1415, 51, 1, 0, 0, 0, 1416, 1417, 5, 62,
		0, 0, 1417, 1418, 5, 430, 0, 0, 1418, 1419, 5, 534, 0, 0, 1419, 53, 1,
		0, 0, 0, 1420, 1421, 5, 452, 0, 0, 1421, 1429, 5, 534, 0, 0, 1422, 1424,
		3, 56, 28, 0, 1423, 1422, 1, 0, 0, 0, 1424, 1425, 1, 0, 0, 0, 1425, 1423,
		1, 0, 0, 0, 1425, 1426, 1, 0, 0, 0, 1426, 1427, 1, 0, 0, 0, 1427, 1428,
		5, 534, 0, 0, 1428, 1430, 1, 0, 0, 0, 1429, 1423, 1, 0, 0, 0, 1429, 1430,
		1, 0, 0, 0, 1430, 55, 1, 0, 0, 0, 1431, 1443, 3, 70, 35, 0, 1432, 1443,
		3, 92, 46, 0, 1433, 1443, 3, 58, 29, 0, 1434, 1443, 3, 72, 36, 0, 1435,
		1443, 3, 80, 40, 0, 1436, 1443, 3, 82, 41, 0, 1437, 1443, 3, 96, 48, 0,
		1438, 1443, 3, 88, 44, 0, 1439, 1443, 3, 86, 43, 0, 1440, 1443, 3, 84,
		42, 0, 1441, 1443, 3, 94, 47, 0, 1442, 1431, 1, 0, 0, 0, 1442, 1432, 1,
		0, 0, 0, 1442, 1433, 1, 0, 0, 0, 1442, 1434, 1, 0, 0, 0, 1442, 1435, 1,
		0, 0, 0, 1442, 1436, 1, 0, 0, 0, 1442, 1437, 1, 0, 0, 0, 1442, 1438, 1,
		0, 0, 0, 1442, 1439, 1, 0, 0, 0, 1442, 1440, 1, 0, 0, 0, 1442, 1441, 1,
		0, 0, 0, 1443, 57, 1, 0, 0, 0, 1444, 1447, 3, 60, 30, 0, 1445, 1447, 3,
		68, 34, 0, 1446, 1444, 1, 0, 0, 0, 1446, 1445, 1, 0, 0, 0, 1447, 59, 1,
		0, 0, 0, 1448, 1449, 5, 10, 0, 0, 1449, 1452, 3, 1114, 557, 0, 1450, 1451,
		5, 212, 0, 0, 1451, 1453, 5, 14, 0, 0, 1452, 1450, 1, 0, 0, 0, 1452, 1453,
		1, 0, 0, 0, 1453, 1455, 1, 0, 0, 0, 1454, 1456, 5, 254, 0, 0, 1455, 1454,
		1, 0, 0, 0, 1455, 1456, 1, 0, 0, 0, 1456, 1468, 1, 0, 0, 0, 1457, 1469,
		5, 151, 0, 0, 1458, 1469, 5, 26, 0, 0, 1459, 1469, 5, 454, 0, 0, 1460,
		1469, 5, 455, 0, 0, 1461, 1469, 5, 306, 0, 0, 1462, 1469, 3, 1170, 585,
		0, 1463, 1465, 3, 62, 31, 0, 1464, 1463, 1, 0, 0, 0, 1465, 1466, 1, 0,
		0, 0, 1466, 1464, 1, 0, 0, 0, 1466, 1467, 1, 0, 0, 0, 1467, 1469, 1, 0,
		0, 0, 1468, 1457, 1, 0, 0, 0, 1468, 1458, 1, 0, 0, 0, 1468, 1459, 1, 0,
		0, 0, 1468, 1460, 1, 0, 0, 0, 1468, 1461, 1, 0, 0, 0, 1468, 1462, 1, 0,
		0, 0, 1468, 1464, 1, 0, 0, 0, 1469, 61, 1, 0, 0, 0, 1470, 1477, 3, 1172,
		586, 0, 1471, 1478, 3, 64, 32, 0, 1472, 1474, 3, 66, 33, 0, 1473, 1472,
		1, 0, 0, 0, 1474, 1475, 1, 0, 0, 0, 1475, 1473, 1, 0, 0, 0, 1475, 1476,
		1, 0, 0, 0, 1476, 1478, 1, 0, 0, 0, 1477, 1471, 1, 0, 0, 0, 1477, 1473,
		1, 0, 0, 0, 1477, 1478, 1, 0, 0, 0, 1478, 63, 1, 0, 0, 0, 1479, 1480, 7,
		4, 0, 0, 1480, 1481, 3, 1172, 586, 0, 1481, 65, 1, 0, 0, 0, 1482, 1484,
		5, 16, 0, 0, 1483, 1485, 3, 1172, 586, 0, 1484, 1483, 1, 0, 0, 0, 1485,
		1486, 1, 0, 0, 0, 1486, 1484, 1, 0, 0, 0, 1486, 1487, 1, 0, 0, 0, 1487,
		67, 1, 0, 0, 0, 1488, 1489, 5, 10, 0, 0, 1489, 1491, 3, 1114, 557, 0, 1490,
		1492, 5, 212, 0, 0, 1491, 1490, 1, 0, 0, 0, 1491, 1492, 1, 0, 0, 0, 1492,
		1493, 1, 0, 0, 0, 1493, 1495, 5, 304, 0, 0, 1494, 1496, 5, 254, 0, 0, 1495,
		1494, 1, 0, 0, 0, 1495, 1496, 1, 0, 0, 0, 1496, 1500, 1, 0, 0, 0, 1497,
		1501, 5, 306, 0, 0, 1498, 1499, 5, 55, 0, 0, 1499, 1501, 3, 1172, 586,
		0, 1500, 1497, 1, 0, 0, 0, 1500, 1498, 1, 0, 0, 0, 1501, 69, 1, 0, 0, 0,
		1502, 1503, 5, 61, 0, 0, 1503, 1505, 3, 1178, 589, 0, 1504, 1506, 5, 254,
		0, 0, 1505, 1504, 1, 0, 0, 0, 1505, 1506, 1, 0, 0, 0, 1506, 1507, 1, 0,
		0, 0, 1507, 1508, 3, 1146, 573, 0, 1508, 71, 1, 0, 0, 0, 1509, 1510, 5,
		64, 0, 0, 1510, 1515, 3, 1122, 561, 0, 1511, 1513, 5, 212, 0, 0, 1512,
		1511, 1, 0, 0, 0, 1512, 1513, 1, 0, 0, 0, 1513, 1514, 1, 0, 0, 0, 1514,
		1516, 7, 5, 0, 0, 1515, 1512, 1, 0, 0, 0, 1515, 1516, 1, 0, 0, 0, 1516,
		1518, 1, 0, 0, 0, 1517, 1519, 5, 254, 0, 0, 1518, 1517, 1, 0, 0, 0, 1518,
		1519, 1, 0, 0, 0, 1519, 1521, 1, 0, 0, 0, 1520, 1522, 3, 74, 37, 0, 1521,
		1520, 1, 0, 0, 0, 1522, 1523, 1, 0, 0, 0, 1523, 1521, 1, 0, 0, 0, 1523,
		1524, 1, 0, 0, 0, 1524, 73, 1, 0, 0, 0, 1525, 1528, 3, 76, 38, 0, 1526,
		1527, 7, 4, 0, 0, 1527, 1529, 3, 78, 39, 0, 1528, 1526, 1, 0, 0, 0, 1528,
		1529, 1, 0, 0, 0, 1529, 75, 1, 0, 0, 0, 1530, 1533, 3, 1074, 537, 0, 1531,
		1533, 3, 1172, 586, 0, 1532, 1530, 1, 0, 0, 0, 1532, 1531, 1, 0, 0, 0,
		1533, 77, 1, 0, 0, 0, 1534, 1537, 3, 1074, 537, 0, 1535, 1537, 3, 1172,
		586, 0, 1536, 1534, 1, 0, 0, 0, 1536, 1535, 1, 0, 0, 0, 1537, 79, 1, 0,
		0, 0, 1538, 1540, 5, 107, 0, 0, 1539, 1541, 5, 438, 0, 0, 1540, 1539, 1,
		0, 0, 0, 1540, 1541, 1, 0, 0, 0, 1541, 1543, 1, 0, 0, 0, 1542, 1544, 5,
		254, 0, 0, 1543, 1542, 1, 0, 0, 0, 1543, 1544, 1, 0, 0, 0, 1544, 1545,
		1, 0, 0, 0, 1545, 1552, 3, 1172, 586, 0, 1546, 1548, 5, 514, 0, 0, 1547,
		1546, 1, 0, 0, 0, 1547, 1548, 1, 0, 0, 0, 1548, 1549, 1, 0, 0, 0, 1549,
		1550, 5, 347, 0, 0, 1550, 1551, 5, 466, 0, 0, 1551, 1553, 3, 1172, 586,
		0, 1552, 1547, 1, 0, 0, 0, 1552, 1553, 1, 0, 0, 0, 1553, 81, 1, 0, 0, 0,
		1554, 1556, 5, 126, 0, 0, 1555, 1557, 5, 254, 0, 0, 1556, 1555, 1, 0, 0,
		0, 1556, 1557, 1, 0, 0, 0, 1557, 1558, 1, 0, 0, 0, 1558, 1559, 5, 76, 0,
		0, 1559, 83, 1, 0, 0, 0, 1560, 1562, 5, 128, 0, 0, 1561, 1563, 7, 6, 0,
		0, 1562, 1561, 1, 0, 0, 0, 1562, 1563, 1, 0, 0, 0, 1563, 1568, 1, 0, 0,
		0, 1564, 1566, 5, 438, 0, 0, 1565, 1567, 5, 254, 0, 0, 1566, 1565, 1, 0,
		0, 0, 1566, 1567, 1, 0, 0, 0, 1567, 1569, 1, 0, 0, 0, 1568, 1564, 1, 0,
		0, 0, 1568, 1569, 1, 0, 0, 0, 1569, 1571, 1, 0, 0, 0, 1570, 1572, 7, 7,
		0, 0, 1571, 1570, 1, 0, 0, 0, 1571, 1572, 1, 0, 0, 0, 1572, 1573, 1, 0,
		0, 0, 1573, 1575, 5, 427, 0, 0, 1574, 1576, 5, 62, 0, 0, 1575, 1574, 1,
		0, 0, 0, 1575, 1576, 1, 0, 0, 0, 1576, 85, 1, 0, 0, 0, 1577, 1582, 5, 129,
		0, 0, 1578, 1580, 5, 438, 0, 0, 1579, 1581, 5, 254, 0, 0, 1580, 1579, 1,
		0, 0, 0, 1580, 1581, 1, 0, 0, 0, 1581, 1583, 1, 0, 0, 0, 1582, 1578, 1,
		0, 0, 0, 1582, 1583, 1, 0, 0, 0, 1583, 1584, 1, 0, 0, 0, 1584, 1589, 7,
		7, 0, 0, 1585, 1587, 5, 427, 0, 0, 1586, 1588, 5, 62, 0, 0, 1587, 1586,
		1, 0, 0, 0, 1587, 1588, 1, 0, 0, 0, 1588, 1590, 1, 0, 0, 0, 1589, 1585,
		1, 0, 0, 0, 1589, 1590, 1, 0, 0, 0, 1590, 87, 1, 0, 0, 0, 1591, 1593, 3,
		1132, 566, 0, 1592, 1594, 5, 254, 0, 0, 1593, 1592, 1, 0, 0, 0, 1593, 1594,
		1, 0, 0, 0, 1594, 1595, 1, 0, 0, 0, 1595, 1597, 3, 1146, 573, 0, 1596,
		1598, 3, 90, 45, 0, 1597, 1596, 1, 0, 0, 0, 1597, 1598, 1, 0, 0, 0, 1598,
		1601, 1, 0, 0, 0, 1599, 1601, 3, 90, 45, 0, 1600, 1591, 1, 0, 0, 0, 1600,
		1599, 1, 0, 0, 0, 1601, 89, 1, 0, 0, 0, 1602, 1604, 5, 326, 0, 0, 1603,
		1605, 5, 457, 0, 0, 1604, 1603, 1, 0, 0, 0, 1604, 1605, 1, 0, 0, 0, 1605,
		1607, 1, 0, 0, 0, 1606, 1608, 5, 254, 0, 0, 1607, 1606, 1, 0, 0, 0, 1607,
		1608, 1, 0, 0, 0, 1608, 1609, 1, 0, 0, 0, 1609, 1618, 3, 1046, 523, 0,
		1610, 1612, 5, 324, 0, 0, 1611, 1613, 5, 457, 0, 0, 1612, 1611, 1, 0, 0,
		0, 1612, 1613, 1, 0, 0, 0, 1613, 1615, 1, 0, 0, 0, 1614, 1616, 5, 254,
		0, 0, 1615, 1614, 1, 0, 0, 0, 1615, 1616, 1, 0, 0, 0, 1616, 1617, 1, 0,
		0, 0, 1617, 1619, 3, 1046, 523, 0, 1618, 1610, 1, 0, 0, 0, 1618, 1619,
		1, 0, 0, 0, 1619, 1639, 1, 0, 0, 0, 1620, 1622, 5, 324, 0, 0, 1621, 1623,
		5, 457, 0, 0, 1622, 1621, 1, 0, 0, 0, 1622, 1623, 1, 0, 0, 0, 1623, 1625,
		1, 0, 0, 0, 1624, 1626, 5, 254, 0, 0, 1625, 1624, 1, 0, 0, 0, 1625, 1626,
		1, 0, 0, 0, 1626, 1627, 1, 0, 0, 0, 1627, 1636, 3, 1046, 523, 0, 1628,
		1630, 5, 326, 0, 0, 1629, 1631, 5, 457, 0, 0, 1630, 1629, 1, 0, 0, 0, 1630,
		1631, 1, 0, 0, 0, 1631, 1633, 1, 0, 0, 0, 1632, 1634, 5, 254, 0, 0, 1633,
		1632, 1, 0, 0, 0, 1633, 1634, 1, 0, 0, 0, 1634, 1635, 1, 0, 0, 0, 1635,
		1637, 3, 1046, 523, 0, 1636, 1628, 1, 0, 0, 0, 1636, 1637, 1, 0, 0, 0,
		1637, 1639, 1, 0, 0, 0, 1638, 1602, 1, 0, 0, 0, 1638, 1620, 1, 0, 0, 0,
		1639, 91, 1, 0, 0, 0, 1640, 1642, 5, 322, 0, 0, 1641, 1643, 5, 254, 0,
		0, 1642, 1641, 1, 0, 0, 0, 1642, 1643, 1, 0, 0, 0, 1643, 1644, 1, 0, 0,
		0, 1644, 1645, 3, 1146, 573, 0, 1645, 93, 1, 0, 0, 0, 1646, 1648, 5, 400,
		0, 0, 1647, 1649, 5, 515, 0, 0, 1648, 1647, 1, 0, 0, 0, 1648, 1649, 1,
		0, 0, 0, 1649, 1651, 1, 0, 0, 0, 1650, 1652, 5, 283, 0, 0, 1651, 1650,
		1, 0, 0, 0, 1651, 1652, 1, 0, 0, 0, 1652, 1654, 1, 0, 0, 0, 1653, 1655,
		5, 254, 0, 0, 1654, 1653, 1, 0, 0, 0, 1654, 1655, 1, 0, 0, 0, 1655, 1656,
		1, 0, 0, 0, 1656, 1658, 5, 308, 0, 0, 1657, 1659, 5, 54, 0, 0, 1658, 1657,
		1, 0, 0, 0, 1658, 1659, 1, 0, 0, 0, 1659, 95, 1, 0, 0, 0, 1660, 1662, 5,
		467, 0, 0, 1661, 1663, 5, 63, 0, 0, 1662, 1661, 1, 0, 0, 0, 1662, 1663,
		1, 0, 0, 0, 1663, 1668, 1, 0, 0, 0, 1664, 1666, 5, 212, 0, 0, 1665, 1664,
		1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1667, 1, 0, 0, 0, 1667, 1669,
		7, 5, 0, 0, 1668, 1665, 1, 0, 0, 0, 1668, 1669, 1, 0, 0, 0, 1669, 1671,
		1, 0, 0, 0, 1670, 1672, 3, 98, 49, 0, 1671, 1670, 1, 0, 0, 0, 1672, 1673,
		1, 0, 0, 0, 1673, 1671, 1, 0, 0, 0, 1673, 1674, 1, 0, 0, 0, 1674, 1677,
		1, 0, 0, 0, 1675, 1676, 5, 239, 0, 0, 1676, 1678, 3, 1114, 557, 0, 1677,
		1675, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 97, 1, 0, 0, 0, 1679, 1681,
		3, 1166, 583, 0, 1680, 1679, 1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682,
		1680, 1, 0, 0, 0, 1682, 1683, 1, 0, 0, 0, 1683, 1685, 1, 0, 0, 0, 1684,
		1686, 7, 8, 0, 0, 1685, 1684, 1, 0, 0, 0, 1685, 1686, 1, 0, 0, 0, 1686,
		1688, 1, 0, 0, 0, 1687, 1689, 3, 1178, 589, 0, 1688, 1687, 1, 0, 0, 0,
		1689, 1690, 1, 0, 0, 0, 1690, 1688, 1, 0, 0, 0, 1690, 1691, 1, 0, 0, 0,
		1691, 99, 1, 0, 0, 0, 1692, 1693, 5, 247, 0, 0, 1693, 1694, 5, 419, 0,
		0, 1694, 1698, 5, 534, 0, 0, 1695, 1697, 3, 102, 51, 0, 1696, 1695, 1,
		0, 0, 0, 1697, 1700, 1, 0, 0, 0, 1698, 1696, 1, 0, 0, 0, 1698, 1699, 1,
		0, 0, 0, 1699, 101, 1, 0, 0, 0, 1700, 1698, 1, 0, 0, 0, 1701, 1704, 3,
		104, 52, 0, 1702, 1704, 3, 134, 67, 0, 1703, 1701, 1, 0, 0, 0, 1703, 1702,
		1, 0, 0, 0, 1704, 103, 1, 0, 0, 0, 1705, 1712, 5, 207, 0, 0, 1706, 1708,
		5, 534, 0, 0, 1707, 1706, 1, 0, 0, 0, 1707, 1708, 1, 0, 0, 0, 1708, 1709,
		1, 0, 0, 0, 1709, 1711, 3, 106, 53, 0, 1710, 1707, 1, 0, 0, 0, 1711, 1714,
		1, 0, 0, 0, 1712, 1710, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713, 1715,
		1, 0, 0, 0, 1714, 1712, 1, 0, 0, 0, 1715, 1716, 5, 534, 0, 0, 1716, 105,
		1, 0, 0, 0, 1717, 1721, 3, 108, 54, 0, 1718, 1720, 3, 110, 55, 0, 1719,
		1718, 1, 0, 0, 0, 1720, 1723, 1, 0, 0, 0, 1721, 1719, 1, 0, 0, 0, 1721,
		1722, 1, 0, 0, 0, 1722, 107, 1, 0, 0, 0, 1723, 1721, 1, 0, 0, 0, 1724,
		1726, 5, 424, 0, 0, 1725, 1727, 5, 328, 0, 0, 1726, 1725, 1, 0, 0, 0, 1726,
		1727, 1, 0, 0, 0, 1727, 1728, 1, 0, 0, 0, 1728, 1729, 3, 1134, 567, 0,
		1729, 109, 1, 0, 0, 0, 1730, 1742, 3, 112, 56, 0, 1731, 1742, 3, 114, 57,
		0, 1732, 1742, 3, 116, 58, 0, 1733, 1742, 3, 118, 59, 0, 1734, 1742, 3,
		120, 60, 0, 1735, 1742, 3, 122, 61, 0, 1736, 1742, 3, 124, 62, 0, 1737,
		1742, 3, 126, 63, 0, 1738, 1742, 3, 130, 65, 0, 1739, 1742, 3, 128, 64,
		0, 1740, 1742, 3, 132, 66, 0, 1741, 1730, 1, 0, 0, 0, 1741, 1731, 1, 0,
		0, 0, 1741, 1732, 1, 0, 0, 0, 1741, 1733, 1, 0, 0, 0, 1741, 1734, 1, 0,
		0, 0, 1741, 1735, 1, 0, 0, 0, 1741, 1736, 1, 0, 0, 0, 1741, 1737, 1, 0,
		0, 0, 1741, 1738, 1, 0, 0, 0, 1741, 1739, 1, 0, 0, 0, 1741, 1740, 1, 0,
		0, 0, 1742, 111, 1, 0, 0, 0, 1743, 1745, 5, 27, 0, 0, 1744, 1746, 5, 489,
		0, 0, 1745, 1744, 1, 0, 0, 0, 1745, 1746, 1, 0, 0, 0, 1746, 1758, 1, 0,
		0, 0, 1747, 1759, 5, 141, 0, 0, 1748, 1759, 5, 142, 0, 0, 1749, 1759, 5,
		260, 0, 0, 1750, 1759, 5, 352, 0, 0, 1751, 1759, 5, 353, 0, 0, 1752, 1759,
		5, 370, 0, 0, 1753, 1759, 5, 371, 0, 0, 1754, 1759, 5, 474, 0, 0, 1755,
		1759, 5, 510, 0, 0, 1756, 1759, 3, 1116, 558, 0, 1757, 1759, 3, 1172, 586,
		0, 1758, 1747, 1, 0, 0, 0, 1758, 1748, 1, 0, 0, 0, 1758, 1749, 1, 0, 0,
		0, 1758, 1750, 1, 0, 0, 0, 1758, 1751, 1, 0, 0, 0, 1758, 1752, 1, 0, 0,
		0, 1758, 1753, 1, 0, 0, 0, 1758, 1754, 1, 0, 0, 0, 1758, 1755, 1, 0, 0,
		0, 1758, 1756, 1, 0, 0, 0, 1758, 1757, 1, 0, 0, 0, 1759, 113, 1, 0, 0,
		0, 1760, 1763, 5, 400, 0, 0, 1761, 1764, 5, 310, 0, 0, 1762, 1764, 3, 1178,
		589, 0, 1763, 1761, 1, 0, 0, 0, 1763, 1762, 1, 0, 0, 0, 1764, 1766, 1,
		0, 0, 0, 1765, 1767, 5, 18, 0, 0, 1766, 1765, 1, 0, 0, 0, 1766, 1767, 1,
		0, 0, 0, 1767, 1769, 1, 0, 0, 0, 1768, 1770, 7, 9, 0, 0, 1769, 1768, 1,
		0, 0, 0, 1769, 1770, 1, 0, 0, 0, 1770, 115, 1, 0, 0, 0, 1771, 1773, 5,
		332, 0, 0, 1772, 1774, 5, 254, 0, 0, 1773, 1772, 1, 0, 0, 0, 1773, 1774,
		1, 0, 0, 0, 1774, 1776, 1, 0, 0, 0, 1775, 1771, 1, 0, 0, 0, 1775, 1776,
		1, 0, 0, 0, 1776, 1782, 1, 0, 0, 0, 1777, 1783, 5, 279, 0, 0, 1778, 1779,
		5, 377, 0, 0, 1779, 1783, 5, 42, 0, 0, 1780, 1783, 5, 377, 0, 0, 1781,
		1783, 5, 42, 0, 0, 1782, 1777, 1, 0, 0, 0, 1782, 1778, 1, 0, 0, 0, 1782,
		1780, 1, 0, 0, 0, 1782, 1781, 1, 0, 0, 0, 1782, 1783, 1, 0, 0, 0, 1783,
		1784, 1, 0, 0, 0, 1784, 1785, 7, 10, 0, 0, 1785, 117, 1, 0, 0, 0, 1786,
		1788, 5, 339, 0, 0, 1787, 1789, 5, 62, 0, 0, 1788, 1787, 1, 0, 0, 0, 1788,
		1789, 1, 0, 0, 0, 1789, 1791, 1, 0, 0, 0, 1790, 1792, 5, 254, 0, 0, 1791,
		1790, 1, 0, 0, 0, 1791, 1792, 1, 0, 0, 0, 1792, 1795, 1, 0, 0, 0, 1793,
		1796, 3, 1090, 545, 0, 1794, 1796, 3, 1172, 586, 0, 1795, 1793, 1, 0, 0,
		0, 1795, 1794, 1, 0, 0, 0, 1796, 119, 1, 0, 0, 0, 1797, 1798, 5, 377, 0,
		0, 1798, 1800, 5, 133, 0, 0, 1799, 1801, 5, 254, 0, 0, 1800, 1799, 1, 0,
		0, 0, 1800, 1801, 1, 0, 0, 0, 1801, 1805, 1, 0, 0, 0, 1802, 1806, 5, 454,
		0, 0, 1803, 1806, 5, 237, 0, 0, 1804, 1806, 3, 1116, 558, 0, 1805, 1802,
		1, 0, 0, 0, 1805, 1803, 1, 0, 0, 0, 1805, 1804, 1, 0, 0, 0, 1806, 121,
		1, 0, 0, 0, 1807, 1809, 5, 3, 0, 0, 1808, 1810, 5, 297, 0, 0, 1809, 1808,
		1, 0, 0, 0, 1809, 1810, 1, 0, 0, 0, 1810, 1812, 1, 0, 0, 0, 1811, 1813,
		5, 254, 0, 0, 1812, 1811, 1, 0, 0, 0, 1812, 1813, 1, 0, 0, 0, 1813, 1814,
		1, 0, 0, 0, 1814, 1815, 7, 11, 0, 0, 1815, 123, 1, 0, 0, 0, 1816, 1818,
		5, 377, 0, 0, 1817, 1819, 5, 259, 0, 0, 1818, 1817, 1, 0, 0, 0, 1818, 1819,
		1, 0, 0, 0, 1819, 1821, 1, 0, 0, 0, 1820, 1822, 5, 254, 0, 0, 1821, 1820,
		1, 0, 0, 0, 1821, 1822, 1, 0, 0, 0, 1822, 1823, 1, 0, 0, 0, 1823, 1825,
		3, 1090, 545, 0, 1824, 1826, 3, 128, 64, 0, 1825, 1824, 1, 0, 0, 0, 1825,
		1826, 1, 0, 0, 0, 1826, 1831, 1, 0, 0, 0, 1827, 1829, 5, 514, 0, 0, 1828,
		1827, 1, 0, 0, 0, 1828, 1829, 1, 0, 0, 0, 1829, 1830, 1, 0, 0, 0, 1830,
		1832, 5, 149, 0, 0, 1831, 1828, 1, 0, 0, 0, 1831, 1832, 1, 0, 0, 0, 1832,
		125, 1, 0, 0, 0, 1833, 1834, 5, 18, 0, 0, 1834, 1836, 5, 377, 0, 0, 1835,
		1837, 5, 259, 0, 0, 1836, 1835, 1, 0, 0, 0, 1836, 1837, 1, 0, 0, 0, 1837,
		1839, 1, 0, 0, 0, 1838, 1840, 5, 254, 0, 0, 1839, 1838, 1, 0, 0, 0, 1839,
		1840, 1, 0, 0, 0, 1840, 1841, 1, 0, 0, 0, 1841, 1843, 3, 1090, 545, 0,
		1842, 1844, 3, 128, 64, 0, 1843, 1842, 1, 0, 0, 0, 1843, 1844, 1, 0, 0,
		0, 1844, 1849, 1, 0, 0, 0, 1845, 1847, 5, 514, 0, 0, 1846, 1845, 1, 0,
		0, 0, 1846, 1847, 1, 0, 0, 0, 1847, 1848, 1, 0, 0, 0, 1848, 1850, 5, 149,
		0, 0, 1849, 1846, 1, 0, 0, 0, 1849, 1850, 1, 0, 0, 0, 1850, 127, 1, 0,
		0, 0, 1851, 1853, 5, 342, 0, 0, 1852, 1854, 5, 254, 0, 0, 1853, 1852, 1,
		0, 0, 0, 1853, 1854, 1, 0, 0, 0, 1854, 1855, 1, 0, 0, 0, 1855, 1856, 3,
		1128, 564, 0, 1856, 129, 1, 0, 0, 0, 1857, 1859, 5, 206, 0, 0, 1858, 1857,
		1, 0, 0, 0, 1858, 1859, 1, 0, 0, 0, 1859, 1860, 1, 0, 0, 0, 1860, 1862,
		5, 457, 0, 0, 1861, 1863, 5, 254, 0, 0, 1862, 1861, 1, 0, 0, 0, 1862, 1863,
		1, 0, 0, 0, 1863, 1864, 1, 0, 0, 0, 1864, 1866, 3, 1090, 545, 0, 1865,
		1867, 3, 1090, 545, 0, 1866, 1865, 1, 0, 0, 0, 1866, 1867, 1, 0, 0, 0,
		1867, 131, 1, 0, 0, 0, 1868, 1870, 5, 386, 0, 0, 1869, 1871, 5, 259, 0,
		0, 1870, 1869, 1, 0, 0, 0, 1870, 1871, 1, 0, 0, 0, 1871, 1873, 1, 0, 0,
		0, 1872, 1874, 5, 254, 0, 0, 1873, 1872, 1, 0, 0, 0, 1873, 1874, 1, 0,
		0, 0, 1874, 1875, 1, 0, 0, 0, 1875, 1876, 3, 1090, 545, 0, 1876, 133, 1,
		0, 0, 0, 1877, 1878, 5, 233, 0, 0, 1878, 1882, 5, 534, 0, 0, 1879, 1880,
		3, 1134, 567, 0, 1880, 1881, 5, 534, 0, 0, 1881, 1883, 1, 0, 0, 0, 1882,
		1879, 1, 0, 0, 0, 1882, 1883, 1, 0, 0, 0, 1883, 1891, 1, 0, 0, 0, 1884,
		1886, 3, 136, 68, 0, 1885, 1884, 1, 0, 0, 0, 1886, 1889, 1, 0, 0, 0, 1887,
		1885, 1, 0, 0, 0, 1887, 1888, 1, 0, 0, 0, 1888, 1890, 1, 0, 0, 0, 1889,
		1887, 1, 0, 0, 0, 1890, 1892, 5, 534, 0, 0, 1891, 1887, 1, 0, 0, 0, 1891,
		1892, 1, 0, 0, 0, 1892, 135, 1, 0, 0, 0, 1893, 1898, 3, 138, 69, 0, 1894,
		1898, 3, 146, 73, 0, 1895, 1898, 3, 148, 74, 0, 1896, 1898, 3, 152, 76,
		0, 1897, 1893, 1, 0, 0, 0, 1897, 1894, 1, 0, 0, 0, 1897, 1895, 1, 0, 0,
		0, 1897, 1896, 1, 0, 0, 0, 1898, 137, 1, 0, 0, 0, 1899, 1905, 5, 399, 0,
		0, 1900, 1903, 5, 326, 0, 0, 1901, 1904, 3, 1116, 558, 0, 1902, 1904, 3,
		1134, 567, 0, 1903, 1901, 1, 0, 0, 0, 1903, 1902, 1, 0, 0, 0, 1904, 1906,
		1, 0, 0, 0, 1905, 1900, 1, 0, 0, 0, 1905, 1906, 1, 0, 0, 0, 1906, 1907,
		1, 0, 0, 0, 1907, 1911, 5, 195, 0, 0, 1908, 1912, 3, 140, 70, 0, 1909,
		1912, 3, 142, 71, 0, 1910, 1912, 3, 144, 72, 0, 1911, 1908, 1, 0, 0, 0,
		1911, 1909, 1, 0, 0, 0, 1911, 1910, 1, 0, 0, 0, 1912, 139, 1, 0, 0, 0,
		1913, 1914, 3, 1178, 589, 0, 1914, 1915, 5, 379, 0, 0, 1915, 141, 1, 0,
		0, 0, 1916, 1918, 5, 158, 0, 0, 1917, 1916, 1, 0, 0, 0, 1917, 1918, 1,
		0, 0, 0, 1918, 1920, 1, 0, 0, 0, 1919, 1921, 5, 323, 0, 0, 1920, 1919,
		1, 0, 0, 0, 1920, 1921, 1, 0, 0, 0, 1921, 1922, 1, 0, 0, 0, 1922, 1923,
		7, 12, 0, 0, 1923, 1924, 5, 323, 0, 0, 1924, 1925, 3, 1134, 567, 0, 1925,
		143, 1, 0, 0, 0, 1926, 1928, 3, 1178, 589, 0, 1927, 1929, 5, 66, 0, 0,
		1928, 1927, 1, 0, 0, 0, 1928, 1929, 1, 0, 0, 0, 1929, 145, 1, 0, 0, 0,
		1930, 1932, 5, 414, 0, 0, 1931, 1933, 7, 13, 0, 0, 1932, 1931, 1, 0, 0,
		0, 1932, 1933, 1, 0, 0, 0, 1933, 1935, 1, 0, 0, 0, 1934, 1936, 5, 22, 0,
		0, 1935, 1934, 1, 0, 0, 0, 1935, 1936, 1, 0, 0, 0, 1936, 1938, 1, 0, 0,
		0, 1937, 1939, 5, 212, 0, 0, 1938, 1937, 1, 0, 0, 0, 1938, 1939, 1, 0,
		0, 0, 1939, 1941, 1, 0, 0, 0, 1940, 1942, 3, 1134, 567, 0, 1941, 1940,
		1, 0, 0, 0, 1942, 1943, 1, 0, 0, 0, 1943, 1941, 1, 0, 0, 0, 1943, 1944,
		1, 0, 0, 0, 1944, 147, 1, 0, 0, 0, 1945, 1946, 5, 301, 0, 0, 1946, 1948,
		5, 206, 0, 0, 1947, 1949, 5, 474, 0, 0, 1948, 1947, 1, 0, 0, 0, 1948, 1949,
		1, 0, 0, 0, 1949, 1951, 1, 0, 0, 0, 1950, 1952, 5, 94, 0, 0, 1951, 1950,
		1, 0, 0, 0, 1951, 1952, 1, 0, 0, 0, 1952, 1954, 1, 0, 0, 0, 1953, 1955,
		3, 150, 75, 0, 1954, 1953, 1, 0, 0, 0, 1955, 1956, 1, 0, 0, 0, 1956, 1954,
		1, 0, 0, 0, 1956, 1957, 1, 0, 0, 0, 1957, 149, 1, 0, 0, 0, 1958, 1961,
		3, 1134, 567, 0, 1959, 1960, 5, 350, 0, 0, 1960, 1962, 3, 1178, 589, 0,
		1961, 1959, 1, 0, 0, 0, 1961, 1962, 1, 0, 0, 0, 1962, 151, 1, 0, 0, 0,
		1963, 1964, 5, 77, 0, 0, 1964, 1966, 5, 97, 0, 0, 1965, 1967, 5, 212, 0,
		0, 1966, 1965, 1, 0, 0, 0, 1966, 1967, 1, 0, 0, 0, 1967, 1968, 1, 0, 0,
		0, 1968, 1969, 3, 1134, 567, 0, 1969, 153, 1, 0, 0, 0, 1970, 1971, 5, 109,
		0, 0, 1971, 1972, 5, 145, 0, 0, 1972, 1976, 5, 534, 0, 0, 1973, 1975, 3,
		156, 78, 0, 1974, 1973, 1, 0, 0, 0, 1975, 1978, 1, 0, 0, 0, 1976, 1974,
		1, 0, 0, 0, 1976, 1977, 1, 0, 0, 0, 1977, 155, 1, 0, 0, 0, 1978, 1976,
		1, 0, 0, 0, 1979, 1989, 3, 158, 79, 0, 1980, 1989, 3, 208, 104, 0, 1981,
		1989, 3, 212, 106, 0, 1982, 1989, 3, 214, 107, 0, 1983, 1989, 3, 216, 108,
		0, 1984, 1989, 3, 254, 127, 0, 1985, 1989, 3, 256, 128, 0, 1986, 1989,
		3, 320, 160, 0, 1987, 1989, 3, 396, 198, 0, 1988, 1979, 1, 0, 0, 0, 1988,
		1980, 1, 0, 0, 0, 1988, 1981, 1, 0, 0, 0, 1988, 1982, 1, 0, 0, 0, 1988,
		1983, 1, 0, 0, 0, 1988, 1984, 1, 0, 0, 0, 1988, 1985, 1, 0, 0, 0, 1988,
		1986, 1, 0, 0, 0, 1988, 1987, 1, 0, 0, 0, 1989, 157, 1, 0, 0, 0, 1990,
		1991, 5, 206, 0, 0, 1991, 1992, 5, 419, 0, 0, 1992, 1996, 5, 534, 0, 0,
		1993, 1995, 3, 160, 80, 0, 1994, 1993, 1, 0, 0, 0, 1995, 1998, 1, 0, 0,
		0, 1996, 1994, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0, 1997, 159, 1, 0, 0,
		0, 1998, 1996, 1, 0, 0, 0, 1999, 2000, 7, 14, 0, 0, 2000, 2007, 3, 1134,
		567, 0, 2001, 2003, 5, 534, 0, 0, 2002, 2001, 1, 0, 0, 0, 2002, 2003, 1,
		0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004, 2006, 3, 162, 81, 0, 2005, 2002,
		1, 0, 0, 0, 2006, 2009, 1, 0, 0, 0, 2007, 2005, 1, 0, 0, 0, 2007, 2008,
		1, 0, 0, 0, 2008, 2010, 1, 0, 0, 0, 2009, 2007, 1, 0, 0, 0, 2010, 2014,
		5, 534, 0, 0, 2011, 2013, 3, 434, 217, 0, 2012, 2011, 1, 0, 0, 0, 2013,
		2016, 1, 0, 0, 0, 2014, 2012, 1, 0, 0, 0, 2014, 2015, 1, 0, 0, 0, 2015,
		161, 1, 0, 0, 0, 2016, 2014, 1, 0, 0, 0, 2017, 2029, 3, 164, 82, 0, 2018,
		2029, 3, 166, 83, 0, 2019, 2029, 3, 168, 84, 0, 2020, 2029, 3, 172, 86,
		0, 2021, 2029, 3, 182, 91, 0, 2022, 2029, 3, 184, 92, 0, 2023, 2029, 3,
		188, 94, 0, 2024, 2029, 3, 190, 95, 0, 2025, 2029, 3, 204, 102, 0, 2026,
		2029, 3, 206, 103, 0, 2027, 2029, 3, 200, 100, 0, 2028, 2017, 1, 0, 0,
		0, 2028, 2018, 1, 0, 0, 0, 2028, 2019, 1, 0, 0, 0, 2028, 2020, 1, 0, 0,
		0, 2028, 2021, 1, 0, 0, 0, 2028, 2022, 1, 0, 0, 0, 2028, 2023, 1, 0, 0,
		0, 2028, 2024, 1, 0, 0, 0, 2028, 2025, 1, 0, 0, 0, 2028, 2026, 1, 0, 0,
		0, 2028, 2027, 1, 0, 0, 0, 2029, 163, 1, 0, 0, 0, 2030, 2032, 5, 254, 0,
		0, 2031, 2030, 1, 0, 0, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2033, 1, 0, 0,
		0, 2033, 2034, 5, 203, 0, 0, 2034, 165, 1, 0, 0, 0, 2035, 2037, 5, 254,
		0, 0, 2036, 2035, 1, 0, 0, 0, 2036, 2037, 1, 0, 0, 0, 2037, 2038, 1, 0,
		0, 0, 2038, 2039, 5, 223, 0, 0, 2039, 167, 1, 0, 0, 0, 2040, 2042, 5, 46,
		0, 0, 2041, 2043, 5, 94, 0, 0, 2042, 2041, 1, 0, 0, 0, 2042, 2043, 1, 0,
		0, 0, 2043, 2044, 1, 0, 0, 0, 2044, 2046, 3, 1178, 589, 0, 2045, 2047,
		3, 170, 85, 0, 2046, 2045, 1, 0, 0, 0, 2046, 2047, 1, 0, 0, 0, 2047, 2049,
		1, 0, 0, 0, 2048, 2050, 7, 15, 0, 0, 2049, 2048, 1, 0, 0, 0, 2049, 2050,
		1, 0, 0, 0, 2050, 169, 1, 0, 0, 0, 2051, 2052, 5, 489, 0, 0, 2052, 2053,
		3, 1178, 589, 0, 2053, 171, 1, 0, 0, 0, 2054, 2058, 5, 377, 0, 0, 2055,
		2059, 3, 174, 87, 0, 2056, 2059, 3, 176, 88, 0, 2057, 2059, 3, 178, 89,
		0, 2058, 2055, 1, 0, 0, 0, 2058, 2056, 1, 0, 0, 0, 2058, 2057, 1, 0, 0,
		0, 2059, 173, 1, 0, 0, 0, 2060, 2062, 5, 94, 0, 0, 2061, 2060, 1, 0, 0,
		0, 2061, 2062, 1, 0, 0, 0, 2062, 2063, 1, 0, 0, 0, 2063, 2065, 3, 1178,
		589, 0, 2064, 2066, 5, 63, 0, 0, 2065, 2064, 1, 0, 0, 0, 2065, 2066, 1,
		0, 0, 0, 2066, 175, 1, 0, 0, 0, 2067, 2069, 5, 254, 0, 0, 2068, 2067, 1,
		0, 0, 0, 2068, 2069, 1, 0, 0, 0, 2069, 2070, 1, 0, 0, 0, 2070, 2072, 5,
		509, 0, 0, 2071, 2073, 5, 239, 0, 0, 2072, 2071, 1, 0, 0, 0, 2072, 2073,
		1, 0, 0, 0, 2073, 2075, 1, 0, 0, 0, 2074, 2076, 5, 439, 0, 0, 2075, 2074,
		1, 0, 0, 0, 2075, 2076, 1, 0, 0, 0, 2076, 2087, 1, 0, 0, 0, 2077, 2079,
		5, 215, 0, 0, 2078, 2077, 1, 0, 0, 0, 2078, 2079, 1, 0, 0, 0, 2079, 2080,
		1, 0, 0, 0, 2080, 2082, 3, 1178, 589, 0, 2081, 2083, 3, 180, 90, 0, 2082,
		2081, 1, 0, 0, 0, 2082, 2083, 1, 0, 0, 0, 2083, 2085, 1, 0, 0, 0, 2084,
		2086, 5, 63, 0, 0, 2085, 2084, 1, 0, 0, 0, 2085, 2086, 1, 0, 0, 0, 2086,
		2088, 1, 0, 0, 0, 2087, 2078, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088,
		2094, 1, 0, 0, 0, 2089, 2091, 5, 134, 0, 0, 2090, 2092, 5, 326, 0, 0, 2091,
		2090, 1, 0, 0, 0, 2091, 2092, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093,
		2095, 3, 1090, 545, 0, 2094, 2089, 1, 0, 0, 0, 2094, 2095, 1, 0, 0, 0,
		2095, 177, 1, 0, 0, 0, 2096, 2098, 5, 94, 0, 0, 2097, 2096, 1, 0, 0, 0,
		2097, 2098, 1, 0, 0, 0, 2098, 2099, 1, 0, 0, 0, 2099, 2100, 3, 1178, 589,
		0, 2100, 2102, 3, 180, 90, 0, 2101, 2103, 5, 63, 0, 0, 2102, 2101, 1, 0,
		0, 0, 2102, 2103, 1, 0, 0, 0, 2103, 179, 1, 0, 0, 0, 2104, 2105, 5, 489,
		0, 0, 2105, 2106, 3, 1178, 589, 0, 2106, 181, 1, 0, 0, 0, 2107, 2116, 5,
		261, 0, 0, 2108, 2110, 5, 377, 0, 0, 2109, 2111, 5, 254, 0, 0, 2110, 2109,
		1, 0, 0, 0, 2110, 2111, 1, 0, 0, 0, 2111, 2117, 1, 0, 0, 0, 2112, 2114,
		5, 379, 0, 0, 2113, 2115, 5, 21, 0, 0, 2114, 2113, 1, 0, 0, 0, 2114, 2115,
		1, 0, 0, 0, 2115, 2117, 1, 0, 0, 0, 2116, 2108, 1, 0, 0, 0, 2116, 2112,
		1, 0, 0, 0, 2117, 2125, 1, 0, 0, 0, 2118, 2126, 5, 325, 0, 0, 2119, 2126,
		5, 453, 0, 0, 2120, 2122, 3, 1128, 564, 0, 2121, 2120, 1, 0, 0, 0, 2122,
		2123, 1, 0, 0, 0, 2123, 2121, 1, 0, 0, 0, 2123, 2124, 1, 0, 0, 0, 2124,
		2126, 1, 0, 0, 0, 2125, 2118, 1, 0, 0, 0, 2125, 2119, 1, 0, 0, 0, 2125,
		2121, 1, 0, 0, 0, 2126, 183, 1, 0, 0, 0, 2127, 2128, 5, 507, 0, 0, 2128,
		2130, 5, 323, 0, 0, 2129, 2131, 3, 186, 93, 0, 2130, 2129, 1, 0, 0, 0,
		2131, 2132, 1, 0, 0, 0, 2132, 2130, 1, 0, 0, 0, 2132, 2133, 1, 0, 0, 0,
		2133, 185, 1, 0, 0, 0, 2134, 2136, 3, 1164, 582, 0, 2135, 2137, 5, 254,
		0, 0, 2136, 2135, 1, 0, 0, 0, 2136, 2137, 1, 0, 0, 0, 2137, 2140, 1, 0,
		0, 0, 2138, 2141, 3, 1090, 545, 0, 2139, 2141, 3, 1172, 586, 0, 2140, 2138,
		1, 0, 0, 0, 2140, 2139, 1, 0, 0, 0, 2141, 187, 1, 0, 0, 0, 2142, 2151,
		5, 109, 0, 0, 2143, 2145, 5, 377, 0, 0, 2144, 2146, 5, 254, 0, 0, 2145,
		2144, 1, 0, 0, 0, 2145, 2146, 1, 0, 0, 0, 2146, 2152, 1, 0, 0, 0, 2147,
		2149, 5, 379, 0, 0, 2148, 2150, 5, 21, 0, 0, 2149, 2148, 1, 0, 0, 0, 2149,
		2150, 1, 0, 0, 0, 2150, 2152, 1, 0, 0, 0, 2151, 2143, 1, 0, 0, 0, 2151,
		2147, 1, 0, 0, 0, 2152, 2154, 1, 0, 0, 0, 2153, 2155, 3, 1128, 564, 0,
		2154, 2153, 1, 0, 0, 0, 2155, 2156, 1, 0, 0, 0, 2156, 2154, 1, 0, 0, 0,
		2156, 2157, 1, 0, 0, 0, 2157, 189, 1, 0, 0, 0, 2158, 2160, 5, 277, 0, 0,
		2159, 2161, 5, 254, 0, 0, 2160, 2159, 1, 0, 0, 0, 2160, 2161, 1, 0, 0,
		0, 2161, 2164, 1, 0, 0, 0, 2162, 2165, 3, 1128, 564, 0, 2163, 2165, 3,
		1178, 589, 0, 2164, 2162, 1, 0, 0, 0, 2164, 2163, 1, 0, 0, 0, 2165, 2167,
		1, 0, 0, 0, 2166, 2168, 5, 280, 0, 0, 2167, 2166, 1, 0, 0, 0, 2167, 2168,
		1, 0, 0, 0, 2168, 2172, 1, 0, 0, 0, 2169, 2171, 3, 192, 96, 0, 2170, 2169,
		1, 0, 0, 0, 2171, 2174, 1, 0, 0, 0, 2172, 2170, 1, 0, 0, 0, 2172, 2173,
		1, 0, 0, 0, 2173, 191, 1, 0, 0, 0, 2174, 2172, 1, 0, 0, 0, 2175, 2179,
		3, 194, 97, 0, 2176, 2179, 3, 196, 98, 0, 2177, 2179, 3, 198, 99, 0, 2178,
		2175, 1, 0, 0, 0, 2178, 2176, 1, 0, 0, 0, 2178, 2177, 1, 0, 0, 0, 2179,
		193, 1, 0, 0, 0, 2180, 2182, 5, 514, 0, 0, 2181, 2180, 1, 0, 0, 0, 2181,
		2182, 1, 0, 0, 0, 2182, 2183, 1, 0, 0, 0, 2183, 2185, 5, 211, 0, 0, 2184,
		2186, 5, 30, 0, 0, 2185, 2184, 1, 0, 0, 0, 2185, 2186, 1, 0, 0, 0, 2186,
		2189, 1, 0, 0, 0, 2187, 2190, 3, 1128, 564, 0, 2188, 2190, 3, 1178, 589,
		0, 2189, 2187, 1, 0, 0, 0, 2189, 2188, 1, 0, 0, 0, 2190, 195, 1, 0, 0,
		0, 2191, 2193, 5, 280, 0, 0, 2192, 2191, 1, 0, 0, 0, 2192, 2193, 1, 0,
		0, 0, 2193, 2195, 1, 0, 0, 0, 2194, 2196, 5, 30, 0, 0, 2195, 2194, 1, 0,
		0, 0, 2195, 2196, 1, 0, 0, 0, 2196, 2197, 1, 0, 0, 0, 2197, 2200, 5, 492,
		0, 0, 2198, 2201, 3, 1128, 564, 0, 2199, 2201, 3, 1178, 589, 0, 2200, 2198,
		1, 0, 0, 0, 2200, 2199, 1, 0, 0, 0, 2201, 197, 1, 0, 0, 0, 2202, 2204,
		5, 280, 0, 0, 2203, 2202, 1, 0, 0, 0, 2203, 2204, 1, 0, 0, 0, 2204, 2206,
		1, 0, 0, 0, 2205, 2207, 5, 30, 0, 0, 2206, 2205, 1, 0, 0, 0, 2206, 2207,
		1, 0, 0, 0, 2207, 2208, 1, 0, 0, 0, 2208, 2211, 5, 48, 0, 0, 2209, 2212,
		3, 1128, 564, 0, 2210, 2212, 3, 1178, 589, 0, 2211, 2209, 1, 0, 0, 0, 2211,
		2210, 1, 0, 0, 0, 2212, 199, 1, 0, 0, 0, 2213, 2215, 5, 378, 0, 0, 2214,
		2216, 5, 297, 0, 0, 2215, 2214, 1, 0, 0, 0, 2215, 2216, 1, 0, 0, 0, 2216,
		2218, 1, 0, 0, 0, 2217, 2219, 5, 254, 0, 0, 2218, 2217, 1, 0, 0, 0, 2218,
		2219, 1, 0, 0, 0, 2219, 2220, 1, 0, 0, 0, 2220, 2221, 3, 202, 101, 0, 2221,
		201, 1, 0, 0, 0, 2222, 2223, 3, 1170, 585, 0, 2223, 203, 1, 0, 0, 0, 2224,
		2226, 5, 71, 0, 0, 2225, 2227, 5, 254, 0, 0, 2226, 2225, 1, 0, 0, 0, 2226,
		2227, 1, 0, 0, 0, 2227, 2228, 1, 0, 0, 0, 2228, 2229, 3, 1114, 557, 0,
		2229, 205, 1, 0, 0, 0, 2230, 2232, 5, 395, 0, 0, 2231, 2233, 5, 254, 0,
		0, 2232, 2231, 1, 0, 0, 0, 2232, 2233, 1, 0, 0, 0, 2233, 2239, 1, 0, 0,
		0, 2234, 2236, 5, 397, 0, 0, 2235, 2237, 5, 21, 0, 0, 2236, 2235, 1, 0,
		0, 0, 2236, 2237, 1, 0, 0, 0, 2237, 2239, 1, 0, 0, 0, 2238, 2230, 1, 0,
		0, 0, 2238, 2234, 1, 0, 0, 0, 2239, 2241, 1, 0, 0, 0, 2240, 2242, 3, 1156,
		578, 0, 2241, 2240, 1, 0, 0, 0, 2242, 2243, 1, 0, 0, 0, 2243, 2241, 1,
		0, 0, 0, 2243, 2244, 1, 0, 0, 0, 2244, 207, 1, 0, 0, 0, 2245, 2246, 5,
		110, 0, 0, 2246, 2247, 5, 419, 0, 0, 2247, 2251, 5, 534, 0, 0, 2248, 2250,
		3, 210, 105, 0, 2249, 2248, 1, 0, 0, 0, 2250, 2253, 1, 0, 0, 0, 2251, 2249,
		1, 0, 0, 0, 2251, 2252, 1, 0, 0, 0, 2252, 209, 1, 0, 0, 0, 2253, 2251,
		1, 0, 0, 0, 2254, 2255, 3, 1178, 589, 0, 2255, 2256, 3, 1172, 586, 0, 2256,
		2257, 5, 253, 0, 0, 2257, 2258, 3, 1172, 586, 0, 2258, 211, 1, 0, 0, 0,
		2259, 2260, 5, 516, 0, 0, 2260, 2261, 5, 419, 0, 0, 2261, 2265, 5, 534,
		0, 0, 2262, 2264, 3, 434, 217, 0, 2263, 2262, 1, 0, 0, 0, 2264, 2267, 1,
		0, 0, 0, 2265, 2263, 1, 0, 0, 0, 2265, 2266, 1, 0, 0, 0, 2266, 213, 1,
		0, 0, 0, 2267, 2265, 1, 0, 0, 0, 2268, 2269, 5, 282, 0, 0, 2269, 2270,
		5, 419, 0, 0, 2270, 2274, 5, 534, 0, 0, 2271, 2273, 3, 434, 217, 0, 2272,
		2271, 1, 0, 0, 0, 2273, 2276, 1, 0, 0, 0, 2274, 2272, 1, 0, 0, 0, 2274,
		2275, 1, 0, 0, 0, 2275, 215, 1, 0, 0, 0, 2276, 2274, 1, 0, 0, 0, 2277,
		2278, 5, 79, 0, 0, 2278, 2279, 5, 419, 0, 0, 2279, 2284, 5, 534, 0, 0,
		2280, 2283, 3, 218, 109, 0, 2281, 2283, 3, 434, 217, 0, 2282, 2280, 1,
		0, 0, 0, 2282, 2281, 1, 0, 0, 0, 2283, 2286, 1, 0, 0, 0, 2284, 2282, 1,
		0, 0, 0, 2284, 2285, 1, 0, 0, 0, 2285, 217, 1, 0, 0, 0, 2286, 2284, 1,
		0, 0, 0, 2287, 2291, 3, 220, 110, 0, 2288, 2291, 3, 222, 111, 0, 2289,
		2291, 3, 224, 112, 0, 2290, 2287, 1, 0, 0, 0, 2290, 2288, 1, 0, 0, 0, 2290,
		2289, 1, 0, 0, 0, 2291, 219, 1, 0, 0, 0, 2292, 2293, 5, 56, 0, 0, 2293,
		2295, 3, 1120, 560, 0, 2294, 2296, 5, 212, 0, 0, 2295, 2294, 1, 0, 0, 0,
		2295, 2296, 1, 0, 0, 0, 2296, 2298, 1, 0, 0, 0, 2297, 2299, 5, 243, 0,
		0, 2298, 2297, 1, 0, 0, 0, 2298, 2299, 1, 0, 0, 0, 2299, 2300, 1, 0, 0,
		0, 2300, 2315, 5, 246, 0, 0, 2301, 2311, 3, 244, 122, 0, 2302, 2311, 3,
		250, 125, 0, 2303, 2311, 3, 236, 118, 0, 2304, 2311, 3, 238, 119, 0, 2305,
		2311, 3, 246, 123, 0, 2306, 2311, 3, 252, 126, 0, 2307, 2311, 3, 230, 115,
		0, 2308, 2311, 3, 240, 120, 0, 2309, 2311, 3, 234, 117, 0, 2310, 2301,
		1, 0, 0, 0, 2310, 2302, 1, 0, 0, 0, 2310, 2303, 1, 0, 0, 0, 2310, 2304,
		1, 0, 0, 0, 2310, 2305, 1, 0, 0, 0, 2310, 2306, 1, 0, 0, 0, 2310, 2307,
		1, 0, 0, 0, 2310, 2308, 1, 0, 0, 0, 2310, 2309, 1, 0, 0, 0, 2311, 2314,
		1, 0, 0, 0, 2312, 2314, 3, 1130, 565, 0, 2313, 2310, 1, 0, 0, 0, 2313,
		2312, 1, 0, 0, 0, 2314, 2317, 1, 0, 0, 0, 2315, 2313, 1, 0, 0, 0, 2315,
		2316, 1, 0, 0, 0, 2316, 2318, 1, 0, 0, 0, 2317, 2315, 1, 0, 0, 0, 2318,
		2319, 5, 534, 0, 0, 2319, 221, 1, 0, 0, 0, 2320, 2321, 5, 56, 0, 0, 2321,
		2323, 3, 1120, 560, 0, 2322, 2324, 5, 212, 0, 0, 2323, 2322, 1, 0, 0, 0,
		2323, 2324, 1, 0, 0, 0, 2324, 2325, 1, 0, 0, 0, 2325, 2334, 5, 334, 0,
		0, 2326, 2333, 3, 226, 113, 0, 2327, 2333, 3, 252, 126, 0, 2328, 2333,
		3, 240, 120, 0, 2329, 2333, 3, 228, 114, 0, 2330, 2333, 3, 232, 116, 0,
		2331, 2333, 3, 242, 121, 0, 2332, 2326, 1, 0, 0, 0, 2332, 2327, 1, 0, 0,
		0, 2332, 2328, 1, 0, 0, 0, 2332, 2329, 1, 0, 0, 0, 2332, 2330, 1, 0, 0,
		0, 2332, 2331, 1, 0, 0, 0, 2333, 2336, 1, 0, 0, 0, 2334, 2332, 1, 0, 0,
		0, 2334, 2335, 1, 0, 0, 0, 2335, 2337, 1, 0, 0, 0, 2336, 2334, 1, 0, 0,
		0, 2337, 2338, 5, 534, 0, 0, 2338, 223, 1, 0, 0, 0, 2339, 2340, 5, 56,
		0, 0, 2340, 2342, 3, 1120, 560, 0, 2341, 2343, 5, 212, 0, 0, 2342, 2341,
		1, 0, 0, 0, 2342, 2343, 1, 0, 0, 0, 2343, 2344, 1, 0, 0, 0, 2344, 2345,
		5, 243, 0, 0, 2345, 2357, 5, 232, 0, 0, 2346, 2353, 3, 236, 118, 0, 2347,
		2353, 3, 238, 119, 0, 2348, 2353, 3, 248, 124, 0, 2349, 2353, 3, 252, 126,
		0, 2350, 2353, 3, 230, 115, 0, 2351, 2353, 3, 240, 120, 0, 2352, 2346,
		1, 0, 0, 0, 2352, 2347, 1, 0, 0, 0, 2352, 2348, 1, 0, 0, 0, 2352, 2349,
		1, 0, 0, 0, 2352, 2350, 1, 0, 0, 0, 2352, 2351, 1, 0, 0, 0, 2353, 2356,
		1, 0, 0, 0, 2354, 2356, 3, 1130, 565, 0, 2355, 2352, 1, 0, 0, 0, 2355,
		2354, 1, 0, 0, 0, 2356, 2359, 1, 0, 0, 0, 2357, 2355, 1, 0, 0, 0, 2357,
		2358, 1, 0, 0, 0, 2358, 2360, 1, 0, 0, 0, 2359, 2357, 1, 0, 0, 0, 2360,
		2361, 5, 534, 0, 0, 2361, 225, 1, 0, 0, 0, 2362, 2363, 5, 136, 0, 0, 2363,
		2365, 5, 105, 0, 0, 2364, 2366, 5, 254, 0, 0, 2365, 2364, 1, 0, 0, 0, 2365,
		2366, 1, 0, 0, 0, 2366, 2367, 1, 0, 0, 0, 2367, 2368, 3, 1130, 565, 0,
		2368, 227, 1, 0, 0, 0, 2369, 2370, 5, 136, 0, 0, 2370, 2371, 5, 470, 0,
		0, 2371, 2372, 5, 321, 0, 0, 2372, 2373, 3, 1178, 589, 0, 2373, 2381, 5,
		487, 0, 0, 2374, 2375, 5, 241, 0, 0, 2375, 2377, 5, 49, 0, 0, 2376, 2378,
		3, 1138, 569, 0, 2377, 2376, 1, 0, 0, 0, 2378, 2379, 1, 0, 0, 0, 2379,
		2377, 1, 0, 0, 0, 2379, 2380, 1, 0, 0, 0, 2380, 2382, 1, 0, 0, 0, 2381,
		2374, 1, 0, 0, 0, 2381, 2382, 1, 0, 0, 0, 2382, 229, 1, 0, 0, 0, 2383,
		2384, 5, 158, 0, 0, 2384, 2386, 5, 259, 0, 0, 2385, 2387, 5, 254, 0, 0,
		2386, 2385, 1, 0, 0, 0, 2386, 2387, 1, 0, 0, 0, 2387, 2388, 1, 0, 0, 0,
		2388, 2389, 3, 1130, 565, 0, 2389, 231, 1, 0, 0, 0, 2390, 2391, 5, 188,
		0, 0, 2391, 2393, 5, 259, 0, 0, 2392, 2394, 5, 254, 0, 0, 2393, 2392, 1,
		0, 0, 0, 2393, 2394, 1, 0, 0, 0, 2394, 2395, 1, 0, 0, 0, 2395, 2396, 3,
		1130, 565, 0, 2396, 233, 1, 0, 0, 0, 2397, 2399, 5, 295, 0, 0, 2398, 2397,
		1, 0, 0, 0, 2398, 2399, 1, 0, 0, 0, 2399, 2400, 1, 0, 0, 0, 2400, 2402,
		5, 105, 0, 0, 2401, 2403, 5, 254, 0, 0, 2402, 2401, 1, 0, 0, 0, 2402, 2403,
		1, 0, 0, 0, 2403, 2404, 1, 0, 0, 0, 2404, 2405, 3, 1130, 565, 0, 2405,
		235, 1, 0, 0, 0, 2406, 2407, 5, 295, 0, 0, 2407, 2409, 5, 111, 0, 0, 2408,
		2410, 5, 254, 0, 0, 2409, 2408, 1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410,
		2411, 1, 0, 0, 0, 2411, 2412, 3, 1130, 565, 0, 2412, 237, 1, 0, 0, 0, 2413,
		2414, 5, 295, 0, 0, 2414, 2416, 5, 485, 0, 0, 2415, 2417, 5, 254, 0, 0,
		2416, 2415, 1, 0, 0, 0, 2416, 2417, 1, 0, 0, 0, 2417, 2418, 1, 0, 0, 0,
		2418, 2419, 3, 1130, 565, 0, 2419, 239, 1, 0, 0, 0, 2420, 2421, 5, 457,
		0, 0, 2421, 2423, 5, 259, 0, 0, 2422, 2424, 5, 254, 0, 0, 2423, 2422, 1,
		0, 0, 0, 2423, 2424, 1, 0, 0, 0, 2424, 2425, 1, 0, 0, 0, 2425, 2426, 3,
		1130, 565, 0, 2426, 241, 1, 0, 0, 0, 2427, 2429, 5, 467, 0, 0, 2428, 2427,
		1, 0, 0, 0, 2428, 2429, 1, 0, 0, 0, 2429, 2430, 1, 0, 0, 0, 2430, 2432,
		5, 136, 0, 0, 2431, 2433, 5, 254, 0, 0, 2432, 2431, 1, 0, 0, 0, 2432, 2433,
		1, 0, 0, 0, 2433, 2434, 1, 0, 0, 0, 2434, 2435, 3, 1130, 565, 0, 2435,
		243, 1, 0, 0, 0, 2436, 2438, 5, 467, 0, 0, 2437, 2436, 1, 0, 0, 0, 2437,
		2438, 1, 0, 0, 0, 2438, 2439, 1, 0, 0, 0, 2439, 2441, 5, 366, 0, 0, 2440,
		2442, 5, 254, 0, 0, 2441, 2440, 1, 0, 0, 0, 2441, 2442, 1, 0, 0, 0, 2442,
		2443, 1, 0, 0, 0, 2443, 2444, 3, 1130, 565, 0, 2444, 245, 1, 0, 0, 0, 2445,
		2447, 5, 467, 0, 0, 2446, 2445, 1, 0, 0, 0, 2446, 2447, 1, 0, 0, 0, 2447,
		2448, 1, 0, 0, 0, 2448, 2450, 5, 448, 0, 0, 2449, 2451, 5, 254, 0, 0, 2450,
		2449, 1, 0, 0, 0, 2450, 2451, 1, 0, 0, 0, 2451, 2452, 1, 0, 0, 0, 2452,
		2453, 3, 1130, 565, 0, 2453, 247, 1, 0, 0, 0, 2454, 2456, 5, 467, 0, 0,
		2455, 2454, 1, 0, 0, 0, 2455, 2456, 1, 0, 0, 0, 2456, 2457, 1, 0, 0, 0,
		2457, 2459, 5, 475, 0, 0, 2458, 2460, 5, 254, 0, 0, 2459, 2458, 1, 0, 0,
		0, 2459, 2460, 1, 0, 0, 0, 2460, 2461, 1, 0, 0, 0, 2461, 2462, 3, 1130,
		565, 0, 2462, 249, 1, 0, 0, 0, 2463, 2465, 5, 467, 0, 0, 2464, 2463, 1,
		0, 0, 0, 2464, 2465, 1, 0, 0, 0, 2465, 2466, 1, 0, 0, 0, 2466, 2468, 7,
		16, 0, 0, 2467, 2469, 5, 254, 0, 0, 2468, 2467, 1, 0, 0, 0, 2468, 2469,
		1, 0, 0, 0, 2469, 2470, 1, 0, 0, 0, 2470, 2471, 3, 1130, 565, 0, 2471,
		251, 1, 0, 0, 0, 2472, 2473, 5, 478, 0, 0, 2473, 2475, 5, 269, 0, 0, 2474,
		2476, 5, 254, 0, 0, 2475, 2474, 1, 0, 0, 0, 2475, 2476, 1, 0, 0, 0, 2476,
		2477, 1, 0, 0, 0, 2477, 2478, 3, 1130, 565, 0, 2478, 253, 1, 0, 0, 0, 2479,
		2480, 5, 285, 0, 0, 2480, 2481, 5, 419, 0, 0, 2481, 2486, 5, 534, 0, 0,
		2482, 2483, 5, 265, 0, 0, 2483, 2484, 3, 1144, 572, 0, 2484, 2485, 5, 534,
		0, 0, 2485, 2487, 1, 0, 0, 0, 2486, 2482, 1, 0, 0, 0, 2486, 2487, 1, 0,
		0, 0, 2487, 2491, 1, 0, 0, 0, 2488, 2490, 3, 434, 217, 0, 2489, 2488, 1,
		0, 0, 0, 2490, 2493, 1, 0, 0, 0, 2491, 2489, 1, 0, 0, 0, 2491, 2492, 1,
		0, 0, 0, 2492, 255, 1, 0, 0, 0, 2493, 2491, 1, 0, 0, 0, 2494, 2495, 5,
		416, 0, 0, 2495, 2496, 5, 419, 0, 0, 2496, 2500, 5, 534, 0, 0, 2497, 2499,
		3, 258, 129, 0, 2498, 2497, 1, 0, 0, 0, 2499, 2502, 1, 0, 0, 0, 2500, 2498,
		1, 0, 0, 0, 2500, 2501, 1, 0, 0, 0, 2501, 257, 1, 0, 0, 0, 2502, 2500,
		1, 0, 0, 0, 2503, 2506, 5, 555, 0, 0, 2504, 2507, 5, 208, 0, 0, 2505, 2507,
		3, 1160, 580, 0, 2506, 2504, 1, 0, 0, 0, 2506, 2505, 1, 0, 0, 0, 2506,
		2507, 1, 0, 0, 0, 2507, 2540, 1, 0, 0, 0, 2508, 2539, 3, 260, 130, 0, 2509,
		2539, 3, 262, 131, 0, 2510, 2539, 3, 264, 132, 0, 2511, 2539, 3, 266, 133,
		0, 2512, 2539, 3, 268, 134, 0, 2513, 2539, 3, 270, 135, 0, 2514, 2539,
		3, 272, 136, 0, 2515, 2539, 3, 274, 137, 0, 2516, 2539, 3, 276, 138, 0,
		2517, 2539, 3, 278, 139, 0, 2518, 2539, 3, 280, 140, 0, 2519, 2539, 3,
		282, 141, 0, 2520, 2539, 3, 284, 142, 0, 2521, 2539, 3, 286, 143, 0, 2522,
		2539, 3, 288, 144, 0, 2523, 2539, 3, 290, 145, 0, 2524, 2527, 3, 292, 146,
		0, 2525, 2527, 3, 296, 148, 0, 2526, 2524, 1, 0, 0, 0, 2526, 2525, 1, 0,
		0, 0, 2527, 2539, 1, 0, 0, 0, 2528, 2539, 3, 298, 149, 0, 2529, 2539, 3,
		300, 150, 0, 2530, 2539, 3, 302, 151, 0, 2531, 2539, 3, 304, 152, 0, 2532,
		2539, 3, 306, 153, 0, 2533, 2539, 3, 308, 154, 0, 2534, 2539, 3, 310, 155,
		0, 2535, 2539, 3, 312, 156, 0, 2536, 2539, 3, 316, 158, 0, 2537, 2539,
		3, 318, 159, 0, 2538, 2508, 1, 0, 0, 0, 2538, 2509, 1, 0, 0, 0, 2538, 2510,
		1, 0, 0, 0, 2538, 2511, 1, 0, 0, 0, 2538, 2512, 1, 0, 0, 0, 2538, 2513,
		1, 0, 0, 0, 2538, 2514, 1, 0, 0, 0, 2538, 2515, 1, 0, 0, 0, 2538, 2516,
		1, 0, 0, 0, 2538, 2517, 1, 0, 0, 0, 2538, 2518, 1, 0, 0, 0, 2538, 2519,
		1, 0, 0, 0, 2538, 2520, 1, 0, 0, 0, 2538, 2521, 1, 0, 0, 0, 2538, 2522,
		1, 0, 0, 0, 2538, 2523, 1, 0, 0, 0, 2538, 2526, 1, 0, 0, 0, 2538, 2528,
		1, 0, 0, 0, 2538, 2529, 1, 0, 0, 0, 2538, 2530, 1, 0, 0, 0, 2538, 2531,
		1, 0, 0, 0, 2538, 2532, 1, 0, 0, 0, 2538, 2533, 1, 0, 0, 0, 2538, 2534,
		1, 0, 0, 0, 2538, 2535, 1, 0, 0, 0, 2538, 2536, 1, 0, 0, 0, 2538, 2537,
		1, 0, 0, 0, 2539, 2542, 1, 0, 0, 0, 2540, 2538, 1, 0, 0, 0, 2540, 2541,
		1, 0, 0, 0, 2541, 2543, 1, 0, 0, 0, 2542, 2540, 1, 0, 0, 0, 2543, 2544,
		5, 534, 0, 0, 2544, 259, 1, 0, 0, 0, 2545, 2546, 5, 44, 0, 0, 2546, 2547,
		7, 17, 0, 0, 2547, 261, 1, 0, 0, 0, 2548, 2549, 7, 18, 0, 0, 2549, 263,
		1, 0, 0, 0, 2550, 2551, 5, 45, 0, 0, 2551, 265, 1, 0, 0, 0, 2552, 2553,
		5, 187, 0, 0, 2553, 2554, 7, 19, 0, 0, 2554, 267, 1, 0, 0, 0, 2555, 2556,
		7, 20, 0, 0, 2556, 269, 1, 0, 0, 0, 2557, 2558, 7, 21, 0, 0, 2558, 271,
		1, 0, 0, 0, 2559, 2560, 5, 401, 0, 0, 2560, 273, 1, 0, 0, 0, 2561, 2562,
		5, 498, 0, 0, 2562, 275, 1, 0, 0, 0, 2563, 2565, 5, 439, 0, 0, 2564, 2566,
		5, 254, 0, 0, 2565, 2564, 1, 0, 0, 0, 2565, 2566, 1, 0, 0, 0, 2566, 2569,
		1, 0, 0, 0, 2567, 2570, 3, 1074, 537, 0, 2568, 2570, 3, 1178, 589, 0, 2569,
		2567, 1, 0, 0, 0, 2569, 2568, 1, 0, 0, 0, 2570, 277, 1, 0, 0, 0, 2571,
		2579, 5, 279, 0, 0, 2572, 2574, 5, 315, 0, 0, 2573, 2572, 1, 0, 0, 0, 2573,
		2574, 1, 0, 0, 0, 2574, 2576, 1, 0, 0, 0, 2575, 2577, 5, 254, 0, 0, 2576,
		2575, 1, 0, 0, 0, 2576, 2577, 1, 0, 0, 0, 2577, 2578, 1, 0, 0, 0, 2578,
		2580, 7, 22, 0, 0, 2579, 2573, 1, 0, 0, 0, 2579, 2580, 1, 0, 0, 0, 2580,
		2583, 1, 0, 0, 0, 2581, 2584, 3, 1074, 537, 0, 2582, 2584, 3, 1178, 589,
		0, 2583, 2581, 1, 0, 0, 0, 2583, 2582, 1, 0, 0, 0, 2584, 279, 1, 0, 0,
		0, 2585, 2593, 7, 23, 0, 0, 2586, 2588, 5, 315, 0, 0, 2587, 2586, 1, 0,
		0, 0, 2587, 2588, 1, 0, 0, 0, 2588, 2590, 1, 0, 0, 0, 2589, 2591, 5, 254,
		0, 0, 2590, 2589, 1, 0, 0, 0, 2590, 2591, 1, 0, 0, 0, 2591, 2592, 1, 0,
		0, 0, 2592, 2594, 7, 22, 0, 0, 2593, 2587, 1, 0, 0, 0, 2593, 2594, 1, 0,
		0, 0, 2594, 2597, 1, 0, 0, 0, 2595, 2598, 3, 1074, 537, 0, 2596, 2598,
		3, 1178, 589, 0, 2597, 2595, 1, 0, 0, 0, 2597, 2596, 1, 0, 0, 0, 2598,
		281, 1, 0, 0, 0, 2599, 2601, 7, 24, 0, 0, 2600, 2602, 5, 254, 0, 0, 2601,
		2600, 1, 0, 0, 0, 2601, 2602, 1, 0, 0, 0, 2602, 2605, 1, 0, 0, 0, 2603,
		2606, 3, 1074, 537, 0, 2604, 2606, 3, 1178, 589, 0, 2605, 2603, 1, 0, 0,
		0, 2605, 2604, 1, 0, 0, 0, 2606, 283, 1, 0, 0, 0, 2607, 2609, 7, 25, 0,
		0, 2608, 2610, 5, 254, 0, 0, 2609, 2608, 1, 0, 0, 0, 2609, 2610, 1, 0,
		0, 0, 2610, 2613, 1, 0, 0, 0, 2611, 2614, 3, 1074, 537, 0, 2612, 2614,
		3, 1178, 589, 0, 2613, 2611, 1, 0, 0, 0, 2613, 2612, 1, 0, 0, 0, 2614,
		285, 1, 0, 0, 0, 2615, 2617, 5, 97, 0, 0, 2616, 2618, 5, 254, 0, 0, 2617,
		2616, 1, 0, 0, 0, 2617, 2618, 1, 0, 0, 0, 2618, 2619, 1, 0, 0, 0, 2619,
		2620, 3, 1074, 537, 0, 2620, 287, 1, 0, 0, 0, 2621, 2623, 5, 507, 0, 0,
		2622, 2624, 5, 254, 0, 0, 2623, 2622, 1, 0, 0, 0, 2623, 2624, 1, 0, 0,
		0, 2624, 2625, 1, 0, 0, 0, 2625, 2626, 3, 1172, 586, 0, 2626, 289, 1, 0,
		0, 0, 2627, 2629, 7, 26, 0, 0, 2628, 2630, 5, 254, 0, 0, 2629, 2628, 1,
		0, 0, 0, 2629, 2630, 1, 0, 0, 0, 2630, 2631, 1, 0, 0, 0, 2631, 2632, 3,
		466, 233, 0, 2632, 291, 1, 0, 0, 0, 2633, 2636, 5, 215, 0, 0, 2634, 2637,
		3, 1074, 537, 0, 2635, 2637, 3, 1172, 586, 0, 2636, 2634, 1, 0, 0, 0, 2636,
		2635, 1, 0, 0, 0, 2637, 2639, 1, 0, 0, 0, 2638, 2640, 3, 294, 147, 0, 2639,
		2638, 1, 0, 0, 0, 2639, 2640, 1, 0, 0, 0, 2640, 293, 1, 0, 0, 0, 2641,
		2642, 5, 489, 0, 0, 2642, 2643, 3, 1074, 537, 0, 2643, 295, 1, 0, 0, 0,
		2644, 2645, 5, 506, 0, 0, 2645, 2646, 3, 1074, 537, 0, 2646, 297, 1, 0,
		0, 0, 2647, 2649, 5, 504, 0, 0, 2648, 2650, 5, 254, 0, 0, 2649, 2648, 1,
		0, 0, 0, 2649, 2650, 1, 0, 0, 0, 2650, 2651, 1, 0, 0, 0, 2651, 2652, 7,
		27, 0, 0, 2652, 299, 1, 0, 0, 0, 2653, 2655, 5, 44, 0, 0, 2654, 2656, 5,
		512, 0, 0, 2655, 2654, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 2657,
		1, 0, 0, 0, 2657, 2658, 5, 521, 0, 0, 2658, 301, 1, 0, 0, 0, 2659, 2661,
		7, 28, 0, 0, 2660, 2662, 5, 411, 0, 0, 2661, 2660, 1, 0, 0, 0, 2661, 2662,
		1, 0, 0, 0, 2662, 303, 1, 0, 0, 0, 2663, 2665, 5, 438, 0, 0, 2664, 2666,
		5, 254, 0, 0, 2665, 2664, 1, 0, 0, 0, 2665, 2666, 1, 0, 0, 0, 2666, 2668,
		1, 0, 0, 0, 2667, 2663, 1, 0, 0, 0, 2667, 2668, 1, 0, 0, 0, 2668, 2669,
		1, 0, 0, 0, 2669, 2674, 7, 7, 0, 0, 2670, 2672, 5, 427, 0, 0, 2671, 2673,
		5, 62, 0, 0, 2672, 2671, 1, 0, 0, 0, 2672, 2673, 1, 0, 0, 0, 2673, 2675,
		1, 0, 0, 0, 2674, 2670, 1, 0, 0, 0, 2674, 2675, 1, 0, 0, 0, 2675, 305,
		1, 0, 0, 0, 2676, 2677, 7, 29, 0, 0, 2677, 307, 1, 0, 0, 0, 2678, 2679,
		7, 30, 0, 0, 2679, 309, 1, 0, 0, 0, 2680, 2681, 7, 31, 0, 0, 2681, 311,
		1, 0, 0, 0, 2682, 2684, 5, 364, 0, 0, 2683, 2685, 5, 62, 0, 0, 2684, 2683,
		1, 0, 0, 0, 2684, 2685, 1, 0, 0, 0, 2685, 2687, 1, 0, 0, 0, 2686, 2688,
		5, 254, 0, 0, 2687, 2686, 1, 0, 0, 0, 2687, 2688, 1, 0, 0, 0, 2688, 2691,
		1, 0, 0, 0, 2689, 2692, 3, 1074, 537, 0, 2690, 2692, 3, 1172, 586, 0, 2691,
		2689, 1, 0, 0, 0, 2691, 2690, 1, 0, 0, 0, 2692, 2694, 1, 0, 0, 0, 2693,
		2695, 3, 314, 157, 0, 2694, 2693, 1, 0, 0, 0, 2694, 2695, 1, 0, 0, 0, 2695,
		313, 1, 0, 0, 0, 2696, 2697, 5, 321, 0, 0, 2697, 2699, 3, 1178, 589, 0,
		2698, 2700, 5, 487, 0, 0, 2699, 2698, 1, 0, 0, 0, 2699, 2700, 1, 0, 0,
		0, 2700, 315, 1, 0, 0, 0, 2701, 2702, 7, 32, 0, 0, 2702, 317, 1, 0, 0,
		0, 2703, 2704, 5, 522, 0, 0, 2704, 319, 1, 0, 0, 0, 2705, 2706, 5, 395,
		0, 0, 2706, 2707, 5, 419, 0, 0, 2707, 2711, 5, 534, 0, 0, 2708, 2710, 3,
		322, 161, 0, 2709, 2708, 1, 0, 0, 0, 2710, 2713, 1, 0, 0, 0, 2711, 2709,
		1, 0, 0, 0, 2711, 2712, 1, 0, 0, 0, 2712, 321, 1, 0, 0, 0, 2713, 2711,
		1, 0, 0, 0, 2714, 2716, 3, 324, 162, 0, 2715, 2717, 3, 338, 169, 0, 2716,
		2715, 1, 0, 0, 0, 2717, 2718, 1, 0, 0, 0, 2718, 2716, 1, 0, 0, 0, 2718,
		2719, 1, 0, 0, 0, 2719, 323, 1, 0, 0, 0, 2720, 2721, 5, 372, 0, 0, 2721,
		2723, 3, 1156, 578, 0, 2722, 2724, 3, 326, 163, 0, 2723, 2722, 1, 0, 0,
		0, 2723, 2724, 1, 0, 0, 0, 2724, 2738, 1, 0, 0, 0, 2725, 2727, 3, 328,
		164, 0, 2726, 2728, 3, 330, 165, 0, 2727, 2726, 1, 0, 0, 0, 2727, 2728,
		1, 0, 0, 0, 2728, 2730, 1, 0, 0, 0, 2729, 2731, 3, 332, 166, 0, 2730, 2729,
		1, 0, 0, 0, 2730, 2731, 1, 0, 0, 0, 2731, 2733, 1, 0, 0, 0, 2732, 2734,
		3, 334, 167, 0, 2733, 2732, 1, 0, 0, 0, 2733, 2734, 1, 0, 0, 0, 2734, 2736,
		1, 0, 0, 0, 2735, 2737, 3, 336, 168, 0, 2736, 2735, 1, 0, 0, 0, 2736, 2737,
		1, 0, 0, 0, 2737, 2739, 1, 0, 0, 0, 2738, 2725, 1, 0, 0, 0, 2738, 2739,
		1, 0, 0, 0, 2739, 2740, 1, 0, 0, 0, 2740, 2741, 5, 534, 0, 0, 2741, 325,
		1, 0, 0, 0, 2742, 2744, 5, 254, 0, 0, 2743, 2742, 1, 0, 0, 0, 2743, 2744,
		1, 0, 0, 0, 2744, 2745, 1, 0, 0, 0, 2745, 2746, 5, 223, 0, 0, 2746, 327,
		1, 0, 0, 0, 2747, 2756, 5, 340, 0, 0, 2748, 2750, 5, 275, 0, 0, 2749, 2751,
		5, 254, 0, 0, 2750, 2749, 1, 0, 0, 0, 2750, 2751, 1, 0, 0, 0, 2751, 2757,
		1, 0, 0, 0, 2752, 2754, 5, 276, 0, 0, 2753, 2755, 5, 21, 0, 0, 2754, 2753,
		1, 0, 0, 0, 2754, 2755, 1, 0, 0, 0, 2755, 2757, 1, 0, 0, 0, 2756, 2748,
		1, 0, 0, 0, 2756, 2752, 1, 0, 0, 0, 2756, 2757, 1, 0, 0, 0, 2757, 2758,
		1, 0, 0, 0, 2758, 2760, 3, 1178, 589, 0, 2759, 2761, 7, 33, 0, 0, 2760,
		2759, 1, 0, 0, 0, 2760, 2761, 1, 0, 0, 0, 2761, 329, 1, 0, 0, 0, 2762,
		2763, 5, 228, 0, 0, 2763, 2764, 3, 1178, 589, 0, 2764, 331, 1, 0, 0, 0,
		2765, 2766, 5, 210, 0, 0, 2766, 2767, 5, 137, 0, 0, 2767, 2768, 3, 1178,
		589, 0, 2768, 333, 1, 0, 0, 0, 2769, 2770, 5, 263, 0, 0, 2770, 2771, 5,
		137, 0, 0, 2771, 2772, 3, 1178, 589, 0, 2772, 335, 1, 0, 0, 0, 2773, 2774,
		5, 211, 0, 0, 2774, 2775, 3, 1178, 589, 0, 2775, 337, 1, 0, 0, 0, 2776,
		2780, 3, 340, 170, 0, 2777, 2780, 3, 342, 171, 0, 2778, 2780, 3, 344, 172,
		0, 2779, 2776, 1, 0, 0, 0, 2779, 2777, 1, 0, 0, 0, 2779, 2778, 1, 0, 0,
		0, 2780, 339, 1, 0, 0, 0, 2781, 2782, 3, 1178, 589, 0, 2782, 2784, 3, 1128,
		564, 0, 2783, 2785, 3, 354, 177, 0, 2784, 2783, 1, 0, 0, 0, 2784, 2785,
		1, 0, 0, 0, 2785, 2787, 1, 0, 0, 0, 2786, 2788, 3, 360, 180, 0, 2787, 2786,
		1, 0, 0, 0, 2787, 2788, 1, 0, 0, 0, 2788, 2789, 1, 0, 0, 0, 2789, 2791,
		3, 376, 188, 0, 2790, 2792, 3, 388, 194, 0, 2791, 2790, 1, 0, 0, 0, 2791,
		2792, 1, 0, 0, 0, 2792, 2793, 1, 0, 0, 0, 2793, 2794, 5, 534, 0, 0, 2794,
		341, 1, 0, 0, 0, 2795, 2797, 3, 1178, 589, 0, 2796, 2798, 3, 1128, 564,
		0, 2797, 2796, 1, 0, 0, 0, 2797, 2798, 1, 0, 0, 0, 2798, 2800, 1, 0, 0,
		0, 2799, 2801, 3, 354, 177, 0, 2800, 2799, 1, 0, 0, 0, 2800, 2801, 1, 0,
		0, 0, 2801, 2802, 1, 0, 0, 0, 2802, 2803, 3, 388, 194, 0, 2803, 2804, 5,
		534, 0, 0, 2804, 343, 1, 0, 0, 0, 2805, 2807, 3, 1178, 589, 0, 2806, 2808,
		3, 1128, 564, 0, 2807, 2806, 1, 0, 0, 0, 2807, 2808, 1, 0, 0, 0, 2808,
		2825, 1, 0, 0, 0, 2809, 2824, 3, 366, 183, 0, 2810, 2824, 3, 388, 194,
		0, 2811, 2824, 3, 370, 185, 0, 2812, 2824, 3, 352, 176, 0, 2813, 2824,
		3, 346, 173, 0, 2814, 2824, 3, 354, 177, 0, 2815, 2824, 3, 348, 174, 0,
		2816, 2821, 3, 372, 186, 0, 2817, 2821, 3, 394, 197, 0, 2818, 2821, 3,
		374, 187, 0, 2819, 2821, 3, 368, 184, 0, 2820, 2816, 1, 0, 0, 0, 2820,
		2817, 1, 0, 0, 0, 2820, 2818, 1, 0, 0, 0, 2820, 2819, 1, 0, 0, 0, 2821,
		2824, 1, 0, 0, 0, 2822, 2824, 3, 350, 175, 0, 2823, 2809, 1, 0, 0, 0, 2823,
		2810, 1, 0, 0, 0, 2823, 2811, 1, 0, 0, 0, 2823, 2812, 1, 0, 0, 0, 2823,
		2813, 1, 0, 0, 0, 2823, 2814, 1, 0, 0, 0, 2823, 2815, 1, 0, 0, 0, 2823,
		2820, 1, 0, 0, 0, 2823, 2822, 1, 0, 0, 0, 2824, 2827, 1, 0, 0, 0, 2825,
		2823, 1, 0, 0, 0, 2825, 2826, 1, 0, 0, 0, 2826, 2828, 1, 0, 0, 0, 2827,
		2825, 1, 0, 0, 0, 2828, 2829, 5, 534, 0, 0, 2829, 345, 1, 0, 0, 0, 2830,
		2832, 5, 44, 0, 0, 2831, 2833, 5, 512, 0, 0, 2832, 2831, 1, 0, 0, 0, 2832,
		2833, 1, 0, 0, 0, 2833, 2834, 1, 0, 0, 0, 2834, 2835, 5, 521, 0, 0, 2835,
		347, 1, 0, 0, 0, 2836, 2838, 5, 74, 0, 0, 2837, 2839, 5, 315, 0, 0, 2838,
		2837, 1, 0, 0, 0, 2838, 2839, 1, 0, 0, 0, 2839, 2841, 1, 0, 0, 0, 2840,
		2842, 5, 254, 0, 0, 2841, 2840, 1, 0, 0, 0, 2841, 2842, 1, 0, 0, 0, 2842,
		2843, 1, 0, 0, 0, 2843, 2844, 3, 1178, 589, 0, 2844, 349, 1, 0, 0, 0, 2845,
		2847, 5, 227, 0, 0, 2846, 2848, 5, 242, 0, 0, 2847, 2846, 1, 0, 0, 0, 2847,
		2848, 1, 0, 0, 0, 2848, 351, 1, 0, 0, 0, 2849, 2851, 7, 28, 0, 0, 2850,
		2852, 5, 411, 0, 0, 2851, 2850, 1, 0, 0, 0, 2851, 2852, 1, 0, 0, 0, 2852,
		353, 1, 0, 0, 0, 2853, 2855, 5, 279, 0, 0, 2854, 2853, 1, 0, 0, 0, 2854,
		2855, 1, 0, 0, 0, 2855, 2857, 1, 0, 0, 0, 2856, 2858, 5, 315, 0, 0, 2857,
		2856, 1, 0, 0, 0, 2857, 2858, 1, 0, 0, 0, 2858, 2860, 1, 0, 0, 0, 2859,
		2861, 5, 254, 0, 0, 2860, 2859, 1, 0, 0, 0, 2860, 2861, 1, 0, 0, 0, 2861,
		2864, 1, 0, 0, 0, 2862, 2865, 3, 356, 178, 0, 2863, 2865, 3, 358, 179,
		0, 2864, 2862, 1, 0, 0, 0, 2864, 2863, 1, 0, 0, 0, 2865, 355, 1, 0, 0,
		0, 2866, 2872, 3, 1178, 589, 0, 2867, 2869, 5, 326, 0, 0, 2868, 2867, 1,
		0, 0, 0, 2868, 2869, 1, 0, 0, 0, 2869, 2870, 1, 0, 0, 0, 2870, 2871, 5,
		309, 0, 0, 2871, 2873, 5, 340, 0, 0, 2872, 2868, 1, 0, 0, 0, 2872, 2873,
		1, 0, 0, 0, 2873, 357, 1, 0, 0, 0, 2874, 2875, 5, 348, 0, 0, 2875, 2876,
		3, 1178, 589, 0, 2876, 359, 1, 0, 0, 0, 2877, 2878, 5, 309, 0, 0, 2878,
		2880, 5, 227, 0, 0, 2879, 2881, 5, 254, 0, 0, 2880, 2879, 1, 0, 0, 0, 2880,
		2881, 1, 0, 0, 0, 2881, 2885, 1, 0, 0, 0, 2882, 2886, 3, 1178, 589, 0,
		2883, 2886, 3, 364, 182, 0, 2884, 2886, 3, 362, 181, 0, 2885, 2882, 1,
		0, 0, 0, 2885, 2883, 1, 0, 0, 0, 2885, 2884, 1, 0, 0, 0, 2886, 361, 1,
		0, 0, 0, 2887, 2888, 5, 348, 0, 0, 2888, 2889, 3, 1178, 589, 0, 2889, 363,
		1, 0, 0, 0, 2890, 2891, 5, 309, 0, 0, 2891, 2892, 5, 340, 0, 0, 2892, 365,
		1, 0, 0, 0, 2893, 2895, 7, 26, 0, 0, 2894, 2896, 5, 254, 0, 0, 2895, 2894,
		1, 0, 0, 0, 2895, 2896, 1, 0, 0, 0, 2896, 2897, 1, 0, 0, 0, 2897, 2898,
		3, 466, 233, 0, 2898, 367, 1, 0, 0, 0, 2899, 2901, 5, 402, 0, 0, 2900,
		2902, 5, 326, 0, 0, 2901, 2900, 1, 0, 0, 0, 2901, 2902, 1, 0, 0, 0, 2902,
		2905, 1, 0, 0, 0, 2903, 2906, 5, 209, 0, 0, 2904, 2906, 3, 1128, 564, 0,
		2905, 2903, 1, 0, 0, 0, 2905, 2904, 1, 0, 0, 0, 2906, 369, 1, 0, 0, 0,
		2907, 2909, 5, 438, 0, 0, 2908, 2910, 5, 254, 0, 0, 2909, 2908, 1, 0, 0,
		0, 2909, 2910, 1, 0, 0, 0, 2910, 2911, 1, 0, 0, 0, 2911, 2912, 7, 7, 0,
		0, 2912, 2914, 5, 427, 0, 0, 2913, 2915, 5, 62, 0, 0, 2914, 2913, 1, 0,
		0, 0, 2914, 2915, 1, 0, 0, 0, 2915, 371, 1, 0, 0, 0, 2916, 2918, 5, 448,
		0, 0, 2917, 2919, 5, 254, 0, 0, 2918, 2917, 1, 0, 0, 0, 2918, 2919, 1,
		0, 0, 0, 2919, 2920, 1, 0, 0, 0, 2920, 2921, 3, 1074, 537, 0, 2921, 373,
		1, 0, 0, 0, 2922, 2923, 5, 464, 0, 0, 2923, 2930, 3, 1074, 537, 0, 2924,
		2926, 5, 529, 0, 0, 2925, 2924, 1, 0, 0, 0, 2925, 2926, 1, 0, 0, 0, 2926,
		2927, 1, 0, 0, 0, 2927, 2929, 3, 1074, 537, 0, 2928, 2925, 1, 0, 0, 0,
		2929, 2932, 1, 0, 0, 0, 2930, 2928, 1, 0, 0, 0, 2930, 2931, 1, 0, 0, 0,
		2931, 2944, 1, 0, 0, 0, 2932, 2930, 1, 0, 0, 0, 2933, 2934, 5, 503, 0,
		0, 2934, 2941, 3, 1128, 564, 0, 2935, 2937, 5, 529, 0, 0, 2936, 2935, 1,
		0, 0, 0, 2936, 2937, 1, 0, 0, 0, 2937, 2938, 1, 0, 0, 0, 2938, 2940, 3,
		1128, 564, 0, 2939, 2936, 1, 0, 0, 0, 2940, 2943, 1, 0, 0, 0, 2941, 2939,
		1, 0, 0, 0, 2941, 2942, 1, 0, 0, 0, 2942, 2945, 1, 0, 0, 0, 2943, 2941,
		1, 0, 0, 0, 2944, 2933, 1, 0, 0, 0, 2944, 2945, 1, 0, 0, 0, 2945, 375,
		1, 0, 0, 0, 2946, 2948, 5, 496, 0, 0, 2947, 2949, 5, 254, 0, 0, 2948, 2947,
		1, 0, 0, 0, 2948, 2949, 1, 0, 0, 0, 2949, 2957, 1, 0, 0, 0, 2950, 2958,
		3, 378, 189, 0, 2951, 2958, 3, 380, 190, 0, 2952, 2958, 3, 382, 191, 0,
		2953, 2958, 3, 384, 192, 0, 2954, 2958, 3, 386, 193, 0, 2955, 2958, 3,
		390, 195, 0, 2956, 2958, 3, 392, 196, 0, 2957, 2950, 1, 0, 0, 0, 2957,
		2951, 1, 0, 0, 0, 2957, 2952, 1, 0, 0, 0, 2957, 2953, 1, 0, 0, 0, 2957,
		2954, 1, 0, 0, 0, 2957, 2955, 1, 0, 0, 0, 2957, 2956, 1, 0, 0, 0, 2958,
		377, 1, 0, 0, 0, 2959, 2960, 5, 395, 0, 0, 2960, 2963, 5, 228, 0, 0, 2961,
		2963, 5, 410, 0, 0, 2962, 2959, 1, 0, 0, 0, 2962, 2961, 1, 0, 0, 0, 2963,
		379, 1, 0, 0, 0, 2964, 2965, 5, 340, 0, 0, 2965, 2968, 5, 228, 0, 0, 2966,
		2968, 5, 345, 0, 0, 2967, 2964, 1, 0, 0, 0, 2967, 2966, 1, 0, 0, 0, 2968,
		381, 1, 0, 0, 0, 2969, 2970, 5, 97, 0, 0, 2970, 2973, 5, 228, 0, 0, 2971,
		2973, 5, 58, 0, 0, 2972, 2969, 1, 0, 0, 0, 2972, 2971, 1, 0, 0, 0, 2973,
		2976, 1, 0, 0, 0, 2974, 2977, 5, 209, 0, 0, 2975, 2977, 3, 1128, 564, 0,
		2976, 2974, 1, 0, 0, 0, 2976, 2975, 1, 0, 0, 0, 2977, 383, 1, 0, 0, 0,
		2978, 2979, 7, 34, 0, 0, 2979, 385, 1, 0, 0, 0, 2980, 2981, 5, 97, 0, 0,
		2981, 2984, 5, 211, 0, 0, 2982, 2984, 5, 57, 0, 0, 2983, 2980, 1, 0, 0,
		0, 2983, 2982, 1, 0, 0, 0, 2984, 2987, 1, 0, 0, 0, 2985, 2988, 5, 209,
		0, 0, 2986, 2988, 3, 1128, 564, 0, 2987, 2985, 1, 0, 0, 0, 2987, 2986,
		1, 0, 0, 0, 2988, 387, 1, 0, 0, 0, 2989, 2991, 5, 504, 0, 0, 2990, 2992,
		5, 254, 0, 0, 2991, 2990, 1, 0, 0, 0, 2991, 2992, 1, 0, 0, 0, 2992, 2994,
		1, 0, 0, 0, 2993, 2989, 1, 0, 0, 0, 2993, 2994, 1, 0, 0, 0, 2994, 2995,
		1, 0, 0, 0, 2995, 2996, 7, 27, 0, 0, 2996, 389, 1, 0, 0, 0, 2997, 2998,
		5, 340, 0, 0, 2998, 3001, 5, 211, 0, 0, 2999, 3001, 5, 344, 0, 0, 3000,
		2997, 1, 0, 0, 0, 3000, 2999, 1, 0, 0, 0, 3001, 391, 1, 0, 0, 0, 3002,
		3003, 5, 395, 0, 0, 3003, 3006, 5, 211, 0, 0, 3004, 3006, 5, 409, 0, 0,
		3005, 3002, 1, 0, 0, 0, 3005, 3004, 1, 0, 0, 0, 3006, 393, 1, 0, 0, 0,
		3007, 3009, 5, 507, 0, 0, 3008, 3010, 5, 254, 0, 0, 3009, 3008, 1, 0, 0,
		0, 3009, 3010, 1, 0, 0, 0, 3010, 3011, 1, 0, 0, 0, 3011, 3012, 3, 1172,
		586, 0, 3012, 395, 1, 0, 0, 0, 3013, 3014, 5, 363, 0, 0, 3014, 3015, 5,
		419, 0, 0, 3015, 3019, 5, 534, 0, 0, 3016, 3018, 3, 398, 199, 0, 3017,
		3016, 1, 0, 0, 0, 3018, 3021, 1, 0, 0, 0, 3019, 3017, 1, 0, 0, 0, 3019,
		3020, 1, 0, 0, 0, 3020, 397, 1, 0, 0, 0, 3021, 3019, 1, 0, 0, 0, 3022,
		3025, 3, 400, 200, 0, 3023, 3025, 3, 402, 201, 0, 3024, 3022, 1, 0, 0,
		0, 3024, 3023, 1, 0, 0, 0, 3025, 399, 1, 0, 0, 0, 3026, 3027, 5, 265, 0,
		0, 3027, 3028, 3, 1142, 571, 0, 3028, 3030, 5, 200, 0, 0, 3029, 3031, 3,
		404, 202, 0, 3030, 3029, 1, 0, 0, 0, 3030, 3031, 1, 0, 0, 0, 3031, 3033,
		1, 0, 0, 0, 3032, 3034, 3, 414, 207, 0, 3033, 3032, 1, 0, 0, 0, 3033, 3034,
		1, 0, 0, 0, 3034, 401, 1, 0, 0, 0, 3035, 3036, 5, 264, 0, 0, 3036, 3037,
		3, 1142, 571, 0, 3037, 3039, 5, 238, 0, 0, 3038, 3040, 3, 432, 216, 0,
		3039, 3038, 1, 0, 0, 0, 3039, 3040, 1, 0, 0, 0, 3040, 3042, 1, 0, 0, 0,
		3041, 3043, 3, 430, 215, 0, 3042, 3041, 1, 0, 0, 0, 3042, 3043, 1, 0, 0,
		0, 3043, 3048, 1, 0, 0, 0, 3044, 3047, 3, 406, 203, 0, 3045, 3047, 3, 416,
		208, 0, 3046, 3044, 1, 0, 0, 0, 3046, 3045, 1, 0, 0, 0, 3047, 3050, 1,
		0, 0, 0, 3048, 3046, 1, 0, 0, 0, 3048, 3049, 1, 0, 0, 0, 3049, 403, 1,
		0, 0, 0, 3050, 3048, 1, 0, 0, 0, 3051, 3057, 5, 31, 0, 0, 3052, 3054, 5,
		434, 0, 0, 3053, 3055, 5, 254, 0, 0, 3054, 3053, 1, 0, 0, 0, 3054, 3055,
		1, 0, 0, 0, 3055, 3056, 1, 0, 0, 0, 3056, 3058, 7, 35, 0, 0, 3057, 3052,
		1, 0, 0, 0, 3057, 3058, 1, 0, 0, 0, 3058, 405, 1, 0, 0, 0, 3059, 3061,
		5, 31, 0, 0, 3060, 3062, 3, 408, 204, 0, 3061, 3060, 1, 0, 0, 0, 3061,
		3062, 1, 0, 0, 0, 3062, 3068, 1, 0, 0, 0, 3063, 3065, 5, 272, 0, 0, 3064,
		3066, 5, 254, 0, 0, 3065, 3064, 1, 0, 0, 0, 3065, 3066, 1, 0, 0, 0, 3066,
		3067, 1, 0, 0, 0, 3067, 3069, 7, 36, 0, 0, 3068, 3063, 1, 0, 0, 0, 3068,
		3069, 1, 0, 0, 0, 3069, 3071, 1, 0, 0, 0, 3070, 3072, 3, 410, 205, 0, 3071,
		3070, 1, 0, 0, 0, 3071, 3072, 1, 0, 0, 0, 3072, 3074, 1, 0, 0, 0, 3073,
		3075, 3, 412, 206, 0, 3074, 3073, 1, 0, 0, 0, 3074, 3075, 1, 0, 0, 0, 3075,
		407, 1, 0, 0, 0, 3076, 3077, 5, 218, 0, 0, 3077, 3078, 5, 254, 0, 0, 3078,
		3079, 3, 1172, 586, 0, 3079, 409, 1, 0, 0, 0, 3080, 3082, 5, 273, 0, 0,
		3081, 3083, 5, 254, 0, 0, 3082, 3081, 1, 0, 0, 0, 3082, 3083, 1, 0, 0,
		0, 3083, 3084, 1, 0, 0, 0, 3084, 3085, 3, 1172, 586, 0, 3085, 411, 1, 0,
		0, 0, 3086, 3088, 5, 488, 0, 0, 3087, 3089, 5, 254, 0, 0, 3088, 3087, 1,
		0, 0, 0, 3088, 3089, 1, 0, 0, 0, 3089, 3090, 1, 0, 0, 0, 3090, 3091, 3,
		1172, 586, 0, 3091, 413, 1, 0, 0, 0, 3092, 3093, 5, 183, 0, 0, 3093, 3095,
		3, 1152, 576, 0, 3094, 3096, 3, 418, 209, 0, 3095, 3094, 1, 0, 0, 0, 3095,
		3096, 1, 0, 0, 0, 3096, 415, 1, 0, 0, 0, 3097, 3098, 5, 183, 0, 0, 3098,
		3100, 3, 1152, 576, 0, 3099, 3101, 3, 418, 209, 0, 3100, 3099, 1, 0, 0,
		0, 3100, 3101, 1, 0, 0, 0, 3101, 3103, 1, 0, 0, 0, 3102, 3104, 3, 426,
		213, 0, 3103, 3102, 1, 0, 0, 0, 3103, 3104, 1, 0, 0, 0, 3104, 3106, 1,
		0, 0, 0, 3105, 3107, 3, 422, 211, 0, 3106, 3105, 1, 0, 0, 0, 3106, 3107,
		1, 0, 0, 0, 3107, 3109, 1, 0, 0, 0, 3108, 3110, 3, 420, 210, 0, 3109, 3108,
		1, 0, 0, 0, 3109, 3110, 1, 0, 0, 0, 3110, 417, 1, 0, 0, 0, 3111, 3112,
		5, 212, 0, 0, 3112, 3113, 3, 1172, 586, 0, 3113, 419, 1, 0, 0, 0, 3114,
		3115, 5, 222, 0, 0, 3115, 3116, 3, 1128, 564, 0, 3116, 421, 1, 0, 0, 0,
		3117, 3119, 5, 506, 0, 0, 3118, 3120, 3, 424, 212, 0, 3119, 3118, 1, 0,
		0, 0, 3120, 3121, 1, 0, 0, 0, 3121, 3119, 1, 0, 0, 0, 3121, 3122, 1, 0,
		0, 0, 3122, 423, 1, 0, 0, 0, 3123, 3126, 3, 1128, 564, 0, 3124, 3126, 3,
		1134, 567, 0, 3125, 3123, 1, 0, 0, 0, 3125, 3124, 1, 0, 0, 0, 3126, 425,
		1, 0, 0, 0, 3127, 3129, 5, 514, 0, 0, 3128, 3130, 3, 428, 214, 0, 3129,
		3128, 1, 0, 0, 0, 3130, 3131, 1, 0, 0, 0, 3131, 3129, 1, 0, 0, 0, 3131,
		3132, 1, 0, 0, 0, 3132, 427, 1, 0, 0, 0, 3133, 3136, 3, 1144, 572, 0, 3134,
		3136, 3, 1134, 567, 0, 3135, 3133, 1, 0, 0, 0, 3135, 3134, 1, 0, 0, 0,
		3136, 429, 1, 0, 0, 0, 3137, 3139, 5, 254, 0, 0, 3138, 3137, 1, 0, 0, 0,
		3138, 3139, 1, 0, 0, 0, 3139, 3140, 1, 0, 0, 0, 3140, 3141, 5, 78, 0, 0,
		3141, 431, 1, 0, 0, 0, 3142, 3144, 5, 254, 0, 0, 3143, 3142, 1, 0, 0, 0,
		3143, 3144, 1, 0, 0, 0, 3144, 3145, 1, 0, 0, 0, 3145, 3146, 5, 223, 0,
		0, 3146, 433, 1, 0, 0, 0, 3147, 3152, 3, 436, 218, 0, 3148, 3152, 3, 438,
		219, 0, 3149, 3152, 3, 440, 220, 0, 3150, 3152, 3, 442, 221, 0, 3151, 3147,
		1, 0, 0, 0, 3151, 3148, 1, 0, 0, 0, 3151, 3149, 1, 0, 0, 0, 3151, 3150,
		1, 0, 0, 0, 3152, 435, 1, 0, 0, 0, 3153, 3156, 7, 37, 0, 0, 3154, 3157,
		5, 208, 0, 0, 3155, 3157, 3, 1128, 564, 0, 3156, 3154, 1, 0, 0, 0, 3156,
		3155, 1, 0, 0, 0, 3156, 3157, 1, 0, 0, 0, 3157, 3181, 1, 0, 0, 0, 3158,
		3180, 3, 476, 238, 0, 3159, 3180, 3, 454, 227, 0, 3160, 3180, 3, 450, 225,
		0, 3161, 3180, 3, 452, 226, 0, 3162, 3180, 3, 488, 244, 0, 3163, 3180,
		3, 484, 242, 0, 3164, 3180, 3, 464, 232, 0, 3165, 3180, 3, 448, 224, 0,
		3166, 3180, 3, 486, 243, 0, 3167, 3180, 3, 492, 246, 0, 3168, 3180, 3,
		490, 245, 0, 3169, 3180, 3, 494, 247, 0, 3170, 3180, 3, 472, 236, 0, 3171,
		3180, 3, 458, 229, 0, 3172, 3180, 3, 480, 240, 0, 3173, 3180, 3, 482, 241,
		0, 3174, 3180, 3, 456, 228, 0, 3175, 3180, 3, 446, 223, 0, 3176, 3180,
		3, 502, 251, 0, 3177, 3180, 3, 444, 222, 0, 3178, 3180, 3, 474, 237, 0,
		3179, 3158, 1, 0, 0, 0, 3179, 3159, 1, 0, 0, 0, 3179, 3160, 1, 0, 0, 0,
		3179, 3161, 1, 0, 0, 0, 3179, 3162, 1, 0, 0, 0, 3179, 3163, 1, 0, 0, 0,
		3179, 3164, 1, 0, 0, 0, 3179, 3165, 1, 0, 0, 0, 3179, 3166, 1, 0, 0, 0,
		3179, 3167, 1, 0, 0, 0, 3179, 3168, 1, 0, 0, 0, 3179, 3169, 1, 0, 0, 0,
		3179, 3170, 1, 0, 0, 0, 3179, 3171, 1, 0, 0, 0, 3179, 3172, 1, 0, 0, 0,
		3179, 3173, 1, 0, 0, 0, 3179, 3174, 1, 0, 0, 0, 3179, 3175, 1, 0, 0, 0,
		3179, 3176, 1, 0, 0, 0, 3179, 3177, 1, 0, 0, 0, 3179, 3178, 1, 0, 0, 0,
		3180, 3183, 1, 0, 0, 0, 3181, 3179, 1, 0, 0, 0, 3181, 3182, 1, 0, 0, 0,
		3182, 3184, 1, 0, 0, 0, 3183, 3181, 1, 0, 0, 0, 3184, 3185, 5, 534, 0,
		0, 3185, 437, 1, 0, 0, 0, 3186, 3187, 5, 552, 0, 0, 3187, 3188, 3, 1128,
		564, 0, 3188, 3189, 3, 478, 239, 0, 3189, 3190, 5, 534, 0, 0, 3190, 439,
		1, 0, 0, 0, 3191, 3192, 5, 554, 0, 0, 3192, 3193, 3, 1126, 563, 0, 3193,
		3194, 3, 494, 247, 0, 3194, 3195, 5, 534, 0, 0, 3195, 441, 1, 0, 0, 0,
		3196, 3198, 5, 561, 0, 0, 3197, 3196, 1, 0, 0, 0, 3198, 3199, 1, 0, 0,
		0, 3199, 3197, 1, 0, 0, 0, 3199, 3200, 1, 0, 0, 0, 3200, 3202, 1, 0, 0,
		0, 3201, 3203, 5, 534, 0, 0, 3202, 3201, 1, 0, 0, 0, 3202, 3203, 1, 0,
		0, 0, 3203, 443, 1, 0, 0, 0, 3204, 3205, 5, 8, 0, 0, 3205, 445, 1, 0, 0,
		0, 3206, 3208, 5, 44, 0, 0, 3207, 3209, 5, 512, 0, 0, 3208, 3207, 1, 0,
		0, 0, 3208, 3209, 1, 0, 0, 0, 3209, 3210, 1, 0, 0, 0, 3210, 3211, 7, 38,
		0, 0, 3211, 447, 1, 0, 0, 0, 3212, 3213, 7, 39, 0, 0, 3213, 449, 1, 0,
		0, 0, 3214, 3216, 5, 254, 0, 0, 3215, 3214, 1, 0, 0, 0, 3215, 3216, 1,
		0, 0, 0, 3216, 3217, 1, 0, 0, 0, 3217, 3220, 5, 203, 0, 0, 3218, 3219,
		5, 49, 0, 0, 3219, 3221, 3, 1172, 586, 0, 3220, 3218, 1, 0, 0, 0, 3220,
		3221, 1, 0, 0, 0, 3221, 451, 1, 0, 0, 0, 3222, 3224, 5, 254, 0, 0, 3223,
		3222, 1, 0, 0, 0, 3223, 3224, 1, 0, 0, 0, 3224, 3225, 1, 0, 0, 0, 3225,
		3226, 5, 223, 0, 0, 3226, 453, 1, 0, 0, 0, 3227, 3228, 7, 40, 0, 0, 3228,
		455, 1, 0, 0, 0, 3229, 3231, 7, 28, 0, 0, 3230, 3232, 5, 411, 0, 0, 3231,
		3230, 1, 0, 0, 0, 3231, 3232, 1, 0, 0, 0, 3232, 457, 1, 0, 0, 0, 3233,
		3234, 5, 321, 0, 0, 3234, 3236, 3, 1178, 589, 0, 3235, 3237, 3, 460, 230,
		0, 3236, 3235, 1, 0, 0, 0, 3236, 3237, 1, 0, 0, 0, 3237, 3239, 1, 0, 0,
		0, 3238, 3240, 5, 487, 0, 0, 3239, 3238, 1, 0, 0, 0, 3239, 3240, 1, 0,
		0, 0, 3240, 3246, 1, 0, 0, 0, 3241, 3243, 5, 134, 0, 0, 3242, 3244, 5,
		326, 0, 0, 3243, 3242, 1, 0, 0, 0, 3243, 3244, 1, 0, 0, 0, 3244, 3245,
		1, 0, 0, 0, 3245, 3247, 3, 1090, 545, 0, 3246, 3241, 1, 0, 0, 0, 3246,
		3247, 1, 0, 0, 0, 3247, 3251, 1, 0, 0, 0, 3248, 3250, 3, 462, 231, 0, 3249,
		3248, 1, 0, 0, 0, 3250, 3253, 1, 0, 0, 0, 3251, 3249, 1, 0, 0, 0, 3251,
		3252, 1, 0, 0, 0, 3252, 3266, 1, 0, 0, 0, 3253, 3251, 1, 0, 0, 0, 3254,
		3256, 5, 241, 0, 0, 3255, 3257, 5, 49, 0, 0, 3256, 3255, 1, 0, 0, 0, 3256,
		3257, 1, 0, 0, 0, 3257, 3259, 1, 0, 0, 0, 3258, 3260, 5, 284, 0, 0, 3259,
		3258, 1, 0, 0, 0, 3259, 3260, 1, 0, 0, 0, 3260, 3262, 1, 0, 0, 0, 3261,
		3263, 3, 1138, 569, 0, 3262, 3261, 1, 0, 0, 0, 3263, 3264, 1, 0, 0, 0,
		3264, 3262, 1, 0, 0, 0, 3264, 3265, 1, 0, 0, 0, 3265, 3267, 1, 0, 0, 0,
		3266, 3254, 1, 0, 0, 0, 3266, 3267, 1, 0, 0, 0, 3267, 459, 1, 0, 0, 0,
		3268, 3269, 5, 489, 0, 0, 3269, 3270, 3, 1178, 589, 0, 3270, 461, 1, 0,
		0, 0, 3271, 3273, 7, 41, 0, 0, 3272, 3274, 5, 259, 0, 0, 3273, 3272, 1,
		0, 0, 0, 3273, 3274, 1, 0, 0, 0, 3274, 3276, 1, 0, 0, 0, 3275, 3277, 5,
		254, 0, 0, 3276, 3275, 1, 0, 0, 0, 3276, 3277, 1, 0, 0, 0, 3277, 3279,
		1, 0, 0, 0, 3278, 3280, 3, 1090, 545, 0, 3279, 3278, 1, 0, 0, 0, 3280,
		3281, 1, 0, 0, 0, 3281, 3279, 1, 0, 0, 0, 3281, 3282, 1, 0, 0, 0, 3282,
		463, 1, 0, 0, 0, 3283, 3285, 7, 26, 0, 0, 3284, 3286, 5, 254, 0, 0, 3285,
		3284, 1, 0, 0, 0, 3285, 3286, 1, 0, 0, 0, 3286, 3287, 1, 0, 0, 0, 3287,
		3288, 3, 466, 233, 0, 3288, 465, 1, 0, 0, 0, 3289, 3291, 3, 468, 234, 0,
		3290, 3289, 1, 0, 0, 0, 3291, 3292, 1, 0, 0, 0, 3292, 3290, 1, 0, 0, 0,
		3292, 3293, 1, 0, 0, 0, 3293, 3295, 1, 0, 0, 0, 3294, 3296, 3, 470, 235,
		0, 3295, 3294, 1, 0, 0, 0, 3295, 3296, 1, 0, 0, 0, 3296, 3298, 1, 0, 0,
		0, 3297, 3290, 1, 0, 0, 0, 3298, 3299, 1, 0, 0, 0, 3299, 3297, 1, 0, 0,
		0, 3299, 3300, 1, 0, 0, 0, 3300, 467, 1, 0, 0, 0, 3301, 3318, 5, 532, 0,
		0, 3302, 3318, 5, 557, 0, 0, 3303, 3318, 5, 556, 0, 0, 3304, 3318, 5, 550,
		0, 0, 3305, 3318, 5, 529, 0, 0, 3306, 3318, 5, 535, 0, 0, 3307, 3318, 5,
		528, 0, 0, 3308, 3318, 5, 526, 0, 0, 3309, 3318, 5, 527, 0, 0, 3310, 3318,
		5, 542, 0, 0, 3311, 3318, 5, 549, 0, 0, 3312, 3318, 5, 547, 0, 0, 3313,
		3318, 5, 543, 0, 0, 3314, 3318, 5, 540, 0, 0, 3315, 3318, 5, 544, 0, 0,
		3316, 3318, 3, 1178, 589, 0, 3317, 3301, 1, 0, 0, 0, 3317, 3302, 1, 0,
		0, 0, 3317, 3303, 1, 0, 0, 0, 3317, 3304, 1, 0, 0, 0, 3317, 3305, 1, 0,
		0, 0, 3317, 3306, 1, 0, 0, 0, 3317, 3307, 1, 0, 0, 0, 3317, 3308, 1, 0,
		0, 0, 3317, 3309, 1, 0, 0, 0, 3317, 3310, 1, 0, 0, 0, 3317, 3311, 1, 0,
		0, 0, 3317, 3312, 1, 0, 0, 0, 3317, 3313, 1, 0, 0, 0, 3317, 3314, 1, 0,
		0, 0, 3317, 3315, 1, 0, 0, 0, 3317, 3316, 1, 0, 0, 0, 3318, 469, 1, 0,
		0, 0, 3319, 3320, 5, 542, 0, 0, 3320, 3321, 3, 1178, 589, 0, 3321, 3322,
		5, 549, 0, 0, 3322, 471, 1, 0, 0, 0, 3323, 3325, 5, 376, 0, 0, 3324, 3323,
		1, 0, 0, 0, 3324, 3325, 1, 0, 0, 0, 3325, 3327, 1, 0, 0, 0, 3326, 3328,
		5, 49, 0, 0, 3327, 3326, 1, 0, 0, 0, 3327, 3328, 1, 0, 0, 0, 3328, 3329,
		1, 0, 0, 0, 3329, 3330, 7, 42, 0, 0, 3330, 473, 1, 0, 0, 0, 3331, 3332,
		5, 377, 0, 0, 3332, 3333, 5, 22, 0, 0, 3333, 475, 1, 0, 0, 0, 3334, 3335,
		5, 381, 0, 0, 3335, 3336, 3, 1128, 564, 0, 3336, 477, 1, 0, 0, 0, 3337,
		3338, 5, 392, 0, 0, 3338, 3341, 3, 1090, 545, 0, 3339, 3340, 7, 4, 0, 0,
		3340, 3342, 3, 1090, 545, 0, 3341, 3339, 1, 0, 0, 0, 3341, 3342, 1, 0,
		0, 0, 3342, 479, 1, 0, 0, 0, 3343, 3345, 5, 438, 0, 0, 3344, 3346, 5, 254,
		0, 0, 3345, 3344, 1, 0, 0, 0, 3345, 3346, 1, 0, 0, 0, 3346, 3348, 1, 0,
		0, 0, 3347, 3343, 1, 0, 0, 0, 3347, 3348, 1, 0, 0, 0, 3348, 3349, 1, 0,
		0, 0, 3349, 3354, 7, 7, 0, 0, 3350, 3352, 5, 427, 0, 0, 3351, 3353, 5,
		62, 0, 0, 3352, 3351, 1, 0, 0, 0, 3352, 3353, 1, 0, 0, 0, 3353, 3355, 1,
		0, 0, 0, 3354, 3350, 1, 0, 0, 0, 3354, 3355, 1, 0, 0, 0, 3355, 481, 1,
		0, 0, 0, 3356, 3358, 7, 43, 0, 0, 3357, 3359, 7, 44, 0, 0, 3358, 3357,
		1, 0, 0, 0, 3358, 3359, 1, 0, 0, 0, 3359, 483, 1, 0, 0, 0, 3360, 3362,
		5, 254, 0, 0, 3361, 3360, 1, 0, 0, 0, 3361, 3362, 1, 0, 0, 0, 3362, 3363,
		1, 0, 0, 0, 3363, 3364, 5, 482, 0, 0, 3364, 485, 1, 0, 0, 0, 3365, 3367,
		5, 496, 0, 0, 3366, 3368, 5, 254, 0, 0, 3367, 3366, 1, 0, 0, 0, 3367, 3368,
		1, 0, 0, 0, 3368, 3369, 1, 0, 0, 0, 3369, 3370, 7, 45, 0, 0, 3370, 487,
		1, 0, 0, 0, 3371, 3373, 5, 254, 0, 0, 3372, 3371, 1, 0, 0, 0, 3372, 3373,
		1, 0, 0, 0, 3373, 3374, 1, 0, 0, 0, 3374, 3375, 5, 497, 0, 0, 3375, 489,
		1, 0, 0, 0, 3376, 3378, 5, 504, 0, 0, 3377, 3379, 5, 254, 0, 0, 3378, 3377,
		1, 0, 0, 0, 3378, 3379, 1, 0, 0, 0, 3379, 3381, 1, 0, 0, 0, 3380, 3376,
		1, 0, 0, 0, 3380, 3381, 1, 0, 0, 0, 3381, 3415, 1, 0, 0, 0, 3382, 3384,
		5, 42, 0, 0, 3383, 3385, 7, 46, 0, 0, 3384, 3383, 1, 0, 0, 0, 3384, 3385,
		1, 0, 0, 0, 3385, 3416, 1, 0, 0, 0, 3386, 3416, 5, 43, 0, 0, 3387, 3416,
		5, 80, 0, 0, 3388, 3416, 5, 81, 0, 0, 3389, 3416, 5, 82, 0, 0, 3390, 3416,
		5, 83, 0, 0, 3391, 3416, 5, 84, 0, 0, 3392, 3416, 5, 85, 0, 0, 3393, 3416,
		5, 86, 0, 0, 3394, 3416, 5, 87, 0, 0, 3395, 3416, 5, 88, 0, 0, 3396, 3416,
		5, 89, 0, 0, 3397, 3416, 5, 90, 0, 0, 3398, 3416, 5, 91, 0, 0, 3399, 3416,
		5, 98, 0, 0, 3400, 3416, 5, 111, 0, 0, 3401, 3416, 5, 142, 0, 0, 3402,
		3416, 5, 143, 0, 0, 3403, 3416, 5, 147, 0, 0, 3404, 3416, 5, 194, 0, 0,
		3405, 3416, 5, 219, 0, 0, 3406, 3416, 5, 240, 0, 0, 3407, 3416, 5, 257,
		0, 0, 3408, 3416, 5, 286, 0, 0, 3409, 3416, 5, 304, 0, 0, 3410, 3416, 5,
		338, 0, 0, 3411, 3416, 5, 349, 0, 0, 3412, 3416, 5, 357, 0, 0, 3413, 3416,
		5, 373, 0, 0, 3414, 3416, 5, 473, 0, 0, 3415, 3382, 1, 0, 0, 0, 3415, 3386,
		1, 0, 0, 0, 3415, 3387, 1, 0, 0, 0, 3415, 3388, 1, 0, 0, 0, 3415, 3389,
		1, 0, 0, 0, 3415, 3390, 1, 0, 0, 0, 3415, 3391, 1, 0, 0, 0, 3415, 3392,
		1, 0, 0, 0, 3415, 3393, 1, 0, 0, 0, 3415, 3394, 1, 0, 0, 0, 3415, 3395,
		1, 0, 0, 0, 3415, 3396, 1, 0, 0, 0, 3415, 3397, 1, 0, 0, 0, 3415, 3398,
		1, 0, 0, 0, 3415, 3399, 1, 0, 0, 0, 3415, 3400, 1, 0, 0, 0, 3415, 3401,
		1, 0, 0, 0, 3415, 3402, 1, 0, 0, 0, 3415, 3403, 1, 0, 0, 0, 3415, 3404,
		1, 0, 0, 0, 3415, 3405, 1, 0, 0, 0, 3415, 3406, 1, 0, 0, 0, 3415, 3407,
		1, 0, 0, 0, 3415, 3408, 1, 0, 0, 0, 3415, 3409, 1, 0, 0, 0, 3415, 3410,
		1, 0, 0, 0, 3415, 3411, 1, 0, 0, 0, 3415, 3412, 1, 0, 0, 0, 3415, 3413,
		1, 0, 0, 0, 3415, 3414, 1, 0, 0, 0, 3416, 491, 1, 0, 0, 0, 3417, 3418,
		5, 506, 0, 0, 3418, 3420, 7, 47, 0, 0, 3419, 3421, 5, 323, 0, 0, 3420,
		3419, 1, 0, 0, 0, 3420, 3421, 1, 0, 0, 0, 3421, 3424, 1, 0, 0, 0, 3422,
		3425, 3, 1170, 585, 0, 3423, 3425, 3, 1128, 564, 0, 3424, 3422, 1, 0, 0,
		0, 3424, 3423, 1, 0, 0, 0, 3425, 493, 1, 0, 0, 0, 3426, 3428, 5, 507, 0,
		0, 3427, 3429, 5, 254, 0, 0, 3428, 3427, 1, 0, 0, 0, 3428, 3429, 1, 0,
		0, 0, 3429, 3435, 1, 0, 0, 0, 3430, 3432, 5, 508, 0, 0, 3431, 3433, 5,
		21, 0, 0, 3432, 3431, 1, 0, 0, 0, 3432, 3433, 1, 0, 0, 0, 3433, 3435, 1,
		0, 0, 0, 3434, 3426, 1, 0, 0, 0, 3434, 3430, 1, 0, 0, 0, 3434, 3435, 1,
		0, 0, 0, 3435, 3436, 1, 0, 0, 0, 3436, 3443, 3, 496, 248, 0, 3437, 3439,
		5, 529, 0, 0, 3438, 3437, 1, 0, 0, 0, 3438, 3439, 1, 0, 0, 0, 3439, 3440,
		1, 0, 0, 0, 3440, 3442, 3, 496, 248, 0, 3441, 3438, 1, 0, 0, 0, 3442, 3445,
		1, 0, 0, 0, 3443, 3441, 1, 0, 0, 0, 3443, 3444, 1, 0, 0, 0, 3444, 495,
		1, 0, 0, 0, 3445, 3443, 1, 0, 0, 0, 3446, 3448, 3, 498, 249, 0, 3447, 3449,
		3, 500, 250, 0, 3448, 3447, 1, 0, 0, 0, 3448, 3449, 1, 0, 0, 0, 3449, 497,
		1, 0, 0, 0, 3450, 3453, 3, 1172, 586, 0, 3451, 3453, 3, 1170, 585, 0, 3452,
		3450, 1, 0, 0, 0, 3452, 3451, 1, 0, 0, 0, 3453, 499, 1, 0, 0, 0, 3454,
		3455, 7, 4, 0, 0, 3455, 3456, 3, 1172, 586, 0, 3456, 501, 1, 0, 0, 0, 3457,
		3459, 5, 514, 0, 0, 3458, 3457, 1, 0, 0, 0, 3458, 3459, 1, 0, 0, 0, 3459,
		3460, 1, 0, 0, 0, 3460, 3461, 5, 289, 0, 0, 3461, 3462, 5, 47, 0, 0, 3462,
		503, 1, 0, 0, 0, 3463, 3464, 5, 356, 0, 0, 3464, 3466, 5, 145, 0, 0, 3465,
		3467, 3, 506, 253, 0, 3466, 3465, 1, 0, 0, 0, 3466, 3467, 1, 0, 0, 0, 3467,
		3469, 1, 0, 0, 0, 3468, 3470, 3, 508, 254, 0, 3469, 3468, 1, 0, 0, 0, 3469,
		3470, 1, 0, 0, 0, 3470, 3471, 1, 0, 0, 0, 3471, 3473, 5, 534, 0, 0, 3472,
		3474, 3, 520, 260, 0, 3473, 3472, 1, 0, 0, 0, 3473, 3474, 1, 0, 0, 0, 3474,
		3475, 1, 0, 0, 0, 3475, 3476, 3, 526, 263, 0, 3476, 505, 1, 0, 0, 0, 3477,
		3479, 7, 48, 0, 0, 3478, 3480, 3, 510, 255, 0, 3479, 3478, 1, 0, 0, 0,
		3480, 3481, 1, 0, 0, 0, 3481, 3479, 1, 0, 0, 0, 3481, 3482, 1, 0, 0, 0,
		3482, 507, 1, 0, 0, 0, 3483, 3484, 7, 49, 0, 0, 3484, 3485, 3, 1128, 564,
		0, 3485, 509, 1, 0, 0, 0, 3486, 3489, 3, 512, 256, 0, 3487, 3489, 3, 516,
		258, 0, 3488, 3486, 1, 0, 0, 0, 3488, 3487, 1, 0, 0, 0, 3489, 511, 1, 0,
		0, 0, 3490, 3492, 5, 49, 0, 0, 3491, 3490, 1, 0, 0, 0, 3491, 3492, 1, 0,
		0, 0, 3492, 3493, 1, 0, 0, 0, 3493, 3495, 5, 384, 0, 0, 3494, 3491, 1,
		0, 0, 0, 3494, 3495, 1, 0, 0, 0, 3495, 3497, 1, 0, 0, 0, 3496, 3498, 3,
		514, 257, 0, 3497, 3496, 1, 0, 0, 0, 3498, 3499, 1, 0, 0, 0, 3499, 3497,
		1, 0, 0, 0, 3499, 3500, 1, 0, 0, 0, 3500, 513, 1, 0, 0, 0, 3501, 3503,
		5, 328, 0, 0, 3502, 3501, 1, 0, 0, 0, 3502, 3503, 1, 0, 0, 0, 3503, 3506,
		1, 0, 0, 0, 3504, 3507, 3, 1074, 537, 0, 3505, 3507, 3, 1134, 567, 0, 3506,
		3504, 1, 0, 0, 0, 3506, 3505, 1, 0, 0, 0, 3507, 3510, 1, 0, 0, 0, 3508,
		3510, 5, 20, 0, 0, 3509, 3502, 1, 0, 0, 0, 3509, 3508, 1, 0, 0, 0, 3510,
		515, 1, 0, 0, 0, 3511, 3513, 5, 49, 0, 0, 3512, 3511, 1, 0, 0, 0, 3512,
		3513, 1, 0, 0, 0, 3513, 3514, 1, 0, 0, 0, 3514, 3516, 5, 507, 0, 0, 3515,
		3517, 3, 518, 259, 0, 3516, 3515, 1, 0, 0, 0, 3517, 3518, 1, 0, 0, 0, 3518,
		3516, 1, 0, 0, 0, 3518, 3519, 1, 0, 0, 0, 3519, 517, 1, 0, 0, 0, 3520,
		3524, 3, 1074, 537, 0, 3521, 3524, 3, 1172, 586, 0, 3522, 3524, 5, 20,
		0, 0, 3523, 3520, 1, 0, 0, 0, 3523, 3521, 1, 0, 0, 0, 3523, 3522, 1, 0,
		0, 0, 3524, 519, 1, 0, 0, 0, 3525, 3526, 5, 127, 0, 0, 3526, 3528, 5, 534,
		0, 0, 3527, 3529, 3, 522, 261, 0, 3528, 3527, 1, 0, 0, 0, 3529, 3530, 1,
		0, 0, 0, 3530, 3528, 1, 0, 0, 0, 3530, 3531, 1, 0, 0, 0, 3531, 3532, 1,
		0, 0, 0, 3532, 3533, 5, 158, 0, 0, 3533, 3534, 5, 127, 0, 0, 3534, 3535,
		5, 534, 0, 0, 3535, 521, 1, 0, 0, 0, 3536, 3537, 3, 524, 262, 0, 3537,
		3538, 5, 534, 0, 0, 3538, 3539, 3, 986, 493, 0, 3539, 3540, 5, 534, 0,
		0, 3540, 3541, 3, 530, 265, 0, 3541, 523, 1, 0, 0, 0, 3542, 3543, 3, 1162,
		581, 0, 3543, 3545, 5, 419, 0, 0, 3544, 3546, 3, 1178, 589, 0, 3545, 3544,
		1, 0, 0, 0, 3545, 3546, 1, 0, 0, 0, 3546, 525, 1, 0, 0, 0, 3547, 3551,
		3, 530, 265, 0, 3548, 3550, 3, 528, 264, 0, 3549, 3548, 1, 0, 0, 0, 3550,
		3553, 1, 0, 0, 0, 3551, 3549, 1, 0, 0, 0, 3551, 3552, 1, 0, 0, 0, 3552,
		527, 1, 0, 0, 0, 3553, 3551, 1, 0, 0, 0, 3554, 3555, 3, 524, 262, 0, 3555,
		3556, 5, 534, 0, 0, 3556, 3557, 3, 530, 265, 0, 3557, 529, 1, 0, 0, 0,
		3558, 3560, 3, 534, 267, 0, 3559, 3558, 1, 0, 0, 0, 3560, 3563, 1, 0, 0,
		0, 3561, 3559, 1, 0, 0, 0, 3561, 3562, 1, 0, 0, 0, 3562, 3567, 1, 0, 0,
		0, 3563, 3561, 1, 0, 0, 0, 3564, 3566, 3, 532, 266, 0, 3565, 3564, 1, 0,
		0, 0, 3566, 3569, 1, 0, 0, 0, 3567, 3565, 1, 0, 0, 0, 3567, 3568, 1, 0,
		0, 0, 3568, 531, 1, 0, 0, 0, 3569, 3567, 1, 0, 0, 0, 3570, 3571, 3, 1148,
		574, 0, 3571, 3579, 5, 534, 0, 0, 3572, 3580, 3, 564, 282, 0, 3573, 3575,
		3, 534, 267, 0, 3574, 3573, 1, 0, 0, 0, 3575, 3578, 1, 0, 0, 0, 3576, 3574,
		1, 0, 0, 0, 3576, 3577, 1, 0, 0, 0, 3577, 3580, 1, 0, 0, 0, 3578, 3576,
		1, 0, 0, 0, 3579, 3572, 1, 0, 0, 0, 3579, 3576, 1, 0, 0, 0, 3580, 533,
		1, 0, 0, 0, 3581, 3583, 3, 536, 268, 0, 3582, 3581, 1, 0, 0, 0, 3583, 3586,
		1, 0, 0, 0, 3584, 3582, 1, 0, 0, 0, 3584, 3585, 1, 0, 0, 0, 3585, 3587,
		1, 0, 0, 0, 3586, 3584, 1, 0, 0, 0, 3587, 3588, 5, 534, 0, 0, 3588, 535,
		1, 0, 0, 0, 3589, 3639, 3, 538, 269, 0, 3590, 3639, 3, 548, 274, 0, 3591,
		3639, 3, 566, 283, 0, 3592, 3639, 3, 570, 285, 0, 3593, 3639, 3, 590, 295,
		0, 3594, 3639, 3, 594, 297, 0, 3595, 3639, 3, 612, 306, 0, 3596, 3639,
		3, 616, 308, 0, 3597, 3639, 3, 618, 309, 0, 3598, 3639, 3, 620, 310, 0,
		3599, 3639, 3, 622, 311, 0, 3600, 3639, 3, 632, 316, 0, 3601, 3639, 3,
		648, 324, 0, 3602, 3639, 3, 650, 325, 0, 3603, 3639, 3, 652, 326, 0, 3604,
		3639, 3, 678, 339, 0, 3605, 3639, 3, 672, 336, 0, 3606, 3639, 3, 674, 337,
		0, 3607, 3639, 3, 676, 338, 0, 3608, 3639, 3, 682, 341, 0, 3609, 3639,
		3, 684, 342, 0, 3610, 3639, 3, 686, 343, 0, 3611, 3639, 3, 688, 344, 0,
		3612, 3639, 3, 694, 347, 0, 3613, 3639, 3, 700, 350, 0, 3614, 3639, 3,
		706, 353, 0, 3615, 3639, 3, 708, 354, 0, 3616, 3639, 3, 738, 369, 0, 3617,
		3639, 3, 758, 379, 0, 3618, 3639, 3, 768, 384, 0, 3619, 3639, 3, 780, 390,
		0, 3620, 3639, 3, 794, 397, 0, 3621, 3639, 3, 820, 410, 0, 3622, 3639,
		3, 822, 411, 0, 3623, 3639, 3, 830, 415, 0, 3624, 3639, 3, 852, 426, 0,
		3625, 3639, 3, 854, 427, 0, 3626, 3639, 3, 858, 429, 0, 3627, 3639, 3,
		862, 431, 0, 3628, 3639, 3, 868, 434, 0, 3629, 3639, 3, 888, 444, 0, 3630,
		3639, 3, 900, 450, 0, 3631, 3639, 3, 926, 463, 0, 3632, 3639, 3, 930, 465,
		0, 3633, 3639, 3, 932, 466, 0, 3634, 3639, 3, 946, 473, 0, 3635, 3639,
		3, 964, 482, 0, 3636, 3639, 3, 966, 483, 0, 3637, 3639, 3, 996, 498, 0,
		3638, 3589, 1, 0, 0, 0, 3638, 3590, 1, 0, 0, 0, 3638, 3591, 1, 0, 0, 0,
		3638, 3592, 1, 0, 0, 0, 3638, 3593, 1, 0, 0, 0, 3638, 3594, 1, 0, 0, 0,
		3638, 3595, 1, 0, 0, 0, 3638, 3596, 1, 0, 0, 0, 3638, 3597, 1, 0, 0, 0,
		3638, 3598, 1, 0, 0, 0, 3638, 3599, 1, 0, 0, 0, 3638, 3600, 1, 0, 0, 0,
		3638, 3601, 1, 0, 0, 0, 3638, 3602, 1, 0, 0, 0, 3638, 3603, 1, 0, 0, 0,
		3638, 3604, 1, 0, 0, 0, 3638, 3605, 1, 0, 0, 0, 3638, 3606, 1, 0, 0, 0,
		3638, 3607, 1, 0, 0, 0, 3638, 3608, 1, 0, 0, 0, 3638, 3609, 1, 0, 0, 0,
		3638, 3610, 1, 0, 0, 0, 3638, 3611, 1, 0, 0, 0, 3638, 3612, 1, 0, 0, 0,
		3638, 3613, 1, 0, 0, 0, 3638, 3614, 1, 0, 0, 0, 3638, 3615, 1, 0, 0, 0,
		3638, 3616, 1, 0, 0, 0, 3638, 3617, 1, 0, 0, 0, 3638, 3618, 1, 0, 0, 0,
		3638, 3619, 1, 0, 0, 0, 3638, 3620, 1, 0, 0, 0, 3638, 3621, 1, 0, 0, 0,
		3638, 3622, 1, 0, 0, 0, 3638, 3623, 1, 0, 0, 0, 3638, 3624, 1, 0, 0, 0,
		3638, 3625, 1, 0, 0, 0, 3638, 3626, 1, 0, 0, 0, 3638, 3627, 1, 0, 0, 0,
		3638, 3628, 1, 0, 0, 0, 3638, 3629, 1, 0, 0, 0, 3638, 3630, 1, 0, 0, 0,
		3638, 3631, 1, 0, 0, 0, 3638, 3632, 1, 0, 0, 0, 3638, 3633, 1, 0, 0, 0,
		3638, 3634, 1, 0, 0, 0, 3638, 3635, 1, 0, 0, 0, 3638, 3636, 1, 0, 0, 0,
		3638, 3637, 1, 0, 0, 0, 3639, 537, 1, 0, 0, 0, 3640, 3641, 5, 2, 0, 0,
		3641, 3646, 3, 1074, 537, 0, 3642, 3647, 3, 540, 270, 0, 3643, 3647, 3,
		544, 272, 0, 3644, 3647, 3, 542, 271, 0, 3645, 3647, 3, 546, 273, 0, 3646,
		3642, 1, 0, 0, 0, 3646, 3643, 1, 0, 0, 0, 3646, 3644, 1, 0, 0, 0, 3646,
		3645, 1, 0, 0, 0, 3646, 3647, 1, 0, 0, 0, 3647, 3649, 1, 0, 0, 0, 3648,
		3650, 3, 1028, 514, 0, 3649, 3648, 1, 0, 0, 0, 3649, 3650, 1, 0, 0, 0,
		3650, 3652, 1, 0, 0, 0, 3651, 3653, 3, 1030, 515, 0, 3652, 3651, 1, 0,
		0, 0, 3652, 3653, 1, 0, 0, 0, 3653, 3655, 1, 0, 0, 0, 3654, 3656, 5, 159,
		0, 0, 3655, 3654, 1, 0, 0, 0, 3655, 3656, 1, 0, 0, 0, 3656, 539, 1, 0,
		0, 0, 3657, 3677, 5, 215, 0, 0, 3658, 3660, 5, 111, 0, 0, 3659, 3661, 5,
		519, 0, 0, 3660, 3659, 1, 0, 0, 0, 3660, 3661, 1, 0, 0, 0, 3661, 3678,
		1, 0, 0, 0, 3662, 3664, 5, 114, 0, 0, 3663, 3665, 5, 520, 0, 0, 3664, 3663,
		1, 0, 0, 0, 3664, 3665, 1, 0, 0, 0, 3665, 3678, 1, 0, 0, 0, 3666, 3678,
		5, 115, 0, 0, 3667, 3678, 5, 485, 0, 0, 3668, 3678, 5, 486, 0, 0, 3669,
		3671, 5, 490, 0, 0, 3670, 3672, 5, 296, 0, 0, 3671, 3670, 1, 0, 0, 0, 3671,
		3672, 1, 0, 0, 0, 3672, 3678, 1, 0, 0, 0, 3673, 3678, 5, 491, 0, 0, 3674,
		3678, 5, 518, 0, 0, 3675, 3678, 5, 519, 0, 0, 3676, 3678, 5, 520, 0, 0,
		3677, 3658, 1, 0, 0, 0, 3677, 3662, 1, 0, 0, 0, 3677, 3666, 1, 0, 0, 0,
		3677, 3667, 1, 0, 0, 0, 3677, 3668, 1, 0, 0, 0, 3677, 3669, 1, 0, 0, 0,
		3677, 3673, 1, 0, 0, 0, 3677, 3674, 1, 0, 0, 0, 3677, 3675, 1, 0, 0, 0,
		3677, 3676, 1, 0, 0, 0, 3678, 541, 1, 0, 0, 0, 3679, 3680, 5, 215, 0, 0,
		3680, 3681, 3, 1146, 573, 0, 3681, 543, 1, 0, 0, 0, 3682, 3683, 5, 215,
		0, 0, 3683, 3684, 5, 191, 0, 0, 3684, 3685, 5, 259, 0, 0, 3685, 545, 1,
		0, 0, 0, 3686, 3688, 5, 295, 0, 0, 3687, 3686, 1, 0, 0, 0, 3687, 3688,
		1, 0, 0, 0, 3688, 3689, 1, 0, 0, 0, 3689, 3690, 5, 105, 0, 0, 3690, 547,
		1, 0, 0, 0, 3691, 3695, 5, 4, 0, 0, 3692, 3696, 3, 550, 275, 0, 3693, 3696,
		3, 552, 276, 0, 3694, 3696, 3, 554, 277, 0, 3695, 3692, 1, 0, 0, 0, 3695,
		3693, 1, 0, 0, 0, 3695, 3694, 1, 0, 0, 0, 3696, 3698, 1, 0, 0, 0, 3697,
		3699, 3, 1024, 512, 0, 3698, 3697, 1, 0, 0, 0, 3698, 3699, 1, 0, 0, 0,
		3699, 3701, 1, 0, 0, 0, 3700, 3702, 3, 1026, 513, 0, 3701, 3700, 1, 0,
		0, 0, 3701, 3702, 1, 0, 0, 0, 3702, 3704, 1, 0, 0, 0, 3703, 3705, 5, 160,
		0, 0, 3704, 3703, 1, 0, 0, 0, 3704, 3705, 1, 0, 0, 0, 3705, 549, 1, 0,
		0, 0, 3706, 3708, 3, 556, 278, 0, 3707, 3706, 1, 0, 0, 0, 3708, 3709, 1,
		0, 0, 0, 3709, 3707, 1, 0, 0, 0, 3709, 3710, 1, 0, 0, 0, 3710, 3711, 1,
		0, 0, 0, 3711, 3713, 5, 489, 0, 0, 3712, 3714, 3, 558, 279, 0, 3713, 3712,
		1, 0, 0, 0, 3714, 3715, 1, 0, 0, 0, 3715, 3713, 1, 0, 0, 0, 3715, 3716,
		1, 0, 0, 0, 3716, 551, 1, 0, 0, 0, 3717, 3719, 3, 556, 278, 0, 3718, 3717,
		1, 0, 0, 0, 3719, 3720, 1, 0, 0, 0, 3720, 3718, 1, 0, 0, 0, 3720, 3721,
		1, 0, 0, 0, 3721, 3728, 1, 0, 0, 0, 3722, 3724, 5, 489, 0, 0, 3723, 3725,
		3, 560, 280, 0, 3724, 3723, 1, 0, 0, 0, 3725, 3726, 1, 0, 0, 0, 3726, 3724,
		1, 0, 0, 0, 3726, 3727, 1, 0, 0, 0, 3727, 3729, 1, 0, 0, 0, 3728, 3722,
		1, 0, 0, 0, 3728, 3729, 1, 0, 0, 0, 3729, 3730, 1, 0, 0, 0, 3730, 3732,
		5, 222, 0, 0, 3731, 3733, 3, 562, 281, 0, 3732, 3731, 1, 0, 0, 0, 3733,
		3734, 1, 0, 0, 0, 3734, 3732, 1, 0, 0, 0, 3734, 3735, 1, 0, 0, 0, 3735,
		553, 1, 0, 0, 0, 3736, 3737, 7, 50, 0, 0, 3737, 3738, 3, 1074, 537, 0,
		3738, 3739, 5, 489, 0, 0, 3739, 3740, 3, 558, 279, 0, 3740, 555, 1, 0,
		0, 0, 3741, 3744, 3, 1074, 537, 0, 3742, 3744, 3, 1172, 586, 0, 3743, 3741,
		1, 0, 0, 0, 3743, 3742, 1, 0, 0, 0, 3744, 557, 1, 0, 0, 0, 3745, 3747,
		3, 1074, 537, 0, 3746, 3748, 5, 412, 0, 0, 3747, 3746, 1, 0, 0, 0, 3747,
		3748, 1, 0, 0, 0, 3748, 559, 1, 0, 0, 0, 3749, 3752, 3, 1074, 537, 0, 3750,
		3752, 3, 1172, 586, 0, 3751, 3749, 1, 0, 0, 0, 3751, 3750, 1, 0, 0, 0,
		3752, 561, 1, 0, 0, 0, 3753, 3755, 3, 1074, 537, 0, 3754, 3756, 5, 412,
		0, 0, 3755, 3754, 1, 0, 0, 0, 3755, 3756, 1, 0, 0, 0, 3756, 563, 1, 0,
		0, 0, 3757, 3759, 5, 224, 0, 0, 3758, 3760, 5, 489, 0, 0, 3759, 3758, 1,
		0, 0, 0, 3759, 3760, 1, 0, 0, 0, 3760, 3761, 1, 0, 0, 0, 3761, 3762, 5,
		534, 0, 0, 3762, 565, 1, 0, 0, 0, 3763, 3765, 5, 17, 0, 0, 3764, 3766,
		3, 568, 284, 0, 3765, 3764, 1, 0, 0, 0, 3766, 3767, 1, 0, 0, 0, 3767, 3765,
		1, 0, 0, 0, 3767, 3768, 1, 0, 0, 0, 3768, 567, 1, 0, 0, 0, 3769, 3770,
		3, 1150, 575, 0, 3770, 3773, 5, 489, 0, 0, 3771, 3772, 5, 359, 0, 0, 3772,
		3774, 5, 489, 0, 0, 3773, 3771, 1, 0, 0, 0, 3773, 3774, 1, 0, 0, 0, 3774,
		3775, 1, 0, 0, 0, 3775, 3776, 3, 1150, 575, 0, 3776, 569, 1, 0, 0, 0, 3777,
		3780, 5, 52, 0, 0, 3778, 3781, 3, 1074, 537, 0, 3779, 3781, 3, 1172, 586,
		0, 3780, 3778, 1, 0, 0, 0, 3780, 3779, 1, 0, 0, 0, 3781, 3783, 1, 0, 0,
		0, 3782, 3784, 3, 572, 286, 0, 3783, 3782, 1, 0, 0, 0, 3783, 3784, 1, 0,
		0, 0, 3784, 3786, 1, 0, 0, 0, 3785, 3787, 3, 588, 294, 0, 3786, 3785, 1,
		0, 0, 0, 3786, 3787, 1, 0, 0, 0, 3787, 3789, 1, 0, 0, 0, 3788, 3790, 3,
		1020, 510, 0, 3789, 3788, 1, 0, 0, 0, 3789, 3790, 1, 0, 0, 0, 3790, 3792,
		1, 0, 0, 0, 3791, 3793, 3, 1028, 514, 0, 3792, 3791, 1, 0, 0, 0, 3792,
		3793, 1, 0, 0, 0, 3793, 3795, 1, 0, 0, 0, 3794, 3796, 3, 1030, 515, 0,
		3795, 3794, 1, 0, 0, 0, 3795, 3796, 1, 0, 0, 0, 3796, 3798, 1, 0, 0, 0,
		3797, 3799, 5, 161, 0, 0, 3798, 3797, 1, 0, 0, 0, 3798, 3799, 1, 0, 0,
		0, 3799, 571, 1, 0, 0, 0, 3800, 3802, 5, 506, 0, 0, 3801, 3803, 3, 574,
		287, 0, 3802, 3801, 1, 0, 0, 0, 3803, 3804, 1, 0, 0, 0, 3804, 3802, 1,
		0, 0, 0, 3804, 3805, 1, 0, 0, 0, 3805, 573, 1, 0, 0, 0, 3806, 3810, 3,
		576, 288, 0, 3807, 3810, 3, 580, 290, 0, 3808, 3810, 3, 584, 292, 0, 3809,
		3806, 1, 0, 0, 0, 3809, 3807, 1, 0, 0, 0, 3809, 3808, 1, 0, 0, 0, 3810,
		575, 1, 0, 0, 0, 3811, 3813, 5, 49, 0, 0, 3812, 3811, 1, 0, 0, 0, 3812,
		3813, 1, 0, 0, 0, 3813, 3814, 1, 0, 0, 0, 3814, 3816, 5, 384, 0, 0, 3815,
		3812, 1, 0, 0, 0, 3815, 3816, 1, 0, 0, 0, 3816, 3818, 1, 0, 0, 0, 3817,
		3819, 3, 578, 289, 0, 3818, 3817, 1, 0, 0, 0, 3819, 3820, 1, 0, 0, 0, 3820,
		3818, 1, 0, 0, 0, 3820, 3821, 1, 0, 0, 0, 3821, 577, 1, 0, 0, 0, 3822,
		3823, 5, 5, 0, 0, 3823, 3827, 5, 323, 0, 0, 3824, 3827, 5, 250, 0, 0, 3825,
		3827, 5, 459, 0, 0, 3826, 3822, 1, 0, 0, 0, 3826, 3824, 1, 0, 0, 0, 3826,
		3825, 1, 0, 0, 0, 3826, 3827, 1, 0, 0, 0, 3827, 3828, 1, 0, 0, 0, 3828,
		3832, 3, 1074, 537, 0, 3829, 3832, 3, 1172, 586, 0, 3830, 3832, 3, 1134,
		567, 0, 3831, 3826, 1, 0, 0, 0, 3831, 3829, 1, 0, 0, 0, 3831, 3830, 1,
		0, 0, 0, 3832, 3835, 1, 0, 0, 0, 3833, 3835, 5, 325, 0, 0, 3834, 3831,
		1, 0, 0, 0, 3834, 3833, 1, 0, 0, 0, 3835, 579, 1, 0, 0, 0, 3836, 3838,
		5, 49, 0, 0, 3837, 3836, 1, 0, 0, 0, 3837, 3838, 1, 0, 0, 0, 3838, 3839,
		1, 0, 0, 0, 3839, 3841, 5, 507, 0, 0, 3840, 3842, 3, 582, 291, 0, 3841,
		3840, 1, 0, 0, 0, 3842, 3843, 1, 0, 0, 0, 3843, 3841, 1, 0, 0, 0, 3843,
		3844, 1, 0, 0, 0, 3844, 581, 1, 0, 0, 0, 3845, 3846, 5, 5, 0, 0, 3846,
		3852, 5, 323, 0, 0, 3847, 3849, 5, 269, 0, 0, 3848, 3850, 5, 323, 0, 0,
		3849, 3848, 1, 0, 0, 0, 3849, 3850, 1, 0, 0, 0, 3850, 3852, 1, 0, 0, 0,
		3851, 3845, 1, 0, 0, 0, 3851, 3847, 1, 0, 0, 0, 3851, 3852, 1, 0, 0, 0,
		3852, 3855, 1, 0, 0, 0, 3853, 3856, 3, 1074, 537, 0, 3854, 3856, 3, 1172,
		586, 0, 3855, 3853, 1, 0, 0, 0, 3855, 3854, 1, 0, 0, 0, 3856, 583, 1, 0,
		0, 0, 3857, 3859, 5, 49, 0, 0, 3858, 3857, 1, 0, 0, 0, 3858, 3859, 1, 0,
		0, 0, 3859, 3860, 1, 0, 0, 0, 3860, 3862, 5, 95, 0, 0, 3861, 3863, 3, 586,
		293, 0, 3862, 3861, 1, 0, 0, 0, 3863, 3864, 1, 0, 0, 0, 3864, 3862, 1,
		0, 0, 0, 3864, 3865, 1, 0, 0, 0, 3865, 585, 1, 0, 0, 0, 3866, 3867, 5,
		5, 0, 0, 3867, 3873, 5, 323, 0, 0, 3868, 3870, 5, 269, 0, 0, 3869, 3871,
		5, 323, 0, 0, 3870, 3869, 1, 0, 0, 0, 3870, 3871, 1, 0, 0, 0, 3871, 3873,
		1, 0, 0, 0, 3872, 3866, 1, 0, 0, 0, 3872, 3868, 1, 0, 0, 0, 3872, 3873,
		1, 0, 0, 0, 3873, 3874, 1, 0, 0, 0, 3874, 3878, 3, 1074, 537, 0, 3875,
		3878, 3, 1172, 586, 0, 3876, 3878, 5, 325, 0, 0, 3877, 3872, 1, 0, 0, 0,
		3877, 3875, 1, 0, 0, 0, 3877, 3876, 1, 0, 0, 0, 3878, 587, 1, 0, 0, 0,
		3879, 3880, 7, 49, 0, 0, 3880, 3881, 3, 1074, 537, 0, 3881, 589, 1, 0,
		0, 0, 3882, 3884, 5, 53, 0, 0, 3883, 3885, 3, 592, 296, 0, 3884, 3883,
		1, 0, 0, 0, 3885, 3886, 1, 0, 0, 0, 3886, 3884, 1, 0, 0, 0, 3886, 3887,
		1, 0, 0, 0, 3887, 591, 1, 0, 0, 0, 3888, 3889, 3, 1142, 571, 0, 3889, 3890,
		7, 36, 0, 0, 3890, 3894, 1, 0, 0, 0, 3891, 3894, 3, 1074, 537, 0, 3892,
		3894, 3, 1172, 586, 0, 3893, 3888, 1, 0, 0, 0, 3893, 3891, 1, 0, 0, 0,
		3893, 3892, 1, 0, 0, 0, 3894, 593, 1, 0, 0, 0, 3895, 3897, 5, 67, 0, 0,
		3896, 3898, 3, 596, 298, 0, 3897, 3896, 1, 0, 0, 0, 3898, 3899, 1, 0, 0,
		0, 3899, 3897, 1, 0, 0, 0, 3899, 3900, 1, 0, 0, 0, 3900, 595, 1, 0, 0,
		0, 3901, 3905, 3, 1134, 567, 0, 3902, 3906, 3, 598, 299, 0, 3903, 3906,
		3, 600, 300, 0, 3904, 3906, 3, 602, 301, 0, 3905, 3902, 1, 0, 0, 0, 3905,
		3903, 1, 0, 0, 0, 3905, 3904, 1, 0, 0, 0, 3905, 3906, 1, 0, 0, 0, 3906,
		597, 1, 0, 0, 0, 3907, 3912, 7, 12, 0, 0, 3908, 3910, 5, 212, 0, 0, 3909,
		3908, 1, 0, 0, 0, 3909, 3910, 1, 0, 0, 0, 3910, 3911, 1, 0, 0, 0, 3911,
		3913, 5, 390, 0, 0, 3912, 3909, 1, 0, 0, 0, 3912, 3913, 1, 0, 0, 0, 3913,
		3922, 1, 0, 0, 0, 3914, 3916, 5, 514, 0, 0, 3915, 3914, 1, 0, 0, 0, 3915,
		3916, 1, 0, 0, 0, 3916, 3920, 1, 0, 0, 0, 3917, 3918, 5, 310, 0, 0, 3918,
		3921, 5, 407, 0, 0, 3919, 3921, 5, 286, 0, 0, 3920, 3917, 1, 0, 0, 0, 3920,
		3919, 1, 0, 0, 0, 3921, 3923, 1, 0, 0, 0, 3922, 3915, 1, 0, 0, 0, 3922,
		3923, 1, 0, 0, 0, 3923, 599, 1, 0, 0, 0, 3924, 3926, 5, 514, 0, 0, 3925,
		3924, 1, 0, 0, 0, 3925, 3926, 1, 0, 0, 0, 3926, 3930, 1, 0, 0, 0, 3927,
		3928, 5, 310, 0, 0, 3928, 3931, 5, 407, 0, 0, 3929, 3931, 5, 286, 0, 0,
		3930, 3927, 1, 0, 0, 0, 3930, 3929, 1, 0, 0, 0, 3931, 601, 1, 0, 0, 0,
		3932, 3934, 5, 514, 0, 0, 3933, 3932, 1, 0, 0, 0, 3933, 3934, 1, 0, 0,
		0, 3934, 3935, 1, 0, 0, 0, 3935, 3936, 5, 310, 0, 0, 3936, 3940, 5, 511,
		0, 0, 3937, 3938, 5, 514, 0, 0, 3938, 3940, 5, 511, 0, 0, 3939, 3933, 1,
		0, 0, 0, 3939, 3937, 1, 0, 0, 0, 3940, 3947, 1, 0, 0, 0, 3941, 3943, 5,
		506, 0, 0, 3942, 3944, 3, 604, 302, 0, 3943, 3942, 1, 0, 0, 0, 3944, 3945,
		1, 0, 0, 0, 3945, 3943, 1, 0, 0, 0, 3945, 3946, 1, 0, 0, 0, 3946, 3948,
		1, 0, 0, 0, 3947, 3941, 1, 0, 0, 0, 3947, 3948, 1, 0, 0, 0, 3948, 603,
		1, 0, 0, 0, 3949, 3953, 3, 606, 303, 0, 3950, 3953, 3, 608, 304, 0, 3951,
		3953, 3, 610, 305, 0, 3952, 3949, 1, 0, 0, 0, 3952, 3950, 1, 0, 0, 0, 3952,
		3951, 1, 0, 0, 0, 3953, 605, 1, 0, 0, 0, 3954, 3956, 5, 68, 0, 0, 3955,
		3957, 5, 323, 0, 0, 3956, 3955, 1, 0, 0, 0, 3956, 3957, 1, 0, 0, 0, 3957,
		3958, 1, 0, 0, 0, 3958, 3959, 7, 51, 0, 0, 3959, 607, 1, 0, 0, 0, 3960,
		3963, 5, 28, 0, 0, 3961, 3964, 3, 1074, 537, 0, 3962, 3964, 3, 1178, 589,
		0, 3963, 3961, 1, 0, 0, 0, 3963, 3962, 1, 0, 0, 0, 3964, 609, 1, 0, 0,
		0, 3965, 3967, 5, 29, 0, 0, 3966, 3968, 5, 323, 0, 0, 3967, 3966, 1, 0,
		0, 0, 3967, 3968, 1, 0, 0, 0, 3968, 3971, 1, 0, 0, 0, 3969, 3972, 3, 1074,
		537, 0, 3970, 3972, 3, 1178, 589, 0, 3971, 3969, 1, 0, 0, 0, 3971, 3970,
		1, 0, 0, 0, 3972, 611, 1, 0, 0, 0, 3973, 3975, 5, 92, 0, 0, 3974, 3976,
		3, 614, 307, 0, 3975, 3974, 1, 0, 0, 0, 3976, 3977, 1, 0, 0, 0, 3977, 3975,
		1, 0, 0, 0, 3977, 3978, 1, 0, 0, 0, 3978, 3979, 1, 0, 0, 0, 3979, 3980,
		7, 52, 0, 0, 3980, 3982, 3, 1032, 516, 0, 3981, 3983, 3, 1024, 512, 0,
		3982, 3981, 1, 0, 0, 0, 3982, 3983, 1, 0, 0, 0, 3983, 3985, 1, 0, 0, 0,
		3984, 3986, 3, 1026, 513, 0, 3985, 3984, 1, 0, 0, 0, 3985, 3986, 1, 0,
		0, 0, 3986, 3988, 1, 0, 0, 0, 3987, 3989, 5, 162, 0, 0, 3988, 3987, 1,
		0, 0, 0, 3988, 3989, 1, 0, 0, 0, 3989, 613, 1, 0, 0, 0, 3990, 3992, 3,
		1074, 537, 0, 3991, 3993, 5, 412, 0, 0, 3992, 3991, 1, 0, 0, 0, 3992, 3993,
		1, 0, 0, 0, 3993, 615, 1, 0, 0, 0, 3994, 3995, 5, 96, 0, 0, 3995, 617,
		1, 0, 0, 0, 3996, 3997, 5, 131, 0, 0, 3997, 3999, 3, 1134, 567, 0, 3998,
		4000, 5, 377, 0, 0, 3999, 3998, 1, 0, 0, 0, 3999, 4000, 1, 0, 0, 0, 4000,
		4002, 1, 0, 0, 0, 4001, 4003, 3, 1016, 508, 0, 4002, 4001, 1, 0, 0, 0,
		4002, 4003, 1, 0, 0, 0, 4003, 4005, 1, 0, 0, 0, 4004, 4006, 3, 1018, 509,
		0, 4005, 4004, 1, 0, 0, 0, 4005, 4006, 1, 0, 0, 0, 4006, 4008, 1, 0, 0,
		0, 4007, 4009, 5, 163, 0, 0, 4008, 4007, 1, 0, 0, 0, 4008, 4009, 1, 0,
		0, 0, 4009, 619, 1, 0, 0, 0, 4010, 4018, 5, 140, 0, 0, 4011, 4013, 5, 246,
		0, 0, 4012, 4014, 5, 475, 0, 0, 4013, 4012, 1, 0, 0, 0, 4013, 4014, 1,
		0, 0, 0, 4014, 4019, 1, 0, 0, 0, 4015, 4016, 5, 232, 0, 0, 4016, 4019,
		5, 475, 0, 0, 4017, 4019, 5, 334, 0, 0, 4018, 4011, 1, 0, 0, 0, 4018, 4015,
		1, 0, 0, 0, 4018, 4017, 1, 0, 0, 0, 4019, 4020, 1, 0, 0, 0, 4020, 4022,
		3, 1120, 560, 0, 4021, 4023, 5, 514, 0, 0, 4022, 4021, 1, 0, 0, 0, 4022,
		4023, 1, 0, 0, 0, 4023, 4024, 1, 0, 0, 0, 4024, 4027, 5, 259, 0, 0, 4025,
		4028, 3, 1074, 537, 0, 4026, 4028, 3, 1172, 586, 0, 4027, 4025, 1, 0, 0,
		0, 4027, 4026, 1, 0, 0, 0, 4028, 621, 1, 0, 0, 0, 4029, 4031, 5, 142, 0,
		0, 4030, 4032, 3, 624, 312, 0, 4031, 4030, 1, 0, 0, 0, 4032, 4033, 1, 0,
		0, 0, 4033, 4031, 1, 0, 0, 0, 4033, 4034, 1, 0, 0, 0, 4034, 4036, 1, 0,
		0, 0, 4035, 4037, 3, 626, 313, 0, 4036, 4035, 1, 0, 0, 0, 4036, 4037, 1,
		0, 0, 0, 4037, 4039, 1, 0, 0, 0, 4038, 4040, 3, 628, 314, 0, 4039, 4038,
		1, 0, 0, 0, 4039, 4040, 1, 0, 0, 0, 4040, 4042, 1, 0, 0, 0, 4041, 4043,
		3, 630, 315, 0, 4042, 4041, 1, 0, 0, 0, 4042, 4043, 1, 0, 0, 0, 4043, 623,
		1, 0, 0, 0, 4044, 4047, 3, 1074, 537, 0, 4045, 4047, 3, 1172, 586, 0, 4046,
		4044, 1, 0, 0, 0, 4046, 4045, 1, 0, 0, 0, 4047, 625, 1, 0, 0, 0, 4048,
		4051, 5, 30, 0, 0, 4049, 4052, 3, 1074, 537, 0, 4050, 4052, 3, 1172, 586,
		0, 4051, 4049, 1, 0, 0, 0, 4051, 4050, 1, 0, 0, 0, 4052, 627, 1, 0, 0,
		0, 4053, 4056, 5, 503, 0, 0, 4054, 4057, 3, 1146, 573, 0, 4055, 4057, 3,
		1132, 566, 0, 4056, 4054, 1, 0, 0, 0, 4056, 4055, 1, 0, 0, 0, 4057, 629,
		1, 0, 0, 0, 4058, 4060, 5, 514, 0, 0, 4059, 4058, 1, 0, 0, 0, 4059, 4060,
		1, 0, 0, 0, 4060, 4061, 1, 0, 0, 0, 4061, 4062, 5, 310, 0, 0, 4062, 4063,
		5, 6, 0, 0, 4063, 631, 1, 0, 0, 0, 4064, 4067, 5, 144, 0, 0, 4065, 4068,
		3, 1074, 537, 0, 4066, 4068, 3, 1172, 586, 0, 4067, 4065, 1, 0, 0, 0, 4067,
		4066, 1, 0, 0, 0, 4068, 4072, 1, 0, 0, 0, 4069, 4073, 3, 634, 317, 0, 4070,
		4073, 3, 636, 318, 0, 4071, 4073, 3, 638, 319, 0, 4072, 4069, 1, 0, 0,
		0, 4072, 4070, 1, 0, 0, 0, 4072, 4071, 1, 0, 0, 0, 4073, 4075, 1, 0, 0,
		0, 4074, 4076, 3, 646, 323, 0, 4075, 4074, 1, 0, 0, 0, 4075, 4076, 1, 0,
		0, 0, 4076, 4078, 1, 0, 0, 0, 4077, 4079, 3, 1024, 512, 0, 4078, 4077,
		1, 0, 0, 0, 4078, 4079, 1, 0, 0, 0, 4079, 4081, 1, 0, 0, 0, 4080, 4082,
		3, 1026, 513, 0, 4081, 4080, 1, 0, 0, 0, 4081, 4082, 1, 0, 0, 0, 4082,
		4084, 1, 0, 0, 0, 4083, 4085, 5, 164, 0, 0, 4084, 4083, 1, 0, 0, 0, 4084,
		4085, 1, 0, 0, 0, 4085, 633, 1, 0, 0, 0, 4086, 4088, 5, 251, 0, 0, 4087,
		4089, 3, 642, 321, 0, 4088, 4087, 1, 0, 0, 0, 4089, 4090, 1, 0, 0, 0, 4090,
		4088, 1, 0, 0, 0, 4090, 4091, 1, 0, 0, 0, 4091, 635, 1, 0, 0, 0, 4092,
		4095, 5, 251, 0, 0, 4093, 4096, 3, 1074, 537, 0, 4094, 4096, 3, 1172, 586,
		0, 4095, 4093, 1, 0, 0, 0, 4095, 4094, 1, 0, 0, 0, 4096, 4098, 1, 0, 0,
		0, 4097, 4099, 3, 640, 320, 0, 4098, 4097, 1, 0, 0, 0, 4098, 4099, 1, 0,
		0, 0, 4099, 637, 1, 0, 0, 0, 4100, 4103, 5, 49, 0, 0, 4101, 4104, 3, 1074,
		537, 0, 4102, 4104, 3, 1172, 586, 0, 4103, 4101, 1, 0, 0, 0, 4103, 4102,
		1, 0, 0, 0, 4104, 4106, 1, 0, 0, 0, 4105, 4107, 3, 640, 320, 0, 4106, 4105,
		1, 0, 0, 0, 4106, 4107, 1, 0, 0, 0, 4107, 639, 1, 0, 0, 0, 4108, 4110,
		5, 222, 0, 0, 4109, 4111, 3, 644, 322, 0, 4110, 4109, 1, 0, 0, 0, 4111,
		4112, 1, 0, 0, 0, 4112, 4110, 1, 0, 0, 0, 4112, 4113, 1, 0, 0, 0, 4113,
		641, 1, 0, 0, 0, 4114, 4116, 3, 1074, 537, 0, 4115, 4117, 5, 412, 0, 0,
		4116, 4115, 1, 0, 0, 0, 4116, 4117, 1, 0, 0, 0, 4117, 643, 1, 0, 0, 0,
		4118, 4120, 3, 1074, 537, 0, 4119, 4121, 5, 412, 0, 0, 4120, 4119, 1, 0,
		0, 0, 4120, 4121, 1, 0, 0, 0, 4121, 645, 1, 0, 0, 0, 4122, 4123, 5, 388,
		0, 0, 4123, 4124, 3, 1074, 537, 0, 4124, 647, 1, 0, 0, 0, 4125, 4133, 5,
		157, 0, 0, 4126, 4128, 5, 246, 0, 0, 4127, 4129, 5, 475, 0, 0, 4128, 4127,
		1, 0, 0, 0, 4128, 4129, 1, 0, 0, 0, 4129, 4134, 1, 0, 0, 0, 4130, 4131,
		5, 232, 0, 0, 4131, 4134, 5, 475, 0, 0, 4132, 4134, 5, 334, 0, 0, 4133,
		4126, 1, 0, 0, 0, 4133, 4130, 1, 0, 0, 0, 4133, 4132, 1, 0, 0, 0, 4134,
		4135, 1, 0, 0, 0, 4135, 4137, 3, 1120, 560, 0, 4136, 4138, 5, 514, 0, 0,
		4137, 4136, 1, 0, 0, 0, 4137, 4138, 1, 0, 0, 0, 4138, 4139, 1, 0, 0, 0,
		4139, 4142, 5, 259, 0, 0, 4140, 4143, 3, 1172, 586, 0, 4141, 4143, 3, 1074,
		537, 0, 4142, 4140, 1, 0, 0, 0, 4142, 4141, 1, 0, 0, 0, 4143, 649, 1, 0,
		0, 0, 4144, 4145, 5, 182, 0, 0, 4145, 4152, 3, 1172, 586, 0, 4146, 4148,
		5, 506, 0, 0, 4147, 4149, 3, 1074, 537, 0, 4148, 4147, 1, 0, 0, 0, 4149,
		4150, 1, 0, 0, 0, 4150, 4148, 1, 0, 0, 0, 4150, 4151, 1, 0, 0, 0, 4151,
		4153, 1, 0, 0, 0, 4152, 4146, 1, 0, 0, 0, 4152, 4153, 1, 0, 0, 0, 4153,
		651, 1, 0, 0, 0, 4154, 4155, 5, 193, 0, 0, 4155, 4159, 3, 654, 327, 0,
		4156, 4158, 3, 656, 328, 0, 4157, 4156, 1, 0, 0, 0, 4158, 4161, 1, 0, 0,
		0, 4159, 4157, 1, 0, 0, 0, 4159, 4160, 1, 0, 0, 0, 4160, 4163, 1, 0, 0,
		0, 4161, 4159, 1, 0, 0, 0, 4162, 4164, 3, 658, 329, 0, 4163, 4162, 1, 0,
		0, 0, 4164, 4165, 1, 0, 0, 0, 4165, 4163, 1, 0, 0, 0, 4165, 4166, 1, 0,
		0, 0, 4166, 4168, 1, 0, 0, 0, 4167, 4169, 3, 668, 334, 0, 4168, 4167, 1,
		0, 0, 0, 4168, 4169, 1, 0, 0, 0, 4169, 4171, 1, 0, 0, 0, 4170, 4172, 5,
		165, 0, 0, 4171, 4170, 1, 0, 0, 0, 4171, 4172, 1, 0, 0, 0, 4172, 653, 1,
		0, 0, 0, 4173, 4178, 3, 1074, 537, 0, 4174, 4178, 3, 1172, 586, 0, 4175,
		4178, 3, 1032, 516, 0, 4176, 4178, 3, 1046, 523, 0, 4177, 4173, 1, 0, 0,
		0, 4177, 4174, 1, 0, 0, 0, 4177, 4175, 1, 0, 0, 0, 4177, 4176, 1, 0, 0,
		0, 4178, 655, 1, 0, 0, 0, 4179, 4180, 5, 16, 0, 0, 4180, 4181, 3, 654,
		327, 0, 4181, 657, 1, 0, 0, 0, 4182, 4184, 3, 660, 330, 0, 4183, 4182,
		1, 0, 0, 0, 4184, 4185, 1, 0, 0, 0, 4185, 4183, 1, 0, 0, 0, 4185, 4186,
		1, 0, 0, 0, 4186, 4190, 1, 0, 0, 0, 4187, 4189, 3, 536, 268, 0, 4188, 4187,
		1, 0, 0, 0, 4189, 4192, 1, 0, 0, 0, 4190, 4188, 1, 0, 0, 0, 4190, 4191,
		1, 0, 0, 0, 4191, 659, 1, 0, 0, 0, 4192, 4190, 1, 0, 0, 0, 4193, 4194,
		5, 512, 0, 0, 4194, 4198, 3, 662, 331, 0, 4195, 4197, 3, 666, 333, 0, 4196,
		4195, 1, 0, 0, 0, 4197, 4200, 1, 0, 0, 0, 4198, 4196, 1, 0, 0, 0, 4198,
		4199, 1, 0, 0, 0, 4199, 661, 1, 0, 0, 0, 4200, 4198, 1, 0, 0, 0, 4201,
		4212, 5, 20, 0, 0, 4202, 4204, 5, 312, 0, 0, 4203, 4202, 1, 0, 0, 0, 4203,
		4204, 1, 0, 0, 0, 4204, 4205, 1, 0, 0, 0, 4205, 4207, 3, 670, 335, 0, 4206,
		4208, 3, 664, 332, 0, 4207, 4206, 1, 0, 0, 0, 4207, 4208, 1, 0, 0, 0, 4208,
		4212, 1, 0, 0, 0, 4209, 4212, 3, 1046, 523, 0, 4210, 4212, 3, 1174, 587,
		0, 4211, 4201, 1, 0, 0, 0, 4211, 4203, 1, 0, 0, 0, 4211, 4209, 1, 0, 0,
		0, 4211, 4210, 1, 0, 0, 0, 4212, 663, 1, 0, 0, 0, 4213, 4214, 7, 4, 0,
		0, 4214, 4215, 3, 670, 335, 0, 4215, 665, 1, 0, 0, 0, 4216, 4217, 5, 16,
		0, 0, 4217, 4218, 3, 662, 331, 0, 4218, 667, 1, 0, 0, 0, 4219, 4220, 5,
		512, 0, 0, 4220, 4224, 5, 333, 0, 0, 4221, 4223, 3, 536, 268, 0, 4222,
		4221, 1, 0, 0, 0, 4223, 4226, 1, 0, 0, 0, 4224, 4222, 1, 0, 0, 0, 4224,
		4225, 1, 0, 0, 0, 4225, 669, 1, 0, 0, 0, 4226, 4224, 1, 0, 0, 0, 4227,
		4231, 3, 1074, 537, 0, 4228, 4231, 3, 1172, 586, 0, 4229, 4231, 3, 1032,
		516, 0, 4230, 4227, 1, 0, 0, 0, 4230, 4228, 1, 0, 0, 0, 4230, 4229, 1,
		0, 0, 0, 4231, 671, 1, 0, 0, 0, 4232, 4234, 5, 559, 0, 0, 4233, 4232, 1,
		0, 0, 0, 4234, 4235, 1, 0, 0, 0, 4235, 4233, 1, 0, 0, 0, 4235, 4236, 1,
		0, 0, 0, 4236, 673, 1, 0, 0, 0, 4237, 4239, 5, 561, 0, 0, 4238, 4237, 1,
		0, 0, 0, 4239, 4240, 1, 0, 0, 0, 4240, 4238, 1, 0, 0, 0, 4240, 4241, 1,
		0, 0, 0, 4241, 675, 1, 0, 0, 0, 4242, 4244, 5, 560, 0, 0, 4243, 4242, 1,
		0, 0, 0, 4244, 4245, 1, 0, 0, 0, 4245, 4243, 1, 0, 0, 0, 4245, 4246, 1,
		0, 0, 0, 4246, 677, 1, 0, 0, 0, 4247, 4249, 5, 198, 0, 0, 4248, 4250, 5,
		303, 0, 0, 4249, 4248, 1, 0, 0, 0, 4249, 4250, 1, 0, 0, 0, 4250, 4252,
		1, 0, 0, 0, 4251, 4253, 5, 60, 0, 0, 4252, 4251, 1, 0, 0, 0, 4252, 4253,
		1, 0, 0, 0, 4253, 4255, 1, 0, 0, 0, 4254, 4256, 3, 680, 340, 0, 4255, 4254,
		1, 0, 0, 0, 4256, 4257, 1, 0, 0, 0, 4257, 4255, 1, 0, 0, 0, 4257, 4258,
		1, 0, 0, 0, 4258, 679, 1, 0, 0, 0, 4259, 4262, 3, 1074, 537, 0, 4260, 4262,
		3, 1172, 586, 0, 4261, 4259, 1, 0, 0, 0, 4261, 4260, 1, 0, 0, 0, 4262,
		681, 1, 0, 0, 0, 4263, 4265, 5, 199, 0, 0, 4264, 4266, 5, 361, 0, 0, 4265,
		4264, 1, 0, 0, 0, 4265, 4266, 1, 0, 0, 0, 4266, 683, 1, 0, 0, 0, 4267,
		4268, 5, 220, 0, 0, 4268, 4269, 3, 1156, 578, 0, 4269, 685, 1, 0, 0, 0,
		4270, 4271, 5, 221, 0, 0, 4271, 687, 1, 0, 0, 0, 4272, 4274, 5, 224, 0,
		0, 4273, 4275, 5, 489, 0, 0, 4274, 4273, 1, 0, 0, 0, 4274, 4275, 1, 0,
		0, 0, 4275, 4278, 1, 0, 0, 0, 4276, 4279, 3, 690, 345, 0, 4277, 4279, 3,
		692, 346, 0, 4278, 4276, 1, 0, 0, 0, 4278, 4277, 1, 0, 0, 0, 4279, 689,
		1, 0, 0, 0, 4280, 4281, 3, 1150, 575, 0, 4281, 691, 1, 0, 0, 0, 4282, 4296,
		5, 299, 0, 0, 4283, 4285, 3, 1150, 575, 0, 4284, 4283, 1, 0, 0, 0, 4285,
		4286, 1, 0, 0, 0, 4286, 4284, 1, 0, 0, 0, 4286, 4287, 1, 0, 0, 0, 4287,
		4293, 1, 0, 0, 0, 4288, 4290, 5, 134, 0, 0, 4289, 4291, 5, 326, 0, 0, 4290,
		4289, 1, 0, 0, 0, 4290, 4291, 1, 0, 0, 0, 4291, 4292, 1, 0, 0, 0, 4292,
		4294, 3, 1074, 537, 0, 4293, 4288, 1, 0, 0, 0, 4293, 4294, 1, 0, 0, 0,
		4294, 4296, 1, 0, 0, 0, 4295, 4282, 1, 0, 0, 0, 4295, 4284, 1, 0, 0, 0,
		4296, 693, 1, 0, 0, 0, 4297, 4298, 5, 236, 0, 0, 4298, 4299, 3, 1046, 523,
		0, 4299, 4301, 3, 696, 348, 0, 4300, 4302, 3, 698, 349, 0, 4301, 4300,
		1, 0, 0, 0, 4301, 4302, 1, 0, 0, 0, 4302, 4304, 1, 0, 0, 0, 4303, 4305,
		5, 166, 0, 0, 4304, 4303, 1, 0, 0, 0, 4304, 4305, 1, 0, 0, 0, 4305, 695,
		1, 0, 0, 0, 4306, 4308, 5, 480, 0, 0, 4307, 4306, 1, 0, 0, 0, 4307, 4308,
		1, 0, 0, 0, 4308, 4317, 1, 0, 0, 0, 4309, 4310, 5, 309, 0, 0, 4310, 4318,
		5, 426, 0, 0, 4311, 4313, 3, 536, 268, 0, 4312, 4311, 1, 0, 0, 0, 4313,
		4316, 1, 0, 0, 0, 4314, 4312, 1, 0, 0, 0, 4314, 4315, 1, 0, 0, 0, 4315,
		4318, 1, 0, 0, 0, 4316, 4314, 1, 0, 0, 0, 4317, 4309, 1, 0, 0, 0, 4317,
		4314, 1, 0, 0, 0, 4318, 697, 1, 0, 0, 0, 4319, 4328, 5, 154, 0, 0, 4320,
		4321, 5, 309, 0, 0, 4321, 4329, 5, 426, 0, 0, 4322, 4324, 3, 536, 268,
		0, 4323, 4322, 1, 0, 0, 0, 4324, 4327, 1, 0, 0, 0, 4325, 4323, 1, 0, 0,
		0, 4325, 4326, 1, 0, 0, 0, 4326, 4329, 1, 0, 0, 0, 4327, 4325, 1, 0, 0,
		0, 4328, 4320, 1, 0, 0, 0, 4328, 4325, 1, 0, 0, 0, 4329, 699, 1, 0, 0,
		0, 4330, 4332, 5, 244, 0, 0, 4331, 4333, 3, 1074, 537, 0, 4332, 4331, 1,
		0, 0, 0, 4333, 4334, 1, 0, 0, 0, 4334, 4332, 1, 0, 0, 0, 4334, 4335, 1,
		0, 0, 0, 4335, 4337, 1, 0, 0, 0, 4336, 4338, 3, 702, 351, 0, 4337, 4336,
		1, 0, 0, 0, 4337, 4338, 1, 0, 0, 0, 4338, 701, 1, 0, 0, 0, 4339, 4341,
		5, 394, 0, 0, 4340, 4342, 3, 704, 352, 0, 4341, 4340, 1, 0, 0, 0, 4342,
		4343, 1, 0, 0, 0, 4343, 4341, 1, 0, 0, 0, 4343, 4344, 1, 0, 0, 0, 4344,
		703, 1, 0, 0, 0, 4345, 4347, 7, 53, 0, 0, 4346, 4348, 5, 109, 0, 0, 4347,
		4346, 1, 0, 0, 0, 4347, 4348, 1, 0, 0, 0, 4348, 4349, 1, 0, 0, 0, 4349,
		4352, 5, 49, 0, 0, 4350, 4353, 3, 1074, 537, 0, 4351, 4353, 3, 1172, 586,
		0, 4352, 4350, 1, 0, 0, 0, 4352, 4351, 1, 0, 0, 0, 4353, 705, 1, 0, 0,
		0, 4354, 4356, 5, 245, 0, 0, 4355, 4357, 3, 1156, 578, 0, 4356, 4355, 1,
		0, 0, 0, 4357, 4358, 1, 0, 0, 0, 4358, 4356, 1, 0, 0, 0, 4358, 4359, 1,
		0, 0, 0, 4359, 707, 1, 0, 0, 0, 4360, 4361, 5, 248, 0, 0, 4361, 4366, 3,
		1074, 537, 0, 4362, 4367, 3, 710, 355, 0, 4363, 4367, 3, 712, 356, 0, 4364,
		4367, 3, 714, 357, 0, 4365, 4367, 3, 716, 358, 0, 4366, 4362, 1, 0, 0,
		0, 4366, 4363, 1, 0, 0, 0, 4366, 4364, 1, 0, 0, 0, 4366, 4365, 1, 0, 0,
		0, 4367, 709, 1, 0, 0, 0, 4368, 4370, 5, 472, 0, 0, 4369, 4371, 3, 718,
		359, 0, 4370, 4369, 1, 0, 0, 0, 4371, 4372, 1, 0, 0, 0, 4372, 4370, 1,
		0, 0, 0, 4372, 4373, 1, 0, 0, 0, 4373, 711, 1, 0, 0, 0, 4374, 4377, 5,
		394, 0, 0, 4375, 4378, 3, 722, 361, 0, 4376, 4378, 3, 726, 363, 0, 4377,
		4375, 1, 0, 0, 0, 4377, 4376, 1, 0, 0, 0, 4378, 4379, 1, 0, 0, 0, 4379,
		4377, 1, 0, 0, 0, 4379, 4380, 1, 0, 0, 0, 4380, 713, 1, 0, 0, 0, 4381,
		4383, 5, 472, 0, 0, 4382, 4384, 3, 718, 359, 0, 4383, 4382, 1, 0, 0, 0,
		4384, 4385, 1, 0, 0, 0, 4385, 4383, 1, 0, 0, 0, 4385, 4386, 1, 0, 0, 0,
		4386, 4388, 1, 0, 0, 0, 4387, 4389, 3, 712, 356, 0, 4388, 4387, 1, 0, 0,
		0, 4389, 4390, 1, 0, 0, 0, 4390, 4388, 1, 0, 0, 0, 4390, 4391, 1, 0, 0,
		0, 4391, 715, 1, 0, 0, 0, 4392, 4395, 5, 101, 0, 0, 4393, 4396, 3, 1074,
		537, 0, 4394, 4396, 3, 1172, 586, 0, 4395, 4393, 1, 0, 0, 0, 4395, 4394,
		1, 0, 0, 0, 4396, 4397, 1, 0, 0, 0, 4397, 4401, 3, 734, 367, 0, 4398, 4400,
		3, 736, 368, 0, 4399, 4398, 1, 0, 0, 0, 4400, 4403, 1, 0, 0, 0, 4401, 4399,
		1, 0, 0, 0, 4401, 4402, 1, 0, 0, 0, 4402, 717, 1, 0, 0, 0, 4403, 4401,
		1, 0, 0, 0, 4404, 4405, 3, 1074, 537, 0, 4405, 4408, 5, 212, 0, 0, 4406,
		4409, 3, 720, 360, 0, 4407, 4409, 3, 724, 362, 0, 4408, 4406, 1, 0, 0,
		0, 4408, 4407, 1, 0, 0, 0, 4409, 4410, 1, 0, 0, 0, 4410, 4408, 1, 0, 0,
		0, 4410, 4411, 1, 0, 0, 0, 4411, 719, 1, 0, 0, 0, 4412, 4416, 5, 63, 0,
		0, 4413, 4415, 3, 736, 368, 0, 4414, 4413, 1, 0, 0, 0, 4415, 4418, 1, 0,
		0, 0, 4416, 4414, 1, 0, 0, 0, 4416, 4417, 1, 0, 0, 0, 4417, 721, 1, 0,
		0, 0, 4418, 4416, 1, 0, 0, 0, 4419, 4420, 5, 63, 0, 0, 4420, 4424, 3, 732,
		366, 0, 4421, 4423, 3, 736, 368, 0, 4422, 4421, 1, 0, 0, 0, 4423, 4426,
		1, 0, 0, 0, 4424, 4422, 1, 0, 0, 0, 4424, 4425, 1, 0, 0, 0, 4425, 723,
		1, 0, 0, 0, 4426, 4424, 1, 0, 0, 0, 4427, 4429, 7, 54, 0, 0, 4428, 4430,
		3, 728, 364, 0, 4429, 4428, 1, 0, 0, 0, 4430, 4431, 1, 0, 0, 0, 4431, 4429,
		1, 0, 0, 0, 4431, 4432, 1, 0, 0, 0, 4432, 725, 1, 0, 0, 0, 4433, 4435,
		7, 55, 0, 0, 4434, 4436, 3, 730, 365, 0, 4435, 4434, 1, 0, 0, 0, 4436,
		4437, 1, 0, 0, 0, 4437, 4435, 1, 0, 0, 0, 4437, 4438, 1, 0, 0, 0, 4438,
		727, 1, 0, 0, 0, 4439, 4442, 3, 1074, 537, 0, 4440, 4442, 3, 1172, 586,
		0, 4441, 4439, 1, 0, 0, 0, 4441, 4440, 1, 0, 0, 0, 4442, 4446, 1, 0, 0,
		0, 4443, 4445, 3, 736, 368, 0, 4444, 4443, 1, 0, 0, 0, 4445, 4448, 1, 0,
		0, 0, 4446, 4444, 1, 0, 0, 0, 4446, 4447, 1, 0, 0, 0, 4447, 729, 1, 0,
		0, 0, 4448, 4446, 1, 0, 0, 0, 4449, 4452, 3, 1074, 537, 0, 4450, 4452,
		3, 1172, 586, 0, 4451, 4449, 1, 0, 0, 0, 4451, 4450, 1, 0, 0, 0, 4452,
		4453, 1, 0, 0, 0, 4453, 4457, 3, 732, 366, 0, 4454, 4456, 3, 736, 368,
		0, 4455, 4454, 1, 0, 0, 0, 4456, 4459, 1, 0, 0, 0, 4457, 4455, 1, 0, 0,
		0, 4457, 4458, 1, 0, 0, 0, 4458, 731, 1, 0, 0, 0, 4459, 4457, 1, 0, 0,
		0, 4460, 4463, 5, 49, 0, 0, 4461, 4464, 3, 1074, 537, 0, 4462, 4464, 3,
		1172, 586, 0, 4463, 4461, 1, 0, 0, 0, 4463, 4462, 1, 0, 0, 0, 4464, 733,
		1, 0, 0, 0, 4465, 4468, 5, 489, 0, 0, 4466, 4469, 3, 1074, 537, 0, 4467,
		4469, 3, 1172, 586, 0, 4468, 4466, 1, 0, 0, 0, 4468, 4467, 1, 0, 0, 0,
		4469, 735, 1, 0, 0, 0, 4470, 4472, 7, 56, 0, 0, 4471, 4473, 5, 243, 0,
		0, 4472, 4471, 1, 0, 0, 0, 4472, 4473, 1, 0, 0, 0, 4473, 4476, 1, 0, 0,
		0, 4474, 4477, 3, 1074, 537, 0, 4475, 4477, 3, 1172, 586, 0, 4476, 4474,
		1, 0, 0, 0, 4476, 4475, 1, 0, 0, 0, 4477, 737, 1, 0, 0, 0, 4478, 4479,
		5, 294, 0, 0, 4479, 4481, 3, 1134, 567, 0, 4480, 4482, 3, 740, 370, 0,
		4481, 4480, 1, 0, 0, 0, 4482, 4483, 1, 0, 0, 0, 4483, 4481, 1, 0, 0, 0,
		4483, 4484, 1, 0, 0, 0, 4484, 4486, 1, 0, 0, 0, 4485, 4487, 3, 742, 371,
		0, 4486, 4485, 1, 0, 0, 0, 4486, 4487, 1, 0, 0, 0, 4487, 4491, 1, 0, 0,
		0, 4488, 4490, 3, 748, 374, 0, 4489, 4488, 1, 0, 0, 0, 4490, 4493, 1, 0,
		0, 0, 4491, 4489, 1, 0, 0, 0, 4491, 4492, 1, 0, 0, 0, 4492, 4495, 1, 0,
		0, 0, 4493, 4491, 1, 0, 0, 0, 4494, 4496, 3, 750, 375, 0, 4495, 4494, 1,
		0, 0, 0, 4495, 4496, 1, 0, 0, 0, 4496, 4500, 1, 0, 0, 0, 4497, 4499, 3,
		754, 377, 0, 4498, 4497, 1, 0, 0, 0, 4499, 4502, 1, 0, 0, 0, 4500, 4498,
		1, 0, 0, 0, 4500, 4501, 1, 0, 0, 0, 4501, 739, 1, 0, 0, 0, 4502, 4500,
		1, 0, 0, 0, 4503, 4505, 5, 326, 0, 0, 4504, 4503, 1, 0, 0, 0, 4504, 4505,
		1, 0, 0, 0, 4505, 4506, 1, 0, 0, 0, 4506, 4508, 7, 41, 0, 0, 4507, 4509,
		5, 259, 0, 0, 4508, 4507, 1, 0, 0, 0, 4508, 4509, 1, 0, 0, 0, 4509, 4511,
		1, 0, 0, 0, 4510, 4512, 3, 1090, 545, 0, 4511, 4510, 1, 0, 0, 0, 4512,
		4513, 1, 0, 0, 0, 4513, 4511, 1, 0, 0, 0, 4513, 4514, 1, 0, 0, 0, 4514,
		741, 1, 0, 0, 0, 4515, 4517, 5, 72, 0, 0, 4516, 4515, 1, 0, 0, 0, 4516,
		4517, 1, 0, 0, 0, 4517, 4518, 1, 0, 0, 0, 4518, 4520, 5, 428, 0, 0, 4519,
		4521, 5, 254, 0, 0, 4520, 4519, 1, 0, 0, 0, 4520, 4521, 1, 0, 0, 0, 4521,
		4523, 1, 0, 0, 0, 4522, 4524, 3, 1114, 557, 0, 4523, 4522, 1, 0, 0, 0,
		4524, 4525, 1, 0, 0, 0, 4525, 4523, 1, 0, 0, 0, 4525, 4526, 1, 0, 0, 0,
		4526, 4528, 1, 0, 0, 0, 4527, 4529, 3, 744, 372, 0, 4528, 4527, 1, 0, 0,
		0, 4528, 4529, 1, 0, 0, 0, 4529, 4531, 1, 0, 0, 0, 4530, 4532, 3, 746,
		373, 0, 4531, 4530, 1, 0, 0, 0, 4531, 4532, 1, 0, 0, 0, 4532, 743, 1, 0,
		0, 0, 4533, 4535, 5, 212, 0, 0, 4534, 4533, 1, 0, 0, 0, 4534, 4535, 1,
		0, 0, 0, 4535, 4536, 1, 0, 0, 0, 4536, 4537, 5, 14, 0, 0, 4537, 4538, 5,
		254, 0, 0, 4538, 4539, 3, 1114, 557, 0, 4539, 745, 1, 0, 0, 0, 4540, 4542,
		5, 212, 0, 0, 4541, 4540, 1, 0, 0, 0, 4541, 4542, 1, 0, 0, 0, 4542, 4543,
		1, 0, 0, 0, 4543, 4545, 5, 304, 0, 0, 4544, 4546, 5, 254, 0, 0, 4545, 4544,
		1, 0, 0, 0, 4545, 4546, 1, 0, 0, 0, 4546, 4547, 1, 0, 0, 0, 4547, 4548,
		3, 1114, 557, 0, 4548, 747, 1, 0, 0, 0, 4549, 4551, 5, 506, 0, 0, 4550,
		4552, 3, 1134, 567, 0, 4551, 4550, 1, 0, 0, 0, 4552, 4553, 1, 0, 0, 0,
		4553, 4551, 1, 0, 0, 0, 4553, 4554, 1, 0, 0, 0, 4554, 749, 1, 0, 0, 0,
		4555, 4556, 5, 334, 0, 0, 4556, 4558, 5, 356, 0, 0, 4557, 4559, 5, 254,
		0, 0, 4558, 4557, 1, 0, 0, 0, 4558, 4559, 1, 0, 0, 0, 4559, 4560, 1, 0,
		0, 0, 4560, 4562, 3, 1150, 575, 0, 4561, 4563, 3, 752, 376, 0, 4562, 4561,
		1, 0, 0, 0, 4562, 4563, 1, 0, 0, 0, 4563, 751, 1, 0, 0, 0, 4564, 4565,
		7, 4, 0, 0, 4565, 4566, 3, 1150, 575, 0, 4566, 753, 1, 0, 0, 0, 4567, 4569,
		5, 222, 0, 0, 4568, 4570, 3, 756, 378, 0, 4569, 4568, 1, 0, 0, 0, 4570,
		4571, 1, 0, 0, 0, 4571, 4569, 1, 0, 0, 0, 4571, 4572, 1, 0, 0, 0, 4572,
		755, 1, 0, 0, 0, 4573, 4583, 3, 1134, 567, 0, 4574, 4584, 5, 286, 0, 0,
		4575, 4584, 5, 415, 0, 0, 4576, 4577, 5, 310, 0, 0, 4577, 4584, 5, 407,
		0, 0, 4578, 4584, 5, 106, 0, 0, 4579, 4584, 5, 387, 0, 0, 4580, 4581, 5,
		514, 0, 0, 4581, 4582, 5, 391, 0, 0, 4582, 4584, 5, 106, 0, 0, 4583, 4574,
		1, 0, 0, 0, 4583, 4575, 1, 0, 0, 0, 4583, 4576, 1, 0, 0, 0, 4583, 4578,
		1, 0, 0, 0, 4583, 4579, 1, 0, 0, 0, 4583, 4580, 1, 0, 0, 0, 4583, 4584,
		1, 0, 0, 0, 4584, 757, 1, 0, 0, 0, 4585, 4587, 5, 300, 0, 0, 4586, 4588,
		5, 9, 0, 0, 4587, 4586, 1, 0, 0, 0, 4587, 4588, 1, 0, 0, 0, 4588, 4591,
		1, 0, 0, 0, 4589, 4592, 3, 760, 380, 0, 4590, 4592, 3, 764, 382, 0, 4591,
		4589, 1, 0, 0, 0, 4591, 4590, 1, 0, 0, 0, 4592, 759, 1, 0, 0, 0, 4593,
		4594, 3, 762, 381, 0, 4594, 4596, 5, 489, 0, 0, 4595, 4597, 3, 1074, 537,
		0, 4596, 4595, 1, 0, 0, 0, 4597, 4598, 1, 0, 0, 0, 4598, 4596, 1, 0, 0,
		0, 4598, 4599, 1, 0, 0, 0, 4599, 761, 1, 0, 0, 0, 4600, 4603, 3, 1074,
		537, 0, 4601, 4603, 3, 1172, 586, 0, 4602, 4600, 1, 0, 0, 0, 4602, 4601,
		1, 0, 0, 0, 4603, 763, 1, 0, 0, 0, 4604, 4605, 7, 50, 0, 0, 4605, 4606,
		3, 766, 383, 0, 4606, 4608, 5, 489, 0, 0, 4607, 4609, 3, 1074, 537, 0,
		4608, 4607, 1, 0, 0, 0, 4609, 4610, 1, 0, 0, 0, 4610, 4608, 1, 0, 0, 0,
		4610, 4611, 1, 0, 0, 0, 4611, 765, 1, 0, 0, 0, 4612, 4613, 3, 1074, 537,
		0, 4613, 767, 1, 0, 0, 0, 4614, 4617, 5, 302, 0, 0, 4615, 4618, 3, 1074,
		537, 0, 4616, 4618, 3, 1172, 586, 0, 4617, 4615, 1, 0, 0, 0, 4617, 4616,
		1, 0, 0, 0, 4618, 4619, 1, 0, 0, 0, 4619, 4622, 5, 49, 0, 0, 4620, 4623,
		3, 770, 385, 0, 4621, 4623, 3, 774, 387, 0, 4622, 4620, 1, 0, 0, 0, 4622,
		4621, 1, 0, 0, 0, 4623, 4625, 1, 0, 0, 0, 4624, 4626, 3, 1024, 512, 0,
		4625, 4624, 1, 0, 0, 0, 4625, 4626, 1, 0, 0, 0, 4626, 4628, 1, 0, 0, 0,
		4627, 4629, 3, 1026, 513, 0, 4628, 4627, 1, 0, 0, 0, 4628, 4629, 1, 0,
		0, 0, 4629, 4631, 1, 0, 0, 0, 4630, 4632, 5, 167, 0, 0, 4631, 4630, 1,
		0, 0, 0, 4631, 4632, 1, 0, 0, 0, 4632, 769, 1, 0, 0, 0, 4633, 4635, 3,
		772, 386, 0, 4634, 4633, 1, 0, 0, 0, 4635, 4636, 1, 0, 0, 0, 4636, 4634,
		1, 0, 0, 0, 4636, 4637, 1, 0, 0, 0, 4637, 771, 1, 0, 0, 0, 4638, 4640,
		3, 1074, 537, 0, 4639, 4641, 5, 412, 0, 0, 4640, 4639, 1, 0, 0, 0, 4640,
		4641, 1, 0, 0, 0, 4641, 773, 1, 0, 0, 0, 4642, 4643, 3, 776, 388, 0, 4643,
		4645, 5, 222, 0, 0, 4644, 4646, 3, 778, 389, 0, 4645, 4644, 1, 0, 0, 0,
		4646, 4647, 1, 0, 0, 0, 4647, 4645, 1, 0, 0, 0, 4647, 4648, 1, 0, 0, 0,
		4648, 775, 1, 0, 0, 0, 4649, 4652, 3, 1074, 537, 0, 4650, 4652, 3, 1172,
		586, 0, 4651, 4649, 1, 0, 0, 0, 4651, 4650, 1, 0, 0, 0, 4652, 777, 1, 0,
		0, 0, 4653, 4655, 3, 1074, 537, 0, 4654, 4656, 5, 412, 0, 0, 4655, 4654,
		1, 0, 0, 0, 4655, 4656, 1, 0, 0, 0, 4656, 779, 1, 0, 0, 0, 4657, 4662,
		5, 327, 0, 0, 4658, 4663, 3, 782, 391, 0, 4659, 4663, 3, 786, 393, 0, 4660,
		4663, 3, 790, 395, 0, 4661, 4663, 3, 792, 396, 0, 4662, 4658, 1, 0, 0,
		0, 4662, 4659, 1, 0, 0, 0, 4662, 4660, 1, 0, 0, 0, 4662, 4661, 1, 0, 0,
		0, 4663, 4664, 1, 0, 0, 0, 4664, 4662, 1, 0, 0, 0, 4664, 4665, 1, 0, 0,
		0, 4665, 781, 1, 0, 0, 0, 4666, 4668, 5, 246, 0, 0, 4667, 4669, 3, 784,
		392, 0, 4668, 4667, 1, 0, 0, 0, 4669, 4670, 1, 0, 0, 0, 4670, 4668, 1,
		0, 0, 0, 4670, 4671, 1, 0, 0, 0, 4671, 783, 1, 0, 0, 0, 4672, 4679, 3,
		1134, 567, 0, 4673, 4680, 5, 406, 0, 0, 4674, 4676, 5, 514, 0, 0, 4675,
		4674, 1, 0, 0, 0, 4675, 4676, 1, 0, 0, 0, 4676, 4677, 1, 0, 0, 0, 4677,
		4678, 5, 310, 0, 0, 4678, 4680, 5, 407, 0, 0, 4679, 4673, 1, 0, 0, 0, 4679,
		4675, 1, 0, 0, 0, 4679, 4680, 1, 0, 0, 0, 4680, 785, 1, 0, 0, 0, 4681,
		4683, 5, 334, 0, 0, 4682, 4684, 3, 788, 394, 0, 4683, 4682, 1, 0, 0, 0,
		4684, 4685, 1, 0, 0, 0, 4685, 4683, 1, 0, 0, 0, 4685, 4686, 1, 0, 0, 0,
		4686, 787, 1, 0, 0, 0, 4687, 4693, 3, 1134, 567, 0, 4688, 4690, 5, 514,
		0, 0, 4689, 4688, 1, 0, 0, 0, 4689, 4690, 1, 0, 0, 0, 4690, 4691, 1, 0,
		0, 0, 4691, 4692, 5, 310, 0, 0, 4692, 4694, 5, 407, 0, 0, 4693, 4689, 1,
		0, 0, 0, 4693, 4694, 1, 0, 0, 0, 4694, 789, 1, 0, 0, 0, 4695, 4697, 5,
		232, 0, 0, 4696, 4698, 3, 1134, 567, 0, 4697, 4696, 1, 0, 0, 0, 4698, 4699,
		1, 0, 0, 0, 4699, 4697, 1, 0, 0, 0, 4699, 4700, 1, 0, 0, 0, 4700, 791,
		1, 0, 0, 0, 4701, 4703, 5, 201, 0, 0, 4702, 4704, 3, 1134, 567, 0, 4703,
		4702, 1, 0, 0, 0, 4704, 4705, 1, 0, 0, 0, 4705, 4703, 1, 0, 0, 0, 4705,
		4706, 1, 0, 0, 0, 4706, 793, 1, 0, 0, 0, 4707, 4710, 5, 343, 0, 0, 4708,
		4711, 3, 796, 398, 0, 4709, 4711, 3, 798, 399, 0, 4710, 4708, 1, 0, 0,
		0, 4710, 4709, 1, 0, 0, 0, 4711, 795, 1, 0, 0, 0, 4712, 4714, 3, 800, 400,
		0, 4713, 4712, 1, 0, 0, 0, 4713, 4714, 1, 0, 0, 0, 4714, 4718, 1, 0, 0,
		0, 4715, 4717, 3, 536, 268, 0, 4716, 4715, 1, 0, 0, 0, 4717, 4720, 1, 0,
		0, 0, 4718, 4716, 1, 0, 0, 0, 4718, 4719, 1, 0, 0, 0, 4719, 4721, 1, 0,
		0, 0, 4720, 4718, 1, 0, 0, 0, 4721, 4722, 5, 169, 0, 0, 4722, 797, 1, 0,
		0, 0, 4723, 4726, 3, 1150, 575, 0, 4724, 4725, 7, 4, 0, 0, 4725, 4727,
		3, 1150, 575, 0, 4726, 4724, 1, 0, 0, 0, 4726, 4727, 1, 0, 0, 0, 4727,
		4729, 1, 0, 0, 0, 4728, 4730, 3, 800, 400, 0, 4729, 4728, 1, 0, 0, 0, 4729,
		4730, 1, 0, 0, 0, 4730, 799, 1, 0, 0, 0, 4731, 4735, 3, 802, 401, 0, 4732,
		4735, 3, 804, 402, 0, 4733, 4735, 3, 806, 403, 0, 4734, 4731, 1, 0, 0,
		0, 4734, 4732, 1, 0, 0, 0, 4734, 4733, 1, 0, 0, 0, 4735, 801, 1, 0, 0,
		0, 4736, 4739, 3, 1074, 537, 0, 4737, 4739, 3, 1178, 589, 0, 4738, 4736,
		1, 0, 0, 0, 4738, 4737, 1, 0, 0, 0, 4739, 4740, 1, 0, 0, 0, 4740, 4741,
		5, 487, 0, 0, 4741, 803, 1, 0, 0, 0, 4742, 4744, 3, 818, 409, 0, 4743,
		4742, 1, 0, 0, 0, 4743, 4744, 1, 0, 0, 0, 4744, 4745, 1, 0, 0, 0, 4745,
		4746, 5, 501, 0, 0, 4746, 4747, 3, 1046, 523, 0, 4747, 805, 1, 0, 0, 0,
		4748, 4749, 3, 818, 409, 0, 4749, 4750, 3, 808, 404, 0, 4750, 4756, 1,
		0, 0, 0, 4751, 4753, 3, 808, 404, 0, 4752, 4754, 3, 818, 409, 0, 4753,
		4752, 1, 0, 0, 0, 4753, 4754, 1, 0, 0, 0, 4754, 4756, 1, 0, 0, 0, 4755,
		4748, 1, 0, 0, 0, 4755, 4751, 1, 0, 0, 0, 4756, 807, 1, 0, 0, 0, 4757,
		4758, 5, 509, 0, 0, 4758, 4762, 3, 810, 405, 0, 4759, 4761, 3, 812, 406,
		0, 4760, 4759, 1, 0, 0, 0, 4761, 4764, 1, 0, 0, 0, 4762, 4760, 1, 0, 0,
		0, 4762, 4763, 1, 0, 0, 0, 4763, 809, 1, 0, 0, 0, 4764, 4762, 1, 0, 0,
		0, 4765, 4768, 3, 1074, 537, 0, 4766, 4768, 3, 1172, 586, 0, 4767, 4765,
		1, 0, 0, 0, 4767, 4766, 1, 0, 0, 0, 4768, 4769, 1, 0, 0, 0, 4769, 4770,
		3, 814, 407, 0, 4770, 4771, 3, 816, 408, 0, 4771, 4772, 3, 804, 402, 0,
		4772, 811, 1, 0, 0, 0, 4773, 4774, 5, 7, 0, 0, 4774, 4775, 3, 810, 405,
		0, 4775, 813, 1, 0, 0, 0, 4776, 4780, 5, 215, 0, 0, 4777, 4781, 3, 1074,
		537, 0, 4778, 4781, 3, 1172, 586, 0, 4779, 4781, 3, 1032, 516, 0, 4780,
		4777, 1, 0, 0, 0, 4780, 4778, 1, 0, 0, 0, 4780, 4779, 1, 0, 0, 0, 4781,
		815, 1, 0, 0, 0, 4782, 4786, 5, 49, 0, 0, 4783, 4787, 3, 1074, 537, 0,
		4784, 4787, 3, 1172, 586, 0, 4785, 4787, 3, 1032, 516, 0, 4786, 4783, 1,
		0, 0, 0, 4786, 4784, 1, 0, 0, 0, 4786, 4785, 1, 0, 0, 0, 4787, 817, 1,
		0, 0, 0, 4788, 4790, 5, 514, 0, 0, 4789, 4788, 1, 0, 0, 0, 4789, 4790,
		1, 0, 0, 0, 4790, 4791, 1, 0, 0, 0, 4791, 4792, 5, 477, 0, 0, 4792, 4793,
		7, 56, 0, 0, 4793, 819, 1, 0, 0, 0, 4794, 4796, 5, 365, 0, 0, 4795, 4797,
		3, 1120, 560, 0, 4796, 4795, 1, 0, 0, 0, 4797, 4798, 1, 0, 0, 0, 4798,
		4796, 1, 0, 0, 0, 4798, 4799, 1, 0, 0, 0, 4799, 821, 1, 0, 0, 0, 4800,
		4801, 5, 374, 0, 0, 4801, 4803, 3, 1134, 567, 0, 4802, 4804, 5, 309, 0,
		0, 4803, 4802, 1, 0, 0, 0, 4803, 4804, 1, 0, 0, 0, 4804, 4806, 1, 0, 0,
		0, 4805, 4807, 5, 377, 0, 0, 4806, 4805, 1, 0, 0, 0, 4806, 4807, 1, 0,
		0, 0, 4807, 4809, 1, 0, 0, 0, 4808, 4810, 3, 824, 412, 0, 4809, 4808, 1,
		0, 0, 0, 4809, 4810, 1, 0, 0, 0, 4810, 4812, 1, 0, 0, 0, 4811, 4813, 3,
		826, 413, 0, 4812, 4811, 1, 0, 0, 0, 4812, 4813, 1, 0, 0, 0, 4813, 4815,
		1, 0, 0, 0, 4814, 4816, 3, 828, 414, 0, 4815, 4814, 1, 0, 0, 0, 4815, 4816,
		1, 0, 0, 0, 4816, 4818, 1, 0, 0, 0, 4817, 4819, 3, 1016, 508, 0, 4818,
		4817, 1, 0, 0, 0, 4818, 4819, 1, 0, 0, 0, 4819, 4821, 1, 0, 0, 0, 4820,
		4822, 3, 1018, 509, 0, 4821, 4820, 1, 0, 0, 0, 4821, 4822, 1, 0, 0, 0,
		4822, 4824, 1, 0, 0, 0, 4823, 4825, 3, 1012, 506, 0, 4824, 4823, 1, 0,
		0, 0, 4824, 4825, 1, 0, 0, 0, 4825, 4827, 1, 0, 0, 0, 4826, 4828, 3, 1014,
		507, 0, 4827, 4826, 1, 0, 0, 0, 4827, 4828, 1, 0, 0, 0, 4828, 4830, 1,
		0, 0, 0, 4829, 4831, 5, 170, 0, 0, 4830, 4829, 1, 0, 0, 0, 4830, 4831,
		1, 0, 0, 0, 4831, 823, 1, 0, 0, 0, 4832, 4833, 5, 251, 0, 0, 4833, 4834,
		3, 1074, 537, 0, 4834, 825, 1, 0, 0, 0, 4835, 4837, 5, 514, 0, 0, 4836,
		4835, 1, 0, 0, 0, 4836, 4837, 1, 0, 0, 0, 4837, 4841, 1, 0, 0, 0, 4838,
		4839, 7, 57, 0, 0, 4839, 4842, 5, 286, 0, 0, 4840, 4842, 5, 511, 0, 0,
		4841, 4838, 1, 0, 0, 0, 4841, 4840, 1, 0, 0, 0, 4842, 827, 1, 0, 0, 0,
		4843, 4845, 5, 259, 0, 0, 4844, 4846, 5, 254, 0, 0, 4845, 4844, 1, 0, 0,
		0, 4845, 4846, 1, 0, 0, 0, 4846, 4847, 1, 0, 0, 0, 4847, 4848, 3, 1090,
		545, 0, 4848, 829, 1, 0, 0, 0, 4849, 4852, 5, 375, 0, 0, 4850, 4853, 3,
		832, 416, 0, 4851, 4853, 3, 836, 418, 0, 4852, 4850, 1, 0, 0, 0, 4852,
		4851, 1, 0, 0, 0, 4853, 4855, 1, 0, 0, 0, 4854, 4856, 3, 1028, 514, 0,
		4855, 4854, 1, 0, 0, 0, 4855, 4856, 1, 0, 0, 0, 4856, 4858, 1, 0, 0, 0,
		4857, 4859, 3, 1030, 515, 0, 4858, 4857, 1, 0, 0, 0, 4858, 4859, 1, 0,
		0, 0, 4859, 4861, 1, 0, 0, 0, 4860, 4862, 5, 171, 0, 0, 4861, 4860, 1,
		0, 0, 0, 4861, 4862, 1, 0, 0, 0, 4862, 831, 1, 0, 0, 0, 4863, 4864, 3,
		1128, 564, 0, 4864, 4865, 5, 215, 0, 0, 4865, 4873, 3, 834, 417, 0, 4866,
		4872, 3, 842, 421, 0, 4867, 4872, 3, 844, 422, 0, 4868, 4872, 3, 846, 423,
		0, 4869, 4872, 3, 848, 424, 0, 4870, 4872, 3, 850, 425, 0, 4871, 4866,
		1, 0, 0, 0, 4871, 4867, 1, 0, 0, 0, 4871, 4868, 1, 0, 0, 0, 4871, 4869,
		1, 0, 0, 0, 4871, 4870, 1, 0, 0, 0, 4872, 4875, 1, 0, 0, 0, 4873, 4871,
		1, 0, 0, 0, 4873, 4874, 1, 0, 0, 0, 4874, 833, 1, 0, 0, 0, 4875, 4873,
		1, 0, 0, 0, 4876, 4877, 5, 481, 0, 0, 4877, 4883, 3, 1128, 564, 0, 4878,
		4879, 5, 263, 0, 0, 4879, 4883, 5, 481, 0, 0, 4880, 4881, 5, 20, 0, 0,
		4881, 4883, 5, 481, 0, 0, 4882, 4876, 1, 0, 0, 0, 4882, 4878, 1, 0, 0,
		0, 4882, 4880, 1, 0, 0, 0, 4883, 835, 1, 0, 0, 0, 4884, 4885, 3, 1120,
		560, 0, 4885, 4887, 7, 58, 0, 0, 4886, 4888, 5, 251, 0, 0, 4887, 4886,
		1, 0, 0, 0, 4887, 4888, 1, 0, 0, 0, 4888, 4889, 1, 0, 0, 0, 4889, 4891,
		3, 1074, 537, 0, 4890, 4892, 3, 838, 419, 0, 4891, 4890, 1, 0, 0, 0, 4891,
		4892, 1, 0, 0, 0, 4892, 4894, 1, 0, 0, 0, 4893, 4895, 3, 840, 420, 0, 4894,
		4893, 1, 0, 0, 0, 4894, 4895, 1, 0, 0, 0, 4895, 837, 1, 0, 0, 0, 4896,
		4897, 5, 310, 0, 0, 4897, 4901, 5, 109, 0, 0, 4898, 4900, 3, 536, 268,
		0, 4899, 4898, 1, 0, 0, 0, 4900, 4903, 1, 0, 0, 0, 4901, 4899, 1, 0, 0,
		0, 4901, 4902, 1, 0, 0, 0, 4902, 839, 1, 0, 0, 0, 4903, 4901, 1, 0, 0,
		0, 4904, 4905, 5, 514, 0, 0, 4905, 4909, 5, 109, 0, 0, 4906, 4908, 3, 536,
		268, 0, 4907, 4906, 1, 0, 0, 0, 4908, 4911, 1, 0, 0, 0, 4909, 4907, 1,
		0, 0, 0, 4909, 4910, 1, 0, 0, 0, 4910, 841, 1, 0, 0, 0, 4911, 4909, 1,
		0, 0, 0, 4912, 4914, 5, 39, 0, 0, 4913, 4915, 5, 485, 0, 0, 4914, 4913,
		1, 0, 0, 0, 4914, 4915, 1, 0, 0, 0, 4915, 4918, 1, 0, 0, 0, 4916, 4919,
		3, 1176, 588, 0, 4917, 4919, 3, 1074, 537, 0, 4918, 4916, 1, 0, 0, 0, 4918,
		4917, 1, 0, 0, 0, 4919, 843, 1, 0, 0, 0, 4920, 4922, 5, 514, 0, 0, 4921,
		4920, 1, 0, 0, 0, 4921, 4922, 1, 0, 0, 0, 4922, 4923, 1, 0, 0, 0, 4923,
		4924, 5, 310, 0, 0, 4924, 4925, 5, 511, 0, 0, 4925, 845, 1, 0, 0, 0, 4926,
		4928, 5, 481, 0, 0, 4927, 4929, 5, 239, 0, 0, 4928, 4927, 1, 0, 0, 0, 4928,
		4929, 1, 0, 0, 0, 4929, 4930, 1, 0, 0, 0, 4930, 4931, 3, 1128, 564, 0,
		4931, 847, 1, 0, 0, 0, 4932, 4934, 5, 439, 0, 0, 4933, 4935, 5, 239, 0,
		0, 4934, 4933, 1, 0, 0, 0, 4934, 4935, 1, 0, 0, 0, 4935, 4938, 1, 0, 0,
		0, 4936, 4939, 3, 1176, 588, 0, 4937, 4939, 3, 1074, 537, 0, 4938, 4936,
		1, 0, 0, 0, 4938, 4937, 1, 0, 0, 0, 4939, 849, 1, 0, 0, 0, 4940, 4942,
		5, 457, 0, 0, 4941, 4943, 5, 239, 0, 0, 4942, 4941, 1, 0, 0, 0, 4942, 4943,
		1, 0, 0, 0, 4943, 4944, 1, 0, 0, 0, 4944, 4945, 3, 1074, 537, 0, 4945,
		851, 1, 0, 0, 0, 4946, 4947, 5, 387, 0, 0, 4947, 4950, 3, 1154, 577, 0,
		4948, 4949, 5, 215, 0, 0, 4949, 4951, 3, 1090, 545, 0, 4950, 4948, 1, 0,
		0, 0, 4950, 4951, 1, 0, 0, 0, 4951, 853, 1, 0, 0, 0, 4952, 4953, 5, 403,
		0, 0, 4953, 4955, 3, 1134, 567, 0, 4954, 4956, 5, 377, 0, 0, 4955, 4954,
		1, 0, 0, 0, 4955, 4956, 1, 0, 0, 0, 4956, 4958, 1, 0, 0, 0, 4957, 4959,
		3, 856, 428, 0, 4958, 4957, 1, 0, 0, 0, 4958, 4959, 1, 0, 0, 0, 4959, 4960,
		1, 0, 0, 0, 4960, 4962, 3, 1012, 506, 0, 4961, 4963, 3, 1014, 507, 0, 4962,
		4961, 1, 0, 0, 0, 4962, 4963, 1, 0, 0, 0, 4963, 4965, 1, 0, 0, 0, 4964,
		4966, 5, 172, 0, 0, 4965, 4964, 1, 0, 0, 0, 4965, 4966, 1, 0, 0, 0, 4966,
		855, 1, 0, 0, 0, 4967, 4968, 5, 251, 0, 0, 4968, 4969, 3, 1090, 545, 0,
		4969, 857, 1, 0, 0, 0, 4970, 4971, 5, 408, 0, 0, 4971, 4973, 3, 1154, 577,
		0, 4972, 4974, 3, 860, 430, 0, 4973, 4972, 1, 0, 0, 0, 4973, 4974, 1, 0,
		0, 0, 4974, 4976, 1, 0, 0, 0, 4975, 4977, 3, 1016, 508, 0, 4976, 4975,
		1, 0, 0, 0, 4976, 4977, 1, 0, 0, 0, 4977, 4979, 1, 0, 0, 0, 4978, 4980,
		3, 1018, 509, 0, 4979, 4978, 1, 0, 0, 0, 4979, 4980, 1, 0, 0, 0, 4980,
		4982, 1, 0, 0, 0, 4981, 4983, 5, 173, 0, 0, 4982, 4981, 1, 0, 0, 0, 4982,
		4983, 1, 0, 0, 0, 4983, 859, 1, 0, 0, 0, 4984, 4985, 5, 215, 0, 0, 4985,
		4986, 3, 1074, 537, 0, 4986, 861, 1, 0, 0, 0, 4987, 4989, 5, 418, 0, 0,
		4988, 4990, 5, 9, 0, 0, 4989, 4988, 1, 0, 0, 0, 4989, 4990, 1, 0, 0, 0,
		4990, 4991, 1, 0, 0, 0, 4991, 4993, 3, 1090, 545, 0, 4992, 4994, 3, 864,
		432, 0, 4993, 4992, 1, 0, 0, 0, 4993, 4994, 1, 0, 0, 0, 4994, 4996, 1,
		0, 0, 0, 4995, 4997, 3, 1012, 506, 0, 4996, 4995, 1, 0, 0, 0, 4996, 4997,
		1, 0, 0, 0, 4997, 4999, 1, 0, 0, 0, 4998, 5000, 3, 866, 433, 0, 4999, 4998,
		1, 0, 0, 0, 5000, 5001, 1, 0, 0, 0, 5001, 4999, 1, 0, 0, 0, 5001, 5002,
		1, 0, 0, 0, 5002, 5004, 1, 0, 0, 0, 5003, 5005, 5, 174, 0, 0, 5004, 5003,
		1, 0, 0, 0, 5004, 5005, 1, 0, 0, 0, 5005, 863, 1, 0, 0, 0, 5006, 5007,
		5, 509, 0, 0, 5007, 5008, 3, 1090, 545, 0, 5008, 865, 1, 0, 0, 0, 5009,
		5010, 5, 512, 0, 0, 5010, 5019, 3, 1046, 523, 0, 5011, 5012, 5, 309, 0,
		0, 5012, 5020, 5, 426, 0, 0, 5013, 5015, 3, 536, 268, 0, 5014, 5013, 1,
		0, 0, 0, 5015, 5018, 1, 0, 0, 0, 5016, 5014, 1, 0, 0, 0, 5016, 5017, 1,
		0, 0, 0, 5017, 5020, 1, 0, 0, 0, 5018, 5016, 1, 0, 0, 0, 5019, 5011, 1,
		0, 0, 0, 5019, 5016, 1, 0, 0, 0, 5020, 867, 1, 0, 0, 0, 5021, 5024, 5,
		425, 0, 0, 5022, 5025, 3, 870, 435, 0, 5023, 5025, 3, 872, 436, 0, 5024,
		5022, 1, 0, 0, 0, 5024, 5023, 1, 0, 0, 0, 5025, 5027, 1, 0, 0, 0, 5026,
		5028, 3, 1028, 514, 0, 5027, 5026, 1, 0, 0, 0, 5027, 5028, 1, 0, 0, 0,
		5028, 5030, 1, 0, 0, 0, 5029, 5031, 3, 1030, 515, 0, 5030, 5029, 1, 0,
		0, 0, 5030, 5031, 1, 0, 0, 0, 5031, 869, 1, 0, 0, 0, 5032, 5035, 3, 1074,
		537, 0, 5033, 5035, 3, 1172, 586, 0, 5034, 5032, 1, 0, 0, 0, 5034, 5033,
		1, 0, 0, 0, 5035, 5037, 1, 0, 0, 0, 5036, 5038, 3, 874, 437, 0, 5037, 5036,
		1, 0, 0, 0, 5037, 5038, 1, 0, 0, 0, 5038, 5040, 1, 0, 0, 0, 5039, 5041,
		3, 876, 438, 0, 5040, 5039, 1, 0, 0, 0, 5040, 5041, 1, 0, 0, 0, 5041, 5043,
		1, 0, 0, 0, 5042, 5044, 3, 878, 439, 0, 5043, 5042, 1, 0, 0, 0, 5043, 5044,
		1, 0, 0, 0, 5044, 5046, 1, 0, 0, 0, 5045, 5047, 3, 880, 440, 0, 5046, 5045,
		1, 0, 0, 0, 5046, 5047, 1, 0, 0, 0, 5047, 871, 1, 0, 0, 0, 5048, 5049,
		5, 489, 0, 0, 5049, 5050, 7, 59, 0, 0, 5050, 5051, 3, 1074, 537, 0, 5051,
		873, 1, 0, 0, 0, 5052, 5053, 5, 215, 0, 0, 5053, 5054, 3, 1074, 537, 0,
		5054, 875, 1, 0, 0, 0, 5055, 5060, 5, 514, 0, 0, 5056, 5061, 5, 153, 0,
		0, 5057, 5061, 5, 155, 0, 0, 5058, 5061, 5, 192, 0, 0, 5059, 5061, 3, 1074,
		537, 0, 5060, 5056, 1, 0, 0, 0, 5060, 5057, 1, 0, 0, 0, 5060, 5058, 1,
		0, 0, 0, 5060, 5059, 1, 0, 0, 0, 5061, 877, 1, 0, 0, 0, 5062, 5064, 5,
		394, 0, 0, 5063, 5065, 5, 279, 0, 0, 5064, 5063, 1, 0, 0, 0, 5064, 5065,
		1, 0, 0, 0, 5065, 879, 1, 0, 0, 0, 5066, 5068, 7, 56, 0, 0, 5067, 5069,
		5, 6, 0, 0, 5068, 5067, 1, 0, 0, 0, 5068, 5069, 1, 0, 0, 0, 5069, 5073,
		1, 0, 0, 0, 5070, 5074, 3, 882, 441, 0, 5071, 5074, 3, 884, 442, 0, 5072,
		5074, 3, 886, 443, 0, 5073, 5070, 1, 0, 0, 0, 5073, 5071, 1, 0, 0, 0, 5073,
		5072, 1, 0, 0, 0, 5074, 881, 1, 0, 0, 0, 5075, 5076, 5, 340, 0, 0, 5076,
		883, 1, 0, 0, 0, 5077, 5080, 3, 1074, 537, 0, 5078, 5080, 3, 1172, 586,
		0, 5079, 5077, 1, 0, 0, 0, 5079, 5078, 1, 0, 0, 0, 5080, 5082, 1, 0, 0,
		0, 5081, 5083, 7, 33, 0, 0, 5082, 5081, 1, 0, 0, 0, 5082, 5083, 1, 0, 0,
		0, 5083, 885, 1, 0, 0, 0, 5084, 5085, 3, 1146, 573, 0, 5085, 887, 1, 0,
		0, 0, 5086, 5093, 5, 430, 0, 0, 5087, 5089, 3, 890, 445, 0, 5088, 5087,
		1, 0, 0, 0, 5089, 5090, 1, 0, 0, 0, 5090, 5088, 1, 0, 0, 0, 5090, 5091,
		1, 0, 0, 0, 5091, 5094, 1, 0, 0, 0, 5092, 5094, 3, 892, 446, 0, 5093, 5088,
		1, 0, 0, 0, 5093, 5092, 1, 0, 0, 0, 5094, 889, 1, 0, 0, 0, 5095, 5097,
		3, 894, 447, 0, 5096, 5095, 1, 0, 0, 0, 5097, 5098, 1, 0, 0, 0, 5098, 5096,
		1, 0, 0, 0, 5098, 5099, 1, 0, 0, 0, 5099, 5100, 1, 0, 0, 0, 5100, 5102,
		5, 489, 0, 0, 5101, 5103, 3, 896, 448, 0, 5102, 5101, 1, 0, 0, 0, 5103,
		5104, 1, 0, 0, 0, 5104, 5102, 1, 0, 0, 0, 5104, 5105, 1, 0, 0, 0, 5105,
		891, 1, 0, 0, 0, 5106, 5108, 3, 894, 447, 0, 5107, 5106, 1, 0, 0, 0, 5108,
		5109, 1, 0, 0, 0, 5109, 5107, 1, 0, 0, 0, 5109, 5110, 1, 0, 0, 0, 5110,
		5115, 1, 0, 0, 0, 5111, 5112, 5, 502, 0, 0, 5112, 5116, 5, 49, 0, 0, 5113,
		5114, 5, 148, 0, 0, 5114, 5116, 5, 49, 0, 0, 5115, 5111, 1, 0, 0, 0, 5115,
		5113, 1, 0, 0, 0, 5116, 5117, 1, 0, 0, 0, 5117, 5118, 3, 898, 449, 0, 5118,
		893, 1, 0, 0, 0, 5119, 5120, 3, 1074, 537, 0, 5120, 895, 1, 0, 0, 0, 5121,
		5131, 5, 326, 0, 0, 5122, 5131, 5, 324, 0, 0, 5123, 5126, 5, 182, 0, 0,
		5124, 5127, 3, 1074, 537, 0, 5125, 5127, 3, 1172, 586, 0, 5126, 5124, 1,
		0, 0, 0, 5126, 5125, 1, 0, 0, 0, 5127, 5131, 1, 0, 0, 0, 5128, 5131, 3,
		1074, 537, 0, 5129, 5131, 3, 1172, 586, 0, 5130, 5121, 1, 0, 0, 0, 5130,
		5122, 1, 0, 0, 0, 5130, 5123, 1, 0, 0, 0, 5130, 5128, 1, 0, 0, 0, 5130,
		5129, 1, 0, 0, 0, 5131, 897, 1, 0, 0, 0, 5132, 5135, 3, 1074, 537, 0, 5133,
		5135, 3, 1172, 586, 0, 5134, 5132, 1, 0, 0, 0, 5134, 5133, 1, 0, 0, 0,
		5135, 899, 1, 0, 0, 0, 5136, 5137, 5, 440, 0, 0, 5137, 5139, 3, 1134, 567,
		0, 5138, 5140, 3, 902, 451, 0, 5139, 5138, 1, 0, 0, 0, 5140, 5141, 1, 0,
		0, 0, 5141, 5139, 1, 0, 0, 0, 5141, 5142, 1, 0, 0, 0, 5142, 5144, 1, 0,
		0, 0, 5143, 5145, 3, 904, 452, 0, 5144, 5143, 1, 0, 0, 0, 5144, 5145, 1,
		0, 0, 0, 5145, 5147, 1, 0, 0, 0, 5146, 5148, 3, 906, 453, 0, 5147, 5146,
		1, 0, 0, 0, 5147, 5148, 1, 0, 0, 0, 5148, 5150, 1, 0, 0, 0, 5149, 5151,
		3, 912, 456, 0, 5150, 5149, 1, 0, 0, 0, 5150, 5151, 1, 0, 0, 0, 5151, 5155,
		1, 0, 0, 0, 5152, 5154, 3, 916, 458, 0, 5153, 5152, 1, 0, 0, 0, 5154, 5157,
		1, 0, 0, 0, 5155, 5153, 1, 0, 0, 0, 5155, 5156, 1, 0, 0, 0, 5156, 5159,
		1, 0, 0, 0, 5157, 5155, 1, 0, 0, 0, 5158, 5160, 3, 918, 459, 0, 5159, 5158,
		1, 0, 0, 0, 5159, 5160, 1, 0, 0, 0, 5160, 5164, 1, 0, 0, 0, 5161, 5163,
		3, 922, 461, 0, 5162, 5161, 1, 0, 0, 0, 5163, 5166, 1, 0, 0, 0, 5164, 5162,
		1, 0, 0, 0, 5164, 5165, 1, 0, 0, 0, 5165, 901, 1, 0, 0, 0, 5166, 5164,
		1, 0, 0, 0, 5167, 5169, 5, 326, 0, 0, 5168, 5167, 1, 0, 0, 0, 5168, 5169,
		1, 0, 0, 0, 5169, 5170, 1, 0, 0, 0, 5170, 5172, 7, 41, 0, 0, 5171, 5173,
		5, 259, 0, 0, 5172, 5171, 1, 0, 0, 0, 5172, 5173, 1, 0, 0, 0, 5173, 5175,
		1, 0, 0, 0, 5174, 5176, 3, 1090, 545, 0, 5175, 5174, 1, 0, 0, 0, 5176,
		5177, 1, 0, 0, 0, 5177, 5175, 1, 0, 0, 0, 5177, 5178, 1, 0, 0, 0, 5178,
		903, 1, 0, 0, 0, 5179, 5181, 5, 514, 0, 0, 5180, 5179, 1, 0, 0, 0, 5180,
		5181, 1, 0, 0, 0, 5181, 5182, 1, 0, 0, 0, 5182, 5184, 5, 149, 0, 0, 5183,
		5185, 5, 239, 0, 0, 5184, 5183, 1, 0, 0, 0, 5184, 5185, 1, 0, 0, 0, 5185,
		5187, 1, 0, 0, 0, 5186, 5188, 5, 330, 0, 0, 5187, 5186, 1, 0, 0, 0, 5187,
		5188, 1, 0, 0, 0, 5188, 905, 1, 0, 0, 0, 5189, 5191, 5, 72, 0, 0, 5190,
		5189, 1, 0, 0, 0, 5190, 5191, 1, 0, 0, 0, 5191, 5192, 1, 0, 0, 0, 5192,
		5194, 5, 428, 0, 0, 5193, 5195, 5, 254, 0, 0, 5194, 5193, 1, 0, 0, 0, 5194,
		5195, 1, 0, 0, 0, 5195, 5197, 1, 0, 0, 0, 5196, 5198, 3, 1114, 557, 0,
		5197, 5196, 1, 0, 0, 0, 5198, 5199, 1, 0, 0, 0, 5199, 5197, 1, 0, 0, 0,
		5199, 5200, 1, 0, 0, 0, 5200, 5202, 1, 0, 0, 0, 5201, 5203, 3, 908, 454,
		0, 5202, 5201, 1, 0, 0, 0, 5202, 5203, 1, 0, 0, 0, 5203, 5205, 1, 0, 0,
		0, 5204, 5206, 3, 910, 455, 0, 5205, 5204, 1, 0, 0, 0, 5205, 5206, 1, 0,
		0, 0, 5206, 907, 1, 0, 0, 0, 5207, 5209, 5, 212, 0, 0, 5208, 5207, 1, 0,
		0, 0, 5208, 5209, 1, 0, 0, 0, 5209, 5210, 1, 0, 0, 0, 5210, 5211, 5, 14,
		0, 0, 5211, 5212, 5, 254, 0, 0, 5212, 5213, 3, 1114, 557, 0, 5213, 909,
		1, 0, 0, 0, 5214, 5216, 5, 212, 0, 0, 5215, 5214, 1, 0, 0, 0, 5215, 5216,
		1, 0, 0, 0, 5216, 5217, 1, 0, 0, 0, 5217, 5219, 5, 304, 0, 0, 5218, 5220,
		5, 254, 0, 0, 5219, 5218, 1, 0, 0, 0, 5219, 5220, 1, 0, 0, 0, 5220, 5221,
		1, 0, 0, 0, 5221, 5222, 3, 1114, 557, 0, 5222, 911, 1, 0, 0, 0, 5223, 5224,
		5, 246, 0, 0, 5224, 5226, 5, 356, 0, 0, 5225, 5227, 5, 254, 0, 0, 5226,
		5225, 1, 0, 0, 0, 5226, 5227, 1, 0, 0, 0, 5227, 5228, 1, 0, 0, 0, 5228,
		5230, 3, 1150, 575, 0, 5229, 5231, 3, 914, 457, 0, 5230, 5229, 1, 0, 0,
		0, 5230, 5231, 1, 0, 0, 0, 5231, 913, 1, 0, 0, 0, 5232, 5233, 7, 4, 0,
		0, 5233, 5234, 3, 1150, 575, 0, 5234, 915, 1, 0, 0, 0, 5235, 5237, 5, 506,
		0, 0, 5236, 5238, 3, 1134, 567, 0, 5237, 5236, 1, 0, 0, 0, 5238, 5239,
		1, 0, 0, 0, 5239, 5237, 1, 0, 0, 0, 5239, 5240, 1, 0, 0, 0, 5240, 917,
		1, 0, 0, 0, 5241, 5242, 5, 334, 0, 0, 5242, 5244, 5, 356, 0, 0, 5243, 5245,
		5, 254, 0, 0, 5244, 5243, 1, 0, 0, 0, 5244, 5245, 1, 0, 0, 0, 5245, 5246,
		1, 0, 0, 0, 5246, 5248, 3, 1150, 575, 0, 5247, 5249, 3, 920, 460, 0, 5248,
		5247, 1, 0, 0, 0, 5248, 5249, 1, 0, 0, 0, 5249, 919, 1, 0, 0, 0, 5250,
		5251, 7, 4, 0, 0, 5251, 5252, 3, 1150, 575, 0, 5252, 921, 1, 0, 0, 0, 5253,
		5255, 5, 222, 0, 0, 5254, 5256, 3, 924, 462, 0, 5255, 5254, 1, 0, 0, 0,
		5256, 5257, 1, 0, 0, 0, 5257, 5255, 1, 0, 0, 0, 5257, 5258, 1, 0, 0, 0,
		5258, 923, 1, 0, 0, 0, 5259, 5269, 3, 1134, 567, 0, 5260, 5270, 5, 286,
		0, 0, 5261, 5270, 5, 415, 0, 0, 5262, 5263, 5, 310, 0, 0, 5263, 5270, 5,
		407, 0, 0, 5264, 5270, 5, 106, 0, 0, 5265, 5270, 5, 387, 0, 0, 5266, 5267,
		5, 514, 0, 0, 5267, 5268, 5, 391, 0, 0, 5268, 5270, 5, 106, 0, 0, 5269,
		5260, 1, 0, 0, 0, 5269, 5261, 1, 0, 0, 0, 5269, 5262, 1, 0, 0, 0, 5269,
		5264, 1, 0, 0, 0, 5269, 5265, 1, 0, 0, 0, 5269, 5266, 1, 0, 0, 0, 5269,
		5270, 1, 0, 0, 0, 5270, 925, 1, 0, 0, 0, 5271, 5272, 5, 456, 0, 0, 5272,
		5274, 3, 1134, 567, 0, 5273, 5275, 3, 928, 464, 0, 5274, 5273, 1, 0, 0,
		0, 5274, 5275, 1, 0, 0, 0, 5275, 5277, 1, 0, 0, 0, 5276, 5278, 3, 1016,
		508, 0, 5277, 5276, 1, 0, 0, 0, 5277, 5278, 1, 0, 0, 0, 5278, 5280, 1,
		0, 0, 0, 5279, 5281, 3, 1018, 509, 0, 5280, 5279, 1, 0, 0, 0, 5280, 5281,
		1, 0, 0, 0, 5281, 5283, 1, 0, 0, 0, 5282, 5284, 5, 175, 0, 0, 5283, 5282,
		1, 0, 0, 0, 5283, 5284, 1, 0, 0, 0, 5284, 927, 1, 0, 0, 0, 5285, 5287,
		5, 259, 0, 0, 5286, 5288, 5, 254, 0, 0, 5287, 5286, 1, 0, 0, 0, 5287, 5288,
		1, 0, 0, 0, 5288, 5316, 1, 0, 0, 0, 5289, 5291, 5, 186, 0, 0, 5290, 5292,
		5, 489, 0, 0, 5291, 5290, 1, 0, 0, 0, 5291, 5292, 1, 0, 0, 0, 5292, 5317,
		1, 0, 0, 0, 5293, 5317, 5, 536, 0, 0, 5294, 5296, 5, 225, 0, 0, 5295, 5297,
		5, 479, 0, 0, 5296, 5295, 1, 0, 0, 0, 5296, 5297, 1, 0, 0, 0, 5297, 5317,
		1, 0, 0, 0, 5298, 5317, 5, 544, 0, 0, 5299, 5300, 5, 312, 0, 0, 5300, 5302,
		5, 271, 0, 0, 5301, 5303, 5, 479, 0, 0, 5302, 5301, 1, 0, 0, 0, 5302, 5303,
		1, 0, 0, 0, 5303, 5317, 1, 0, 0, 0, 5304, 5305, 5, 312, 0, 0, 5305, 5317,
		5, 540, 0, 0, 5306, 5308, 5, 225, 0, 0, 5307, 5309, 5, 479, 0, 0, 5308,
		5307, 1, 0, 0, 0, 5308, 5309, 1, 0, 0, 0, 5309, 5310, 1, 0, 0, 0, 5310,
		5311, 5, 329, 0, 0, 5311, 5313, 5, 186, 0, 0, 5312, 5314, 5, 489, 0, 0,
		5313, 5312, 1, 0, 0, 0, 5313, 5314, 1, 0, 0, 0, 5314, 5317, 1, 0, 0, 0,
		5315, 5317, 5, 545, 0, 0, 5316, 5289, 1, 0, 0, 0, 5316, 5293, 1, 0, 0,
		0, 5316, 5294, 1, 0, 0, 0, 5316, 5298, 1, 0, 0, 0, 5316, 5299, 1, 0, 0,
		0, 5316, 5304, 1, 0, 0, 0, 5316, 5306, 1, 0, 0, 0, 5316, 5315, 1, 0, 0,
		0, 5317, 5318, 1, 0, 0, 0, 5318, 5319, 3, 1090, 545, 0, 5319, 929, 1, 0,
		0, 0, 5320, 5323, 5, 458, 0, 0, 5321, 5324, 5, 413, 0, 0, 5322, 5324, 3,
		1172, 586, 0, 5323, 5321, 1, 0, 0, 0, 5323, 5322, 1, 0, 0, 0, 5324, 931,
		1, 0, 0, 0, 5325, 5327, 5, 459, 0, 0, 5326, 5328, 3, 934, 467, 0, 5327,
		5326, 1, 0, 0, 0, 5328, 5329, 1, 0, 0, 0, 5329, 5327, 1, 0, 0, 0, 5329,
		5330, 1, 0, 0, 0, 5330, 5331, 1, 0, 0, 0, 5331, 5333, 3, 942, 471, 0, 5332,
		5334, 3, 944, 472, 0, 5333, 5332, 1, 0, 0, 0, 5333, 5334, 1, 0, 0, 0, 5334,
		5336, 1, 0, 0, 0, 5335, 5337, 3, 1020, 510, 0, 5336, 5335, 1, 0, 0, 0,
		5336, 5337, 1, 0, 0, 0, 5337, 5339, 1, 0, 0, 0, 5338, 5340, 3, 1022, 511,
		0, 5339, 5338, 1, 0, 0, 0, 5339, 5340, 1, 0, 0, 0, 5340, 5342, 1, 0, 0,
		0, 5341, 5343, 5, 176, 0, 0, 5342, 5341, 1, 0, 0, 0, 5342, 5343, 1, 0,
		0, 0, 5343, 933, 1, 0, 0, 0, 5344, 5346, 3, 936, 468, 0, 5345, 5344, 1,
		0, 0, 0, 5346, 5347, 1, 0, 0, 0, 5347, 5345, 1, 0, 0, 0, 5347, 5348, 1,
		0, 0, 0, 5348, 5351, 1, 0, 0, 0, 5349, 5352, 3, 938, 469, 0, 5350, 5352,
		3, 940, 470, 0, 5351, 5349, 1, 0, 0, 0, 5351, 5350, 1, 0, 0, 0, 5352, 935,
		1, 0, 0, 0, 5353, 5356, 3, 1074, 537, 0, 5354, 5356, 3, 1172, 586, 0, 5355,
		5353, 1, 0, 0, 0, 5355, 5354, 1, 0, 0, 0, 5356, 937, 1, 0, 0, 0, 5357,
		5359, 5, 132, 0, 0, 5358, 5360, 5, 49, 0, 0, 5359, 5358, 1, 0, 0, 0, 5359,
		5360, 1, 0, 0, 0, 5360, 5364, 1, 0, 0, 0, 5361, 5365, 5, 439, 0, 0, 5362,
		5365, 3, 1074, 537, 0, 5363, 5365, 3, 1172, 586, 0, 5364, 5361, 1, 0, 0,
		0, 5364, 5362, 1, 0, 0, 0, 5364, 5363, 1, 0, 0, 0, 5365, 939, 1, 0, 0,
		0, 5366, 5369, 5, 212, 0, 0, 5367, 5370, 3, 1074, 537, 0, 5368, 5370, 3,
		1172, 586, 0, 5369, 5367, 1, 0, 0, 0, 5369, 5368, 1, 0, 0, 0, 5370, 941,
		1, 0, 0, 0, 5371, 5372, 5, 251, 0, 0, 5372, 5373, 3, 1074, 537, 0, 5373,
		943, 1, 0, 0, 0, 5374, 5376, 5, 514, 0, 0, 5375, 5374, 1, 0, 0, 0, 5375,
		5376, 1, 0, 0, 0, 5376, 5377, 1, 0, 0, 0, 5377, 5378, 5, 349, 0, 0, 5378,
		5379, 3, 1090, 545, 0, 5379, 945, 1, 0, 0, 0, 5380, 5384, 5, 463, 0, 0,
		5381, 5385, 3, 948, 474, 0, 5382, 5385, 3, 950, 475, 0, 5383, 5385, 3,
		952, 476, 0, 5384, 5381, 1, 0, 0, 0, 5384, 5382, 1, 0, 0, 0, 5384, 5383,
		1, 0, 0, 0, 5385, 5387, 1, 0, 0, 0, 5386, 5388, 3, 1024, 512, 0, 5387,
		5386, 1, 0, 0, 0, 5387, 5388, 1, 0, 0, 0, 5388, 5390, 1, 0, 0, 0, 5389,
		5391, 3, 1026, 513, 0, 5390, 5389, 1, 0, 0, 0, 5390, 5391, 1, 0, 0, 0,
		5391, 5393, 1, 0, 0, 0, 5392, 5394, 5, 177, 0, 0, 5393, 5392, 1, 0, 0,
		0, 5393, 5394, 1, 0, 0, 0, 5394, 947, 1, 0, 0, 0, 5395, 5397, 3, 954, 477,
		0, 5396, 5395, 1, 0, 0, 0, 5397, 5398, 1, 0, 0, 0, 5398, 5396, 1, 0, 0,
		0, 5398, 5399, 1, 0, 0, 0, 5399, 5400, 1, 0, 0, 0, 5400, 5402, 5, 215,
		0, 0, 5401, 5403, 3, 956, 478, 0, 5402, 5401, 1, 0, 0, 0, 5403, 5404, 1,
		0, 0, 0, 5404, 5402, 1, 0, 0, 0, 5404, 5405, 1, 0, 0, 0, 5405, 949, 1,
		0, 0, 0, 5406, 5408, 3, 954, 477, 0, 5407, 5406, 1, 0, 0, 0, 5408, 5409,
		1, 0, 0, 0, 5409, 5407, 1, 0, 0, 0, 5409, 5410, 1, 0, 0, 0, 5410, 5411,
		1, 0, 0, 0, 5411, 5412, 5, 215, 0, 0, 5412, 5413, 3, 958, 479, 0, 5413,
		5415, 5, 222, 0, 0, 5414, 5416, 3, 960, 480, 0, 5415, 5414, 1, 0, 0, 0,
		5416, 5417, 1, 0, 0, 0, 5417, 5415, 1, 0, 0, 0, 5417, 5418, 1, 0, 0, 0,
		5418, 951, 1, 0, 0, 0, 5419, 5420, 7, 50, 0, 0, 5420, 5421, 3, 1090, 545,
		0, 5421, 5422, 5, 215, 0, 0, 5422, 5423, 3, 962, 481, 0, 5423, 953, 1,
		0, 0, 0, 5424, 5427, 3, 1074, 537, 0, 5425, 5427, 3, 1172, 586, 0, 5426,
		5424, 1, 0, 0, 0, 5426, 5425, 1, 0, 0, 0, 5427, 955, 1, 0, 0, 0, 5428,
		5430, 3, 1074, 537, 0, 5429, 5431, 5, 412, 0, 0, 5430, 5429, 1, 0, 0, 0,
		5430, 5431, 1, 0, 0, 0, 5431, 957, 1, 0, 0, 0, 5432, 5435, 3, 1074, 537,
		0, 5433, 5435, 3, 1172, 586, 0, 5434, 5432, 1, 0, 0, 0, 5434, 5433, 1,
		0, 0, 0, 5435, 959, 1, 0, 0, 0, 5436, 5438, 3, 1074, 537, 0, 5437, 5439,
		5, 412, 0, 0, 5438, 5437, 1, 0, 0, 0, 5438, 5439, 1, 0, 0, 0, 5439, 961,
		1, 0, 0, 0, 5440, 5442, 3, 1090, 545, 0, 5441, 5443, 5, 412, 0, 0, 5442,
		5441, 1, 0, 0, 0, 5442, 5443, 1, 0, 0, 0, 5443, 963, 1, 0, 0, 0, 5444,
		5445, 5, 476, 0, 0, 5445, 5446, 3, 1156, 578, 0, 5446, 965, 1, 0, 0, 0,
		5447, 5448, 5, 500, 0, 0, 5448, 5449, 3, 968, 484, 0, 5449, 5451, 3, 974,
		487, 0, 5450, 5452, 3, 982, 491, 0, 5451, 5450, 1, 0, 0, 0, 5451, 5452,
		1, 0, 0, 0, 5452, 5454, 1, 0, 0, 0, 5453, 5455, 3, 984, 492, 0, 5454, 5453,
		1, 0, 0, 0, 5454, 5455, 1, 0, 0, 0, 5455, 5457, 1, 0, 0, 0, 5456, 5458,
		3, 1020, 510, 0, 5457, 5456, 1, 0, 0, 0, 5457, 5458, 1, 0, 0, 0, 5458,
		5460, 1, 0, 0, 0, 5459, 5461, 3, 1022, 511, 0, 5460, 5459, 1, 0, 0, 0,
		5460, 5461, 1, 0, 0, 0, 5461, 5463, 1, 0, 0, 0, 5462, 5464, 5, 178, 0,
		0, 5463, 5462, 1, 0, 0, 0, 5463, 5464, 1, 0, 0, 0, 5464, 967, 1, 0, 0,
		0, 5465, 5473, 3, 1074, 537, 0, 5466, 5470, 3, 970, 485, 0, 5467, 5469,
		3, 972, 486, 0, 5468, 5467, 1, 0, 0, 0, 5469, 5472, 1, 0, 0, 0, 5470, 5468,
		1, 0, 0, 0, 5470, 5471, 1, 0, 0, 0, 5471, 5474, 1, 0, 0, 0, 5472, 5470,
		1, 0, 0, 0, 5473, 5466, 1, 0, 0, 0, 5473, 5474, 1, 0, 0, 0, 5474, 969,
		1, 0, 0, 0, 5475, 5477, 5, 132, 0, 0, 5476, 5478, 5, 49, 0, 0, 5477, 5476,
		1, 0, 0, 0, 5477, 5478, 1, 0, 0, 0, 5478, 5480, 1, 0, 0, 0, 5479, 5481,
		5, 9, 0, 0, 5480, 5479, 1, 0, 0, 0, 5480, 5481, 1, 0, 0, 0, 5481, 5484,
		1, 0, 0, 0, 5482, 5485, 3, 1074, 537, 0, 5483, 5485, 3, 1172, 586, 0, 5484,
		5482, 1, 0, 0, 0, 5484, 5483, 1, 0, 0, 0, 5485, 971, 1, 0, 0, 0, 5486,
		5488, 5, 329, 0, 0, 5487, 5489, 5, 9, 0, 0, 5488, 5487, 1, 0, 0, 0, 5488,
		5489, 1, 0, 0, 0, 5489, 5492, 1, 0, 0, 0, 5490, 5493, 3, 1074, 537, 0,
		5491, 5493, 3, 1172, 586, 0, 5492, 5490, 1, 0, 0, 0, 5492, 5491, 1, 0,
		0, 0, 5493, 973, 1, 0, 0, 0, 5494, 5496, 5, 251, 0, 0, 5495, 5497, 3, 976,
		488, 0, 5496, 5495, 1, 0, 0, 0, 5497, 5498, 1, 0, 0, 0, 5498, 5496, 1,
		0, 0, 0, 5498, 5499, 1, 0, 0, 0, 5499, 975, 1, 0, 0, 0, 5500, 5502, 3,
		1074, 537, 0, 5501, 5503, 3, 978, 489, 0, 5502, 5501, 1, 0, 0, 0, 5502,
		5503, 1, 0, 0, 0, 5503, 5505, 1, 0, 0, 0, 5504, 5506, 3, 980, 490, 0, 5505,
		5504, 1, 0, 0, 0, 5505, 5506, 1, 0, 0, 0, 5506, 977, 1, 0, 0, 0, 5507,
		5509, 5, 133, 0, 0, 5508, 5510, 5, 239, 0, 0, 5509, 5508, 1, 0, 0, 0, 5509,
		5510, 1, 0, 0, 0, 5510, 5511, 1, 0, 0, 0, 5511, 5512, 3, 1074, 537, 0,
		5512, 979, 1, 0, 0, 0, 5513, 5515, 5, 105, 0, 0, 5514, 5516, 5, 239, 0,
		0, 5515, 5514, 1, 0, 0, 0, 5515, 5516, 1, 0, 0, 0, 5516, 5517, 1, 0, 0,
		0, 5517, 5518, 3, 1074, 537, 0, 5518, 981, 1, 0, 0, 0, 5519, 5521, 5, 514,
		0, 0, 5520, 5519, 1, 0, 0, 0, 5520, 5521, 1, 0, 0, 0, 5521, 5522, 1, 0,
		0, 0, 5522, 5523, 5, 349, 0, 0, 5523, 5524, 3, 1090, 545, 0, 5524, 983,
		1, 0, 0, 0, 5525, 5527, 5, 472, 0, 0, 5526, 5528, 5, 239, 0, 0, 5527, 5526,
		1, 0, 0, 0, 5527, 5528, 1, 0, 0, 0, 5528, 5529, 1, 0, 0, 0, 5529, 5530,
		3, 1090, 545, 0, 5530, 985, 1, 0, 0, 0, 5531, 5534, 5, 505, 0, 0, 5532,
		5535, 3, 988, 494, 0, 5533, 5535, 3, 992, 496, 0, 5534, 5532, 1, 0, 0,
		0, 5534, 5533, 1, 0, 0, 0, 5535, 987, 1, 0, 0, 0, 5536, 5538, 5, 223, 0,
		0, 5537, 5536, 1, 0, 0, 0, 5537, 5538, 1, 0, 0, 0, 5538, 5539, 1, 0, 0,
		0, 5539, 5541, 5, 7, 0, 0, 5540, 5542, 5, 453, 0, 0, 5541, 5540, 1, 0,
		0, 0, 5541, 5542, 1, 0, 0, 0, 5542, 5543, 1, 0, 0, 0, 5543, 5544, 7, 60,
		0, 0, 5544, 5546, 5, 356, 0, 0, 5545, 5547, 5, 326, 0, 0, 5546, 5545, 1,
		0, 0, 0, 5546, 5547, 1, 0, 0, 0, 5547, 5548, 1, 0, 0, 0, 5548, 5549, 3,
		990, 495, 0, 5549, 989, 1, 0, 0, 0, 5550, 5560, 5, 246, 0, 0, 5551, 5560,
		5, 334, 0, 0, 5552, 5560, 5, 232, 0, 0, 5553, 5560, 5, 201, 0, 0, 5554,
		5556, 3, 1134, 567, 0, 5555, 5554, 1, 0, 0, 0, 5556, 5557, 1, 0, 0, 0,
		5557, 5555, 1, 0, 0, 0, 5557, 5558, 1, 0, 0, 0, 5558, 5560, 1, 0, 0, 0,
		5559, 5550, 1, 0, 0, 0, 5559, 5551, 1, 0, 0, 0, 5559, 5552, 1, 0, 0, 0,
		5559, 5553, 1, 0, 0, 0, 5559, 5555, 1, 0, 0, 0, 5560, 991, 1, 0, 0, 0,
		5561, 5563, 5, 212, 0, 0, 5562, 5561, 1, 0, 0, 0, 5562, 5563, 1, 0, 0,
		0, 5563, 5564, 1, 0, 0, 0, 5564, 5566, 5, 125, 0, 0, 5565, 5567, 5, 326,
		0, 0, 5566, 5565, 1, 0, 0, 0, 5566, 5567, 1, 0, 0, 0, 5567, 5569, 1, 0,
		0, 0, 5568, 5570, 3, 994, 497, 0, 5569, 5568, 1, 0, 0, 0, 5570, 5571, 1,
		0, 0, 0, 5571, 5569, 1, 0, 0, 0, 5571, 5572, 1, 0, 0, 0, 5572, 993, 1,
		0, 0, 0, 5573, 5574, 5, 9, 0, 0, 5574, 5586, 5, 358, 0, 0, 5575, 5577,
		5, 9, 0, 0, 5576, 5578, 5, 385, 0, 0, 5577, 5576, 1, 0, 0, 0, 5577, 5578,
		1, 0, 0, 0, 5578, 5580, 1, 0, 0, 0, 5579, 5581, 5, 323, 0, 0, 5580, 5579,
		1, 0, 0, 0, 5580, 5581, 1, 0, 0, 0, 5581, 5582, 1, 0, 0, 0, 5582, 5586,
		3, 1074, 537, 0, 5583, 5586, 3, 1150, 575, 0, 5584, 5586, 3, 1134, 567,
		0, 5585, 5573, 1, 0, 0, 0, 5585, 5575, 1, 0, 0, 0, 5585, 5583, 1, 0, 0,
		0, 5585, 5584, 1, 0, 0, 0, 5586, 995, 1, 0, 0, 0, 5587, 5588, 5, 517, 0,
		0, 5588, 5590, 3, 1154, 577, 0, 5589, 5591, 3, 998, 499, 0, 5590, 5589,
		1, 0, 0, 0, 5590, 5591, 1, 0, 0, 0, 5591, 5593, 1, 0, 0, 0, 5592, 5594,
		3, 1000, 500, 0, 5593, 5592, 1, 0, 0, 0, 5593, 5594, 1, 0, 0, 0, 5594,
		5596, 1, 0, 0, 0, 5595, 5597, 3, 1008, 504, 0, 5596, 5595, 1, 0, 0, 0,
		5596, 5597, 1, 0, 0, 0, 5597, 5599, 1, 0, 0, 0, 5598, 5600, 3, 1010, 505,
		0, 5599, 5598, 1, 0, 0, 0, 5599, 5600, 1, 0, 0, 0, 5600, 5602, 1, 0, 0,
		0, 5601, 5603, 3, 1016, 508, 0, 5602, 5601, 1, 0, 0, 0, 5602, 5603, 1,
		0, 0, 0, 5603, 5605, 1, 0, 0, 0, 5604, 5606, 3, 1018, 509, 0, 5605, 5604,
		1, 0, 0, 0, 5605, 5606, 1, 0, 0, 0, 5606, 5608, 1, 0, 0, 0, 5607, 5609,
		5, 179, 0, 0, 5608, 5607, 1, 0, 0, 0, 5608, 5609, 1, 0, 0, 0, 5609, 997,
		1, 0, 0, 0, 5610, 5613, 5, 215, 0, 0, 5611, 5614, 3, 1074, 537, 0, 5612,
		5614, 3, 1172, 586, 0, 5613, 5611, 1, 0, 0, 0, 5613, 5612, 1, 0, 0, 0,
		5614, 999, 1, 0, 0, 0, 5615, 5617, 7, 56, 0, 0, 5616, 5618, 5, 6, 0, 0,
		5617, 5616, 1, 0, 0, 0, 5617, 5618, 1, 0, 0, 0, 5618, 5622, 1, 0, 0, 0,
		5619, 5623, 3, 1002, 501, 0, 5620, 5623, 3, 1004, 502, 0, 5621, 5623, 3,
		1006, 503, 0, 5622, 5619, 1, 0, 0, 0, 5622, 5620, 1, 0, 0, 0, 5622, 5621,
		1, 0, 0, 0, 5623, 1001, 1, 0, 0, 0, 5624, 5625, 5, 340, 0, 0, 5625, 1003,
		1, 0, 0, 0, 5626, 5629, 3, 1074, 537, 0, 5627, 5629, 3, 1172, 586, 0, 5628,
		5626, 1, 0, 0, 0, 5628, 5627, 1, 0, 0, 0, 5629, 5631, 1, 0, 0, 0, 5630,
		5632, 7, 33, 0, 0, 5631, 5630, 1, 0, 0, 0, 5631, 5632, 1, 0, 0, 0, 5632,
		1005, 1, 0, 0, 0, 5633, 5634, 3, 1146, 573, 0, 5634, 1007, 1, 0, 0, 0,
		5635, 5637, 5, 30, 0, 0, 5636, 5635, 1, 0, 0, 0, 5636, 5637, 1, 0, 0, 0,
		5637, 5638, 1, 0, 0, 0, 5638, 5642, 7, 61, 0, 0, 5639, 5641, 3, 536, 268,
		0, 5640, 5639, 1, 0, 0, 0, 5641, 5644, 1, 0, 0, 0, 5642, 5640, 1, 0, 0,
		0, 5642, 5643, 1, 0, 0, 0, 5643, 1009, 1, 0, 0, 0, 5644, 5642, 1, 0, 0,
		0, 5645, 5647, 5, 312, 0, 0, 5646, 5648, 5, 30, 0, 0, 5647, 5646, 1, 0,
		0, 0, 5647, 5648, 1, 0, 0, 0, 5648, 5649, 1, 0, 0, 0, 5649, 5653, 7, 61,
		0, 0, 5650, 5652, 3, 536, 268, 0, 5651, 5650, 1, 0, 0, 0, 5652, 5655, 1,
		0, 0, 0, 5653, 5651, 1, 0, 0, 0, 5653, 5654, 1, 0, 0, 0, 5654, 1011, 1,
		0, 0, 0, 5655, 5653, 1, 0, 0, 0, 5656, 5658, 5, 30, 0, 0, 5657, 5656, 1,
		0, 0, 0, 5657, 5658, 1, 0, 0, 0, 5658, 5659, 1, 0, 0, 0, 5659, 5663, 5,
		158, 0, 0, 5660, 5662, 3, 536, 268, 0, 5661, 5660, 1, 0, 0, 0, 5662, 5665,
		1, 0, 0, 0, 5663, 5661, 1, 0, 0, 0, 5663, 5664, 1, 0, 0, 0, 5664, 1013,
		1, 0, 0, 0, 5665, 5663, 1, 0, 0, 0, 5666, 5668, 5, 312, 0, 0, 5667, 5669,
		5, 30, 0, 0, 5668, 5667, 1, 0, 0, 0, 5668, 5669, 1, 0, 0, 0, 5669, 5670,
		1, 0, 0, 0, 5670, 5674, 5, 158, 0, 0, 5671, 5673, 3, 536, 268, 0, 5672,
		5671, 1, 0, 0, 0, 5673, 5676, 1, 0, 0, 0, 5674, 5672, 1, 0, 0, 0, 5674,
		5675, 1, 0, 0, 0, 5675, 1015, 1, 0, 0, 0, 5676, 5674, 1, 0, 0, 0, 5677,
		5679, 5, 252, 0, 0, 5678, 5680, 5, 259, 0, 0, 5679, 5678, 1, 0, 0, 0, 5679,
		5680, 1, 0, 0, 0, 5680, 5684, 1, 0, 0, 0, 5681, 5683, 3, 536, 268, 0, 5682,
		5681, 1, 0, 0, 0, 5683, 5686, 1, 0, 0, 0, 5684, 5682, 1, 0, 0, 0, 5684,
		5685, 1, 0, 0, 0, 5685, 1017, 1, 0, 0, 0, 5686, 5684, 1, 0, 0, 0, 5687,
		5688, 5, 312, 0, 0, 5688, 5690, 5, 252, 0, 0, 5689, 5691, 5, 259, 0, 0,
		5690, 5689, 1, 0, 0, 0, 5690, 5691, 1, 0, 0, 0, 5691, 5695, 1, 0, 0, 0,
		5692, 5694, 3, 536, 268, 0, 5693, 5692, 1, 0, 0, 0, 5694, 5697, 1, 0, 0,
		0, 5695, 5693, 1, 0, 0, 0, 5695, 5696, 1, 0, 0, 0, 5696, 1019, 1, 0, 0,
		0, 5697, 5695, 1, 0, 0, 0, 5698, 5700, 5, 326, 0, 0, 5699, 5698, 1, 0,
		0, 0, 5699, 5700, 1, 0, 0, 0, 5700, 5701, 1, 0, 0, 0, 5701, 5705, 5, 335,
		0, 0, 5702, 5704, 3, 536, 268, 0, 5703, 5702, 1, 0, 0, 0, 5704, 5707, 1,
		0, 0, 0, 5705, 5703, 1, 0, 0, 0, 5705, 5706, 1, 0, 0, 0, 5706, 1021, 1,
		0, 0, 0, 5707, 5705, 1, 0, 0, 0, 5708, 5710, 5, 312, 0, 0, 5709, 5711,
		5, 326, 0, 0, 5710, 5709, 1, 0, 0, 0, 5710, 5711, 1, 0, 0, 0, 5711, 5712,
		1, 0, 0, 0, 5712, 5716, 5, 335, 0, 0, 5713, 5715, 3, 536, 268, 0, 5714,
		5713, 1, 0, 0, 0, 5715, 5718, 1, 0, 0, 0, 5716, 5714, 1, 0, 0, 0, 5716,
		5717, 1, 0, 0, 0, 5717, 1023, 1, 0, 0, 0, 5718, 5716, 1, 0, 0, 0, 5719,
		5721, 5, 326, 0, 0, 5720, 5719, 1, 0, 0, 0, 5720, 5721, 1, 0, 0, 0, 5721,
		5722, 1, 0, 0, 0, 5722, 5723, 5, 439, 0, 0, 5723, 5727, 5, 188, 0, 0, 5724,
		5726, 3, 536, 268, 0, 5725, 5724, 1, 0, 0, 0, 5726, 5729, 1, 0, 0, 0, 5727,
		5725, 1, 0, 0, 0, 5727, 5728, 1, 0, 0, 0, 5728, 1025, 1, 0, 0, 0, 5729,
		5727, 1, 0, 0, 0, 5730, 5732, 5, 312, 0, 0, 5731, 5733, 5, 326, 0, 0, 5732,
		5731, 1, 0, 0, 0, 5732, 5733, 1, 0, 0, 0, 5733, 5734, 1, 0, 0, 0, 5734,
		5735, 5, 439, 0, 0, 5735, 5739, 5, 188, 0, 0, 5736, 5738, 3, 536, 268,
		0, 5737, 5736, 1, 0, 0, 0, 5738, 5741, 1, 0, 0, 0, 5739, 5737, 1, 0, 0,
		0, 5739, 5740, 1, 0, 0, 0, 5740, 1027, 1, 0, 0, 0, 5741, 5739, 1, 0, 0,
		0, 5742, 5744, 5, 326, 0, 0, 5743, 5742, 1, 0, 0, 0, 5743, 5744, 1, 0,
		0, 0, 5744, 5745, 1, 0, 0, 0, 5745, 5749, 5, 196, 0, 0, 5746, 5748, 3,
		536, 268, 0, 5747, 5746, 1, 0, 0, 0, 5748, 5751, 1, 0, 0, 0, 5749, 5747,
		1, 0, 0, 0, 5749, 5750, 1, 0, 0, 0, 5750, 1029, 1, 0, 0, 0, 5751, 5749,
		1, 0, 0, 0, 5752, 5754, 5, 312, 0, 0, 5753, 5755, 5, 326, 0, 0, 5754, 5753,
		1, 0, 0, 0, 5754, 5755, 1, 0, 0, 0, 5755, 5756, 1, 0, 0, 0, 5756, 5760,
		5, 196, 0, 0, 5757, 5759, 3, 536, 268, 0, 5758, 5757, 1, 0, 0, 0, 5759,
		5762, 1, 0, 0, 0, 5760, 5758, 1, 0, 0, 0, 5760, 5761, 1, 0, 0, 0, 5761,
		1031, 1, 0, 0, 0, 5762, 5760, 1, 0, 0, 0, 5763, 5767, 3, 1036, 518, 0,
		5764, 5766, 3, 1034, 517, 0, 5765, 5764, 1, 0, 0, 0, 5766, 5769, 1, 0,
		0, 0, 5767, 5765, 1, 0, 0, 0, 5767, 5768, 1, 0, 0, 0, 5768, 1033, 1, 0,
		0, 0, 5769, 5767, 1, 0, 0, 0, 5770, 5771, 7, 62, 0, 0, 5771, 5772, 3, 1036,
		518, 0, 5772, 1035, 1, 0, 0, 0, 5773, 5777, 3, 1040, 520, 0, 5774, 5776,
		3, 1038, 519, 0, 5775, 5774, 1, 0, 0, 0, 5776, 5779, 1, 0, 0, 0, 5777,
		5775, 1, 0, 0, 0, 5777, 5778, 1, 0, 0, 0, 5778, 1037, 1, 0, 0, 0, 5779,
		5777, 1, 0, 0, 0, 5780, 5781, 7, 63, 0, 0, 5781, 5782, 3, 1040, 520, 0,
		5782, 1039, 1, 0, 0, 0, 5783, 5785, 7, 62, 0, 0, 5784, 5783, 1, 0, 0, 0,
		5784, 5785, 1, 0, 0, 0, 5785, 5786, 1, 0, 0, 0, 5786, 5790, 3, 1044, 522,
		0, 5787, 5789, 3, 1042, 521, 0, 5788, 5787, 1, 0, 0, 0, 5789, 5792, 1,
		0, 0, 0, 5790, 5788, 1, 0, 0, 0, 5790, 5791, 1, 0, 0, 0, 5791, 1041, 1,
		0, 0, 0, 5792, 5790, 1, 0, 0, 0, 5793, 5794, 5, 527, 0, 0, 5794, 5795,
		3, 1044, 522, 0, 5795, 1043, 1, 0, 0, 0, 5796, 5797, 5, 542, 0, 0, 5797,
		5798, 3, 1032, 516, 0, 5798, 5799, 5, 549, 0, 0, 5799, 5803, 1, 0, 0, 0,
		5800, 5803, 3, 1074, 537, 0, 5801, 5803, 3, 1172, 586, 0, 5802, 5796, 1,
		0, 0, 0, 5802, 5800, 1, 0, 0, 0, 5802, 5801, 1, 0, 0, 0, 5803, 1045, 1,
		0, 0, 0, 5804, 5808, 3, 1050, 525, 0, 5805, 5807, 3, 1048, 524, 0, 5806,
		5805, 1, 0, 0, 0, 5807, 5810, 1, 0, 0, 0, 5808, 5806, 1, 0, 0, 0, 5808,
		5809, 1, 0, 0, 0, 5809, 1047, 1, 0, 0, 0, 5810, 5808, 1, 0, 0, 0, 5811,
		5818, 7, 64, 0, 0, 5812, 5819, 3, 1050, 525, 0, 5813, 5815, 3, 1072, 536,
		0, 5814, 5813, 1, 0, 0, 0, 5815, 5816, 1, 0, 0, 0, 5816, 5814, 1, 0, 0,
		0, 5816, 5817, 1, 0, 0, 0, 5817, 5819, 1, 0, 0, 0, 5818, 5812, 1, 0, 0,
		0, 5818, 5814, 1, 0, 0, 0, 5819, 1049, 1, 0, 0, 0, 5820, 5822, 5, 312,
		0, 0, 5821, 5820, 1, 0, 0, 0, 5821, 5822, 1, 0, 0, 0, 5822, 5823, 1, 0,
		0, 0, 5823, 5824, 3, 1052, 526, 0, 5824, 1051, 1, 0, 0, 0, 5825, 5826,
		5, 542, 0, 0, 5826, 5827, 3, 1046, 523, 0, 5827, 5828, 5, 549, 0, 0, 5828,
		5833, 1, 0, 0, 0, 5829, 5833, 3, 1060, 530, 0, 5830, 5833, 3, 1054, 527,
		0, 5831, 5833, 3, 1056, 528, 0, 5832, 5825, 1, 0, 0, 0, 5832, 5829, 1,
		0, 0, 0, 5832, 5830, 1, 0, 0, 0, 5832, 5831, 1, 0, 0, 0, 5833, 1053, 1,
		0, 0, 0, 5834, 5836, 3, 1074, 537, 0, 5835, 5837, 5, 254, 0, 0, 5836, 5835,
		1, 0, 0, 0, 5836, 5837, 1, 0, 0, 0, 5837, 5839, 1, 0, 0, 0, 5838, 5840,
		5, 312, 0, 0, 5839, 5838, 1, 0, 0, 0, 5839, 5840, 1, 0, 0, 0, 5840, 5848,
		1, 0, 0, 0, 5841, 5849, 5, 316, 0, 0, 5842, 5849, 5, 11, 0, 0, 5843, 5849,
		5, 12, 0, 0, 5844, 5849, 5, 13, 0, 0, 5845, 5849, 5, 116, 0, 0, 5846, 5849,
		5, 257, 0, 0, 5847, 5849, 3, 1122, 561, 0, 5848, 5841, 1, 0, 0, 0, 5848,
		5842, 1, 0, 0, 0, 5848, 5843, 1, 0, 0, 0, 5848, 5844, 1, 0, 0, 0, 5848,
		5845, 1, 0, 0, 0, 5848, 5846, 1, 0, 0, 0, 5848, 5847, 1, 0, 0, 0, 5849,
		1055, 1, 0, 0, 0, 5850, 5872, 3, 1126, 563, 0, 5851, 5853, 3, 1102, 551,
		0, 5852, 5851, 1, 0, 0, 0, 5853, 5856, 1, 0, 0, 0, 5854, 5852, 1, 0, 0,
		0, 5854, 5855, 1, 0, 0, 0, 5855, 5858, 1, 0, 0, 0, 5856, 5854, 1, 0, 0,
		0, 5857, 5859, 3, 1104, 552, 0, 5858, 5857, 1, 0, 0, 0, 5858, 5859, 1,
		0, 0, 0, 5859, 5863, 1, 0, 0, 0, 5860, 5862, 3, 1058, 529, 0, 5861, 5860,
		1, 0, 0, 0, 5862, 5865, 1, 0, 0, 0, 5863, 5861, 1, 0, 0, 0, 5863, 5864,
		1, 0, 0, 0, 5864, 5873, 1, 0, 0, 0, 5865, 5863, 1, 0, 0, 0, 5866, 5868,
		3, 1106, 553, 0, 5867, 5866, 1, 0, 0, 0, 5868, 5871, 1, 0, 0, 0, 5869,
		5867, 1, 0, 0, 0, 5869, 5870, 1, 0, 0, 0, 5870, 5873, 1, 0, 0, 0, 5871,
		5869, 1, 0, 0, 0, 5872, 5854, 1, 0, 0, 0, 5872, 5869, 1, 0, 0, 0, 5873,
		1057, 1, 0, 0, 0, 5874, 5875, 5, 542, 0, 0, 5875, 5882, 3, 1086, 543, 0,
		5876, 5878, 5, 529, 0, 0, 5877, 5876, 1, 0, 0, 0, 5877, 5878, 1, 0, 0,
		0, 5878, 5879, 1, 0, 0, 0, 5879, 5881, 3, 1086, 543, 0, 5880, 5877, 1,
		0, 0, 0, 5881, 5884, 1, 0, 0, 0, 5882, 5880, 1, 0, 0, 0, 5882, 5883, 1,
		0, 0, 0, 5883, 5885, 1, 0, 0, 0, 5884, 5882, 1, 0, 0, 0, 5885, 5886, 5,
		549, 0, 0, 5886, 1059, 1, 0, 0, 0, 5887, 5891, 3, 1062, 531, 0, 5888, 5891,
		3, 1064, 532, 0, 5889, 5891, 3, 1066, 533, 0, 5890, 5887, 1, 0, 0, 0, 5890,
		5888, 1, 0, 0, 0, 5890, 5889, 1, 0, 0, 0, 5891, 1061, 1, 0, 0, 0, 5892,
		5894, 3, 1032, 516, 0, 5893, 5895, 5, 254, 0, 0, 5894, 5893, 1, 0, 0, 0,
		5894, 5895, 1, 0, 0, 0, 5895, 5897, 1, 0, 0, 0, 5896, 5898, 5, 312, 0,
		0, 5897, 5896, 1, 0, 0, 0, 5897, 5898, 1, 0, 0, 0, 5898, 5899, 1, 0, 0,
		0, 5899, 5900, 7, 65, 0, 0, 5900, 1063, 1, 0, 0, 0, 5901, 5902, 3, 1032,
		516, 0, 5902, 5903, 3, 1070, 535, 0, 5903, 5904, 3, 1032, 516, 0, 5904,
		1065, 1, 0, 0, 0, 5905, 5906, 3, 1032, 516, 0, 5906, 5907, 3, 1070, 535,
		0, 5907, 5908, 5, 542, 0, 0, 5908, 5909, 3, 1068, 534, 0, 5909, 5910, 5,
		549, 0, 0, 5910, 1067, 1, 0, 0, 0, 5911, 5914, 3, 1032, 516, 0, 5912, 5913,
		7, 64, 0, 0, 5913, 5915, 3, 1032, 516, 0, 5914, 5912, 1, 0, 0, 0, 5915,
		5916, 1, 0, 0, 0, 5916, 5914, 1, 0, 0, 0, 5916, 5917, 1, 0, 0, 0, 5917,
		1069, 1, 0, 0, 0, 5918, 5920, 7, 8, 0, 0, 5919, 5918, 1, 0, 0, 0, 5919,
		5920, 1, 0, 0, 0, 5920, 5962, 1, 0, 0, 0, 5921, 5923, 5, 312, 0, 0, 5922,
		5921, 1, 0, 0, 0, 5922, 5923, 1, 0, 0, 0, 5923, 5939, 1, 0, 0, 0, 5924,
		5926, 5, 225, 0, 0, 5925, 5927, 5, 479, 0, 0, 5926, 5925, 1, 0, 0, 0, 5926,
		5927, 1, 0, 0, 0, 5927, 5940, 1, 0, 0, 0, 5928, 5940, 5, 544, 0, 0, 5929,
		5931, 5, 271, 0, 0, 5930, 5932, 5, 479, 0, 0, 5931, 5930, 1, 0, 0, 0, 5931,
		5932, 1, 0, 0, 0, 5932, 5940, 1, 0, 0, 0, 5933, 5940, 5, 540, 0, 0, 5934,
		5936, 5, 186, 0, 0, 5935, 5937, 5, 489, 0, 0, 5936, 5935, 1, 0, 0, 0, 5936,
		5937, 1, 0, 0, 0, 5937, 5940, 1, 0, 0, 0, 5938, 5940, 5, 536, 0, 0, 5939,
		5924, 1, 0, 0, 0, 5939, 5928, 1, 0, 0, 0, 5939, 5929, 1, 0, 0, 0, 5939,
		5933, 1, 0, 0, 0, 5939, 5934, 1, 0, 0, 0, 5939, 5938, 1, 0, 0, 0, 5940,
		5963, 1, 0, 0, 0, 5941, 5963, 5, 546, 0, 0, 5942, 5944, 5, 225, 0, 0, 5943,
		5945, 5, 479, 0, 0, 5944, 5943, 1, 0, 0, 0, 5944, 5945, 1, 0, 0, 0, 5945,
		5946, 1, 0, 0, 0, 5946, 5947, 5, 329, 0, 0, 5947, 5949, 5, 186, 0, 0, 5948,
		5950, 5, 489, 0, 0, 5949, 5948, 1, 0, 0, 0, 5949, 5950, 1, 0, 0, 0, 5950,
		5963, 1, 0, 0, 0, 5951, 5963, 5, 545, 0, 0, 5952, 5954, 5, 271, 0, 0, 5953,
		5955, 5, 479, 0, 0, 5954, 5953, 1, 0, 0, 0, 5954, 5955, 1, 0, 0, 0, 5955,
		5956, 1, 0, 0, 0, 5956, 5957, 5, 329, 0, 0, 5957, 5959, 5, 186, 0, 0, 5958,
		5960, 5, 489, 0, 0, 5959, 5958, 1, 0, 0, 0, 5959, 5960, 1, 0, 0, 0, 5960,
		5963, 1, 0, 0, 0, 5961, 5963, 5, 541, 0, 0, 5962, 5922, 1, 0, 0, 0, 5962,
		5941, 1, 0, 0, 0, 5962, 5942, 1, 0, 0, 0, 5962, 5951, 1, 0, 0, 0, 5962,
		5952, 1, 0, 0, 0, 5962, 5961, 1, 0, 0, 0, 5963, 1071, 1, 0, 0, 0, 5964,
		5966, 5, 312, 0, 0, 5965, 5964, 1, 0, 0, 0, 5965, 5966, 1, 0, 0, 0, 5966,
		5968, 1, 0, 0, 0, 5967, 5969, 3, 1070, 535, 0, 5968, 5967, 1, 0, 0, 0,
		5968, 5969, 1, 0, 0, 0, 5969, 5976, 1, 0, 0, 0, 5970, 5977, 3, 1032, 516,
		0, 5971, 5972, 5, 542, 0, 0, 5972, 5973, 3, 1032, 516, 0, 5973, 5974, 3,
		1072, 536, 0, 5974, 5975, 5, 549, 0, 0, 5975, 5977, 1, 0, 0, 0, 5976, 5970,
		1, 0, 0, 0, 5976, 5971, 1, 0, 0, 0, 5977, 1073, 1, 0, 0, 0, 5978, 5983,
		3, 1090, 545, 0, 5979, 5983, 3, 1076, 538, 0, 5980, 5983, 3, 1078, 539,
		0, 5981, 5983, 3, 1186, 593, 0, 5982, 5978, 1, 0, 0, 0, 5982, 5979, 1,
		0, 0, 0, 5982, 5980, 1, 0, 0, 0, 5982, 5981, 1, 0, 0, 0, 5983, 1075, 1,
		0, 0, 0, 5984, 6000, 3, 1090, 545, 0, 5985, 5986, 5, 542, 0, 0, 5986, 5993,
		3, 1086, 543, 0, 5987, 5989, 5, 529, 0, 0, 5988, 5987, 1, 0, 0, 0, 5988,
		5989, 1, 0, 0, 0, 5989, 5990, 1, 0, 0, 0, 5990, 5992, 3, 1086, 543, 0,
		5991, 5988, 1, 0, 0, 0, 5992, 5995, 1, 0, 0, 0, 5993, 5991, 1, 0, 0, 0,
		5993, 5994, 1, 0, 0, 0, 5994, 5996, 1, 0, 0, 0, 5995, 5993, 1, 0, 0, 0,
		5996, 5997, 5, 549, 0, 0, 5997, 5999, 1, 0, 0, 0, 5998, 5985, 1, 0, 0,
		0, 5999, 6002, 1, 0, 0, 0, 6000, 5998, 1, 0, 0, 0, 6000, 6001, 1, 0, 0,
		0, 6001, 6004, 1, 0, 0, 0, 6002, 6000, 1, 0, 0, 0, 6003, 6005, 3, 1080,
		540, 0, 6004, 6003, 1, 0, 0, 0, 6004, 6005, 1, 0, 0, 0, 6005, 1077, 1,
		0, 0, 0, 6006, 6007, 5, 217, 0, 0, 6007, 6023, 3, 1136, 568, 0, 6008, 6009,
		5, 542, 0, 0, 6009, 6016, 3, 1088, 544, 0, 6010, 6012, 5, 529, 0, 0, 6011,
		6010, 1, 0, 0, 0, 6011, 6012, 1, 0, 0, 0, 6012, 6013, 1, 0, 0, 0, 6013,
		6015, 3, 1088, 544, 0, 6014, 6011, 1, 0, 0, 0, 6015, 6018, 1, 0, 0, 0,
		6016, 6014, 1, 0, 0, 0, 6016, 6017, 1, 0, 0, 0, 6017, 6019, 1, 0, 0, 0,
		6018, 6016, 1, 0, 0, 0, 6019, 6020, 5, 549, 0, 0, 6020, 6022, 1, 0, 0,
		0, 6021, 6008, 1, 0, 0, 0, 6022, 6025, 1, 0, 0, 0, 6023, 6021, 1, 0, 0,
		0, 6023, 6024, 1, 0, 0, 0, 6024, 6027, 1, 0, 0, 0, 6025, 6023, 1, 0, 0,
		0, 6026, 6028, 3, 1080, 540, 0, 6027, 6026, 1, 0, 0, 0, 6027, 6028, 1,
		0, 0, 0, 6028, 1079, 1, 0, 0, 0, 6029, 6030, 5, 542, 0, 0, 6030, 6031,
		3, 1082, 541, 0, 6031, 6033, 5, 528, 0, 0, 6032, 6034, 3, 1084, 542, 0,
		6033, 6032, 1, 0, 0, 0, 6033, 6034, 1, 0, 0, 0, 6034, 6035, 1, 0, 0, 0,
		6035, 6036, 5, 549, 0, 0, 6036, 1081, 1, 0, 0, 0, 6037, 6038, 3, 1032,
		516, 0, 6038, 1083, 1, 0, 0, 0, 6039, 6040, 3, 1032, 516, 0, 6040, 1085,
		1, 0, 0, 0, 6041, 6053, 5, 9, 0, 0, 6042, 6053, 3, 1178, 589, 0, 6043,
		6045, 3, 1090, 545, 0, 6044, 6046, 3, 1178, 589, 0, 6045, 6044, 1, 0, 0,
		0, 6045, 6046, 1, 0, 0, 0, 6046, 6053, 1, 0, 0, 0, 6047, 6049, 3, 1138,
		569, 0, 6048, 6050, 3, 1178, 589, 0, 6049, 6048, 1, 0, 0, 0, 6049, 6050,
		1, 0, 0, 0, 6050, 6053, 1, 0, 0, 0, 6051, 6053, 3, 1032, 516, 0, 6052,
		6041, 1, 0, 0, 0, 6052, 6042, 1, 0, 0, 0, 6052, 6043, 1, 0, 0, 0, 6052,
		6047, 1, 0, 0, 0, 6052, 6051, 1, 0, 0, 0, 6053, 1087, 1, 0, 0, 0, 6054,
		6066, 3, 1172, 586, 0, 6055, 6066, 3, 1074, 537, 0, 6056, 6058, 3, 1090,
		545, 0, 6057, 6059, 3, 1178, 589, 0, 6058, 6057, 1, 0, 0, 0, 6058, 6059,
		1, 0, 0, 0, 6059, 6066, 1, 0, 0, 0, 6060, 6062, 3, 1138, 569, 0, 6061,
		6063, 3, 1178, 589, 0, 6062, 6061, 1, 0, 0, 0, 6062, 6063, 1, 0, 0, 0,
		6063, 6066, 1, 0, 0, 0, 6064, 6066, 3, 1032, 516, 0, 6065, 6054, 1, 0,
		0, 0, 6065, 6055, 1, 0, 0, 0, 6065, 6056, 1, 0, 0, 0, 6065, 6060, 1, 0,
		0, 0, 6065, 6064, 1, 0, 0, 0, 6066, 1089, 1, 0, 0, 0, 6067, 6072, 3, 1092,
		546, 0, 6068, 6072, 3, 1094, 547, 0, 6069, 6072, 3, 1096, 548, 0, 6070,
		6072, 3, 1098, 549, 0, 6071, 6067, 1, 0, 0, 0, 6071, 6068, 1, 0, 0, 0,
		6071, 6069, 1, 0, 0, 0, 6071, 6070, 1, 0, 0, 0, 6072, 1091, 1, 0, 0, 0,
		6073, 6076, 3, 1128, 564, 0, 6074, 6076, 3, 1126, 563, 0, 6075, 6073, 1,
		0, 0, 0, 6075, 6074, 1, 0, 0, 0, 6076, 6086, 1, 0, 0, 0, 6077, 6079, 3,
		1100, 550, 0, 6078, 6077, 1, 0, 0, 0, 6079, 6080, 1, 0, 0, 0, 6080, 6078,
		1, 0, 0, 0, 6080, 6081, 1, 0, 0, 0, 6081, 6083, 1, 0, 0, 0, 6082, 6084,
		3, 1104, 552, 0, 6083, 6082, 1, 0, 0, 0, 6083, 6084, 1, 0, 0, 0, 6084,
		6087, 1, 0, 0, 0, 6085, 6087, 3, 1104, 552, 0, 6086, 6078, 1, 0, 0, 0,
		6086, 6085, 1, 0, 0, 0, 6086, 6087, 1, 0, 0, 0, 6087, 1093, 1, 0, 0, 0,
		6088, 6089, 3, 1148, 574, 0, 6089, 6090, 3, 1108, 554, 0, 6090, 1095, 1,
		0, 0, 0, 6091, 6092, 3, 1168, 584, 0, 6092, 6093, 3, 1110, 555, 0, 6093,
		1097, 1, 0, 0, 0, 6094, 6095, 5, 278, 0, 0, 6095, 6096, 3, 1104, 552, 0,
		6096, 1099, 1, 0, 0, 0, 6097, 6100, 3, 1102, 551, 0, 6098, 6100, 3, 1112,
		556, 0, 6099, 6097, 1, 0, 0, 0, 6099, 6098, 1, 0, 0, 0, 6100, 1101, 1,
		0, 0, 0, 6101, 6102, 7, 66, 0, 0, 6102, 6103, 3, 1128, 564, 0, 6103, 1103,
		1, 0, 0, 0, 6104, 6105, 7, 66, 0, 0, 6105, 6106, 3, 1134, 567, 0, 6106,
		1105, 1, 0, 0, 0, 6107, 6108, 7, 66, 0, 0, 6108, 6109, 3, 1146, 573, 0,
		6109, 1107, 1, 0, 0, 0, 6110, 6111, 7, 66, 0, 0, 6111, 6112, 3, 1162, 581,
		0, 6112, 1109, 1, 0, 0, 0, 6113, 6114, 7, 66, 0, 0, 6114, 6115, 3, 1142,
		571, 0, 6115, 1111, 1, 0, 0, 0, 6116, 6117, 7, 66, 0, 0, 6117, 6118, 3,
		1076, 538, 0, 6118, 1113, 1, 0, 0, 0, 6119, 6120, 3, 1170, 585, 0, 6120,
		1115, 1, 0, 0, 0, 6121, 6122, 3, 1164, 582, 0, 6122, 1117, 1, 0, 0, 0,
		6123, 6124, 3, 1152, 576, 0, 6124, 1119, 1, 0, 0, 0, 6125, 6126, 3, 1170,
		585, 0, 6126, 1121, 1, 0, 0, 0, 6127, 6128, 3, 1170, 585, 0, 6128, 1123,
		1, 0, 0, 0, 6129, 6130, 3, 1164, 582, 0, 6130, 1125, 1, 0, 0, 0, 6131,
		6132, 3, 1170, 585, 0, 6132, 1127, 1, 0, 0, 0, 6133, 6134, 3, 1170, 585,
		0, 6134, 1129, 1, 0, 0, 0, 6135, 6139, 5, 208, 0, 0, 6136, 6139, 5, 108,
		0, 0, 6137, 6139, 3, 1128, 564, 0, 6138, 6135, 1, 0, 0, 0, 6138, 6136,
		1, 0, 0, 0, 6138, 6137, 1, 0, 0, 0, 6139, 1131, 1, 0, 0, 0, 6140, 6141,
		3, 1164, 582, 0, 6141, 1133, 1, 0, 0, 0, 6142, 6143, 3, 1170, 585, 0, 6143,
		1135, 1, 0, 0, 0, 6144, 6151, 5, 250, 0, 0, 6145, 6151, 5, 269, 0, 0, 6146,
		6151, 5, 369, 0, 0, 6147, 6151, 5, 464, 0, 0, 6148, 6151, 5, 513, 0, 0,
		6149, 6151, 3, 1170, 585, 0, 6150, 6144, 1, 0, 0, 0, 6150, 6145, 1, 0,
		0, 0, 6150, 6146, 1, 0, 0, 0, 6150, 6147, 1, 0, 0, 0, 6150, 6148, 1, 0,
		0, 0, 6150, 6149, 1, 0, 0, 0, 6151, 1137, 1, 0, 0, 0, 6152, 6153, 3, 1170,
		585, 0, 6153, 1139, 1, 0, 0, 0, 6154, 6155, 3, 1164, 582, 0, 6155, 1141,
		1, 0, 0, 0, 6156, 6157, 3, 1170, 585, 0, 6157, 1143, 1, 0, 0, 0, 6158,
		6159, 3, 1170, 585, 0, 6159, 1145, 1, 0, 0, 0, 6160, 6161, 3, 1170, 585,
		0, 6161, 1147, 1, 0, 0, 0, 6162, 6165, 3, 1170, 585, 0, 6163, 6165, 3,
		1178, 589, 0, 6164, 6162, 1, 0, 0, 0, 6164, 6163, 1, 0, 0, 0, 6165, 1149,
		1, 0, 0, 0, 6166, 6168, 3, 1148, 574, 0, 6167, 6169, 3, 1108, 554, 0, 6168,
		6167, 1, 0, 0, 0, 6168, 6169, 1, 0, 0, 0, 6169, 6172, 1, 0, 0, 0, 6170,
		6172, 3, 1162, 581, 0, 6171, 6166, 1, 0, 0, 0, 6171, 6170, 1, 0, 0, 0,
		6172, 1151, 1, 0, 0, 0, 6173, 6176, 5, 551, 0, 0, 6174, 6176, 3, 1170,
		585, 0, 6175, 6173, 1, 0, 0, 0, 6175, 6174, 1, 0, 0, 0, 6176, 1153, 1,
		0, 0, 0, 6177, 6178, 3, 1090, 545, 0, 6178, 1155, 1, 0, 0, 0, 6179, 6180,
		3, 1090, 545, 0, 6180, 1157, 1, 0, 0, 0, 6181, 6182, 3, 1170, 585, 0, 6182,
		1159, 1, 0, 0, 0, 6183, 6184, 3, 1170, 585, 0, 6184, 1161, 1, 0, 0, 0,
		6185, 6188, 3, 1170, 585, 0, 6186, 6188, 3, 1178, 589, 0, 6187, 6185, 1,
		0, 0, 0, 6187, 6186, 1, 0, 0, 0, 6188, 1163, 1, 0, 0, 0, 6189, 6190, 3,
		1170, 585, 0, 6190, 1165, 1, 0, 0, 0, 6191, 6192, 3, 1170, 585, 0, 6192,
		1167, 1, 0, 0, 0, 6193, 6194, 3, 1170, 585, 0, 6194, 1169, 1, 0, 0, 0,
		6195, 6196, 7, 67, 0, 0, 6196, 1171, 1, 0, 0, 0, 6197, 6204, 5, 551, 0,
		0, 6198, 6204, 3, 1184, 592, 0, 6199, 6204, 3, 1176, 588, 0, 6200, 6204,
		3, 1174, 587, 0, 6201, 6204, 3, 1180, 590, 0, 6202, 6204, 3, 1182, 591,
		0, 6203, 6197, 1, 0, 0, 0, 6203, 6198, 1, 0, 0, 0, 6203, 6199, 1, 0, 0,
		0, 6203, 6200, 1, 0, 0, 0, 6203, 6201, 1, 0, 0, 0, 6203, 6202, 1, 0, 0,
		0, 6204, 1173, 1, 0, 0, 0, 6205, 6206, 7, 68, 0, 0, 6206, 1175, 1, 0, 0,
		0, 6207, 6211, 5, 556, 0, 0, 6208, 6211, 5, 521, 0, 0, 6209, 6211, 3, 1178,
		589, 0, 6210, 6207, 1, 0, 0, 0, 6210, 6208, 1, 0, 0, 0, 6210, 6209, 1,
		0, 0, 0, 6211, 1177, 1, 0, 0, 0, 6212, 6213, 7, 69, 0, 0, 6213, 1179, 1,
		0, 0, 0, 6214, 6215, 5, 138, 0, 0, 6215, 6218, 5, 542, 0, 0, 6216, 6219,
		3, 1170, 585, 0, 6217, 6219, 3, 1172, 586, 0, 6218, 6216, 1, 0, 0, 0, 6218,
		6217, 1, 0, 0, 0, 6219, 6220, 1, 0, 0, 0, 6220, 6221, 5, 549, 0, 0, 6221,
		1181, 1, 0, 0, 0, 6222, 6223, 5, 139, 0, 0, 6223, 6226, 5, 542, 0, 0, 6224,
		6227, 3, 1170, 585, 0, 6225, 6227, 3, 1172, 586, 0, 6226, 6224, 1, 0, 0,
		0, 6226, 6225, 1, 0, 0, 0, 6227, 6228, 1, 0, 0, 0, 6228, 6229, 5, 549,
		0, 0, 6229, 1183, 1, 0, 0, 0, 6230, 6231, 5, 9, 0, 0, 6231, 6246, 3, 1172,
		586, 0, 6232, 6246, 5, 230, 0, 0, 6233, 6246, 5, 231, 0, 0, 6234, 6246,
		5, 291, 0, 0, 6235, 6246, 5, 292, 0, 0, 6236, 6246, 5, 313, 0, 0, 6237,
		6246, 5, 314, 0, 0, 6238, 6246, 5, 367, 0, 0, 6239, 6246, 5, 368, 0, 0,
		6240, 6246, 5, 450, 0, 0, 6241, 6246, 5, 451, 0, 0, 6242, 6246, 5, 521,
		0, 0, 6243, 6246, 5, 523, 0, 0, 6244, 6246, 5, 524, 0, 0, 6245, 6230, 1,
		0, 0, 0, 6245, 6232, 1, 0, 0, 0, 6245, 6233, 1, 0, 0, 0, 6245, 6234, 1,
		0, 0, 0, 6245, 6235, 1, 0, 0, 0, 6245, 6236, 1, 0, 0, 0, 6245, 6237, 1,
		0, 0, 0, 6245, 6238, 1, 0, 0, 0, 6245, 6239, 1, 0, 0, 0, 6245, 6240, 1,
		0, 0, 0, 6245, 6241, 1, 0, 0, 0, 6245, 6242, 1, 0, 0, 0, 6245, 6243, 1,
		0, 0, 0, 6245, 6244, 1, 0, 0, 0, 6246, 1185, 1, 0, 0, 0, 6247, 6248, 5,
		5, 0, 0, 6248, 6249, 5, 323, 0, 0, 6249, 6281, 3, 1074, 537, 0, 6250, 6281,
		5, 111, 0, 0, 6251, 6281, 5, 114, 0, 0, 6252, 6281, 5, 115, 0, 0, 6253,
		6281, 5, 118, 0, 0, 6254, 6281, 5, 119, 0, 0, 6255, 6281, 5, 120, 0, 0,
		6256, 6281, 5, 121, 0, 0, 6257, 6281, 5, 122, 0, 0, 6258, 6281, 5, 123,
		0, 0, 6259, 6281, 5, 124, 0, 0, 6260, 6262, 5, 269, 0, 0, 6261, 6263, 5,
		323, 0, 0, 6262, 6261, 1, 0, 0, 0, 6262, 6263, 1, 0, 0, 0, 6263, 6264,
		1, 0, 0, 0, 6264, 6281, 3, 1074, 537, 0, 6265, 6281, 5, 278, 0, 0, 6266,
		6281, 5, 281, 0, 0, 6267, 6281, 5, 341, 0, 0, 6268, 6281, 5, 404, 0, 0,
		6269, 6281, 5, 435, 0, 0, 6270, 6281, 5, 436, 0, 0, 6271, 6281, 5, 441,
		0, 0, 6272, 6281, 5, 442, 0, 0, 6273, 6281, 5, 443, 0, 0, 6274, 6281, 5,
		445, 0, 0, 6275, 6281, 5, 446, 0, 0, 6276, 6281, 5, 447, 0, 0, 6277, 6281,
		5, 471, 0, 0, 6278, 6281, 5, 485, 0, 0, 6279, 6281, 5, 513, 0, 0, 6280,
		6247, 1, 0, 0, 0, 6280, 6250, 1, 0, 0, 0, 6280, 6251, 1, 0, 0, 0, 6280,
		6252, 1, 0, 0, 0, 6280, 6253, 1, 0, 0, 0, 6280, 6254, 1, 0, 0, 0, 6280,
		6255, 1, 0, 0, 0, 6280, 6256, 1, 0, 0, 0, 6280, 6257, 1, 0, 0, 0, 6280,
		6258, 1, 0, 0, 0, 6280, 6259, 1, 0, 0, 0, 6280, 6260, 1, 0, 0, 0, 6280,
		6265, 1, 0, 0, 0, 6280, 6266, 1, 0, 0, 0, 6280, 6267, 1, 0, 0, 0, 6280,
		6268, 1, 0, 0, 0, 6280, 6269, 1, 0, 0, 0, 6280, 6270, 1, 0, 0, 0, 6280,
		6271, 1, 0, 0, 0, 6280, 6272, 1, 0, 0, 0, 6280, 6273, 1, 0, 0, 0, 6280,
		6274, 1, 0, 0, 0, 6280, 6275, 1, 0, 0, 0, 6280, 6276, 1, 0, 0, 0, 6280,
		6277, 1, 0, 0, 0, 6280, 6278, 1, 0, 0, 0, 6280, 6279, 1, 0, 0, 0, 6281,
		1187, 1, 0, 0, 0, 6282, 6284, 5, 562, 0, 0, 6283, 6282, 1, 0, 0, 0, 6284,
		6285, 1, 0, 0, 0, 6285, 6283, 1, 0, 0, 0, 6285, 6286, 1, 0, 0, 0, 6286,
		1189, 1, 0, 0, 0, 979, 1196, 1200, 1203, 1206, 1211, 1215, 1229, 1238,
		1244, 1248, 1250, 1253, 1256, 1261, 1266, 1271, 1276, 1281, 1286, 1294,
		1300, 1308, 1314, 1320, 1324, 1334, 1344, 1348, 1352, 1355, 1359, 1362,
		1366, 1369, 1372, 1375, 1379, 1384, 1387, 1390, 1393, 1397, 1402, 1406,
		1412, 1425, 1429, 1442, 1446, 1452, 1455, 1466, 1468, 1475, 1477, 1486,
		1491, 1495, 1500, 1505, 1512, 1515, 1518, 1523, 1528, 1532, 1536, 1540,
		1543, 1547, 1552, 1556, 1562, 1566, 1568, 1571, 1575, 1580, 1582, 1587,
		1589, 1593, 1597, 1600, 1604, 1607, 1612, 1615, 1618, 1622, 1625, 1630,
		1633, 1636, 1638, 1642, 1648, 1651, 1654, 1658, 1662, 1665, 1668, 1673,
		1677, 1682, 1685, 1690, 1698, 1703, 1707, 1712, 1721, 1726, 1741, 1745,
		1758, 1763, 1766, 1769, 1773, 1775, 1782, 1788, 1791, 1795, 1800, 1805,
		1809, 1812, 1818, 1821, 1825, 1828, 1831, 1836, 1839, 1843, 1846, 1849,
		1853, 1858, 1862, 1866, 1870, 1873, 1882, 1887, 1891, 1897, 1903, 1905,
		1911, 1917, 1920, 1928, 1932, 1935, 1938, 1943, 1948, 1951, 1956, 1961,
		1966, 1976, 1988, 1996, 2002, 2007, 2014, 2028, 2031, 2036, 2042, 2046,
		2049, 2058, 2061, 2065, 2068, 2072, 2075, 2078, 2082, 2085, 2087, 2091,
		2094, 2097, 2102, 2110, 2114, 2116, 2123, 2125, 2132, 2136, 2140, 2145,
		2149, 2151, 2156, 2160, 2164, 2167, 2172, 2178, 2181, 2185, 2189, 2192,
		2195, 2200, 2203, 2206, 2211, 2215, 2218, 2226, 2232, 2236, 2238, 2243,
		2251, 2265, 2274, 2282, 2284, 2290, 2295, 2298, 2310, 2313, 2315, 2323,
		2332, 2334, 2342, 2352, 2355, 2357, 2365, 2379, 2381, 2386, 2393, 2398,
		2402, 2409, 2416, 2423, 2428, 2432, 2437, 2441, 2446, 2450, 2455, 2459,
		2464, 2468, 2475, 2486, 2491, 2500, 2506, 2526, 2538, 2540, 2565, 2569,
		2573, 2576, 2579, 2583, 2587, 2590, 2593, 2597, 2601, 2605, 2609, 2613,
		2617, 2623, 2629, 2636, 2639, 2649, 2655, 2661, 2665, 2667, 2672, 2674,
		2684, 2687, 2691, 2694, 2699, 2711, 2718, 2723, 2727, 2730, 2733, 2736,
		2738, 2743, 2750, 2754, 2756, 2760, 2779, 2784, 2787, 2791, 2797, 2800,
		2807, 2820, 2823, 2825, 2832, 2838, 2841, 2847, 2851, 2854, 2857, 2860,
		2864, 2868, 2872, 2880, 2885, 2895, 2901, 2905, 2909, 2914, 2918, 2925,
		2930, 2936, 2941, 2944, 2948, 2957, 2962, 2967, 2972, 2976, 2983, 2987,
		2991, 2993, 3000, 3005, 3009, 3019, 3024, 3030, 3033, 3039, 3042, 3046,
		3048, 3054, 3057, 3061, 3065, 3068, 3071, 3074, 3082, 3088, 3095, 3100,
		3103, 3106, 3109, 3121, 3125, 3131, 3135, 3138, 3143, 3151, 3156, 3179,
		3181, 3199, 3202, 3208, 3215, 3220, 3223, 3231, 3236, 3239, 3243, 3246,
		3251, 3256, 3259, 3264, 3266, 3273, 3276, 3281, 3285, 3292, 3295, 3299,
		3317, 3324, 3327, 3341, 3345, 3347, 3352, 3354, 3358, 3361, 3367, 3372,
		3378, 3380, 3384, 3415, 3420, 3424, 3428, 3432, 3434, 3438, 3443, 3448,
		3452, 3458, 3466, 3469, 3473, 3481, 3488, 3491, 3494, 3499, 3502, 3506,
		3509, 3512, 3518, 3523, 3530, 3545, 3551, 3561, 3567, 3576, 3579, 3584,
		3638, 3646, 3649, 3652, 3655, 3660, 3664, 3671, 3677, 3687, 3695, 3698,
		3701, 3704, 3709, 3715, 3720, 3726, 3728, 3734, 3743, 3747, 3751, 3755,
		3759, 3767, 3773, 3780, 3783, 3786, 3789, 3792, 3795, 3798, 3804, 3809,
		3812, 3815, 3820, 3826, 3831, 3834, 3837, 3843, 3849, 3851, 3855, 3858,
		3864, 3870, 3872, 3877, 3886, 3893, 3899, 3905, 3909, 3912, 3915, 3920,
		3922, 3925, 3930, 3933, 3939, 3945, 3947, 3952, 3956, 3963, 3967, 3971,
		3977, 3982, 3985, 3988, 3992, 3999, 4002, 4005, 4008, 4013, 4018, 4022,
		4027, 4033, 4036, 4039, 4042, 4046, 4051, 4056, 4059, 4067, 4072, 4075,
		4078, 4081, 4084, 4090, 4095, 4098, 4103, 4106, 4112, 4116, 4120, 4128,
		4133, 4137, 4142, 4150, 4152, 4159, 4165, 4168, 4171, 4177, 4185, 4190,
		4198, 4203, 4207, 4211, 4224, 4230, 4235, 4240, 4245, 4249, 4252, 4257,
		4261, 4265, 4274, 4278, 4286, 4290, 4293, 4295, 4301, 4304, 4307, 4314,
		4317, 4325, 4328, 4334, 4337, 4343, 4347, 4352, 4358, 4366, 4372, 4377,
		4379, 4385, 4390, 4395, 4401, 4408, 4410, 4416, 4424, 4431, 4437, 4441,
		4446, 4451, 4457, 4463, 4468, 4472, 4476, 4483, 4486, 4491, 4495, 4500,
		4504, 4508, 4513, 4516, 4520, 4525, 4528, 4531, 4534, 4541, 4545, 4553,
		4558, 4562, 4571, 4583, 4587, 4591, 4598, 4602, 4610, 4617, 4622, 4625,
		4628, 4631, 4636, 4640, 4647, 4651, 4655, 4662, 4664, 4670, 4675, 4679,
		4685, 4689, 4693, 4699, 4705, 4710, 4713, 4718, 4726, 4729, 4734, 4738,
		4743, 4753, 4755, 4762, 4767, 4780, 4786, 4789, 4798, 4803, 4806, 4809,
		4812, 4815, 4818, 4821, 4824, 4827, 4830, 4836, 4841, 4845, 4852, 4855,
		4858, 4861, 4871, 4873, 4882, 4887, 4891, 4894, 4901, 4909, 4914, 4918,
		4921, 4928, 4934, 4938, 4942, 4950, 4955, 4958, 4962, 4965, 4973, 4976,
		4979, 4982, 4989, 4993, 4996, 5001, 5004, 5016, 5019, 5024, 5027, 5030,
		5034, 5037, 5040, 5043, 5046, 5060, 5064, 5068, 5073, 5079, 5082, 5090,
		5093, 5098, 5104, 5109, 5115, 5126, 5130, 5134, 5141, 5144, 5147, 5150,
		5155, 5159, 5164, 5168, 5172, 5177, 5180, 5184, 5187, 5190, 5194, 5199,
		5202, 5205, 5208, 5215, 5219, 5226, 5230, 5239, 5244, 5248, 5257, 5269,
		5274, 5277, 5280, 5283, 5287, 5291, 5296, 5302, 5308, 5313, 5316, 5323,
		5329, 5333, 5336, 5339, 5342, 5347, 5351, 5355, 5359, 5364, 5369, 5375,
		5384, 5387, 5390, 5393, 5398, 5404, 5409, 5417, 5426, 5430, 5434, 5438,
		5442, 5451, 5454, 5457, 5460, 5463, 5470, 5473, 5477, 5480, 5484, 5488,
		5492, 5498, 5502, 5505, 5509, 5515, 5520, 5527, 5534, 5537, 5541, 5546,
		5557, 5559, 5562, 5566, 5571, 5577, 5580, 5585, 5590, 5593, 5596, 5599,
		5602, 5605, 5608, 5613, 5617, 5622, 5628, 5631, 5636, 5642, 5647, 5653,
		5657, 5663, 5668, 5674, 5679, 5684, 5690, 5695, 5699, 5705, 5710, 5716,
		5720, 5727, 5732, 5739, 5743, 5749, 5754, 5760, 5767, 5777, 5784, 5790,
		5802, 5808, 5816, 5818, 5821, 5832, 5836, 5839, 5848, 5854, 5858, 5863,
		5869, 5872, 5877, 5882, 5890, 5894, 5897, 5916, 5919, 5922, 5926, 5931,
		5936, 5939, 5944, 5949, 5954, 5959, 5962, 5965, 5968, 5976, 5982, 5988,
		5993, 6000, 6004, 6011, 6016, 6023, 6027, 6033, 6045, 6049, 6052, 6058,
		6062, 6065, 6071, 6075, 6080, 6083, 6086, 6099, 6138, 6150, 6164, 6168,
		6171, 6175, 6187, 6203, 6210, 6218, 6226, 6245, 6262, 6280, 6285,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// Cobol85ParserInit initializes any static state used to implement Cobol85Parser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCobol85Parser(). You can call this function if you wish to initialize the static state ahead
// of time.
func Cobol85ParserInit() {
	staticData := &cobol85ParserStaticData
	staticData.once.Do(cobol85ParserInit)
}

// NewCobol85Parser produces a new parser instance for the optional input antlr.TokenStream.
func NewCobol85Parser(input antlr.TokenStream) *Cobol85Parser {
	Cobol85ParserInit()
	this := new(Cobol85Parser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &cobol85ParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.predictionContextCache)
	this.RuleNames = staticData.ruleNames
	this.LiteralNames = staticData.literalNames
	this.SymbolicNames = staticData.symbolicNames
	this.GrammarFileName = "java-escape"

	return this
}

// Cobol85Parser tokens.
const (
	Cobol85ParserEOF                    = antlr.TokenEOF
	Cobol85ParserABORT                  = 1
	Cobol85ParserACCEPT                 = 2
	Cobol85ParserACCESS                 = 3
	Cobol85ParserADD                    = 4
	Cobol85ParserADDRESS                = 5
	Cobol85ParserADVANCING              = 6
	Cobol85ParserAFTER                  = 7
	Cobol85ParserALIGNED                = 8
	Cobol85ParserALL                    = 9
	Cobol85ParserALPHABET               = 10
	Cobol85ParserALPHABETIC             = 11
	Cobol85ParserALPHABETIC_LOWER       = 12
	Cobol85ParserALPHABETIC_UPPER       = 13
	Cobol85ParserALPHANUMERIC           = 14
	Cobol85ParserALPHANUMERIC_EDITED    = 15
	Cobol85ParserALSO                   = 16
	Cobol85ParserALTER                  = 17
	Cobol85ParserALTERNATE              = 18
	Cobol85ParserAND                    = 19
	Cobol85ParserANY                    = 20
	Cobol85ParserARE                    = 21
	Cobol85ParserAREA                   = 22
	Cobol85ParserAREAS                  = 23
	Cobol85ParserAS                     = 24
	Cobol85ParserASCENDING              = 25
	Cobol85ParserASCII                  = 26
	Cobol85ParserASSIGN                 = 27
	Cobol85ParserASSOCIATED_DATA        = 28
	Cobol85ParserASSOCIATED_DATA_LENGTH = 29
	Cobol85ParserAT                     = 30
	Cobol85ParserATTRIBUTE              = 31
	Cobol85ParserAUTHOR                 = 32
	Cobol85ParserAUTO                   = 33
	Cobol85ParserAUTO_SKIP              = 34
	Cobol85ParserBACKGROUND_COLOR       = 35
	Cobol85ParserBACKGROUND_COLOUR      = 36
	Cobol85ParserBASIS                  = 37
	Cobol85ParserBEEP                   = 38
	Cobol85ParserBEFORE                 = 39
	Cobol85ParserBEGINNING              = 40
	Cobol85ParserBELL                   = 41
	Cobol85ParserBINARY                 = 42
	Cobol85ParserBIT                    = 43
	Cobol85ParserBLANK                  = 44
	Cobol85ParserBLINK                  = 45
	Cobol85ParserBLOCK                  = 46
	Cobol85ParserBOUNDS                 = 47
	Cobol85ParserBOTTOM                 = 48
	Cobol85ParserBY                     = 49
	Cobol85ParserBYFUNCTION             = 50
	Cobol85ParserBYTITLE                = 51
	Cobol85ParserCALL                   = 52
	Cobol85ParserCANCEL                 = 53
	Cobol85ParserCAPABLE                = 54
	Cobol85ParserCCSVERSION             = 55
	Cobol85ParserCD                     = 56
	Cobol85ParserCF                     = 57
	Cobol85ParserCH                     = 58
	Cobol85ParserCHAINING               = 59
	Cobol85ParserCHANGED                = 60
	Cobol85ParserCHANNEL                = 61
	Cobol85ParserCHARACTER              = 62
	Cobol85ParserCHARACTERS             = 63
	Cobol85ParserCLASS                  = 64
	Cobol85ParserCLASS_ID               = 65
	Cobol85ParserCLOCK_UNITS            = 66
	Cobol85ParserCLOSE                  = 67
	Cobol85ParserCLOSE_DISPOSITION      = 68
	Cobol85ParserCOBOL                  = 69
	Cobol85ParserCODE                   = 70
	Cobol85ParserCODE_SET               = 71
	Cobol85ParserCOLLATING              = 72
	Cobol85ParserCOL                    = 73
	Cobol85ParserCOLUMN                 = 74
	Cobol85ParserCOM_REG                = 75
	Cobol85ParserCOMMA                  = 76
	Cobol85ParserCOMMITMENT             = 77
	Cobol85ParserCOMMON                 = 78
	Cobol85ParserCOMMUNICATION          = 79
	Cobol85ParserCOMP                   = 80
	Cobol85ParserCOMP_1                 = 81
	Cobol85ParserCOMP_2                 = 82
	Cobol85ParserCOMP_3                 = 83
	Cobol85ParserCOMP_4                 = 84
	Cobol85ParserCOMP_5                 = 85
	Cobol85ParserCOMPUTATIONAL          = 86
	Cobol85ParserCOMPUTATIONAL_1        = 87
	Cobol85ParserCOMPUTATIONAL_2        = 88
	Cobol85ParserCOMPUTATIONAL_3        = 89
	Cobol85ParserCOMPUTATIONAL_4        = 90
	Cobol85ParserCOMPUTATIONAL_5        = 91
	Cobol85ParserCOMPUTE                = 92
	Cobol85ParserCONFIGURATION          = 93
	Cobol85ParserCONTAINS               = 94
	Cobol85ParserCONTENT                = 95
	Cobol85ParserCONTINUE               = 96
	Cobol85ParserCONTROL                = 97
	Cobol85ParserCONTROL_POINT          = 98
	Cobol85ParserCONTROLS               = 99
	Cobol85ParserCONVENTION             = 100
	Cobol85ParserCONVERTING             = 101
	Cobol85ParserCOPY                   = 102
	Cobol85ParserCORR                   = 103
	Cobol85ParserCORRESPONDING          = 104
	Cobol85ParserCOUNT                  = 105
	Cobol85ParserCRUNCH                 = 106
	Cobol85ParserCURRENCY               = 107
	Cobol85ParserCURSOR                 = 108
	Cobol85ParserDATA                   = 109
	Cobol85ParserDATA_BASE              = 110
	Cobol85ParserDATE                   = 111
	Cobol85ParserDATE_COMPILED          = 112
	Cobol85ParserDATE_WRITTEN           = 113
	Cobol85ParserDAY                    = 114
	Cobol85ParserDAY_OF_WEEK            = 115
	Cobol85ParserDBCS                   = 116
	Cobol85ParserDE                     = 117
	Cobol85ParserDEBUG_CONTENTS         = 118
	Cobol85ParserDEBUG_ITEM             = 119
	Cobol85ParserDEBUG_LINE             = 120
	Cobol85ParserDEBUG_NAME             = 121
	Cobol85ParserDEBUG_SUB_1            = 122
	Cobol85ParserDEBUG_SUB_2            = 123
	Cobol85ParserDEBUG_SUB_3            = 124
	Cobol85ParserDEBUGGING              = 125
	Cobol85ParserDECIMAL_POINT          = 126
	Cobol85ParserDECLARATIVES           = 127
	Cobol85ParserDEFAULT                = 128
	Cobol85ParserDEFAULT_DISPLAY        = 129
	Cobol85ParserDEFINITION             = 130
	Cobol85ParserDELETE                 = 131
	Cobol85ParserDELIMITED              = 132
	Cobol85ParserDELIMITER              = 133
	Cobol85ParserDEPENDING              = 134
	Cobol85ParserDESCENDING             = 135
	Cobol85ParserDESTINATION            = 136
	Cobol85ParserDETAIL                 = 137
	Cobol85ParserDFHRESP                = 138
	Cobol85ParserDFHVALUE               = 139
	Cobol85ParserDISABLE                = 140
	Cobol85ParserDISK                   = 141
	Cobol85ParserDISPLAY                = 142
	Cobol85ParserDISPLAY_1              = 143
	Cobol85ParserDIVIDE                 = 144
	Cobol85ParserDIVISION               = 145
	Cobol85ParserDONTCARE               = 146
	Cobol85ParserDOUBLE                 = 147
	Cobol85ParserDOWN                   = 148
	Cobol85ParserDUPLICATES             = 149
	Cobol85ParserDYNAMIC                = 150
	Cobol85ParserEBCDIC                 = 151
	Cobol85ParserEGCS                   = 152
	Cobol85ParserEGI                    = 153
	Cobol85ParserELSE                   = 154
	Cobol85ParserEMI                    = 155
	Cobol85ParserEMPTY_CHECK            = 156
	Cobol85ParserENABLE                 = 157
	Cobol85ParserEND                    = 158
	Cobol85ParserEND_ACCEPT             = 159
	Cobol85ParserEND_ADD                = 160
	Cobol85ParserEND_CALL               = 161
	Cobol85ParserEND_COMPUTE            = 162
	Cobol85ParserEND_DELETE             = 163
	Cobol85ParserEND_DIVIDE             = 164
	Cobol85ParserEND_EVALUATE           = 165
	Cobol85ParserEND_IF                 = 166
	Cobol85ParserEND_MULTIPLY           = 167
	Cobol85ParserEND_OF_PAGE            = 168
	Cobol85ParserEND_PERFORM            = 169
	Cobol85ParserEND_READ               = 170
	Cobol85ParserEND_RECEIVE            = 171
	Cobol85ParserEND_RETURN             = 172
	Cobol85ParserEND_REWRITE            = 173
	Cobol85ParserEND_SEARCH             = 174
	Cobol85ParserEND_START              = 175
	Cobol85ParserEND_STRING             = 176
	Cobol85ParserEND_SUBTRACT           = 177
	Cobol85ParserEND_UNSTRING           = 178
	Cobol85ParserEND_WRITE              = 179
	Cobol85ParserENDING                 = 180
	Cobol85ParserENTER                  = 181
	Cobol85ParserENTRY                  = 182
	Cobol85ParserENTRY_PROCEDURE        = 183
	Cobol85ParserENVIRONMENT            = 184
	Cobol85ParserEOP                    = 185
	Cobol85ParserEQUAL                  = 186
	Cobol85ParserERASE                  = 187
	Cobol85ParserERROR                  = 188
	Cobol85ParserEOL                    = 189
	Cobol85ParserEOS                    = 190
	Cobol85ParserESCAPE                 = 191
	Cobol85ParserESI                    = 192
	Cobol85ParserEVALUATE               = 193
	Cobol85ParserEVENT                  = 194
	Cobol85ParserEVERY                  = 195
	Cobol85ParserEXCEPTION              = 196
	Cobol85ParserEXCLUSIVE              = 197
	Cobol85ParserEXHIBIT                = 198
	Cobol85ParserEXIT                   = 199
	Cobol85ParserEXPORT                 = 200
	Cobol85ParserEXTEND                 = 201
	Cobol85ParserEXTENDED               = 202
	Cobol85ParserEXTERNAL               = 203
	Cobol85ParserFALSE                  = 204
	Cobol85ParserFD                     = 205
	Cobol85ParserFILE                   = 206
	Cobol85ParserFILE_CONTROL           = 207
	Cobol85ParserFILLER                 = 208
	Cobol85ParserFINAL                  = 209
	Cobol85ParserFIRST                  = 210
	Cobol85ParserFOOTING                = 211
	Cobol85ParserFOR                    = 212
	Cobol85ParserFOREGROUND_COLOR       = 213
	Cobol85ParserFOREGROUND_COLOUR      = 214
	Cobol85ParserFROM                   = 215
	Cobol85ParserFULL                   = 216
	Cobol85ParserFUNCTION               = 217
	Cobol85ParserFUNCTIONNAME           = 218
	Cobol85ParserFUNCTION_POINTER       = 219
	Cobol85ParserGENERATE               = 220
	Cobol85ParserGOBACK                 = 221
	Cobol85ParserGIVING                 = 222
	Cobol85ParserGLOBAL                 = 223
	Cobol85ParserGO                     = 224
	Cobol85ParserGREATER                = 225
	Cobol85ParserGRID                   = 226
	Cobol85ParserGROUP                  = 227
	Cobol85ParserHEADING                = 228
	Cobol85ParserHIGHLIGHT              = 229
	Cobol85ParserHIGH_VALUE             = 230
	Cobol85ParserHIGH_VALUES            = 231
	Cobol85ParserI_O                    = 232
	Cobol85ParserI_O_CONTROL            = 233
	Cobol85ParserID                     = 234
	Cobol85ParserIDENTIFICATION         = 235
	Cobol85ParserIF                     = 236
	Cobol85ParserIMPLICIT               = 237
	Cobol85ParserIMPORT                 = 238
	Cobol85ParserIN                     = 239
	Cobol85ParserINDEX                  = 240
	Cobol85ParserINDEXED                = 241
	Cobol85ParserINDICATE               = 242
	Cobol85ParserINITIAL                = 243
	Cobol85ParserINITIALIZE             = 244
	Cobol85ParserINITIATE               = 245
	Cobol85ParserINPUT                  = 246
	Cobol85ParserINPUT_OUTPUT           = 247
	Cobol85ParserINSPECT                = 248
	Cobol85ParserINSTALLATION           = 249
	Cobol85ParserINTEGER                = 250
	Cobol85ParserINTO                   = 251
	Cobol85ParserINVALID                = 252
	Cobol85ParserINVOKE                 = 253
	Cobol85ParserIS                     = 254
	Cobol85ParserJUST                   = 255
	Cobol85ParserJUSTIFIED              = 256
	Cobol85ParserKANJI                  = 257
	Cobol85ParserKEPT                   = 258
	Cobol85ParserKEY                    = 259
	Cobol85ParserKEYBOARD               = 260
	Cobol85ParserLABEL                  = 261
	Cobol85ParserLANGUAGE               = 262
	Cobol85ParserLAST                   = 263
	Cobol85ParserLB                     = 264
	Cobol85ParserLD                     = 265
	Cobol85ParserLEADING                = 266
	Cobol85ParserLEFT                   = 267
	Cobol85ParserLEFTLINE               = 268
	Cobol85ParserLENGTH                 = 269
	Cobol85ParserLENGTH_CHECK           = 270
	Cobol85ParserLESS                   = 271
	Cobol85ParserLIBACCESS              = 272
	Cobol85ParserLIBPARAMETER           = 273
	Cobol85ParserLIBRARY                = 274
	Cobol85ParserLIMIT                  = 275
	Cobol85ParserLIMITS                 = 276
	Cobol85ParserLINAGE                 = 277
	Cobol85ParserLINAGE_COUNTER         = 278
	Cobol85ParserLINE                   = 279
	Cobol85ParserLINES                  = 280
	Cobol85ParserLINE_COUNTER           = 281
	Cobol85ParserLINKAGE                = 282
	Cobol85ParserLIST                   = 283
	Cobol85ParserLOCAL                  = 284
	Cobol85ParserLOCAL_STORAGE          = 285
	Cobol85ParserLOCK                   = 286
	Cobol85ParserLONG_DATE              = 287
	Cobol85ParserLONG_TIME              = 288
	Cobol85ParserLOWER                  = 289
	Cobol85ParserLOWLIGHT               = 290
	Cobol85ParserLOW_VALUE              = 291
	Cobol85ParserLOW_VALUES             = 292
	Cobol85ParserMEMORY                 = 293
	Cobol85ParserMERGE                  = 294
	Cobol85ParserMESSAGE                = 295
	Cobol85ParserMMDDYYYY               = 296
	Cobol85ParserMODE                   = 297
	Cobol85ParserMODULES                = 298
	Cobol85ParserMORE_LABELS            = 299
	Cobol85ParserMOVE                   = 300
	Cobol85ParserMULTIPLE               = 301
	Cobol85ParserMULTIPLY               = 302
	Cobol85ParserNAMED                  = 303
	Cobol85ParserNATIONAL               = 304
	Cobol85ParserNATIONAL_EDITED        = 305
	Cobol85ParserNATIVE                 = 306
	Cobol85ParserNEGATIVE               = 307
	Cobol85ParserNETWORK                = 308
	Cobol85ParserNEXT                   = 309
	Cobol85ParserNO                     = 310
	Cobol85ParserNO_ECHO                = 311
	Cobol85ParserNOT                    = 312
	Cobol85ParserNULL_                  = 313
	Cobol85ParserNULLS                  = 314
	Cobol85ParserNUMBER                 = 315
	Cobol85ParserNUMERIC                = 316
	Cobol85ParserNUMERIC_DATE           = 317
	Cobol85ParserNUMERIC_EDITED         = 318
	Cobol85ParserNUMERIC_TIME           = 319
	Cobol85ParserOBJECT_COMPUTER        = 320
	Cobol85ParserOCCURS                 = 321
	Cobol85ParserODT                    = 322
	Cobol85ParserOF                     = 323
	Cobol85ParserOFF                    = 324
	Cobol85ParserOMITTED                = 325
	Cobol85ParserON                     = 326
	Cobol85ParserOPEN                   = 327
	Cobol85ParserOPTIONAL               = 328
	Cobol85ParserOR                     = 329
	Cobol85ParserORDER                  = 330
	Cobol85ParserORDERLY                = 331
	Cobol85ParserORGANIZATION           = 332
	Cobol85ParserOTHER                  = 333
	Cobol85ParserOUTPUT                 = 334
	Cobol85ParserOVERFLOW               = 335
	Cobol85ParserOVERLINE               = 336
	Cobol85ParserOWN                    = 337
	Cobol85ParserPACKED_DECIMAL         = 338
	Cobol85ParserPADDING                = 339
	Cobol85ParserPAGE                   = 340
	Cobol85ParserPAGE_COUNTER           = 341
	Cobol85ParserPASSWORD               = 342
	Cobol85ParserPERFORM                = 343
	Cobol85ParserPF                     = 344
	Cobol85ParserPH                     = 345
	Cobol85ParserPIC                    = 346
	Cobol85ParserPICTURE                = 347
	Cobol85ParserPLUS                   = 348
	Cobol85ParserPOINTER                = 349
	Cobol85ParserPOSITION               = 350
	Cobol85ParserPOSITIVE               = 351
	Cobol85ParserPORT                   = 352
	Cobol85ParserPRINTER                = 353
	Cobol85ParserPRINTING               = 354
	Cobol85ParserPRIVATE                = 355
	Cobol85ParserPROCEDURE              = 356
	Cobol85ParserPROCEDURE_POINTER      = 357
	Cobol85ParserPROCEDURES             = 358
	Cobol85ParserPROCEED                = 359
	Cobol85ParserPROCESS                = 360
	Cobol85ParserPROGRAM                = 361
	Cobol85ParserPROGRAM_ID             = 362
	Cobol85ParserPROGRAM_LIBRARY        = 363
	Cobol85ParserPROMPT                 = 364
	Cobol85ParserPURGE                  = 365
	Cobol85ParserQUEUE                  = 366
	Cobol85ParserQUOTE                  = 367
	Cobol85ParserQUOTES                 = 368
	Cobol85ParserRANDOM                 = 369
	Cobol85ParserREADER                 = 370
	Cobol85ParserREMOTE                 = 371
	Cobol85ParserRD                     = 372
	Cobol85ParserREAL                   = 373
	Cobol85ParserREAD                   = 374
	Cobol85ParserRECEIVE                = 375
	Cobol85ParserRECEIVED               = 376
	Cobol85ParserRECORD                 = 377
	Cobol85ParserRECORDING              = 378
	Cobol85ParserRECORDS                = 379
	Cobol85ParserRECURSIVE              = 380
	Cobol85ParserREDEFINES              = 381
	Cobol85ParserREEL                   = 382
	Cobol85ParserREF                    = 383
	Cobol85ParserREFERENCE              = 384
	Cobol85ParserREFERENCES             = 385
	Cobol85ParserRELATIVE               = 386
	Cobol85ParserRELEASE                = 387
	Cobol85ParserREMAINDER              = 388
	Cobol85ParserREMARKS                = 389
	Cobol85ParserREMOVAL                = 390
	Cobol85ParserREMOVE                 = 391
	Cobol85ParserRENAMES                = 392
	Cobol85ParserREPLACE                = 393
	Cobol85ParserREPLACING              = 394
	Cobol85ParserREPORT                 = 395
	Cobol85ParserREPORTING              = 396
	Cobol85ParserREPORTS                = 397
	Cobol85ParserREQUIRED               = 398
	Cobol85ParserRERUN                  = 399
	Cobol85ParserRESERVE                = 400
	Cobol85ParserREVERSE_VIDEO          = 401
	Cobol85ParserRESET                  = 402
	Cobol85ParserRETURN                 = 403
	Cobol85ParserRETURN_CODE            = 404
	Cobol85ParserRETURNING              = 405
	Cobol85ParserREVERSED               = 406
	Cobol85ParserREWIND                 = 407
	Cobol85ParserREWRITE                = 408
	Cobol85ParserRF                     = 409
	Cobol85ParserRH                     = 410
	Cobol85ParserRIGHT                  = 411
	Cobol85ParserROUNDED                = 412
	Cobol85ParserRUN                    = 413
	Cobol85ParserSAME                   = 414
	Cobol85ParserSAVE                   = 415
	Cobol85ParserSCREEN                 = 416
	Cobol85ParserSD                     = 417
	Cobol85ParserSEARCH                 = 418
	Cobol85ParserSECTION                = 419
	Cobol85ParserSECURE                 = 420
	Cobol85ParserSECURITY               = 421
	Cobol85ParserSEGMENT                = 422
	Cobol85ParserSEGMENT_LIMIT          = 423
	Cobol85ParserSELECT                 = 424
	Cobol85ParserSEND                   = 425
	Cobol85ParserSENTENCE               = 426
	Cobol85ParserSEPARATE               = 427
	Cobol85ParserSEQUENCE               = 428
	Cobol85ParserSEQUENTIAL             = 429
	Cobol85ParserSET                    = 430
	Cobol85ParserSHARED                 = 431
	Cobol85ParserSHAREDBYALL            = 432
	Cobol85ParserSHAREDBYRUNUNIT        = 433
	Cobol85ParserSHARING                = 434
	Cobol85ParserSHIFT_IN               = 435
	Cobol85ParserSHIFT_OUT              = 436
	Cobol85ParserSHORT_DATE             = 437
	Cobol85ParserSIGN                   = 438
	Cobol85ParserSIZE                   = 439
	Cobol85ParserSORT                   = 440
	Cobol85ParserSORT_CONTROL           = 441
	Cobol85ParserSORT_CORE_SIZE         = 442
	Cobol85ParserSORT_FILE_SIZE         = 443
	Cobol85ParserSORT_MERGE             = 444
	Cobol85ParserSORT_MESSAGE           = 445
	Cobol85ParserSORT_MODE_SIZE         = 446
	Cobol85ParserSORT_RETURN            = 447
	Cobol85ParserSOURCE                 = 448
	Cobol85ParserSOURCE_COMPUTER        = 449
	Cobol85ParserSPACE                  = 450
	Cobol85ParserSPACES                 = 451
	Cobol85ParserSPECIAL_NAMES          = 452
	Cobol85ParserSTANDARD               = 453
	Cobol85ParserSTANDARD_1             = 454
	Cobol85ParserSTANDARD_2             = 455
	Cobol85ParserSTART                  = 456
	Cobol85ParserSTATUS                 = 457
	Cobol85ParserSTOP                   = 458
	Cobol85ParserSTRING                 = 459
	Cobol85ParserSUB_QUEUE_1            = 460
	Cobol85ParserSUB_QUEUE_2            = 461
	Cobol85ParserSUB_QUEUE_3            = 462
	Cobol85ParserSUBTRACT               = 463
	Cobol85ParserSUM                    = 464
	Cobol85ParserSUPPRESS               = 465
	Cobol85ParserSYMBOL                 = 466
	Cobol85ParserSYMBOLIC               = 467
	Cobol85ParserSYNC                   = 468
	Cobol85ParserSYNCHRONIZED           = 469
	Cobol85ParserTABLE                  = 470
	Cobol85ParserTALLY                  = 471
	Cobol85ParserTALLYING               = 472
	Cobol85ParserTASK                   = 473
	Cobol85ParserTAPE                   = 474
	Cobol85ParserTERMINAL               = 475
	Cobol85ParserTERMINATE              = 476
	Cobol85ParserTEST                   = 477
	Cobol85ParserTEXT                   = 478
	Cobol85ParserTHAN                   = 479
	Cobol85ParserTHEN                   = 480
	Cobol85ParserTHREAD                 = 481
	Cobol85ParserTHREAD_LOCAL           = 482
	Cobol85ParserTHROUGH                = 483
	Cobol85ParserTHRU                   = 484
	Cobol85ParserTIME                   = 485
	Cobol85ParserTIMER                  = 486
	Cobol85ParserTIMES                  = 487
	Cobol85ParserTITLE                  = 488
	Cobol85ParserTO                     = 489
	Cobol85ParserTODAYS_DATE            = 490
	Cobol85ParserTODAYS_NAME            = 491
	Cobol85ParserTOP                    = 492
	Cobol85ParserTRAILING               = 493
	Cobol85ParserTRUE                   = 494
	Cobol85ParserTRUNCATED              = 495
	Cobol85ParserTYPE                   = 496
	Cobol85ParserTYPEDEF                = 497
	Cobol85ParserUNDERLINE              = 498
	Cobol85ParserUNIT                   = 499
	Cobol85ParserUNSTRING               = 500
	Cobol85ParserUNTIL                  = 501
	Cobol85ParserUP                     = 502
	Cobol85ParserUPON                   = 503
	Cobol85ParserUSAGE                  = 504
	Cobol85ParserUSE                    = 505
	Cobol85ParserUSING                  = 506
	Cobol85ParserVALUE                  = 507
	Cobol85ParserVALUES                 = 508
	Cobol85ParserVARYING                = 509
	Cobol85ParserVIRTUAL                = 510
	Cobol85ParserWAIT                   = 511
	Cobol85ParserWHEN                   = 512
	Cobol85ParserWHEN_COMPILED          = 513
	Cobol85ParserWITH                   = 514
	Cobol85ParserWORDS                  = 515
	Cobol85ParserWORKING_STORAGE        = 516
	Cobol85ParserWRITE                  = 517
	Cobol85ParserYEAR                   = 518
	Cobol85ParserYYYYMMDD               = 519
	Cobol85ParserYYYYDDD                = 520
	Cobol85ParserZERO                   = 521
	Cobol85ParserZERO_FILL              = 522
	Cobol85ParserZEROS                  = 523
	Cobol85ParserZEROES                 = 524
	Cobol85ParserAMPCHAR                = 525
	Cobol85ParserASTERISKCHAR           = 526
	Cobol85ParserDOUBLEASTERISKCHAR     = 527
	Cobol85ParserCOLONCHAR              = 528
	Cobol85ParserCOMMACHAR              = 529
	Cobol85ParserCOMMENTENTRYTAG        = 530
	Cobol85ParserCOMMENTTAG             = 531
	Cobol85ParserDOLLARCHAR             = 532
	Cobol85ParserDOUBLEQUOTE            = 533
	Cobol85ParserDOT_FS                 = 534
	Cobol85ParserDOT                    = 535
	Cobol85ParserEQUALCHAR              = 536
	Cobol85ParserEXECCICSTAG            = 537
	Cobol85ParserEXECSQLTAG             = 538
	Cobol85ParserEXECSQLIMSTAG          = 539
	Cobol85ParserLESSTHANCHAR           = 540
	Cobol85ParserLESSTHANOREQUAL        = 541
	Cobol85ParserLPARENCHAR             = 542
	Cobol85ParserMINUSCHAR              = 543
	Cobol85ParserMORETHANCHAR           = 544
	Cobol85ParserMORETHANOREQUAL        = 545
	Cobol85ParserNOTEQUALCHAR           = 546
	Cobol85ParserPLUSCHAR               = 547
	Cobol85ParserSINGLEQUOTE            = 548
	Cobol85ParserRPARENCHAR             = 549
	Cobol85ParserSLASHCHAR              = 550
	Cobol85ParserNONNUMERICLITERAL      = 551
	Cobol85ParserLEVEL_NUMBER_66        = 552
	Cobol85ParserLEVEL_NUMBER_77        = 553
	Cobol85ParserLEVEL_NUMBER_88        = 554
	Cobol85ParserINTEGERLITERAL         = 555
	Cobol85ParserNUMERICLITERAL         = 556
	Cobol85ParserIDENTIFIER             = 557
	Cobol85ParserNEWLINE                = 558
	Cobol85ParserEXECCICSLINE           = 559
	Cobol85ParserEXECSQLIMSLINE         = 560
	Cobol85ParserEXECSQLLINE            = 561
	Cobol85ParserCOMMENTENTRYLINE       = 562
	Cobol85ParserCOMMENTLINE            = 563
	Cobol85ParserWS                     = 564
	Cobol85ParserSEPARATOR              = 565
)

// Cobol85Parser rules.
const (
	Cobol85ParserRULE_startRule                                     = 0
	Cobol85ParserRULE_compilationUnit                               = 1
	Cobol85ParserRULE_programUnit                                   = 2
	Cobol85ParserRULE_endProgramStatement                           = 3
	Cobol85ParserRULE_identificationDivision                        = 4
	Cobol85ParserRULE_identificationDivisionBody                    = 5
	Cobol85ParserRULE_programIdParagraph                            = 6
	Cobol85ParserRULE_authorParagraph                               = 7
	Cobol85ParserRULE_installationParagraph                         = 8
	Cobol85ParserRULE_dateWrittenParagraph                          = 9
	Cobol85ParserRULE_dateCompiledParagraph                         = 10
	Cobol85ParserRULE_securityParagraph                             = 11
	Cobol85ParserRULE_remarksParagraph                              = 12
	Cobol85ParserRULE_environmentDivision                           = 13
	Cobol85ParserRULE_environmentDivisionBody                       = 14
	Cobol85ParserRULE_configurationSection                          = 15
	Cobol85ParserRULE_configurationSectionParagraph                 = 16
	Cobol85ParserRULE_sourceComputerParagraph                       = 17
	Cobol85ParserRULE_objectComputerParagraph                       = 18
	Cobol85ParserRULE_objectComputerClause                          = 19
	Cobol85ParserRULE_memorySizeClause                              = 20
	Cobol85ParserRULE_diskSizeClause                                = 21
	Cobol85ParserRULE_collatingSequenceClause                       = 22
	Cobol85ParserRULE_collatingSequenceClauseAlphanumeric           = 23
	Cobol85ParserRULE_collatingSequenceClauseNational               = 24
	Cobol85ParserRULE_segmentLimitClause                            = 25
	Cobol85ParserRULE_characterSetClause                            = 26
	Cobol85ParserRULE_specialNamesParagraph                         = 27
	Cobol85ParserRULE_specialNameClause                             = 28
	Cobol85ParserRULE_alphabetClause                                = 29
	Cobol85ParserRULE_alphabetClauseFormat1                         = 30
	Cobol85ParserRULE_alphabetLiterals                              = 31
	Cobol85ParserRULE_alphabetThrough                               = 32
	Cobol85ParserRULE_alphabetAlso                                  = 33
	Cobol85ParserRULE_alphabetClauseFormat2                         = 34
	Cobol85ParserRULE_channelClause                                 = 35
	Cobol85ParserRULE_classClause                                   = 36
	Cobol85ParserRULE_classClauseThrough                            = 37
	Cobol85ParserRULE_classClauseFrom                               = 38
	Cobol85ParserRULE_classClauseTo                                 = 39
	Cobol85ParserRULE_currencySignClause                            = 40
	Cobol85ParserRULE_decimalPointClause                            = 41
	Cobol85ParserRULE_defaultComputationalSignClause                = 42
	Cobol85ParserRULE_defaultDisplaySignClause                      = 43
	Cobol85ParserRULE_environmentSwitchNameClause                   = 44
	Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase = 45
	Cobol85ParserRULE_odtClause                                     = 46
	Cobol85ParserRULE_reserveNetworkClause                          = 47
	Cobol85ParserRULE_symbolicCharactersClause                      = 48
	Cobol85ParserRULE_symbolicCharacters                            = 49
	Cobol85ParserRULE_inputOutputSection                            = 50
	Cobol85ParserRULE_inputOutputSectionParagraph                   = 51
	Cobol85ParserRULE_fileControlParagraph                          = 52
	Cobol85ParserRULE_fileControlEntry                              = 53
	Cobol85ParserRULE_selectClause                                  = 54
	Cobol85ParserRULE_fileControlClause                             = 55
	Cobol85ParserRULE_assignClause                                  = 56
	Cobol85ParserRULE_reserveClause                                 = 57
	Cobol85ParserRULE_organizationClause                            = 58
	Cobol85ParserRULE_paddingCharacterClause                        = 59
	Cobol85ParserRULE_recordDelimiterClause                         = 60
	Cobol85ParserRULE_accessModeClause                              = 61
	Cobol85ParserRULE_recordKeyClause                               = 62
	Cobol85ParserRULE_alternateRecordKeyClause                      = 63
	Cobol85ParserRULE_passwordClause                                = 64
	Cobol85ParserRULE_fileStatusClause                              = 65
	Cobol85ParserRULE_relativeKeyClause                             = 66
	Cobol85ParserRULE_ioControlParagraph                            = 67
	Cobol85ParserRULE_ioControlClause                               = 68
	Cobol85ParserRULE_rerunClause                                   = 69
	Cobol85ParserRULE_rerunEveryRecords                             = 70
	Cobol85ParserRULE_rerunEveryOf                                  = 71
	Cobol85ParserRULE_rerunEveryClock                               = 72
	Cobol85ParserRULE_sameClause                                    = 73
	Cobol85ParserRULE_multipleFileClause                            = 74
	Cobol85ParserRULE_multipleFilePosition                          = 75
	Cobol85ParserRULE_commitmentControlClause                       = 76
	Cobol85ParserRULE_dataDivision                                  = 77
	Cobol85ParserRULE_dataDivisionSection                           = 78
	Cobol85ParserRULE_fileSection                                   = 79
	Cobol85ParserRULE_fileDescriptionEntry                          = 80
	Cobol85ParserRULE_fileDescriptionEntryClause                    = 81
	Cobol85ParserRULE_externalClause                                = 82
	Cobol85ParserRULE_globalClause                                  = 83
	Cobol85ParserRULE_blockContainsClause                           = 84
	Cobol85ParserRULE_blockContainsTo                               = 85
	Cobol85ParserRULE_recordContainsClause                          = 86
	Cobol85ParserRULE_recordContainsClauseFormat1                   = 87
	Cobol85ParserRULE_recordContainsClauseFormat2                   = 88
	Cobol85ParserRULE_recordContainsClauseFormat3                   = 89
	Cobol85ParserRULE_recordContainsTo                              = 90
	Cobol85ParserRULE_labelRecordsClause                            = 91
	Cobol85ParserRULE_valueOfClause                                 = 92
	Cobol85ParserRULE_valuePair                                     = 93
	Cobol85ParserRULE_dataRecordsClause                             = 94
	Cobol85ParserRULE_linageClause                                  = 95
	Cobol85ParserRULE_linageAt                                      = 96
	Cobol85ParserRULE_linageFootingAt                               = 97
	Cobol85ParserRULE_linageLinesAtTop                              = 98
	Cobol85ParserRULE_linageLinesAtBottom                           = 99
	Cobol85ParserRULE_recordingModeClause                           = 100
	Cobol85ParserRULE_modeStatement                                 = 101
	Cobol85ParserRULE_codeSetClause                                 = 102
	Cobol85ParserRULE_reportClause                                  = 103
	Cobol85ParserRULE_dataBaseSection                               = 104
	Cobol85ParserRULE_dataBaseSectionEntry                          = 105
	Cobol85ParserRULE_workingStorageSection                         = 106
	Cobol85ParserRULE_linkageSection                                = 107
	Cobol85ParserRULE_communicationSection                          = 108
	Cobol85ParserRULE_communicationDescriptionEntry                 = 109
	Cobol85ParserRULE_communicationDescriptionEntryFormat1          = 110
	Cobol85ParserRULE_communicationDescriptionEntryFormat2          = 111
	Cobol85ParserRULE_communicationDescriptionEntryFormat3          = 112
	Cobol85ParserRULE_destinationCountClause                        = 113
	Cobol85ParserRULE_destinationTableClause                        = 114
	Cobol85ParserRULE_endKeyClause                                  = 115
	Cobol85ParserRULE_errorKeyClause                                = 116
	Cobol85ParserRULE_messageCountClause                            = 117
	Cobol85ParserRULE_messageDateClause                             = 118
	Cobol85ParserRULE_messageTimeClause                             = 119
	Cobol85ParserRULE_statusKeyClause                               = 120
	Cobol85ParserRULE_symbolicDestinationClause                     = 121
	Cobol85ParserRULE_symbolicQueueClause                           = 122
	Cobol85ParserRULE_symbolicSourceClause                          = 123
	Cobol85ParserRULE_symbolicTerminalClause                        = 124
	Cobol85ParserRULE_symbolicSubQueueClause                        = 125
	Cobol85ParserRULE_textLengthClause                              = 126
	Cobol85ParserRULE_localStorageSection                           = 127
	Cobol85ParserRULE_screenSection                                 = 128
	Cobol85ParserRULE_screenDescriptionEntry                        = 129
	Cobol85ParserRULE_screenDescriptionBlankClause                  = 130
	Cobol85ParserRULE_screenDescriptionBellClause                   = 131
	Cobol85ParserRULE_screenDescriptionBlinkClause                  = 132
	Cobol85ParserRULE_screenDescriptionEraseClause                  = 133
	Cobol85ParserRULE_screenDescriptionLightClause                  = 134
	Cobol85ParserRULE_screenDescriptionGridClause                   = 135
	Cobol85ParserRULE_screenDescriptionReverseVideoClause           = 136
	Cobol85ParserRULE_screenDescriptionUnderlineClause              = 137
	Cobol85ParserRULE_screenDescriptionSizeClause                   = 138
	Cobol85ParserRULE_screenDescriptionLineClause                   = 139
	Cobol85ParserRULE_screenDescriptionColumnClause                 = 140
	Cobol85ParserRULE_screenDescriptionForegroundColorClause        = 141
	Cobol85ParserRULE_screenDescriptionBackgroundColorClause        = 142
	Cobol85ParserRULE_screenDescriptionControlClause                = 143
	Cobol85ParserRULE_screenDescriptionValueClause                  = 144
	Cobol85ParserRULE_screenDescriptionPictureClause                = 145
	Cobol85ParserRULE_screenDescriptionFromClause                   = 146
	Cobol85ParserRULE_screenDescriptionToClause                     = 147
	Cobol85ParserRULE_screenDescriptionUsingClause                  = 148
	Cobol85ParserRULE_screenDescriptionUsageClause                  = 149
	Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause          = 150
	Cobol85ParserRULE_screenDescriptionJustifiedClause              = 151
	Cobol85ParserRULE_screenDescriptionSignClause                   = 152
	Cobol85ParserRULE_screenDescriptionAutoClause                   = 153
	Cobol85ParserRULE_screenDescriptionSecureClause                 = 154
	Cobol85ParserRULE_screenDescriptionRequiredClause               = 155
	Cobol85ParserRULE_screenDescriptionPromptClause                 = 156
	Cobol85ParserRULE_screenDescriptionPromptOccursClause           = 157
	Cobol85ParserRULE_screenDescriptionFullClause                   = 158
	Cobol85ParserRULE_screenDescriptionZeroFillClause               = 159
	Cobol85ParserRULE_reportSection                                 = 160
	Cobol85ParserRULE_reportDescription                             = 161
	Cobol85ParserRULE_reportDescriptionEntry                        = 162
	Cobol85ParserRULE_reportDescriptionGlobalClause                 = 163
	Cobol85ParserRULE_reportDescriptionPageLimitClause              = 164
	Cobol85ParserRULE_reportDescriptionHeadingClause                = 165
	Cobol85ParserRULE_reportDescriptionFirstDetailClause            = 166
	Cobol85ParserRULE_reportDescriptionLastDetailClause             = 167
	Cobol85ParserRULE_reportDescriptionFootingClause                = 168
	Cobol85ParserRULE_reportGroupDescriptionEntry                   = 169
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat1            = 170
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat2            = 171
	Cobol85ParserRULE_reportGroupDescriptionEntryFormat3            = 172
	Cobol85ParserRULE_reportGroupBlankWhenZeroClause                = 173
	Cobol85ParserRULE_reportGroupColumnNumberClause                 = 174
	Cobol85ParserRULE_reportGroupIndicateClause                     = 175
	Cobol85ParserRULE_reportGroupJustifiedClause                    = 176
	Cobol85ParserRULE_reportGroupLineNumberClause                   = 177
	Cobol85ParserRULE_reportGroupLineNumberNextPage                 = 178
	Cobol85ParserRULE_reportGroupLineNumberPlus                     = 179
	Cobol85ParserRULE_reportGroupNextGroupClause                    = 180
	Cobol85ParserRULE_reportGroupNextGroupPlus                      = 181
	Cobol85ParserRULE_reportGroupNextGroupNextPage                  = 182
	Cobol85ParserRULE_reportGroupPictureClause                      = 183
	Cobol85ParserRULE_reportGroupResetClause                        = 184
	Cobol85ParserRULE_reportGroupSignClause                         = 185
	Cobol85ParserRULE_reportGroupSourceClause                       = 186
	Cobol85ParserRULE_reportGroupSumClause                          = 187
	Cobol85ParserRULE_reportGroupTypeClause                         = 188
	Cobol85ParserRULE_reportGroupTypeReportHeading                  = 189
	Cobol85ParserRULE_reportGroupTypePageHeading                    = 190
	Cobol85ParserRULE_reportGroupTypeControlHeading                 = 191
	Cobol85ParserRULE_reportGroupTypeDetail                         = 192
	Cobol85ParserRULE_reportGroupTypeControlFooting                 = 193
	Cobol85ParserRULE_reportGroupUsageClause                        = 194
	Cobol85ParserRULE_reportGroupTypePageFooting                    = 195
	Cobol85ParserRULE_reportGroupTypeReportFooting                  = 196
	Cobol85ParserRULE_reportGroupValueClause                        = 197
	Cobol85ParserRULE_programLibrarySection                         = 198
	Cobol85ParserRULE_libraryDescriptionEntry                       = 199
	Cobol85ParserRULE_libraryDescriptionEntryFormat1                = 200
	Cobol85ParserRULE_libraryDescriptionEntryFormat2                = 201
	Cobol85ParserRULE_libraryAttributeClauseFormat1                 = 202
	Cobol85ParserRULE_libraryAttributeClauseFormat2                 = 203
	Cobol85ParserRULE_libraryAttributeFunction                      = 204
	Cobol85ParserRULE_libraryAttributeParameter                     = 205
	Cobol85ParserRULE_libraryAttributeTitle                         = 206
	Cobol85ParserRULE_libraryEntryProcedureClauseFormat1            = 207
	Cobol85ParserRULE_libraryEntryProcedureClauseFormat2            = 208
	Cobol85ParserRULE_libraryEntryProcedureForClause                = 209
	Cobol85ParserRULE_libraryEntryProcedureGivingClause             = 210
	Cobol85ParserRULE_libraryEntryProcedureUsingClause              = 211
	Cobol85ParserRULE_libraryEntryProcedureUsingName                = 212
	Cobol85ParserRULE_libraryEntryProcedureWithClause               = 213
	Cobol85ParserRULE_libraryEntryProcedureWithName                 = 214
	Cobol85ParserRULE_libraryIsCommonClause                         = 215
	Cobol85ParserRULE_libraryIsGlobalClause                         = 216
	Cobol85ParserRULE_dataDescriptionEntry                          = 217
	Cobol85ParserRULE_dataDescriptionEntryFormat1                   = 218
	Cobol85ParserRULE_dataDescriptionEntryFormat2                   = 219
	Cobol85ParserRULE_dataDescriptionEntryFormat3                   = 220
	Cobol85ParserRULE_dataDescriptionEntryExecSql                   = 221
	Cobol85ParserRULE_dataAlignedClause                             = 222
	Cobol85ParserRULE_dataBlankWhenZeroClause                       = 223
	Cobol85ParserRULE_dataCommonOwnLocalClause                      = 224
	Cobol85ParserRULE_dataExternalClause                            = 225
	Cobol85ParserRULE_dataGlobalClause                              = 226
	Cobol85ParserRULE_dataIntegerStringClause                       = 227
	Cobol85ParserRULE_dataJustifiedClause                           = 228
	Cobol85ParserRULE_dataOccursClause                              = 229
	Cobol85ParserRULE_dataOccursTo                                  = 230
	Cobol85ParserRULE_dataOccursSort                                = 231
	Cobol85ParserRULE_dataPictureClause                             = 232
	Cobol85ParserRULE_pictureString                                 = 233
	Cobol85ParserRULE_pictureChars                                  = 234
	Cobol85ParserRULE_pictureCardinality                            = 235
	Cobol85ParserRULE_dataReceivedByClause                          = 236
	Cobol85ParserRULE_dataRecordAreaClause                          = 237
	Cobol85ParserRULE_dataRedefinesClause                           = 238
	Cobol85ParserRULE_dataRenamesClause                             = 239
	Cobol85ParserRULE_dataSignClause                                = 240
	Cobol85ParserRULE_dataSynchronizedClause                        = 241
	Cobol85ParserRULE_dataThreadLocalClause                         = 242
	Cobol85ParserRULE_dataTypeClause                                = 243
	Cobol85ParserRULE_dataTypeDefClause                             = 244
	Cobol85ParserRULE_dataUsageClause                               = 245
	Cobol85ParserRULE_dataUsingClause                               = 246
	Cobol85ParserRULE_dataValueClause                               = 247
	Cobol85ParserRULE_dataValueInterval                             = 248
	Cobol85ParserRULE_dataValueIntervalFrom                         = 249
	Cobol85ParserRULE_dataValueIntervalTo                           = 250
	Cobol85ParserRULE_dataWithLowerBoundsClause                     = 251
	Cobol85ParserRULE_procedureDivision                             = 252
	Cobol85ParserRULE_procedureDivisionUsingClause                  = 253
	Cobol85ParserRULE_procedureDivisionGivingClause                 = 254
	Cobol85ParserRULE_procedureDivisionUsingParameter               = 255
	Cobol85ParserRULE_procedureDivisionByReferencePhrase            = 256
	Cobol85ParserRULE_procedureDivisionByReference                  = 257
	Cobol85ParserRULE_procedureDivisionByValuePhrase                = 258
	Cobol85ParserRULE_procedureDivisionByValue                      = 259
	Cobol85ParserRULE_procedureDeclaratives                         = 260
	Cobol85ParserRULE_procedureDeclarative                          = 261
	Cobol85ParserRULE_procedureSectionHeader                        = 262
	Cobol85ParserRULE_procedureDivisionBody                         = 263
	Cobol85ParserRULE_procedureSection                              = 264
	Cobol85ParserRULE_paragraphs                                    = 265
	Cobol85ParserRULE_paragraph                                     = 266
	Cobol85ParserRULE_sentence                                      = 267
	Cobol85ParserRULE_statement                                     = 268
	Cobol85ParserRULE_acceptStatement                               = 269
	Cobol85ParserRULE_acceptFromDateStatement                       = 270
	Cobol85ParserRULE_acceptFromMnemonicStatement                   = 271
	Cobol85ParserRULE_acceptFromEscapeKeyStatement                  = 272
	Cobol85ParserRULE_acceptMessageCountStatement                   = 273
	Cobol85ParserRULE_addStatement                                  = 274
	Cobol85ParserRULE_addToStatement                                = 275
	Cobol85ParserRULE_addToGivingStatement                          = 276
	Cobol85ParserRULE_addCorrespondingStatement                     = 277
	Cobol85ParserRULE_addFrom                                       = 278
	Cobol85ParserRULE_addTo                                         = 279
	Cobol85ParserRULE_addToGiving                                   = 280
	Cobol85ParserRULE_addGiving                                     = 281
	Cobol85ParserRULE_alteredGoTo                                   = 282
	Cobol85ParserRULE_alterStatement                                = 283
	Cobol85ParserRULE_alterProceedTo                                = 284
	Cobol85ParserRULE_callStatement                                 = 285
	Cobol85ParserRULE_callUsingPhrase                               = 286
	Cobol85ParserRULE_callUsingParameter                            = 287
	Cobol85ParserRULE_callByReferencePhrase                         = 288
	Cobol85ParserRULE_callByReference                               = 289
	Cobol85ParserRULE_callByValuePhrase                             = 290
	Cobol85ParserRULE_callByValue                                   = 291
	Cobol85ParserRULE_callByContentPhrase                           = 292
	Cobol85ParserRULE_callByContent                                 = 293
	Cobol85ParserRULE_callGivingPhrase                              = 294
	Cobol85ParserRULE_cancelStatement                               = 295
	Cobol85ParserRULE_cancelCall                                    = 296
	Cobol85ParserRULE_closeStatement                                = 297
	Cobol85ParserRULE_closeFile                                     = 298
	Cobol85ParserRULE_closeReelUnitStatement                        = 299
	Cobol85ParserRULE_closeRelativeStatement                        = 300
	Cobol85ParserRULE_closePortFileIOStatement                      = 301
	Cobol85ParserRULE_closePortFileIOUsing                          = 302
	Cobol85ParserRULE_closePortFileIOUsingCloseDisposition          = 303
	Cobol85ParserRULE_closePortFileIOUsingAssociatedData            = 304
	Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength      = 305
	Cobol85ParserRULE_computeStatement                              = 306
	Cobol85ParserRULE_computeStore                                  = 307
	Cobol85ParserRULE_continueStatement                             = 308
	Cobol85ParserRULE_deleteStatement                               = 309
	Cobol85ParserRULE_disableStatement                              = 310
	Cobol85ParserRULE_displayStatement                              = 311
	Cobol85ParserRULE_displayOperand                                = 312
	Cobol85ParserRULE_displayAt                                     = 313
	Cobol85ParserRULE_displayUpon                                   = 314
	Cobol85ParserRULE_displayWith                                   = 315
	Cobol85ParserRULE_divideStatement                               = 316
	Cobol85ParserRULE_divideIntoStatement                           = 317
	Cobol85ParserRULE_divideIntoGivingStatement                     = 318
	Cobol85ParserRULE_divideByGivingStatement                       = 319
	Cobol85ParserRULE_divideGivingPhrase                            = 320
	Cobol85ParserRULE_divideInto                                    = 321
	Cobol85ParserRULE_divideGiving                                  = 322
	Cobol85ParserRULE_divideRemainder                               = 323
	Cobol85ParserRULE_enableStatement                               = 324
	Cobol85ParserRULE_entryStatement                                = 325
	Cobol85ParserRULE_evaluateStatement                             = 326
	Cobol85ParserRULE_evaluateSelect                                = 327
	Cobol85ParserRULE_evaluateAlsoSelect                            = 328
	Cobol85ParserRULE_evaluateWhenPhrase                            = 329
	Cobol85ParserRULE_evaluateWhen                                  = 330
	Cobol85ParserRULE_evaluateCondition                             = 331
	Cobol85ParserRULE_evaluateThrough                               = 332
	Cobol85ParserRULE_evaluateAlsoCondition                         = 333
	Cobol85ParserRULE_evaluateWhenOther                             = 334
	Cobol85ParserRULE_evaluateValue                                 = 335
	Cobol85ParserRULE_execCicsStatement                             = 336
	Cobol85ParserRULE_execSqlStatement                              = 337
	Cobol85ParserRULE_execSqlImsStatement                           = 338
	Cobol85ParserRULE_exhibitStatement                              = 339
	Cobol85ParserRULE_exhibitOperand                                = 340
	Cobol85ParserRULE_exitStatement                                 = 341
	Cobol85ParserRULE_generateStatement                             = 342
	Cobol85ParserRULE_gobackStatement                               = 343
	Cobol85ParserRULE_goToStatement                                 = 344
	Cobol85ParserRULE_goToStatementSimple                           = 345
	Cobol85ParserRULE_goToDependingOnStatement                      = 346
	Cobol85ParserRULE_ifStatement                                   = 347
	Cobol85ParserRULE_ifThen                                        = 348
	Cobol85ParserRULE_ifElse                                        = 349
	Cobol85ParserRULE_initializeStatement                           = 350
	Cobol85ParserRULE_initializeReplacingPhrase                     = 351
	Cobol85ParserRULE_initializeReplacingBy                         = 352
	Cobol85ParserRULE_initiateStatement                             = 353
	Cobol85ParserRULE_inspectStatement                              = 354
	Cobol85ParserRULE_inspectTallyingPhrase                         = 355
	Cobol85ParserRULE_inspectReplacingPhrase                        = 356
	Cobol85ParserRULE_inspectTallyingReplacingPhrase                = 357
	Cobol85ParserRULE_inspectConvertingPhrase                       = 358
	Cobol85ParserRULE_inspectFor                                    = 359
	Cobol85ParserRULE_inspectCharacters                             = 360
	Cobol85ParserRULE_inspectReplacingCharacters                    = 361
	Cobol85ParserRULE_inspectAllLeadings                            = 362
	Cobol85ParserRULE_inspectReplacingAllLeadings                   = 363
	Cobol85ParserRULE_inspectAllLeading                             = 364
	Cobol85ParserRULE_inspectReplacingAllLeading                    = 365
	Cobol85ParserRULE_inspectBy                                     = 366
	Cobol85ParserRULE_inspectTo                                     = 367
	Cobol85ParserRULE_inspectBeforeAfter                            = 368
	Cobol85ParserRULE_mergeStatement                                = 369
	Cobol85ParserRULE_mergeOnKeyClause                              = 370
	Cobol85ParserRULE_mergeCollatingSequencePhrase                  = 371
	Cobol85ParserRULE_mergeCollatingAlphanumeric                    = 372
	Cobol85ParserRULE_mergeCollatingNational                        = 373
	Cobol85ParserRULE_mergeUsing                                    = 374
	Cobol85ParserRULE_mergeOutputProcedurePhrase                    = 375
	Cobol85ParserRULE_mergeOutputThrough                            = 376
	Cobol85ParserRULE_mergeGivingPhrase                             = 377
	Cobol85ParserRULE_mergeGiving                                   = 378
	Cobol85ParserRULE_moveStatement                                 = 379
	Cobol85ParserRULE_moveToStatement                               = 380
	Cobol85ParserRULE_moveToSendingArea                             = 381
	Cobol85ParserRULE_moveCorrespondingToStatement                  = 382
	Cobol85ParserRULE_moveCorrespondingToSendingArea                = 383
	Cobol85ParserRULE_multiplyStatement                             = 384
	Cobol85ParserRULE_multiplyRegular                               = 385
	Cobol85ParserRULE_multiplyRegularOperand                        = 386
	Cobol85ParserRULE_multiplyGiving                                = 387
	Cobol85ParserRULE_multiplyGivingOperand                         = 388
	Cobol85ParserRULE_multiplyGivingResult                          = 389
	Cobol85ParserRULE_openStatement                                 = 390
	Cobol85ParserRULE_openInputStatement                            = 391
	Cobol85ParserRULE_openInput                                     = 392
	Cobol85ParserRULE_openOutputStatement                           = 393
	Cobol85ParserRULE_openOutput                                    = 394
	Cobol85ParserRULE_openIOStatement                               = 395
	Cobol85ParserRULE_openExtendStatement                           = 396
	Cobol85ParserRULE_performStatement                              = 397
	Cobol85ParserRULE_performInlineStatement                        = 398
	Cobol85ParserRULE_performProcedureStatement                     = 399
	Cobol85ParserRULE_performType                                   = 400
	Cobol85ParserRULE_performTimes                                  = 401
	Cobol85ParserRULE_performUntil                                  = 402
	Cobol85ParserRULE_performVarying                                = 403
	Cobol85ParserRULE_performVaryingClause                          = 404
	Cobol85ParserRULE_performVaryingPhrase                          = 405
	Cobol85ParserRULE_performAfter                                  = 406
	Cobol85ParserRULE_performFrom                                   = 407
	Cobol85ParserRULE_performBy                                     = 408
	Cobol85ParserRULE_performTestClause                             = 409
	Cobol85ParserRULE_purgeStatement                                = 410
	Cobol85ParserRULE_readStatement                                 = 411
	Cobol85ParserRULE_readInto                                      = 412
	Cobol85ParserRULE_readWith                                      = 413
	Cobol85ParserRULE_readKey                                       = 414
	Cobol85ParserRULE_receiveStatement                              = 415
	Cobol85ParserRULE_receiveFromStatement                          = 416
	Cobol85ParserRULE_receiveFrom                                   = 417
	Cobol85ParserRULE_receiveIntoStatement                          = 418
	Cobol85ParserRULE_receiveNoData                                 = 419
	Cobol85ParserRULE_receiveWithData                               = 420
	Cobol85ParserRULE_receiveBefore                                 = 421
	Cobol85ParserRULE_receiveWith                                   = 422
	Cobol85ParserRULE_receiveThread                                 = 423
	Cobol85ParserRULE_receiveSize                                   = 424
	Cobol85ParserRULE_receiveStatus                                 = 425
	Cobol85ParserRULE_releaseStatement                              = 426
	Cobol85ParserRULE_returnStatement                               = 427
	Cobol85ParserRULE_returnInto                                    = 428
	Cobol85ParserRULE_rewriteStatement                              = 429
	Cobol85ParserRULE_rewriteFrom                                   = 430
	Cobol85ParserRULE_searchStatement                               = 431
	Cobol85ParserRULE_searchVarying                                 = 432
	Cobol85ParserRULE_searchWhen                                    = 433
	Cobol85ParserRULE_sendStatement                                 = 434
	Cobol85ParserRULE_sendStatementSync                             = 435
	Cobol85ParserRULE_sendStatementAsync                            = 436
	Cobol85ParserRULE_sendFromPhrase                                = 437
	Cobol85ParserRULE_sendWithPhrase                                = 438
	Cobol85ParserRULE_sendReplacingPhrase                           = 439
	Cobol85ParserRULE_sendAdvancingPhrase                           = 440
	Cobol85ParserRULE_sendAdvancingPage                             = 441
	Cobol85ParserRULE_sendAdvancingLines                            = 442
	Cobol85ParserRULE_sendAdvancingMnemonic                         = 443
	Cobol85ParserRULE_setStatement                                  = 444
	Cobol85ParserRULE_setToStatement                                = 445
	Cobol85ParserRULE_setUpDownByStatement                          = 446
	Cobol85ParserRULE_setTo                                         = 447
	Cobol85ParserRULE_setToValue                                    = 448
	Cobol85ParserRULE_setByValue                                    = 449
	Cobol85ParserRULE_sortStatement                                 = 450
	Cobol85ParserRULE_sortOnKeyClause                               = 451
	Cobol85ParserRULE_sortDuplicatesPhrase                          = 452
	Cobol85ParserRULE_sortCollatingSequencePhrase                   = 453
	Cobol85ParserRULE_sortCollatingAlphanumeric                     = 454
	Cobol85ParserRULE_sortCollatingNational                         = 455
	Cobol85ParserRULE_sortInputProcedurePhrase                      = 456
	Cobol85ParserRULE_sortInputThrough                              = 457
	Cobol85ParserRULE_sortUsing                                     = 458
	Cobol85ParserRULE_sortOutputProcedurePhrase                     = 459
	Cobol85ParserRULE_sortOutputThrough                             = 460
	Cobol85ParserRULE_sortGivingPhrase                              = 461
	Cobol85ParserRULE_sortGiving                                    = 462
	Cobol85ParserRULE_startStatement                                = 463
	Cobol85ParserRULE_startKey                                      = 464
	Cobol85ParserRULE_stopStatement                                 = 465
	Cobol85ParserRULE_stringStatement                               = 466
	Cobol85ParserRULE_stringSendingPhrase                           = 467
	Cobol85ParserRULE_stringSending                                 = 468
	Cobol85ParserRULE_stringDelimitedByPhrase                       = 469
	Cobol85ParserRULE_stringForPhrase                               = 470
	Cobol85ParserRULE_stringIntoPhrase                              = 471
	Cobol85ParserRULE_stringWithPointerPhrase                       = 472
	Cobol85ParserRULE_subtractStatement                             = 473
	Cobol85ParserRULE_subtractFromStatement                         = 474
	Cobol85ParserRULE_subtractFromGivingStatement                   = 475
	Cobol85ParserRULE_subtractCorrespondingStatement                = 476
	Cobol85ParserRULE_subtractSubtrahend                            = 477
	Cobol85ParserRULE_subtractMinuend                               = 478
	Cobol85ParserRULE_subtractMinuendGiving                         = 479
	Cobol85ParserRULE_subtractGiving                                = 480
	Cobol85ParserRULE_subtractMinuendCorresponding                  = 481
	Cobol85ParserRULE_terminateStatement                            = 482
	Cobol85ParserRULE_unstringStatement                             = 483
	Cobol85ParserRULE_unstringSendingPhrase                         = 484
	Cobol85ParserRULE_unstringDelimitedByPhrase                     = 485
	Cobol85ParserRULE_unstringOrAllPhrase                           = 486
	Cobol85ParserRULE_unstringIntoPhrase                            = 487
	Cobol85ParserRULE_unstringInto                                  = 488
	Cobol85ParserRULE_unstringDelimiterIn                           = 489
	Cobol85ParserRULE_unstringCountIn                               = 490
	Cobol85ParserRULE_unstringWithPointerPhrase                     = 491
	Cobol85ParserRULE_unstringTallyingPhrase                        = 492
	Cobol85ParserRULE_useStatement                                  = 493
	Cobol85ParserRULE_useAfterClause                                = 494
	Cobol85ParserRULE_useAfterOn                                    = 495
	Cobol85ParserRULE_useDebugClause                                = 496
	Cobol85ParserRULE_useDebugOn                                    = 497
	Cobol85ParserRULE_writeStatement                                = 498
	Cobol85ParserRULE_writeFromPhrase                               = 499
	Cobol85ParserRULE_writeAdvancingPhrase                          = 500
	Cobol85ParserRULE_writeAdvancingPage                            = 501
	Cobol85ParserRULE_writeAdvancingLines                           = 502
	Cobol85ParserRULE_writeAdvancingMnemonic                        = 503
	Cobol85ParserRULE_writeAtEndOfPagePhrase                        = 504
	Cobol85ParserRULE_writeNotAtEndOfPagePhrase                     = 505
	Cobol85ParserRULE_atEndPhrase                                   = 506
	Cobol85ParserRULE_notAtEndPhrase                                = 507
	Cobol85ParserRULE_invalidKeyPhrase                              = 508
	Cobol85ParserRULE_notInvalidKeyPhrase                           = 509
	Cobol85ParserRULE_onOverflowPhrase                              = 510
	Cobol85ParserRULE_notOnOverflowPhrase                           = 511
	Cobol85ParserRULE_onSizeErrorPhrase                             = 512
	Cobol85ParserRULE_notOnSizeErrorPhrase                          = 513
	Cobol85ParserRULE_onExceptionClause                             = 514
	Cobol85ParserRULE_notOnExceptionClause                          = 515
	Cobol85ParserRULE_arithmeticExpression                          = 516
	Cobol85ParserRULE_plusMinus                                     = 517
	Cobol85ParserRULE_multDivs                                      = 518
	Cobol85ParserRULE_multDiv                                       = 519
	Cobol85ParserRULE_powers                                        = 520
	Cobol85ParserRULE_power                                         = 521
	Cobol85ParserRULE_basis                                         = 522
	Cobol85ParserRULE_condition                                     = 523
	Cobol85ParserRULE_andOrCondition                                = 524
	Cobol85ParserRULE_combinableCondition                           = 525
	Cobol85ParserRULE_simpleCondition                               = 526
	Cobol85ParserRULE_classCondition                                = 527
	Cobol85ParserRULE_conditionNameReference                        = 528
	Cobol85ParserRULE_conditionNameSubscriptReference               = 529
	Cobol85ParserRULE_relationCondition                             = 530
	Cobol85ParserRULE_relationSignCondition                         = 531
	Cobol85ParserRULE_relationArithmeticComparison                  = 532
	Cobol85ParserRULE_relationCombinedComparison                    = 533
	Cobol85ParserRULE_relationCombinedCondition                     = 534
	Cobol85ParserRULE_relationalOperator                            = 535
	Cobol85ParserRULE_abbreviation                                  = 536
	Cobol85ParserRULE_identifier                                    = 537
	Cobol85ParserRULE_tableCall                                     = 538
	Cobol85ParserRULE_functionCall                                  = 539
	Cobol85ParserRULE_referenceModifier                             = 540
	Cobol85ParserRULE_characterPosition                             = 541
	Cobol85ParserRULE_length                                        = 542
	Cobol85ParserRULE_subscript_                                    = 543
	Cobol85ParserRULE_argument                                      = 544
	Cobol85ParserRULE_qualifiedDataName                             = 545
	Cobol85ParserRULE_qualifiedDataNameFormat1                      = 546
	Cobol85ParserRULE_qualifiedDataNameFormat2                      = 547
	Cobol85ParserRULE_qualifiedDataNameFormat3                      = 548
	Cobol85ParserRULE_qualifiedDataNameFormat4                      = 549
	Cobol85ParserRULE_qualifiedInData                               = 550
	Cobol85ParserRULE_inData                                        = 551
	Cobol85ParserRULE_inFile                                        = 552
	Cobol85ParserRULE_inMnemonic                                    = 553
	Cobol85ParserRULE_inSection                                     = 554
	Cobol85ParserRULE_inLibrary                                     = 555
	Cobol85ParserRULE_inTable                                       = 556
	Cobol85ParserRULE_alphabetName                                  = 557
	Cobol85ParserRULE_assignmentName                                = 558
	Cobol85ParserRULE_basisName                                     = 559
	Cobol85ParserRULE_cdName                                        = 560
	Cobol85ParserRULE_className                                     = 561
	Cobol85ParserRULE_computerName                                  = 562
	Cobol85ParserRULE_conditionName                                 = 563
	Cobol85ParserRULE_dataName                                      = 564
	Cobol85ParserRULE_dataDescName                                  = 565
	Cobol85ParserRULE_environmentName                               = 566
	Cobol85ParserRULE_fileName                                      = 567
	Cobol85ParserRULE_functionName                                  = 568
	Cobol85ParserRULE_indexName                                     = 569
	Cobol85ParserRULE_languageName                                  = 570
	Cobol85ParserRULE_libraryName                                   = 571
	Cobol85ParserRULE_localName                                     = 572
	Cobol85ParserRULE_mnemonicName                                  = 573
	Cobol85ParserRULE_paragraphName                                 = 574
	Cobol85ParserRULE_procedureName                                 = 575
	Cobol85ParserRULE_programName                                   = 576
	Cobol85ParserRULE_recordName                                    = 577
	Cobol85ParserRULE_reportName                                    = 578
	Cobol85ParserRULE_routineName                                   = 579
	Cobol85ParserRULE_screenName                                    = 580
	Cobol85ParserRULE_sectionName                                   = 581
	Cobol85ParserRULE_systemName                                    = 582
	Cobol85ParserRULE_symbolicCharacter                             = 583
	Cobol85ParserRULE_textName                                      = 584
	Cobol85ParserRULE_cobolWord                                     = 585
	Cobol85ParserRULE_literal                                       = 586
	Cobol85ParserRULE_booleanLiteral                                = 587
	Cobol85ParserRULE_numericLiteral                                = 588
	Cobol85ParserRULE_integerLiteral                                = 589
	Cobol85ParserRULE_cicsDfhRespLiteral                            = 590
	Cobol85ParserRULE_cicsDfhValueLiteral                           = 591
	Cobol85ParserRULE_figurativeConstant                            = 592
	Cobol85ParserRULE_specialRegister                               = 593
	Cobol85ParserRULE_commentEntry                                  = 594
)

// IStartRuleContext is an interface to support dynamic dispatch.
type IStartRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartRuleContext differentiates from other interfaces.
	IsStartRuleContext()
}

type StartRuleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartRuleContext() *StartRuleContext {
	var p = new(StartRuleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startRule
	return p
}

func (*StartRuleContext) IsStartRuleContext() {}

func NewStartRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartRuleContext {
	var p = new(StartRuleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startRule

	return p
}

func (s *StartRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *StartRuleContext) CompilationUnit() ICompilationUnitContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompilationUnitContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompilationUnitContext)
}

func (s *StartRuleContext) EOF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOF, 0)
}

func (s *StartRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartRule(s)
	}
}

func (s *StartRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartRule(s)
	}
}

func (s *StartRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStartRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StartRule() (localctx IStartRuleContext) {
	this := p
	_ = this

	localctx = NewStartRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, Cobol85ParserRULE_startRule)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1190)
		p.CompilationUnit()
	}
	{
		p.SetState(1191)
		p.Match(Cobol85ParserEOF)
	}

	return localctx
}

// ICompilationUnitContext is an interface to support dynamic dispatch.
type ICompilationUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCompilationUnitContext differentiates from other interfaces.
	IsCompilationUnitContext()
}

type CompilationUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompilationUnitContext() *CompilationUnitContext {
	var p = new(CompilationUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_compilationUnit
	return p
}

func (*CompilationUnitContext) IsCompilationUnitContext() {}

func NewCompilationUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompilationUnitContext {
	var p = new(CompilationUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_compilationUnit

	return p
}

func (s *CompilationUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *CompilationUnitContext) AllProgramUnit() []IProgramUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProgramUnitContext); ok {
			len++
		}
	}

	tst := make([]IProgramUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProgramUnitContext); ok {
			tst[i] = t.(IProgramUnitContext)
			i++
		}
	}

	return tst
}

func (s *CompilationUnitContext) ProgramUnit(i int) IProgramUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramUnitContext)
}

func (s *CompilationUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompilationUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompilationUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCompilationUnit(s)
	}
}

func (s *CompilationUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCompilationUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CompilationUnit() (localctx ICompilationUnitContext) {
	this := p
	_ = this

	localctx = NewCompilationUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, Cobol85ParserRULE_compilationUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1194)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserID || _la == Cobol85ParserIDENTIFICATION {
		{
			p.SetState(1193)
			p.ProgramUnit()
		}

		p.SetState(1196)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProgramUnitContext is an interface to support dynamic dispatch.
type IProgramUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramUnitContext differentiates from other interfaces.
	IsProgramUnitContext()
}

type ProgramUnitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramUnitContext() *ProgramUnitContext {
	var p = new(ProgramUnitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programUnit
	return p
}

func (*ProgramUnitContext) IsProgramUnitContext() {}

func NewProgramUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramUnitContext {
	var p = new(ProgramUnitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programUnit

	return p
}

func (s *ProgramUnitContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramUnitContext) IdentificationDivision() IIdentificationDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentificationDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionContext)
}

func (s *ProgramUnitContext) EnvironmentDivision() IEnvironmentDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvironmentDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvironmentDivisionContext)
}

func (s *ProgramUnitContext) DataDivision() IDataDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDivisionContext)
}

func (s *ProgramUnitContext) ProcedureDivision() IProcedureDivisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionContext)
}

func (s *ProgramUnitContext) AllProgramUnit() []IProgramUnitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProgramUnitContext); ok {
			len++
		}
	}

	tst := make([]IProgramUnitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProgramUnitContext); ok {
			tst[i] = t.(IProgramUnitContext)
			i++
		}
	}

	return tst
}

func (s *ProgramUnitContext) ProgramUnit(i int) IProgramUnitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramUnitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramUnitContext)
}

func (s *ProgramUnitContext) EndProgramStatement() IEndProgramStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndProgramStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndProgramStatementContext)
}

func (s *ProgramUnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramUnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramUnitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramUnit(s)
	}
}

func (s *ProgramUnitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramUnit(s)
	}
}

func (s *ProgramUnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramUnit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramUnit() (localctx IProgramUnitContext) {
	this := p
	_ = this

	localctx = NewProgramUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, Cobol85ParserRULE_programUnit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1198)
		p.IdentificationDivision()
	}
	p.SetState(1200)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserENVIRONMENT {
		{
			p.SetState(1199)
			p.EnvironmentDivision()
		}

	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA {
		{
			p.SetState(1202)
			p.DataDivision()
		}

	}
	p.SetState(1206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCEDURE {
		{
			p.SetState(1205)
			p.ProcedureDivision()
		}

	}
	p.SetState(1211)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1208)
				p.ProgramUnit()
			}

		}
		p.SetState(1213)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
	}
	p.SetState(1215)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1214)
			p.EndProgramStatement()
		}

	}

	return localctx
}

// IEndProgramStatementContext is an interface to support dynamic dispatch.
type IEndProgramStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndProgramStatementContext differentiates from other interfaces.
	IsEndProgramStatementContext()
}

type EndProgramStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndProgramStatementContext() *EndProgramStatementContext {
	var p = new(EndProgramStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_endProgramStatement
	return p
}

func (*EndProgramStatementContext) IsEndProgramStatementContext() {}

func NewEndProgramStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndProgramStatementContext {
	var p = new(EndProgramStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_endProgramStatement

	return p
}

func (s *EndProgramStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EndProgramStatementContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *EndProgramStatementContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *EndProgramStatementContext) ProgramName() IProgramNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *EndProgramStatementContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *EndProgramStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndProgramStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndProgramStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEndProgramStatement(s)
	}
}

func (s *EndProgramStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEndProgramStatement(s)
	}
}

func (s *EndProgramStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEndProgramStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EndProgramStatement() (localctx IEndProgramStatementContext) {
	this := p
	_ = this

	localctx = NewEndProgramStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, Cobol85ParserRULE_endProgramStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1217)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(1218)
		p.Match(Cobol85ParserPROGRAM)
	}
	{
		p.SetState(1219)
		p.ProgramName()
	}
	{
		p.SetState(1220)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IIdentificationDivisionContext is an interface to support dynamic dispatch.
type IIdentificationDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentificationDivisionContext differentiates from other interfaces.
	IsIdentificationDivisionContext()
}

type IdentificationDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionContext() *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identificationDivision
	return p
}

func (*IdentificationDivisionContext) IsIdentificationDivisionContext() {}

func NewIdentificationDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionContext {
	var p = new(IdentificationDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identificationDivision

	return p
}

func (s *IdentificationDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *IdentificationDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *IdentificationDivisionContext) ProgramIdParagraph() IProgramIdParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramIdParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramIdParagraphContext)
}

func (s *IdentificationDivisionContext) IDENTIFICATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFICATION, 0)
}

func (s *IdentificationDivisionContext) ID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserID, 0)
}

func (s *IdentificationDivisionContext) AllIdentificationDivisionBody() []IIdentificationDivisionBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentificationDivisionBodyContext); ok {
			len++
		}
	}

	tst := make([]IIdentificationDivisionBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentificationDivisionBodyContext); ok {
			tst[i] = t.(IIdentificationDivisionBodyContext)
			i++
		}
	}

	return tst
}

func (s *IdentificationDivisionContext) IdentificationDivisionBody(i int) IIdentificationDivisionBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentificationDivisionBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentificationDivisionBodyContext)
}

func (s *IdentificationDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentificationDivision(s)
	}
}

func (s *IdentificationDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIdentificationDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IdentificationDivision() (localctx IIdentificationDivisionContext) {
	this := p
	_ = this

	localctx = NewIdentificationDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, Cobol85ParserRULE_identificationDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1222)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserID || _la == Cobol85ParserIDENTIFICATION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1223)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1224)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1225)
		p.ProgramIdParagraph()
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAUTHOR || _la == Cobol85ParserDATE_COMPILED || _la == Cobol85ParserDATE_WRITTEN || _la == Cobol85ParserINSTALLATION || _la == Cobol85ParserREMARKS || _la == Cobol85ParserSECURITY {
		{
			p.SetState(1226)
			p.IdentificationDivisionBody()
		}

		p.SetState(1231)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IIdentificationDivisionBodyContext is an interface to support dynamic dispatch.
type IIdentificationDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentificationDivisionBodyContext differentiates from other interfaces.
	IsIdentificationDivisionBodyContext()
}

type IdentificationDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentificationDivisionBodyContext() *IdentificationDivisionBodyContext {
	var p = new(IdentificationDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identificationDivisionBody
	return p
}

func (*IdentificationDivisionBodyContext) IsIdentificationDivisionBodyContext() {}

func NewIdentificationDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentificationDivisionBodyContext {
	var p = new(IdentificationDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identificationDivisionBody

	return p
}

func (s *IdentificationDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentificationDivisionBodyContext) AuthorParagraph() IAuthorParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAuthorParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAuthorParagraphContext)
}

func (s *IdentificationDivisionBodyContext) InstallationParagraph() IInstallationParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstallationParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstallationParagraphContext)
}

func (s *IdentificationDivisionBodyContext) DateWrittenParagraph() IDateWrittenParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateWrittenParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateWrittenParagraphContext)
}

func (s *IdentificationDivisionBodyContext) DateCompiledParagraph() IDateCompiledParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateCompiledParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateCompiledParagraphContext)
}

func (s *IdentificationDivisionBodyContext) SecurityParagraph() ISecurityParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISecurityParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISecurityParagraphContext)
}

func (s *IdentificationDivisionBodyContext) RemarksParagraph() IRemarksParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRemarksParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRemarksParagraphContext)
}

func (s *IdentificationDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentificationDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentificationDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentificationDivisionBody(s)
	}
}

func (s *IdentificationDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentificationDivisionBody(s)
	}
}

func (s *IdentificationDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIdentificationDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IdentificationDivisionBody() (localctx IIdentificationDivisionBodyContext) {
	this := p
	_ = this

	localctx = NewIdentificationDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, Cobol85ParserRULE_identificationDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1238)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAUTHOR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1232)
			p.AuthorParagraph()
		}

	case Cobol85ParserINSTALLATION:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1233)
			p.InstallationParagraph()
		}

	case Cobol85ParserDATE_WRITTEN:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1234)
			p.DateWrittenParagraph()
		}

	case Cobol85ParserDATE_COMPILED:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1235)
			p.DateCompiledParagraph()
		}

	case Cobol85ParserSECURITY:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1236)
			p.SecurityParagraph()
		}

	case Cobol85ParserREMARKS:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1237)
			p.RemarksParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProgramIdParagraphContext is an interface to support dynamic dispatch.
type IProgramIdParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramIdParagraphContext differentiates from other interfaces.
	IsProgramIdParagraphContext()
}

type ProgramIdParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramIdParagraphContext() *ProgramIdParagraphContext {
	var p = new(ProgramIdParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programIdParagraph
	return p
}

func (*ProgramIdParagraphContext) IsProgramIdParagraphContext() {}

func NewProgramIdParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramIdParagraphContext {
	var p = new(ProgramIdParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programIdParagraph

	return p
}

func (s *ProgramIdParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramIdParagraphContext) PROGRAM_ID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM_ID, 0)
}

func (s *ProgramIdParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProgramIdParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProgramIdParagraphContext) ProgramName() IProgramNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *ProgramIdParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *ProgramIdParagraphContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *ProgramIdParagraphContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *ProgramIdParagraphContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBRARY, 0)
}

func (s *ProgramIdParagraphContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFINITION, 0)
}

func (s *ProgramIdParagraphContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECURSIVE, 0)
}

func (s *ProgramIdParagraphContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ProgramIdParagraphContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *ProgramIdParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramIdParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramIdParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramIdParagraph(s)
	}
}

func (s *ProgramIdParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramIdParagraph(s)
	}
}

func (s *ProgramIdParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramIdParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramIdParagraph() (localctx IProgramIdParagraphContext) {
	this := p
	_ = this

	localctx = NewProgramIdParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, Cobol85ParserRULE_programIdParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1240)
		p.Match(Cobol85ParserPROGRAM_ID)
	}
	{
		p.SetState(1241)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1242)
		p.ProgramName()
	}
	p.SetState(1250)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMON || _la == Cobol85ParserDEFINITION || (int64((_la-243)) & ^0x3f) == 0 && ((int64(1)<<(_la-243))&2147485697) != 0 || _la == Cobol85ParserRECURSIVE {
		p.SetState(1244)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1243)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1246)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCOMMON || _la == Cobol85ParserDEFINITION || _la == Cobol85ParserINITIAL || _la == Cobol85ParserLIBRARY || _la == Cobol85ParserRECURSIVE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1248)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserPROGRAM {
			{
				p.SetState(1247)
				p.Match(Cobol85ParserPROGRAM)
			}

		}

	}
	p.SetState(1253)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDOT_FS {
		{
			p.SetState(1252)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(1256)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1255)
			p.CommentEntry()
		}

	}

	return localctx
}

// IAuthorParagraphContext is an interface to support dynamic dispatch.
type IAuthorParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAuthorParagraphContext differentiates from other interfaces.
	IsAuthorParagraphContext()
}

type AuthorParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAuthorParagraphContext() *AuthorParagraphContext {
	var p = new(AuthorParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_authorParagraph
	return p
}

func (*AuthorParagraphContext) IsAuthorParagraphContext() {}

func NewAuthorParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AuthorParagraphContext {
	var p = new(AuthorParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_authorParagraph

	return p
}

func (s *AuthorParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *AuthorParagraphContext) AUTHOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTHOR, 0)
}

func (s *AuthorParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *AuthorParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *AuthorParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AuthorParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AuthorParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAuthorParagraph(s)
	}
}

func (s *AuthorParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAuthorParagraph(s)
	}
}

func (s *AuthorParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAuthorParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AuthorParagraph() (localctx IAuthorParagraphContext) {
	this := p
	_ = this

	localctx = NewAuthorParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, Cobol85ParserRULE_authorParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1258)
		p.Match(Cobol85ParserAUTHOR)
	}
	{
		p.SetState(1259)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1261)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1260)
			p.CommentEntry()
		}

	}

	return localctx
}

// IInstallationParagraphContext is an interface to support dynamic dispatch.
type IInstallationParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInstallationParagraphContext differentiates from other interfaces.
	IsInstallationParagraphContext()
}

type InstallationParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstallationParagraphContext() *InstallationParagraphContext {
	var p = new(InstallationParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_installationParagraph
	return p
}

func (*InstallationParagraphContext) IsInstallationParagraphContext() {}

func NewInstallationParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallationParagraphContext {
	var p = new(InstallationParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_installationParagraph

	return p
}

func (s *InstallationParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallationParagraphContext) INSTALLATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINSTALLATION, 0)
}

func (s *InstallationParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *InstallationParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *InstallationParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallationParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallationParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInstallationParagraph(s)
	}
}

func (s *InstallationParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInstallationParagraph(s)
	}
}

func (s *InstallationParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInstallationParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InstallationParagraph() (localctx IInstallationParagraphContext) {
	this := p
	_ = this

	localctx = NewInstallationParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, Cobol85ParserRULE_installationParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1263)
		p.Match(Cobol85ParserINSTALLATION)
	}
	{
		p.SetState(1264)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1265)
			p.CommentEntry()
		}

	}

	return localctx
}

// IDateWrittenParagraphContext is an interface to support dynamic dispatch.
type IDateWrittenParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateWrittenParagraphContext differentiates from other interfaces.
	IsDateWrittenParagraphContext()
}

type DateWrittenParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateWrittenParagraphContext() *DateWrittenParagraphContext {
	var p = new(DateWrittenParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dateWrittenParagraph
	return p
}

func (*DateWrittenParagraphContext) IsDateWrittenParagraphContext() {}

func NewDateWrittenParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateWrittenParagraphContext {
	var p = new(DateWrittenParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dateWrittenParagraph

	return p
}

func (s *DateWrittenParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *DateWrittenParagraphContext) DATE_WRITTEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE_WRITTEN, 0)
}

func (s *DateWrittenParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DateWrittenParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *DateWrittenParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateWrittenParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateWrittenParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDateWrittenParagraph(s)
	}
}

func (s *DateWrittenParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDateWrittenParagraph(s)
	}
}

func (s *DateWrittenParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDateWrittenParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DateWrittenParagraph() (localctx IDateWrittenParagraphContext) {
	this := p
	_ = this

	localctx = NewDateWrittenParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, Cobol85ParserRULE_dateWrittenParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1268)
		p.Match(Cobol85ParserDATE_WRITTEN)
	}
	{
		p.SetState(1269)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1271)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1270)
			p.CommentEntry()
		}

	}

	return localctx
}

// IDateCompiledParagraphContext is an interface to support dynamic dispatch.
type IDateCompiledParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateCompiledParagraphContext differentiates from other interfaces.
	IsDateCompiledParagraphContext()
}

type DateCompiledParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateCompiledParagraphContext() *DateCompiledParagraphContext {
	var p = new(DateCompiledParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dateCompiledParagraph
	return p
}

func (*DateCompiledParagraphContext) IsDateCompiledParagraphContext() {}

func NewDateCompiledParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateCompiledParagraphContext {
	var p = new(DateCompiledParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dateCompiledParagraph

	return p
}

func (s *DateCompiledParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *DateCompiledParagraphContext) DATE_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE_COMPILED, 0)
}

func (s *DateCompiledParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DateCompiledParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *DateCompiledParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateCompiledParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateCompiledParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDateCompiledParagraph(s)
	}
}

func (s *DateCompiledParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDateCompiledParagraph(s)
	}
}

func (s *DateCompiledParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDateCompiledParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DateCompiledParagraph() (localctx IDateCompiledParagraphContext) {
	this := p
	_ = this

	localctx = NewDateCompiledParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, Cobol85ParserRULE_dateCompiledParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1273)
		p.Match(Cobol85ParserDATE_COMPILED)
	}
	{
		p.SetState(1274)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1275)
			p.CommentEntry()
		}

	}

	return localctx
}

// ISecurityParagraphContext is an interface to support dynamic dispatch.
type ISecurityParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecurityParagraphContext differentiates from other interfaces.
	IsSecurityParagraphContext()
}

type SecurityParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecurityParagraphContext() *SecurityParagraphContext {
	var p = new(SecurityParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_securityParagraph
	return p
}

func (*SecurityParagraphContext) IsSecurityParagraphContext() {}

func NewSecurityParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecurityParagraphContext {
	var p = new(SecurityParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_securityParagraph

	return p
}

func (s *SecurityParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SecurityParagraphContext) SECURITY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURITY, 0)
}

func (s *SecurityParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *SecurityParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *SecurityParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecurityParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecurityParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSecurityParagraph(s)
	}
}

func (s *SecurityParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSecurityParagraph(s)
	}
}

func (s *SecurityParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSecurityParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SecurityParagraph() (localctx ISecurityParagraphContext) {
	this := p
	_ = this

	localctx = NewSecurityParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, Cobol85ParserRULE_securityParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1278)
		p.Match(Cobol85ParserSECURITY)
	}
	{
		p.SetState(1279)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1280)
			p.CommentEntry()
		}

	}

	return localctx
}

// IRemarksParagraphContext is an interface to support dynamic dispatch.
type IRemarksParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRemarksParagraphContext differentiates from other interfaces.
	IsRemarksParagraphContext()
}

type RemarksParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRemarksParagraphContext() *RemarksParagraphContext {
	var p = new(RemarksParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_remarksParagraph
	return p
}

func (*RemarksParagraphContext) IsRemarksParagraphContext() {}

func NewRemarksParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RemarksParagraphContext {
	var p = new(RemarksParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_remarksParagraph

	return p
}

func (s *RemarksParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *RemarksParagraphContext) REMARKS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMARKS, 0)
}

func (s *RemarksParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *RemarksParagraphContext) CommentEntry() ICommentEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommentEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommentEntryContext)
}

func (s *RemarksParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RemarksParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RemarksParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRemarksParagraph(s)
	}
}

func (s *RemarksParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRemarksParagraph(s)
	}
}

func (s *RemarksParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRemarksParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RemarksParagraph() (localctx IRemarksParagraphContext) {
	this := p
	_ = this

	localctx = NewRemarksParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, Cobol85ParserRULE_remarksParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1283)
		p.Match(Cobol85ParserREMARKS)
	}
	{
		p.SetState(1284)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1286)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(1285)
			p.CommentEntry()
		}

	}

	return localctx
}

// IEnvironmentDivisionContext is an interface to support dynamic dispatch.
type IEnvironmentDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentDivisionContext differentiates from other interfaces.
	IsEnvironmentDivisionContext()
}

type EnvironmentDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentDivisionContext() *EnvironmentDivisionContext {
	var p = new(EnvironmentDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentDivision
	return p
}

func (*EnvironmentDivisionContext) IsEnvironmentDivisionContext() {}

func NewEnvironmentDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentDivisionContext {
	var p = new(EnvironmentDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentDivision

	return p
}

func (s *EnvironmentDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentDivisionContext) ENVIRONMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENVIRONMENT, 0)
}

func (s *EnvironmentDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *EnvironmentDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *EnvironmentDivisionContext) AllEnvironmentDivisionBody() []IEnvironmentDivisionBodyContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEnvironmentDivisionBodyContext); ok {
			len++
		}
	}

	tst := make([]IEnvironmentDivisionBodyContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEnvironmentDivisionBodyContext); ok {
			tst[i] = t.(IEnvironmentDivisionBodyContext)
			i++
		}
	}

	return tst
}

func (s *EnvironmentDivisionContext) EnvironmentDivisionBody(i int) IEnvironmentDivisionBodyContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvironmentDivisionBodyContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvironmentDivisionBodyContext)
}

func (s *EnvironmentDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentDivision(s)
	}
}

func (s *EnvironmentDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentDivision(s)
	}
}

func (s *EnvironmentDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentDivision() (localctx IEnvironmentDivisionContext) {
	this := p
	_ = this

	localctx = NewEnvironmentDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, Cobol85ParserRULE_environmentDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1288)
		p.Match(Cobol85ParserENVIRONMENT)
	}
	{
		p.SetState(1289)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1290)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1294)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCONFIGURATION || _la == Cobol85ParserINPUT_OUTPUT || _la == Cobol85ParserSPECIAL_NAMES {
		{
			p.SetState(1291)
			p.EnvironmentDivisionBody()
		}

		p.SetState(1296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEnvironmentDivisionBodyContext is an interface to support dynamic dispatch.
type IEnvironmentDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentDivisionBodyContext differentiates from other interfaces.
	IsEnvironmentDivisionBodyContext()
}

type EnvironmentDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentDivisionBodyContext() *EnvironmentDivisionBodyContext {
	var p = new(EnvironmentDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentDivisionBody
	return p
}

func (*EnvironmentDivisionBodyContext) IsEnvironmentDivisionBodyContext() {}

func NewEnvironmentDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentDivisionBodyContext {
	var p = new(EnvironmentDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentDivisionBody

	return p
}

func (s *EnvironmentDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentDivisionBodyContext) ConfigurationSection() IConfigurationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigurationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigurationSectionContext)
}

func (s *EnvironmentDivisionBodyContext) SpecialNamesParagraph() ISpecialNamesParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialNamesParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialNamesParagraphContext)
}

func (s *EnvironmentDivisionBodyContext) InputOutputSection() IInputOutputSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputOutputSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputOutputSectionContext)
}

func (s *EnvironmentDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentDivisionBody(s)
	}
}

func (s *EnvironmentDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentDivisionBody(s)
	}
}

func (s *EnvironmentDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentDivisionBody() (localctx IEnvironmentDivisionBodyContext) {
	this := p
	_ = this

	localctx = NewEnvironmentDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, Cobol85ParserRULE_environmentDivisionBody)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1300)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONFIGURATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1297)
			p.ConfigurationSection()
		}

	case Cobol85ParserSPECIAL_NAMES:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1298)
			p.SpecialNamesParagraph()
		}

	case Cobol85ParserINPUT_OUTPUT:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1299)
			p.InputOutputSection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConfigurationSectionContext is an interface to support dynamic dispatch.
type IConfigurationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationSectionContext differentiates from other interfaces.
	IsConfigurationSectionContext()
}

type ConfigurationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationSectionContext() *ConfigurationSectionContext {
	var p = new(ConfigurationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_configurationSection
	return p
}

func (*ConfigurationSectionContext) IsConfigurationSectionContext() {}

func NewConfigurationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationSectionContext {
	var p = new(ConfigurationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_configurationSection

	return p
}

func (s *ConfigurationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationSectionContext) CONFIGURATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONFIGURATION, 0)
}

func (s *ConfigurationSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ConfigurationSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ConfigurationSectionContext) AllConfigurationSectionParagraph() []IConfigurationSectionParagraphContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConfigurationSectionParagraphContext); ok {
			len++
		}
	}

	tst := make([]IConfigurationSectionParagraphContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConfigurationSectionParagraphContext); ok {
			tst[i] = t.(IConfigurationSectionParagraphContext)
			i++
		}
	}

	return tst
}

func (s *ConfigurationSectionContext) ConfigurationSectionParagraph(i int) IConfigurationSectionParagraphContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConfigurationSectionParagraphContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConfigurationSectionParagraphContext)
}

func (s *ConfigurationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConfigurationSection(s)
	}
}

func (s *ConfigurationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConfigurationSection(s)
	}
}

func (s *ConfigurationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConfigurationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConfigurationSection() (localctx IConfigurationSectionContext) {
	this := p
	_ = this

	localctx = NewConfigurationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, Cobol85ParserRULE_configurationSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1302)
		p.Match(Cobol85ParserCONFIGURATION)
	}
	{
		p.SetState(1303)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1304)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1308)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1305)
				p.ConfigurationSectionParagraph()
			}

		}
		p.SetState(1310)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IConfigurationSectionParagraphContext is an interface to support dynamic dispatch.
type IConfigurationSectionParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConfigurationSectionParagraphContext differentiates from other interfaces.
	IsConfigurationSectionParagraphContext()
}

type ConfigurationSectionParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConfigurationSectionParagraphContext() *ConfigurationSectionParagraphContext {
	var p = new(ConfigurationSectionParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_configurationSectionParagraph
	return p
}

func (*ConfigurationSectionParagraphContext) IsConfigurationSectionParagraphContext() {}

func NewConfigurationSectionParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConfigurationSectionParagraphContext {
	var p = new(ConfigurationSectionParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_configurationSectionParagraph

	return p
}

func (s *ConfigurationSectionParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ConfigurationSectionParagraphContext) SourceComputerParagraph() ISourceComputerParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceComputerParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceComputerParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) ObjectComputerParagraph() IObjectComputerParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectComputerParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectComputerParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) SpecialNamesParagraph() ISpecialNamesParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialNamesParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialNamesParagraphContext)
}

func (s *ConfigurationSectionParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConfigurationSectionParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConfigurationSectionParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConfigurationSectionParagraph(s)
	}
}

func (s *ConfigurationSectionParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConfigurationSectionParagraph(s)
	}
}

func (s *ConfigurationSectionParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConfigurationSectionParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConfigurationSectionParagraph() (localctx IConfigurationSectionParagraphContext) {
	this := p
	_ = this

	localctx = NewConfigurationSectionParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, Cobol85ParserRULE_configurationSectionParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1314)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserSOURCE_COMPUTER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1311)
			p.SourceComputerParagraph()
		}

	case Cobol85ParserOBJECT_COMPUTER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1312)
			p.ObjectComputerParagraph()
		}

	case Cobol85ParserSPECIAL_NAMES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1313)
			p.SpecialNamesParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISourceComputerParagraphContext is an interface to support dynamic dispatch.
type ISourceComputerParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSourceComputerParagraphContext differentiates from other interfaces.
	IsSourceComputerParagraphContext()
}

type SourceComputerParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceComputerParagraphContext() *SourceComputerParagraphContext {
	var p = new(SourceComputerParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sourceComputerParagraph
	return p
}

func (*SourceComputerParagraphContext) IsSourceComputerParagraphContext() {}

func NewSourceComputerParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceComputerParagraphContext {
	var p = new(SourceComputerParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sourceComputerParagraph

	return p
}

func (s *SourceComputerParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceComputerParagraphContext) SOURCE_COMPUTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE_COMPUTER, 0)
}

func (s *SourceComputerParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *SourceComputerParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *SourceComputerParagraphContext) ComputerName() IComputerNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComputerNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComputerNameContext)
}

func (s *SourceComputerParagraphContext) DEBUGGING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUGGING, 0)
}

func (s *SourceComputerParagraphContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *SourceComputerParagraphContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SourceComputerParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceComputerParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SourceComputerParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSourceComputerParagraph(s)
	}
}

func (s *SourceComputerParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSourceComputerParagraph(s)
	}
}

func (s *SourceComputerParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSourceComputerParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SourceComputerParagraph() (localctx ISourceComputerParagraphContext) {
	this := p
	_ = this

	localctx = NewSourceComputerParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, Cobol85ParserRULE_sourceComputerParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1316)
		p.Match(Cobol85ParserSOURCE_COMPUTER)
	}
	{
		p.SetState(1317)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1318)
		p.ComputerName()
	}
	p.SetState(1324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEBUGGING || _la == Cobol85ParserWITH {
		p.SetState(1320)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1319)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1322)
			p.Match(Cobol85ParserDEBUGGING)
		}
		{
			p.SetState(1323)
			p.Match(Cobol85ParserMODE)
		}

	}
	{
		p.SetState(1326)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IObjectComputerParagraphContext is an interface to support dynamic dispatch.
type IObjectComputerParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectComputerParagraphContext differentiates from other interfaces.
	IsObjectComputerParagraphContext()
}

type ObjectComputerParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectComputerParagraphContext() *ObjectComputerParagraphContext {
	var p = new(ObjectComputerParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_objectComputerParagraph
	return p
}

func (*ObjectComputerParagraphContext) IsObjectComputerParagraphContext() {}

func NewObjectComputerParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectComputerParagraphContext {
	var p = new(ObjectComputerParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_objectComputerParagraph

	return p
}

func (s *ObjectComputerParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectComputerParagraphContext) OBJECT_COMPUTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOBJECT_COMPUTER, 0)
}

func (s *ObjectComputerParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ObjectComputerParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ObjectComputerParagraphContext) ComputerName() IComputerNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComputerNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComputerNameContext)
}

func (s *ObjectComputerParagraphContext) AllObjectComputerClause() []IObjectComputerClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IObjectComputerClauseContext); ok {
			len++
		}
	}

	tst := make([]IObjectComputerClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IObjectComputerClauseContext); ok {
			tst[i] = t.(IObjectComputerClauseContext)
			i++
		}
	}

	return tst
}

func (s *ObjectComputerParagraphContext) ObjectComputerClause(i int) IObjectComputerClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IObjectComputerClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IObjectComputerClauseContext)
}

func (s *ObjectComputerParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComputerParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectComputerParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterObjectComputerParagraph(s)
	}
}

func (s *ObjectComputerParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitObjectComputerParagraph(s)
	}
}

func (s *ObjectComputerParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitObjectComputerParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ObjectComputerParagraph() (localctx IObjectComputerParagraphContext) {
	this := p
	_ = this

	localctx = NewObjectComputerParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, Cobol85ParserRULE_objectComputerParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1328)
		p.Match(Cobol85ParserOBJECT_COMPUTER)
	}
	{
		p.SetState(1329)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(1330)
		p.ComputerName()
	}
	p.SetState(1334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCHARACTER || _la == Cobol85ParserCOLLATING || _la == Cobol85ParserDISK || _la == Cobol85ParserMEMORY || _la == Cobol85ParserPROGRAM || _la == Cobol85ParserSEGMENT_LIMIT || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(1331)
			p.ObjectComputerClause()
		}

		p.SetState(1336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1337)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IObjectComputerClauseContext is an interface to support dynamic dispatch.
type IObjectComputerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObjectComputerClauseContext differentiates from other interfaces.
	IsObjectComputerClauseContext()
}

type ObjectComputerClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObjectComputerClauseContext() *ObjectComputerClauseContext {
	var p = new(ObjectComputerClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_objectComputerClause
	return p
}

func (*ObjectComputerClauseContext) IsObjectComputerClauseContext() {}

func NewObjectComputerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObjectComputerClauseContext {
	var p = new(ObjectComputerClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_objectComputerClause

	return p
}

func (s *ObjectComputerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ObjectComputerClauseContext) MemorySizeClause() IMemorySizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMemorySizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMemorySizeClauseContext)
}

func (s *ObjectComputerClauseContext) DiskSizeClause() IDiskSizeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiskSizeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiskSizeClauseContext)
}

func (s *ObjectComputerClauseContext) CollatingSequenceClause() ICollatingSequenceClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollatingSequenceClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseContext)
}

func (s *ObjectComputerClauseContext) SegmentLimitClause() ISegmentLimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISegmentLimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISegmentLimitClauseContext)
}

func (s *ObjectComputerClauseContext) CharacterSetClause() ICharacterSetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterSetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterSetClauseContext)
}

func (s *ObjectComputerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObjectComputerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ObjectComputerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterObjectComputerClause(s)
	}
}

func (s *ObjectComputerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitObjectComputerClause(s)
	}
}

func (s *ObjectComputerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitObjectComputerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ObjectComputerClause() (localctx IObjectComputerClauseContext) {
	this := p
	_ = this

	localctx = NewObjectComputerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, Cobol85ParserRULE_objectComputerClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1344)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserMEMORY:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1339)
			p.MemorySizeClause()
		}

	case Cobol85ParserDISK:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1340)
			p.DiskSizeClause()
		}

	case Cobol85ParserCOLLATING, Cobol85ParserPROGRAM, Cobol85ParserSEQUENCE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1341)
			p.CollatingSequenceClause()
		}

	case Cobol85ParserSEGMENT_LIMIT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1342)
			p.SegmentLimitClause()
		}

	case Cobol85ParserCHARACTER:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1343)
			p.CharacterSetClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMemorySizeClauseContext is an interface to support dynamic dispatch.
type IMemorySizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMemorySizeClauseContext differentiates from other interfaces.
	IsMemorySizeClauseContext()
}

type MemorySizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMemorySizeClauseContext() *MemorySizeClauseContext {
	var p = new(MemorySizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_memorySizeClause
	return p
}

func (*MemorySizeClauseContext) IsMemorySizeClauseContext() {}

func NewMemorySizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MemorySizeClauseContext {
	var p = new(MemorySizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_memorySizeClause

	return p
}

func (s *MemorySizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MemorySizeClauseContext) MEMORY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMEMORY, 0)
}

func (s *MemorySizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MemorySizeClauseContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *MemorySizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *MemorySizeClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *MemorySizeClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *MemorySizeClauseContext) MODULES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODULES, 0)
}

func (s *MemorySizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemorySizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MemorySizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMemorySizeClause(s)
	}
}

func (s *MemorySizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMemorySizeClause(s)
	}
}

func (s *MemorySizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMemorySizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MemorySizeClause() (localctx IMemorySizeClauseContext) {
	this := p
	_ = this

	localctx = NewMemorySizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, Cobol85ParserRULE_memorySizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1346)
		p.Match(Cobol85ParserMEMORY)
	}
	p.SetState(1348)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(1347)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(1352)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1350)
			p.IntegerLiteral()
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(1351)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1355)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS {
		{
			p.SetState(1354)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCHARACTERS || _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDiskSizeClauseContext is an interface to support dynamic dispatch.
type IDiskSizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDiskSizeClauseContext differentiates from other interfaces.
	IsDiskSizeClauseContext()
}

type DiskSizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiskSizeClauseContext() *DiskSizeClauseContext {
	var p = new(DiskSizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_diskSizeClause
	return p
}

func (*DiskSizeClauseContext) IsDiskSizeClauseContext() {}

func NewDiskSizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiskSizeClauseContext {
	var p = new(DiskSizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_diskSizeClause

	return p
}

func (s *DiskSizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DiskSizeClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *DiskSizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DiskSizeClauseContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DiskSizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *DiskSizeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DiskSizeClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *DiskSizeClauseContext) MODULES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODULES, 0)
}

func (s *DiskSizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiskSizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiskSizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDiskSizeClause(s)
	}
}

func (s *DiskSizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDiskSizeClause(s)
	}
}

func (s *DiskSizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDiskSizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DiskSizeClause() (localctx IDiskSizeClauseContext) {
	this := p
	_ = this

	localctx = NewDiskSizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, Cobol85ParserRULE_diskSizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1357)
		p.Match(Cobol85ParserDISK)
	}
	p.SetState(1359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(1358)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(1362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1361)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1366)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1364)
			p.IntegerLiteral()
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(1365)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1369)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS {
		{
			p.SetState(1368)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserMODULES || _la == Cobol85ParserWORDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ICollatingSequenceClauseContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseContext differentiates from other interfaces.
	IsCollatingSequenceClauseContext()
}

type CollatingSequenceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseContext() *CollatingSequenceClauseContext {
	var p = new(CollatingSequenceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClause
	return p
}

func (*CollatingSequenceClauseContext) IsCollatingSequenceClauseContext() {}

func NewCollatingSequenceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseContext {
	var p = new(CollatingSequenceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClause

	return p
}

func (s *CollatingSequenceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *CollatingSequenceClauseContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *CollatingSequenceClauseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *CollatingSequenceClauseContext) CollatingSequenceClauseAlphanumeric() ICollatingSequenceClauseAlphanumericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollatingSequenceClauseAlphanumericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseAlphanumericContext)
}

func (s *CollatingSequenceClauseContext) CollatingSequenceClauseNational() ICollatingSequenceClauseNationalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollatingSequenceClauseNationalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollatingSequenceClauseNationalContext)
}

func (s *CollatingSequenceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseContext) AllAlphabetName() []IAlphabetNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			len++
		}
	}

	tst := make([]IAlphabetNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlphabetNameContext); ok {
			tst[i] = t.(IAlphabetNameContext)
			i++
		}
	}

	return tst
}

func (s *CollatingSequenceClauseContext) AlphabetName(i int) IAlphabetNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClause(s)
	}
}

func (s *CollatingSequenceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClause(s)
	}
}

func (s *CollatingSequenceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCollatingSequenceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClause() (localctx ICollatingSequenceClauseContext) {
	this := p
	_ = this

	localctx = NewCollatingSequenceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, Cobol85ParserRULE_collatingSequenceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM {
		{
			p.SetState(1371)
			p.Match(Cobol85ParserPROGRAM)
		}

	}
	p.SetState(1375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(1374)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(1377)
		p.Match(Cobol85ParserSEQUENCE)
	}

	p.SetState(1379)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1378)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1382)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1381)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1384)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 37, p.GetParserRuleContext())
	}

	p.SetState(1387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1386)
			p.CollatingSequenceClauseAlphanumeric()
		}

	}
	p.SetState(1390)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(1389)
			p.CollatingSequenceClauseNational()
		}

	}

	return localctx
}

// ICollatingSequenceClauseAlphanumericContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseAlphanumericContext differentiates from other interfaces.
	IsCollatingSequenceClauseAlphanumericContext()
}

type CollatingSequenceClauseAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseAlphanumericContext() *CollatingSequenceClauseAlphanumericContext {
	var p = new(CollatingSequenceClauseAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseAlphanumeric
	return p
}

func (*CollatingSequenceClauseAlphanumericContext) IsCollatingSequenceClauseAlphanumericContext() {}

func NewCollatingSequenceClauseAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseAlphanumericContext {
	var p = new(CollatingSequenceClauseAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseAlphanumeric

	return p
}

func (s *CollatingSequenceClauseAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClauseAlphanumeric(s)
	}
}

func (s *CollatingSequenceClauseAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClauseAlphanumeric(s)
	}
}

func (s *CollatingSequenceClauseAlphanumericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCollatingSequenceClauseAlphanumeric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClauseAlphanumeric() (localctx ICollatingSequenceClauseAlphanumericContext) {
	this := p
	_ = this

	localctx = NewCollatingSequenceClauseAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, Cobol85ParserRULE_collatingSequenceClauseAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1392)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1395)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	p.SetState(1397)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1396)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1399)
		p.AlphabetName()
	}

	return localctx
}

// ICollatingSequenceClauseNationalContext is an interface to support dynamic dispatch.
type ICollatingSequenceClauseNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCollatingSequenceClauseNationalContext differentiates from other interfaces.
	IsCollatingSequenceClauseNationalContext()
}

type CollatingSequenceClauseNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollatingSequenceClauseNationalContext() *CollatingSequenceClauseNationalContext {
	var p = new(CollatingSequenceClauseNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseNational
	return p
}

func (*CollatingSequenceClauseNationalContext) IsCollatingSequenceClauseNationalContext() {}

func NewCollatingSequenceClauseNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollatingSequenceClauseNationalContext {
	var p = new(CollatingSequenceClauseNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_collatingSequenceClauseNational

	return p
}

func (s *CollatingSequenceClauseNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *CollatingSequenceClauseNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *CollatingSequenceClauseNationalContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CollatingSequenceClauseNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CollatingSequenceClauseNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CollatingSequenceClauseNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollatingSequenceClauseNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollatingSequenceClauseNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCollatingSequenceClauseNational(s)
	}
}

func (s *CollatingSequenceClauseNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCollatingSequenceClauseNational(s)
	}
}

func (s *CollatingSequenceClauseNationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCollatingSequenceClauseNational(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CollatingSequenceClauseNational() (localctx ICollatingSequenceClauseNationalContext) {
	this := p
	_ = this

	localctx = NewCollatingSequenceClauseNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, Cobol85ParserRULE_collatingSequenceClauseNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1401)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1404)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(1406)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1405)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1408)
		p.AlphabetName()
	}

	return localctx
}

// ISegmentLimitClauseContext is an interface to support dynamic dispatch.
type ISegmentLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSegmentLimitClauseContext differentiates from other interfaces.
	IsSegmentLimitClauseContext()
}

type SegmentLimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySegmentLimitClauseContext() *SegmentLimitClauseContext {
	var p = new(SegmentLimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_segmentLimitClause
	return p
}

func (*SegmentLimitClauseContext) IsSegmentLimitClauseContext() {}

func NewSegmentLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SegmentLimitClauseContext {
	var p = new(SegmentLimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_segmentLimitClause

	return p
}

func (s *SegmentLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SegmentLimitClauseContext) SEGMENT_LIMIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEGMENT_LIMIT, 0)
}

func (s *SegmentLimitClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SegmentLimitClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SegmentLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SegmentLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SegmentLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSegmentLimitClause(s)
	}
}

func (s *SegmentLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSegmentLimitClause(s)
	}
}

func (s *SegmentLimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSegmentLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SegmentLimitClause() (localctx ISegmentLimitClauseContext) {
	this := p
	_ = this

	localctx = NewSegmentLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, Cobol85ParserRULE_segmentLimitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1410)
		p.Match(Cobol85ParserSEGMENT_LIMIT)
	}
	p.SetState(1412)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1411)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1414)
		p.IntegerLiteral()
	}

	return localctx
}

// ICharacterSetClauseContext is an interface to support dynamic dispatch.
type ICharacterSetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterSetClauseContext differentiates from other interfaces.
	IsCharacterSetClauseContext()
}

type CharacterSetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterSetClauseContext() *CharacterSetClauseContext {
	var p = new(CharacterSetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_characterSetClause
	return p
}

func (*CharacterSetClauseContext) IsCharacterSetClauseContext() {}

func NewCharacterSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterSetClauseContext {
	var p = new(CharacterSetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_characterSetClause

	return p
}

func (s *CharacterSetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterSetClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *CharacterSetClauseContext) SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSET, 0)
}

func (s *CharacterSetClauseContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CharacterSetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterSetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterSetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCharacterSetClause(s)
	}
}

func (s *CharacterSetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCharacterSetClause(s)
	}
}

func (s *CharacterSetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCharacterSetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CharacterSetClause() (localctx ICharacterSetClauseContext) {
	this := p
	_ = this

	localctx = NewCharacterSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, Cobol85ParserRULE_characterSetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1416)
		p.Match(Cobol85ParserCHARACTER)
	}
	{
		p.SetState(1417)
		p.Match(Cobol85ParserSET)
	}
	{
		p.SetState(1418)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ISpecialNamesParagraphContext is an interface to support dynamic dispatch.
type ISpecialNamesParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialNamesParagraphContext differentiates from other interfaces.
	IsSpecialNamesParagraphContext()
}

type SpecialNamesParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialNamesParagraphContext() *SpecialNamesParagraphContext {
	var p = new(SpecialNamesParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialNamesParagraph
	return p
}

func (*SpecialNamesParagraphContext) IsSpecialNamesParagraphContext() {}

func NewSpecialNamesParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialNamesParagraphContext {
	var p = new(SpecialNamesParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialNamesParagraph

	return p
}

func (s *SpecialNamesParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialNamesParagraphContext) SPECIAL_NAMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPECIAL_NAMES, 0)
}

func (s *SpecialNamesParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *SpecialNamesParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *SpecialNamesParagraphContext) AllSpecialNameClause() []ISpecialNameClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISpecialNameClauseContext); ok {
			len++
		}
	}

	tst := make([]ISpecialNameClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISpecialNameClauseContext); ok {
			tst[i] = t.(ISpecialNameClauseContext)
			i++
		}
	}

	return tst
}

func (s *SpecialNamesParagraphContext) SpecialNameClause(i int) ISpecialNameClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialNameClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialNameClauseContext)
}

func (s *SpecialNamesParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialNamesParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialNamesParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialNamesParagraph(s)
	}
}

func (s *SpecialNamesParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialNamesParagraph(s)
	}
}

func (s *SpecialNamesParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSpecialNamesParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SpecialNamesParagraph() (localctx ISpecialNamesParagraphContext) {
	this := p
	_ = this

	localctx = NewSpecialNamesParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, Cobol85ParserRULE_specialNamesParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1420)
		p.Match(Cobol85ParserSPECIAL_NAMES)
	}
	{
		p.SetState(1421)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1429)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822850) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4611716890652319793) != 0 || (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1684346260358943737) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&72084021027799369) != 0 || (int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&2892683434315076821) != 0 || (int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&2615189243111195157) != 0 || (int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&86861972244097) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455171) != 0 || _la == Cobol85ParserIDENTIFIER {
		p.SetState(1423)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822850) != 0 || (int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&4611716890652319793) != 0 || (int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-1684346260358943737) != 0 || (int64((_la-194)) & ^0x3f) == 0 && ((int64(1)<<(_la-194))&72084021027799369) != 0 || (int64((_la-258)) & ^0x3f) == 0 && ((int64(1)<<(_la-258))&2892683434315076821) != 0 || (int64((_la-322)) & ^0x3f) == 0 && ((int64(1)<<(_la-322))&2615189243111195157) != 0 || (int64((_la-391)) & ^0x3f) == 0 && ((int64(1)<<(_la-391))&86861972244097) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455171) != 0 || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(1422)
				p.SpecialNameClause()
			}

			p.SetState(1425)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1427)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// ISpecialNameClauseContext is an interface to support dynamic dispatch.
type ISpecialNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialNameClauseContext differentiates from other interfaces.
	IsSpecialNameClauseContext()
}

type SpecialNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialNameClauseContext() *SpecialNameClauseContext {
	var p = new(SpecialNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialNameClause
	return p
}

func (*SpecialNameClauseContext) IsSpecialNameClauseContext() {}

func NewSpecialNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialNameClauseContext {
	var p = new(SpecialNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialNameClause

	return p
}

func (s *SpecialNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialNameClauseContext) ChannelClause() IChannelClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelClauseContext)
}

func (s *SpecialNameClauseContext) OdtClause() IOdtClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOdtClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOdtClauseContext)
}

func (s *SpecialNameClauseContext) AlphabetClause() IAlphabetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseContext)
}

func (s *SpecialNameClauseContext) ClassClause() IClassClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassClauseContext)
}

func (s *SpecialNameClauseContext) CurrencySignClause() ICurrencySignClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICurrencySignClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICurrencySignClauseContext)
}

func (s *SpecialNameClauseContext) DecimalPointClause() IDecimalPointClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDecimalPointClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDecimalPointClauseContext)
}

func (s *SpecialNameClauseContext) SymbolicCharactersClause() ISymbolicCharactersClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicCharactersClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharactersClauseContext)
}

func (s *SpecialNameClauseContext) EnvironmentSwitchNameClause() IEnvironmentSwitchNameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvironmentSwitchNameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvironmentSwitchNameClauseContext)
}

func (s *SpecialNameClauseContext) DefaultDisplaySignClause() IDefaultDisplaySignClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultDisplaySignClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultDisplaySignClauseContext)
}

func (s *SpecialNameClauseContext) DefaultComputationalSignClause() IDefaultComputationalSignClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultComputationalSignClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultComputationalSignClauseContext)
}

func (s *SpecialNameClauseContext) ReserveNetworkClause() IReserveNetworkClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReserveNetworkClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReserveNetworkClauseContext)
}

func (s *SpecialNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialNameClause(s)
	}
}

func (s *SpecialNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialNameClause(s)
	}
}

func (s *SpecialNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSpecialNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SpecialNameClause() (localctx ISpecialNameClauseContext) {
	this := p
	_ = this

	localctx = NewSpecialNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, Cobol85ParserRULE_specialNameClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1442)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 47, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1431)
			p.ChannelClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1432)
			p.OdtClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1433)
			p.AlphabetClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1434)
			p.ClassClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1435)
			p.CurrencySignClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1436)
			p.DecimalPointClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1437)
			p.SymbolicCharactersClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1438)
			p.EnvironmentSwitchNameClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1439)
			p.DefaultDisplaySignClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1440)
			p.DefaultComputationalSignClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1441)
			p.ReserveNetworkClause()
		}

	}

	return localctx
}

// IAlphabetClauseContext is an interface to support dynamic dispatch.
type IAlphabetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseContext differentiates from other interfaces.
	IsAlphabetClauseContext()
}

type AlphabetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseContext() *AlphabetClauseContext {
	var p = new(AlphabetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClause
	return p
}

func (*AlphabetClauseContext) IsAlphabetClauseContext() {}

func NewAlphabetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseContext {
	var p = new(AlphabetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClause

	return p
}

func (s *AlphabetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseContext) AlphabetClauseFormat1() IAlphabetClauseFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetClauseFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseFormat1Context)
}

func (s *AlphabetClauseContext) AlphabetClauseFormat2() IAlphabetClauseFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetClauseFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetClauseFormat2Context)
}

func (s *AlphabetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClause(s)
	}
}

func (s *AlphabetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClause(s)
	}
}

func (s *AlphabetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetClause() (localctx IAlphabetClauseContext) {
	this := p
	_ = this

	localctx = NewAlphabetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, Cobol85ParserRULE_alphabetClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 48, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1444)
			p.AlphabetClauseFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1445)
			p.AlphabetClauseFormat2()
		}

	}

	return localctx
}

// IAlphabetClauseFormat1Context is an interface to support dynamic dispatch.
type IAlphabetClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseFormat1Context differentiates from other interfaces.
	IsAlphabetClauseFormat1Context()
}

type AlphabetClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseFormat1Context() *AlphabetClauseFormat1Context {
	var p = new(AlphabetClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat1
	return p
}

func (*AlphabetClauseFormat1Context) IsAlphabetClauseFormat1Context() {}

func NewAlphabetClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseFormat1Context {
	var p = new(AlphabetClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat1

	return p
}

func (s *AlphabetClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseFormat1Context) ALPHABET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABET, 0)
}

func (s *AlphabetClauseFormat1Context) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *AlphabetClauseFormat1Context) EBCDIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEBCDIC, 0)
}

func (s *AlphabetClauseFormat1Context) ASCII() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCII, 0)
}

func (s *AlphabetClauseFormat1Context) STANDARD_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_1, 0)
}

func (s *AlphabetClauseFormat1Context) STANDARD_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_2, 0)
}

func (s *AlphabetClauseFormat1Context) NATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIVE, 0)
}

func (s *AlphabetClauseFormat1Context) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *AlphabetClauseFormat1Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *AlphabetClauseFormat1Context) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *AlphabetClauseFormat1Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlphabetClauseFormat1Context) AllAlphabetLiterals() []IAlphabetLiteralsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlphabetLiteralsContext); ok {
			len++
		}
	}

	tst := make([]IAlphabetLiteralsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlphabetLiteralsContext); ok {
			tst[i] = t.(IAlphabetLiteralsContext)
			i++
		}
	}

	return tst
}

func (s *AlphabetClauseFormat1Context) AlphabetLiterals(i int) IAlphabetLiteralsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetLiteralsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetLiteralsContext)
}

func (s *AlphabetClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClauseFormat1(s)
	}
}

func (s *AlphabetClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClauseFormat1(s)
	}
}

func (s *AlphabetClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetClauseFormat1() (localctx IAlphabetClauseFormat1Context) {
	this := p
	_ = this

	localctx = NewAlphabetClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, Cobol85ParserRULE_alphabetClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1448)
		p.Match(Cobol85ParserALPHABET)
	}
	{
		p.SetState(1449)
		p.AlphabetName()
	}
	p.SetState(1452)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1450)
			p.Match(Cobol85ParserFOR)
		}
		{
			p.SetState(1451)
			p.Match(Cobol85ParserALPHANUMERIC)
		}

	}
	p.SetState(1455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1454)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1457)
			p.Match(Cobol85ParserEBCDIC)
		}

	case 2:
		{
			p.SetState(1458)
			p.Match(Cobol85ParserASCII)
		}

	case 3:
		{
			p.SetState(1459)
			p.Match(Cobol85ParserSTANDARD_1)
		}

	case 4:
		{
			p.SetState(1460)
			p.Match(Cobol85ParserSTANDARD_2)
		}

	case 5:
		{
			p.SetState(1461)
			p.Match(Cobol85ParserNATIVE)
		}

	case 6:
		{
			p.SetState(1462)
			p.CobolWord()
		}

	case 7:
		p.SetState(1464)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(1463)
					p.AlphabetLiterals()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(1466)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IAlphabetLiteralsContext is an interface to support dynamic dispatch.
type IAlphabetLiteralsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetLiteralsContext differentiates from other interfaces.
	IsAlphabetLiteralsContext()
}

type AlphabetLiteralsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetLiteralsContext() *AlphabetLiteralsContext {
	var p = new(AlphabetLiteralsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetLiterals
	return p
}

func (*AlphabetLiteralsContext) IsAlphabetLiteralsContext() {}

func NewAlphabetLiteralsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetLiteralsContext {
	var p = new(AlphabetLiteralsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetLiterals

	return p
}

func (s *AlphabetLiteralsContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetLiteralsContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetLiteralsContext) AlphabetThrough() IAlphabetThroughContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetThroughContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetThroughContext)
}

func (s *AlphabetLiteralsContext) AllAlphabetAlso() []IAlphabetAlsoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlphabetAlsoContext); ok {
			len++
		}
	}

	tst := make([]IAlphabetAlsoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlphabetAlsoContext); ok {
			tst[i] = t.(IAlphabetAlsoContext)
			i++
		}
	}

	return tst
}

func (s *AlphabetLiteralsContext) AlphabetAlso(i int) IAlphabetAlsoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetAlsoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetAlsoContext)
}

func (s *AlphabetLiteralsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetLiteralsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetLiteralsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetLiterals(s)
	}
}

func (s *AlphabetLiteralsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetLiterals(s)
	}
}

func (s *AlphabetLiteralsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetLiterals(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetLiterals() (localctx IAlphabetLiteralsContext) {
	this := p
	_ = this

	localctx = NewAlphabetLiteralsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, Cobol85ParserRULE_alphabetLiterals)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1470)
		p.Literal()
	}
	p.SetState(1477)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTHROUGH, Cobol85ParserTHRU:
		{
			p.SetState(1471)
			p.AlphabetThrough()
		}

	case Cobol85ParserALSO:
		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == Cobol85ParserALSO {
			{
				p.SetState(1472)
				p.AlphabetAlso()
			}

			p.SetState(1475)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case Cobol85ParserABORT, Cobol85ParserALL, Cobol85ParserALPHABET, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLASS, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURRENCY, Cobol85ParserCURSOR, Cobol85ParserDECIMAL_POINT, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL_, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOFF, Cobol85ParserON, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserRESERVE, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserSYMBOLIC, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserDOT_FS, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:

	default:
	}

	return localctx
}

// IAlphabetThroughContext is an interface to support dynamic dispatch.
type IAlphabetThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetThroughContext differentiates from other interfaces.
	IsAlphabetThroughContext()
}

type AlphabetThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetThroughContext() *AlphabetThroughContext {
	var p = new(AlphabetThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetThrough
	return p
}

func (*AlphabetThroughContext) IsAlphabetThroughContext() {}

func NewAlphabetThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetThroughContext {
	var p = new(AlphabetThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetThrough

	return p
}

func (s *AlphabetThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetThroughContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *AlphabetThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *AlphabetThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetThrough(s)
	}
}

func (s *AlphabetThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetThrough(s)
	}
}

func (s *AlphabetThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetThrough() (localctx IAlphabetThroughContext) {
	this := p
	_ = this

	localctx = NewAlphabetThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, Cobol85ParserRULE_alphabetThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1479)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1480)
		p.Literal()
	}

	return localctx
}

// IAlphabetAlsoContext is an interface to support dynamic dispatch.
type IAlphabetAlsoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetAlsoContext differentiates from other interfaces.
	IsAlphabetAlsoContext()
}

type AlphabetAlsoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetAlsoContext() *AlphabetAlsoContext {
	var p = new(AlphabetAlsoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetAlso
	return p
}

func (*AlphabetAlsoContext) IsAlphabetAlsoContext() {}

func NewAlphabetAlsoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetAlsoContext {
	var p = new(AlphabetAlsoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetAlso

	return p
}

func (s *AlphabetAlsoContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetAlsoContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *AlphabetAlsoContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *AlphabetAlsoContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetAlsoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetAlsoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetAlsoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetAlso(s)
	}
}

func (s *AlphabetAlsoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetAlso(s)
	}
}

func (s *AlphabetAlsoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetAlso(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetAlso() (localctx IAlphabetAlsoContext) {
	this := p
	_ = this

	localctx = NewAlphabetAlsoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, Cobol85ParserRULE_alphabetAlso)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1482)
		p.Match(Cobol85ParserALSO)
	}
	p.SetState(1484)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1483)
				p.Literal()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext())
	}

	return localctx
}

// IAlphabetClauseFormat2Context is an interface to support dynamic dispatch.
type IAlphabetClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetClauseFormat2Context differentiates from other interfaces.
	IsAlphabetClauseFormat2Context()
}

type AlphabetClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetClauseFormat2Context() *AlphabetClauseFormat2Context {
	var p = new(AlphabetClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat2
	return p
}

func (*AlphabetClauseFormat2Context) IsAlphabetClauseFormat2Context() {}

func NewAlphabetClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetClauseFormat2Context {
	var p = new(AlphabetClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetClauseFormat2

	return p
}

func (s *AlphabetClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetClauseFormat2Context) ALPHABET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABET, 0)
}

func (s *AlphabetClauseFormat2Context) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *AlphabetClauseFormat2Context) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *AlphabetClauseFormat2Context) NATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIVE, 0)
}

func (s *AlphabetClauseFormat2Context) CCSVERSION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCCSVERSION, 0)
}

func (s *AlphabetClauseFormat2Context) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AlphabetClauseFormat2Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *AlphabetClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlphabetClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetClauseFormat2(s)
	}
}

func (s *AlphabetClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetClauseFormat2(s)
	}
}

func (s *AlphabetClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetClauseFormat2() (localctx IAlphabetClauseFormat2Context) {
	this := p
	_ = this

	localctx = NewAlphabetClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, Cobol85ParserRULE_alphabetClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1488)
		p.Match(Cobol85ParserALPHABET)
	}
	{
		p.SetState(1489)
		p.AlphabetName()
	}
	p.SetState(1491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1490)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1493)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(1495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1494)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1500)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNATIVE:
		{
			p.SetState(1497)
			p.Match(Cobol85ParserNATIVE)
		}

	case Cobol85ParserCCSVERSION:
		{
			p.SetState(1498)
			p.Match(Cobol85ParserCCSVERSION)
		}
		{
			p.SetState(1499)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IChannelClauseContext is an interface to support dynamic dispatch.
type IChannelClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChannelClauseContext differentiates from other interfaces.
	IsChannelClauseContext()
}

type ChannelClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelClauseContext() *ChannelClauseContext {
	var p = new(ChannelClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_channelClause
	return p
}

func (*ChannelClauseContext) IsChannelClauseContext() {}

func NewChannelClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelClauseContext {
	var p = new(ChannelClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_channelClause

	return p
}

func (s *ChannelClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelClauseContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANNEL, 0)
}

func (s *ChannelClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ChannelClauseContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *ChannelClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ChannelClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterChannelClause(s)
	}
}

func (s *ChannelClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitChannelClause(s)
	}
}

func (s *ChannelClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitChannelClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ChannelClause() (localctx IChannelClauseContext) {
	this := p
	_ = this

	localctx = NewChannelClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, Cobol85ParserRULE_channelClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1502)
		p.Match(Cobol85ParserCHANNEL)
	}
	{
		p.SetState(1503)
		p.IntegerLiteral()
	}
	p.SetState(1505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1504)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1507)
		p.MnemonicName()
	}

	return localctx
}

// IClassClauseContext is an interface to support dynamic dispatch.
type IClassClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseContext differentiates from other interfaces.
	IsClassClauseContext()
}

type ClassClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseContext() *ClassClauseContext {
	var p = new(ClassClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClause
	return p
}

func (*ClassClauseContext) IsClassClauseContext() {}

func NewClassClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseContext {
	var p = new(ClassClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClause

	return p
}

func (s *ClassClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseContext) CLASS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLASS, 0)
}

func (s *ClassClauseContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ClassClauseContext) AllClassClauseThrough() []IClassClauseThroughContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClassClauseThroughContext); ok {
			len++
		}
	}

	tst := make([]IClassClauseThroughContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClassClauseThroughContext); ok {
			tst[i] = t.(IClassClauseThroughContext)
			i++
		}
	}

	return tst
}

func (s *ClassClauseContext) ClassClauseThrough(i int) IClassClauseThroughContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassClauseThroughContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassClauseThroughContext)
}

func (s *ClassClauseContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *ClassClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *ClassClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *ClassClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClause(s)
	}
}

func (s *ClassClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClause(s)
	}
}

func (s *ClassClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClause() (localctx IClassClauseContext) {
	this := p
	_ = this

	localctx = NewClassClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, Cobol85ParserRULE_classClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1509)
		p.Match(Cobol85ParserCLASS)
	}
	{
		p.SetState(1510)
		p.ClassName()
	}
	p.SetState(1515)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
		p.SetState(1512)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(1511)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(1514)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserALPHANUMERIC || _la == Cobol85ParserNATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1518)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1517)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1521)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1520)
				p.ClassClauseThrough()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1523)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext())
	}

	return localctx
}

// IClassClauseThroughContext is an interface to support dynamic dispatch.
type IClassClauseThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseThroughContext differentiates from other interfaces.
	IsClassClauseThroughContext()
}

type ClassClauseThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseThroughContext() *ClassClauseThroughContext {
	var p = new(ClassClauseThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseThrough
	return p
}

func (*ClassClauseThroughContext) IsClassClauseThroughContext() {}

func NewClassClauseThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseThroughContext {
	var p = new(ClassClauseThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseThrough

	return p
}

func (s *ClassClauseThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseThroughContext) ClassClauseFrom() IClassClauseFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassClauseFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassClauseFromContext)
}

func (s *ClassClauseThroughContext) ClassClauseTo() IClassClauseToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassClauseToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassClauseToContext)
}

func (s *ClassClauseThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *ClassClauseThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *ClassClauseThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseThrough(s)
	}
}

func (s *ClassClauseThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseThrough(s)
	}
}

func (s *ClassClauseThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClauseThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClauseThrough() (localctx IClassClauseThroughContext) {
	this := p
	_ = this

	localctx = NewClassClauseThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, Cobol85ParserRULE_classClauseThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1525)
		p.ClassClauseFrom()
	}
	p.SetState(1528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(1526)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1527)
			p.ClassClauseTo()
		}

	}

	return localctx
}

// IClassClauseFromContext is an interface to support dynamic dispatch.
type IClassClauseFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseFromContext differentiates from other interfaces.
	IsClassClauseFromContext()
}

type ClassClauseFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseFromContext() *ClassClauseFromContext {
	var p = new(ClassClauseFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseFrom
	return p
}

func (*ClassClauseFromContext) IsClassClauseFromContext() {}

func NewClassClauseFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseFromContext {
	var p = new(ClassClauseFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseFrom

	return p
}

func (s *ClassClauseFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseFromContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassClauseFromContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ClassClauseFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseFrom(s)
	}
}

func (s *ClassClauseFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseFrom(s)
	}
}

func (s *ClassClauseFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClauseFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClauseFrom() (localctx IClassClauseFromContext) {
	this := p
	_ = this

	localctx = NewClassClauseFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, Cobol85ParserRULE_classClauseFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1532)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1530)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1531)
			p.Literal()
		}

	}

	return localctx
}

// IClassClauseToContext is an interface to support dynamic dispatch.
type IClassClauseToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassClauseToContext differentiates from other interfaces.
	IsClassClauseToContext()
}

type ClassClauseToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassClauseToContext() *ClassClauseToContext {
	var p = new(ClassClauseToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classClauseTo
	return p
}

func (*ClassClauseToContext) IsClassClauseToContext() {}

func NewClassClauseToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassClauseToContext {
	var p = new(ClassClauseToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classClauseTo

	return p
}

func (s *ClassClauseToContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassClauseToContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassClauseToContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ClassClauseToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassClauseToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassClauseToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassClauseTo(s)
	}
}

func (s *ClassClauseToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassClauseTo(s)
	}
}

func (s *ClassClauseToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassClauseTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassClauseTo() (localctx IClassClauseToContext) {
	this := p
	_ = this

	localctx = NewClassClauseToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, Cobol85ParserRULE_classClauseTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1536)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1534)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1535)
			p.Literal()
		}

	}

	return localctx
}

// ICurrencySignClauseContext is an interface to support dynamic dispatch.
type ICurrencySignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCurrencySignClauseContext differentiates from other interfaces.
	IsCurrencySignClauseContext()
}

type CurrencySignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCurrencySignClauseContext() *CurrencySignClauseContext {
	var p = new(CurrencySignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_currencySignClause
	return p
}

func (*CurrencySignClauseContext) IsCurrencySignClauseContext() {}

func NewCurrencySignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CurrencySignClauseContext {
	var p = new(CurrencySignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_currencySignClause

	return p
}

func (s *CurrencySignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CurrencySignClauseContext) CURRENCY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURRENCY, 0)
}

func (s *CurrencySignClauseContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *CurrencySignClauseContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CurrencySignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *CurrencySignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CurrencySignClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *CurrencySignClauseContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOL, 0)
}

func (s *CurrencySignClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CurrencySignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CurrencySignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CurrencySignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCurrencySignClause(s)
	}
}

func (s *CurrencySignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCurrencySignClause(s)
	}
}

func (s *CurrencySignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCurrencySignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CurrencySignClause() (localctx ICurrencySignClauseContext) {
	this := p
	_ = this

	localctx = NewCurrencySignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, Cobol85ParserRULE_currencySignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1538)
		p.Match(Cobol85ParserCURRENCY)
	}
	p.SetState(1540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1539)
			p.Match(Cobol85ParserSIGN)
		}

	}
	p.SetState(1543)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1542)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1545)
		p.Literal()
	}
	p.SetState(1552)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPICTURE || _la == Cobol85ParserWITH {
		p.SetState(1547)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1546)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1549)
			p.Match(Cobol85ParserPICTURE)
		}
		{
			p.SetState(1550)
			p.Match(Cobol85ParserSYMBOL)
		}
		{
			p.SetState(1551)
			p.Literal()
		}

	}

	return localctx
}

// IDecimalPointClauseContext is an interface to support dynamic dispatch.
type IDecimalPointClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDecimalPointClauseContext differentiates from other interfaces.
	IsDecimalPointClauseContext()
}

type DecimalPointClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDecimalPointClauseContext() *DecimalPointClauseContext {
	var p = new(DecimalPointClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_decimalPointClause
	return p
}

func (*DecimalPointClauseContext) IsDecimalPointClauseContext() {}

func NewDecimalPointClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DecimalPointClauseContext {
	var p = new(DecimalPointClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_decimalPointClause

	return p
}

func (s *DecimalPointClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DecimalPointClauseContext) DECIMAL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDECIMAL_POINT, 0)
}

func (s *DecimalPointClauseContext) COMMA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMA, 0)
}

func (s *DecimalPointClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DecimalPointClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DecimalPointClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DecimalPointClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDecimalPointClause(s)
	}
}

func (s *DecimalPointClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDecimalPointClause(s)
	}
}

func (s *DecimalPointClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDecimalPointClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DecimalPointClause() (localctx IDecimalPointClauseContext) {
	this := p
	_ = this

	localctx = NewDecimalPointClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, Cobol85ParserRULE_decimalPointClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1554)
		p.Match(Cobol85ParserDECIMAL_POINT)
	}
	p.SetState(1556)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1555)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1558)
		p.Match(Cobol85ParserCOMMA)
	}

	return localctx
}

// IDefaultComputationalSignClauseContext is an interface to support dynamic dispatch.
type IDefaultComputationalSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultComputationalSignClauseContext differentiates from other interfaces.
	IsDefaultComputationalSignClauseContext()
}

type DefaultComputationalSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultComputationalSignClauseContext() *DefaultComputationalSignClauseContext {
	var p = new(DefaultComputationalSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_defaultComputationalSignClause
	return p
}

func (*DefaultComputationalSignClauseContext) IsDefaultComputationalSignClauseContext() {}

func NewDefaultComputationalSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultComputationalSignClauseContext {
	var p = new(DefaultComputationalSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_defaultComputationalSignClause

	return p
}

func (s *DefaultComputationalSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultComputationalSignClauseContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT, 0)
}

func (s *DefaultComputationalSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DefaultComputationalSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DefaultComputationalSignClauseContext) COMPUTATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL, 0)
}

func (s *DefaultComputationalSignClauseContext) COMP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP, 0)
}

func (s *DefaultComputationalSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DefaultComputationalSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DefaultComputationalSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DefaultComputationalSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DefaultComputationalSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultComputationalSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultComputationalSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDefaultComputationalSignClause(s)
	}
}

func (s *DefaultComputationalSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDefaultComputationalSignClause(s)
	}
}

func (s *DefaultComputationalSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDefaultComputationalSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DefaultComputationalSignClause() (localctx IDefaultComputationalSignClauseContext) {
	this := p
	_ = this

	localctx = NewDefaultComputationalSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, Cobol85ParserRULE_defaultComputationalSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1560)
		p.Match(Cobol85ParserDEFAULT)
	}
	p.SetState(1562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMP || _la == Cobol85ParserCOMPUTATIONAL {
		{
			p.SetState(1561)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCOMP || _la == Cobol85ParserCOMPUTATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1568)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1564)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(1566)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1565)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1571)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING {
		{
			p.SetState(1570)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	{
		p.SetState(1573)
		p.Match(Cobol85ParserSEPARATE)
	}
	p.SetState(1575)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(1574)
			p.Match(Cobol85ParserCHARACTER)
		}

	}

	return localctx
}

// IDefaultDisplaySignClauseContext is an interface to support dynamic dispatch.
type IDefaultDisplaySignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDefaultDisplaySignClauseContext differentiates from other interfaces.
	IsDefaultDisplaySignClauseContext()
}

type DefaultDisplaySignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultDisplaySignClauseContext() *DefaultDisplaySignClauseContext {
	var p = new(DefaultDisplaySignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_defaultDisplaySignClause
	return p
}

func (*DefaultDisplaySignClauseContext) IsDefaultDisplaySignClauseContext() {}

func NewDefaultDisplaySignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultDisplaySignClauseContext {
	var p = new(DefaultDisplaySignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_defaultDisplaySignClause

	return p
}

func (s *DefaultDisplaySignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultDisplaySignClauseContext) DEFAULT_DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT_DISPLAY, 0)
}

func (s *DefaultDisplaySignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DefaultDisplaySignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DefaultDisplaySignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DefaultDisplaySignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DefaultDisplaySignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DefaultDisplaySignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DefaultDisplaySignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultDisplaySignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultDisplaySignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDefaultDisplaySignClause(s)
	}
}

func (s *DefaultDisplaySignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDefaultDisplaySignClause(s)
	}
}

func (s *DefaultDisplaySignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDefaultDisplaySignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DefaultDisplaySignClause() (localctx IDefaultDisplaySignClauseContext) {
	this := p
	_ = this

	localctx = NewDefaultDisplaySignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, Cobol85ParserRULE_defaultDisplaySignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1577)
		p.Match(Cobol85ParserDEFAULT_DISPLAY)
	}
	p.SetState(1582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(1578)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(1580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1579)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(1584)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(1585)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(1587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(1586)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IEnvironmentSwitchNameClauseContext is an interface to support dynamic dispatch.
type IEnvironmentSwitchNameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentSwitchNameClauseContext differentiates from other interfaces.
	IsEnvironmentSwitchNameClauseContext()
}

type EnvironmentSwitchNameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentSwitchNameClauseContext() *EnvironmentSwitchNameClauseContext {
	var p = new(EnvironmentSwitchNameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameClause
	return p
}

func (*EnvironmentSwitchNameClauseContext) IsEnvironmentSwitchNameClauseContext() {}

func NewEnvironmentSwitchNameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentSwitchNameClauseContext {
	var p = new(EnvironmentSwitchNameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameClause

	return p
}

func (s *EnvironmentSwitchNameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentSwitchNameClauseContext) EnvironmentName() IEnvironmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvironmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvironmentNameContext)
}

func (s *EnvironmentSwitchNameClauseContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *EnvironmentSwitchNameClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *EnvironmentSwitchNameClauseContext) EnvironmentSwitchNameSpecialNamesStatusPhrase() IEnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvironmentSwitchNameSpecialNamesStatusPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvironmentSwitchNameSpecialNamesStatusPhraseContext)
}

func (s *EnvironmentSwitchNameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentSwitchNameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentSwitchNameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentSwitchNameClause(s)
	}
}

func (s *EnvironmentSwitchNameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentSwitchNameClause(s)
	}
}

func (s *EnvironmentSwitchNameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentSwitchNameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentSwitchNameClause() (localctx IEnvironmentSwitchNameClauseContext) {
	this := p
	_ = this

	localctx = NewEnvironmentSwitchNameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, Cobol85ParserRULE_environmentSwitchNameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1600)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1591)
			p.EnvironmentName()
		}
		p.SetState(1593)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1592)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1595)
			p.MnemonicName()
		}
		p.SetState(1597)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 82, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1596)
				p.EnvironmentSwitchNameSpecialNamesStatusPhrase()
			}

		}

	case Cobol85ParserOFF, Cobol85ParserON:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1599)
			p.EnvironmentSwitchNameSpecialNamesStatusPhrase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEnvironmentSwitchNameSpecialNamesStatusPhraseContext is an interface to support dynamic dispatch.
type IEnvironmentSwitchNameSpecialNamesStatusPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext differentiates from other interfaces.
	IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext()
}

type EnvironmentSwitchNameSpecialNamesStatusPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentSwitchNameSpecialNamesStatusPhraseContext() *EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var p = new(EnvironmentSwitchNameSpecialNamesStatusPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase
	return p
}

func (*EnvironmentSwitchNameSpecialNamesStatusPhraseContext) IsEnvironmentSwitchNameSpecialNamesStatusPhraseContext() {
}

func NewEnvironmentSwitchNameSpecialNamesStatusPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentSwitchNameSpecialNamesStatusPhraseContext {
	var p = new(EnvironmentSwitchNameSpecialNamesStatusPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase

	return p
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllCondition() []IConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionContext); ok {
			len++
		}
	}

	tst := make([]IConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionContext); ok {
			tst[i] = t.(IConditionContext)
			i++
		}
	}

	return tst
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) Condition(i int) IConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllSTATUS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserSTATUS)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) STATUS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, i)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) AllIS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserIS)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) IS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, i)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOFF, 0)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentSwitchNameSpecialNamesStatusPhrase(s)
	}
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentSwitchNameSpecialNamesStatusPhrase(s)
	}
}

func (s *EnvironmentSwitchNameSpecialNamesStatusPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentSwitchNameSpecialNamesStatusPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentSwitchNameSpecialNamesStatusPhrase() (localctx IEnvironmentSwitchNameSpecialNamesStatusPhraseContext) {
	this := p
	_ = this

	localctx = NewEnvironmentSwitchNameSpecialNamesStatusPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, Cobol85ParserRULE_environmentSwitchNameSpecialNamesStatusPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1638)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserON:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1602)
			p.Match(Cobol85ParserON)
		}
		p.SetState(1604)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserSTATUS {
			{
				p.SetState(1603)
				p.Match(Cobol85ParserSTATUS)
			}

		}
		p.SetState(1607)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1606)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1609)
			p.Condition()
		}
		p.SetState(1618)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1610)
				p.Match(Cobol85ParserOFF)
			}
			p.SetState(1612)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserSTATUS {
				{
					p.SetState(1611)
					p.Match(Cobol85ParserSTATUS)
				}

			}
			p.SetState(1615)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserIS {
				{
					p.SetState(1614)
					p.Match(Cobol85ParserIS)
				}

			}
			{
				p.SetState(1617)
				p.Condition()
			}

		}

	case Cobol85ParserOFF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1620)
			p.Match(Cobol85ParserOFF)
		}
		p.SetState(1622)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserSTATUS {
			{
				p.SetState(1621)
				p.Match(Cobol85ParserSTATUS)
			}

		}
		p.SetState(1625)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1624)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(1627)
			p.Condition()
		}
		p.SetState(1636)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1628)
				p.Match(Cobol85ParserON)
			}
			p.SetState(1630)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserSTATUS {
				{
					p.SetState(1629)
					p.Match(Cobol85ParserSTATUS)
				}

			}
			p.SetState(1633)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserIS {
				{
					p.SetState(1632)
					p.Match(Cobol85ParserIS)
				}

			}
			{
				p.SetState(1635)
				p.Condition()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IOdtClauseContext is an interface to support dynamic dispatch.
type IOdtClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOdtClauseContext differentiates from other interfaces.
	IsOdtClauseContext()
}

type OdtClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOdtClauseContext() *OdtClauseContext {
	var p = new(OdtClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_odtClause
	return p
}

func (*OdtClauseContext) IsOdtClauseContext() {}

func NewOdtClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OdtClauseContext {
	var p = new(OdtClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_odtClause

	return p
}

func (s *OdtClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OdtClauseContext) ODT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserODT, 0)
}

func (s *OdtClauseContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *OdtClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *OdtClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OdtClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OdtClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOdtClause(s)
	}
}

func (s *OdtClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOdtClause(s)
	}
}

func (s *OdtClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOdtClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OdtClause() (localctx IOdtClauseContext) {
	this := p
	_ = this

	localctx = NewOdtClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, Cobol85ParserRULE_odtClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1640)
		p.Match(Cobol85ParserODT)
	}
	p.SetState(1642)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1641)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1644)
		p.MnemonicName()
	}

	return localctx
}

// IReserveNetworkClauseContext is an interface to support dynamic dispatch.
type IReserveNetworkClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReserveNetworkClauseContext differentiates from other interfaces.
	IsReserveNetworkClauseContext()
}

type ReserveNetworkClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReserveNetworkClauseContext() *ReserveNetworkClauseContext {
	var p = new(ReserveNetworkClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reserveNetworkClause
	return p
}

func (*ReserveNetworkClauseContext) IsReserveNetworkClauseContext() {}

func NewReserveNetworkClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReserveNetworkClauseContext {
	var p = new(ReserveNetworkClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reserveNetworkClause

	return p
}

func (s *ReserveNetworkClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReserveNetworkClauseContext) RESERVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESERVE, 0)
}

func (s *ReserveNetworkClauseContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNETWORK, 0)
}

func (s *ReserveNetworkClauseContext) WORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORDS, 0)
}

func (s *ReserveNetworkClauseContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIST, 0)
}

func (s *ReserveNetworkClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReserveNetworkClauseContext) CAPABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCAPABLE, 0)
}

func (s *ReserveNetworkClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReserveNetworkClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReserveNetworkClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReserveNetworkClause(s)
	}
}

func (s *ReserveNetworkClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReserveNetworkClause(s)
	}
}

func (s *ReserveNetworkClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReserveNetworkClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReserveNetworkClause() (localctx IReserveNetworkClauseContext) {
	this := p
	_ = this

	localctx = NewReserveNetworkClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, Cobol85ParserRULE_reserveNetworkClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1646)
		p.Match(Cobol85ParserRESERVE)
	}
	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWORDS {
		{
			p.SetState(1647)
			p.Match(Cobol85ParserWORDS)
		}

	}
	p.SetState(1651)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIST {
		{
			p.SetState(1650)
			p.Match(Cobol85ParserLIST)
		}

	}
	p.SetState(1654)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1653)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1656)
		p.Match(Cobol85ParserNETWORK)
	}
	p.SetState(1658)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 99, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1657)
			p.Match(Cobol85ParserCAPABLE)
		}

	}

	return localctx
}

// ISymbolicCharactersClauseContext is an interface to support dynamic dispatch.
type ISymbolicCharactersClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharactersClauseContext differentiates from other interfaces.
	IsSymbolicCharactersClauseContext()
}

type SymbolicCharactersClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharactersClauseContext() *SymbolicCharactersClauseContext {
	var p = new(SymbolicCharactersClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharactersClause
	return p
}

func (*SymbolicCharactersClauseContext) IsSymbolicCharactersClauseContext() {}

func NewSymbolicCharactersClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharactersClauseContext {
	var p = new(SymbolicCharactersClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharactersClause

	return p
}

func (s *SymbolicCharactersClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharactersClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicCharactersClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *SymbolicCharactersClauseContext) AllSymbolicCharacters() []ISymbolicCharactersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicCharactersContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicCharactersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicCharactersContext); ok {
			tst[i] = t.(ISymbolicCharactersContext)
			i++
		}
	}

	return tst
}

func (s *SymbolicCharactersClauseContext) SymbolicCharacters(i int) ISymbolicCharactersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicCharactersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharactersContext)
}

func (s *SymbolicCharactersClauseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *SymbolicCharactersClauseContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SymbolicCharactersClauseContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *SymbolicCharactersClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *SymbolicCharactersClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SymbolicCharactersClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharactersClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharactersClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharactersClause(s)
	}
}

func (s *SymbolicCharactersClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharactersClause(s)
	}
}

func (s *SymbolicCharactersClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicCharactersClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicCharactersClause() (localctx ISymbolicCharactersClauseContext) {
	this := p
	_ = this

	localctx = NewSymbolicCharactersClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, Cobol85ParserRULE_symbolicCharactersClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1660)
		p.Match(Cobol85ParserSYMBOLIC)
	}
	p.SetState(1662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(1661)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}
	p.SetState(1668)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(1664)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(1667)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserALPHANUMERIC || _la == Cobol85ParserNATIONAL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1671)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1670)
				p.SymbolicCharacters()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1673)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 103, p.GetParserRuleContext())
	}
	p.SetState(1677)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(1675)
			p.Match(Cobol85ParserIN)
		}
		{
			p.SetState(1676)
			p.AlphabetName()
		}

	}

	return localctx
}

// ISymbolicCharactersContext is an interface to support dynamic dispatch.
type ISymbolicCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharactersContext differentiates from other interfaces.
	IsSymbolicCharactersContext()
}

type SymbolicCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharactersContext() *SymbolicCharactersContext {
	var p = new(SymbolicCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacters
	return p
}

func (*SymbolicCharactersContext) IsSymbolicCharactersContext() {}

func NewSymbolicCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharactersContext {
	var p = new(SymbolicCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacters

	return p
}

func (s *SymbolicCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharactersContext) AllSymbolicCharacter() []ISymbolicCharacterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicCharacterContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicCharacterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicCharacterContext); ok {
			tst[i] = t.(ISymbolicCharacterContext)
			i++
		}
	}

	return tst
}

func (s *SymbolicCharactersContext) SymbolicCharacter(i int) ISymbolicCharacterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicCharacterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicCharacterContext)
}

func (s *SymbolicCharactersContext) AllIntegerLiteral() []IIntegerLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			len++
		}
	}

	tst := make([]IIntegerLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIntegerLiteralContext); ok {
			tst[i] = t.(IIntegerLiteralContext)
			i++
		}
	}

	return tst
}

func (s *SymbolicCharactersContext) IntegerLiteral(i int) IIntegerLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SymbolicCharactersContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicCharactersContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *SymbolicCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharacters(s)
	}
}

func (s *SymbolicCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharacters(s)
	}
}

func (s *SymbolicCharactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicCharacters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicCharacters() (localctx ISymbolicCharactersContext) {
	this := p
	_ = this

	localctx = NewSymbolicCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, Cobol85ParserRULE_symbolicCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1680)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(1679)
			p.SymbolicCharacter()
		}

		p.SetState(1682)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserIS {
		{
			p.SetState(1684)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserARE || _la == Cobol85ParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1688)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		{
			p.SetState(1687)
			p.IntegerLiteral()
		}

		p.SetState(1690)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInputOutputSectionContext is an interface to support dynamic dispatch.
type IInputOutputSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputOutputSectionContext differentiates from other interfaces.
	IsInputOutputSectionContext()
}

type InputOutputSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputOutputSectionContext() *InputOutputSectionContext {
	var p = new(InputOutputSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inputOutputSection
	return p
}

func (*InputOutputSectionContext) IsInputOutputSectionContext() {}

func NewInputOutputSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputOutputSectionContext {
	var p = new(InputOutputSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inputOutputSection

	return p
}

func (s *InputOutputSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InputOutputSectionContext) INPUT_OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT_OUTPUT, 0)
}

func (s *InputOutputSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *InputOutputSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *InputOutputSectionContext) AllInputOutputSectionParagraph() []IInputOutputSectionParagraphContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInputOutputSectionParagraphContext); ok {
			len++
		}
	}

	tst := make([]IInputOutputSectionParagraphContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInputOutputSectionParagraphContext); ok {
			tst[i] = t.(IInputOutputSectionParagraphContext)
			i++
		}
	}

	return tst
}

func (s *InputOutputSectionContext) InputOutputSectionParagraph(i int) IInputOutputSectionParagraphContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInputOutputSectionParagraphContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInputOutputSectionParagraphContext)
}

func (s *InputOutputSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputOutputSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputOutputSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInputOutputSection(s)
	}
}

func (s *InputOutputSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInputOutputSection(s)
	}
}

func (s *InputOutputSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInputOutputSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InputOutputSection() (localctx IInputOutputSectionContext) {
	this := p
	_ = this

	localctx = NewInputOutputSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, Cobol85ParserRULE_inputOutputSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1692)
		p.Match(Cobol85ParserINPUT_OUTPUT)
	}
	{
		p.SetState(1693)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1694)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1698)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserFILE_CONTROL || _la == Cobol85ParserI_O_CONTROL {
		{
			p.SetState(1695)
			p.InputOutputSectionParagraph()
		}

		p.SetState(1700)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInputOutputSectionParagraphContext is an interface to support dynamic dispatch.
type IInputOutputSectionParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInputOutputSectionParagraphContext differentiates from other interfaces.
	IsInputOutputSectionParagraphContext()
}

type InputOutputSectionParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInputOutputSectionParagraphContext() *InputOutputSectionParagraphContext {
	var p = new(InputOutputSectionParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inputOutputSectionParagraph
	return p
}

func (*InputOutputSectionParagraphContext) IsInputOutputSectionParagraphContext() {}

func NewInputOutputSectionParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InputOutputSectionParagraphContext {
	var p = new(InputOutputSectionParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inputOutputSectionParagraph

	return p
}

func (s *InputOutputSectionParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *InputOutputSectionParagraphContext) FileControlParagraph() IFileControlParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileControlParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileControlParagraphContext)
}

func (s *InputOutputSectionParagraphContext) IoControlParagraph() IIoControlParagraphContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIoControlParagraphContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIoControlParagraphContext)
}

func (s *InputOutputSectionParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InputOutputSectionParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InputOutputSectionParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInputOutputSectionParagraph(s)
	}
}

func (s *InputOutputSectionParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInputOutputSectionParagraph(s)
	}
}

func (s *InputOutputSectionParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInputOutputSectionParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InputOutputSectionParagraph() (localctx IInputOutputSectionParagraphContext) {
	this := p
	_ = this

	localctx = NewInputOutputSectionParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, Cobol85ParserRULE_inputOutputSectionParagraph)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1703)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFILE_CONTROL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1701)
			p.FileControlParagraph()
		}

	case Cobol85ParserI_O_CONTROL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1702)
			p.IoControlParagraph()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileControlParagraphContext is an interface to support dynamic dispatch.
type IFileControlParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlParagraphContext differentiates from other interfaces.
	IsFileControlParagraphContext()
}

type FileControlParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlParagraphContext() *FileControlParagraphContext {
	var p = new(FileControlParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlParagraph
	return p
}

func (*FileControlParagraphContext) IsFileControlParagraphContext() {}

func NewFileControlParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlParagraphContext {
	var p = new(FileControlParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlParagraph

	return p
}

func (s *FileControlParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlParagraphContext) FILE_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE_CONTROL, 0)
}

func (s *FileControlParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *FileControlParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *FileControlParagraphContext) AllFileControlEntry() []IFileControlEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileControlEntryContext); ok {
			len++
		}
	}

	tst := make([]IFileControlEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileControlEntryContext); ok {
			tst[i] = t.(IFileControlEntryContext)
			i++
		}
	}

	return tst
}

func (s *FileControlParagraphContext) FileControlEntry(i int) IFileControlEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileControlEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileControlEntryContext)
}

func (s *FileControlParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlParagraph(s)
	}
}

func (s *FileControlParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlParagraph(s)
	}
}

func (s *FileControlParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileControlParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileControlParagraph() (localctx IFileControlParagraphContext) {
	this := p
	_ = this

	localctx = NewFileControlParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, Cobol85ParserRULE_fileControlParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1705)
		p.Match(Cobol85ParserFILE_CONTROL)
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(1707)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserDOT_FS {
				{
					p.SetState(1706)
					p.Match(Cobol85ParserDOT_FS)
				}

			}
			{
				p.SetState(1709)
				p.FileControlEntry()
			}

		}
		p.SetState(1714)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 111, p.GetParserRuleContext())
	}
	{
		p.SetState(1715)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IFileControlEntryContext is an interface to support dynamic dispatch.
type IFileControlEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlEntryContext differentiates from other interfaces.
	IsFileControlEntryContext()
}

type FileControlEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlEntryContext() *FileControlEntryContext {
	var p = new(FileControlEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlEntry
	return p
}

func (*FileControlEntryContext) IsFileControlEntryContext() {}

func NewFileControlEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlEntryContext {
	var p = new(FileControlEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlEntry

	return p
}

func (s *FileControlEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlEntryContext) SelectClause() ISelectClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectClauseContext)
}

func (s *FileControlEntryContext) AllFileControlClause() []IFileControlClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileControlClauseContext); ok {
			len++
		}
	}

	tst := make([]IFileControlClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileControlClauseContext); ok {
			tst[i] = t.(IFileControlClauseContext)
			i++
		}
	}

	return tst
}

func (s *FileControlEntryContext) FileControlClause(i int) IFileControlClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileControlClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileControlClauseContext)
}

func (s *FileControlEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlEntry(s)
	}
}

func (s *FileControlEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlEntry(s)
	}
}

func (s *FileControlEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileControlEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileControlEntry() (localctx IFileControlEntryContext) {
	this := p
	_ = this

	localctx = NewFileControlEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, Cobol85ParserRULE_fileControlEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1717)
		p.SelectClause()
	}
	p.SetState(1721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4398180990984) != 0 || _la == Cobol85ParserFILE || _la == Cobol85ParserINDEXED || (int64((_la-279)) & ^0x3f) == 0 && ((int64(1)<<(_la-279))&-8061443332993187839) != 0 || (int64((_la-377)) & ^0x3f) == 0 && ((int64(1)<<(_la-377))&4503599635759617) != 0 || _la == Cobol85ParserSTATUS {
		{
			p.SetState(1718)
			p.FileControlClause()
		}

		p.SetState(1723)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISelectClauseContext is an interface to support dynamic dispatch.
type ISelectClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSelectClauseContext differentiates from other interfaces.
	IsSelectClauseContext()
}

type SelectClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectClauseContext() *SelectClauseContext {
	var p = new(SelectClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_selectClause
	return p
}

func (*SelectClauseContext) IsSelectClauseContext() {}

func NewSelectClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectClauseContext {
	var p = new(SelectClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_selectClause

	return p
}

func (s *SelectClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectClauseContext) SELECT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSELECT, 0)
}

func (s *SelectClauseContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SelectClauseContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIONAL, 0)
}

func (s *SelectClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSelectClause(s)
	}
}

func (s *SelectClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSelectClause(s)
	}
}

func (s *SelectClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSelectClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SelectClause() (localctx ISelectClauseContext) {
	this := p
	_ = this

	localctx = NewSelectClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, Cobol85ParserRULE_selectClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1724)
		p.Match(Cobol85ParserSELECT)
	}
	p.SetState(1726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOPTIONAL {
		{
			p.SetState(1725)
			p.Match(Cobol85ParserOPTIONAL)
		}

	}
	{
		p.SetState(1728)
		p.FileName()
	}

	return localctx
}

// IFileControlClauseContext is an interface to support dynamic dispatch.
type IFileControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileControlClauseContext differentiates from other interfaces.
	IsFileControlClauseContext()
}

type FileControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileControlClauseContext() *FileControlClauseContext {
	var p = new(FileControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileControlClause
	return p
}

func (*FileControlClauseContext) IsFileControlClauseContext() {}

func NewFileControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileControlClauseContext {
	var p = new(FileControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileControlClause

	return p
}

func (s *FileControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileControlClauseContext) AssignClause() IAssignClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignClauseContext)
}

func (s *FileControlClauseContext) ReserveClause() IReserveClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReserveClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReserveClauseContext)
}

func (s *FileControlClauseContext) OrganizationClause() IOrganizationClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrganizationClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrganizationClauseContext)
}

func (s *FileControlClauseContext) PaddingCharacterClause() IPaddingCharacterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPaddingCharacterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPaddingCharacterClauseContext)
}

func (s *FileControlClauseContext) RecordDelimiterClause() IRecordDelimiterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordDelimiterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordDelimiterClauseContext)
}

func (s *FileControlClauseContext) AccessModeClause() IAccessModeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModeClauseContext)
}

func (s *FileControlClauseContext) RecordKeyClause() IRecordKeyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordKeyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordKeyClauseContext)
}

func (s *FileControlClauseContext) AlternateRecordKeyClause() IAlternateRecordKeyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlternateRecordKeyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlternateRecordKeyClauseContext)
}

func (s *FileControlClauseContext) FileStatusClause() IFileStatusClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileStatusClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileStatusClauseContext)
}

func (s *FileControlClauseContext) PasswordClause() IPasswordClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *FileControlClauseContext) RelativeKeyClause() IRelativeKeyClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativeKeyClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativeKeyClauseContext)
}

func (s *FileControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileControlClause(s)
	}
}

func (s *FileControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileControlClause(s)
	}
}

func (s *FileControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileControlClause() (localctx IFileControlClauseContext) {
	this := p
	_ = this

	localctx = NewFileControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, Cobol85ParserRULE_fileControlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1741)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1730)
			p.AssignClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1731)
			p.ReserveClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1732)
			p.OrganizationClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1733)
			p.PaddingCharacterClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1734)
			p.RecordDelimiterClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1735)
			p.AccessModeClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1736)
			p.RecordKeyClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1737)
			p.AlternateRecordKeyClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1738)
			p.FileStatusClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1739)
			p.PasswordClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1740)
			p.RelativeKeyClause()
		}

	}

	return localctx
}

// IAssignClauseContext is an interface to support dynamic dispatch.
type IAssignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignClauseContext differentiates from other interfaces.
	IsAssignClauseContext()
}

type AssignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignClauseContext() *AssignClauseContext {
	var p = new(AssignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_assignClause
	return p
}

func (*AssignClauseContext) IsAssignClauseContext() {}

func NewAssignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignClauseContext {
	var p = new(AssignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_assignClause

	return p
}

func (s *AssignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignClauseContext) ASSIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSIGN, 0)
}

func (s *AssignClauseContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *AssignClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *AssignClauseContext) KEYBOARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEYBOARD, 0)
}

func (s *AssignClauseContext) PORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPORT, 0)
}

func (s *AssignClauseContext) PRINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRINTER, 0)
}

func (s *AssignClauseContext) READER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREADER, 0)
}

func (s *AssignClauseContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOTE, 0)
}

func (s *AssignClauseContext) TAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTAPE, 0)
}

func (s *AssignClauseContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVIRTUAL, 0)
}

func (s *AssignClauseContext) AssignmentName() IAssignmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *AssignClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AssignClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AssignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAssignClause(s)
	}
}

func (s *AssignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAssignClause(s)
	}
}

func (s *AssignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAssignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AssignClause() (localctx IAssignClauseContext) {
	this := p
	_ = this

	localctx = NewAssignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, Cobol85ParserRULE_assignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1743)
		p.Match(Cobol85ParserASSIGN)
	}
	p.SetState(1745)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(1744)
			p.Match(Cobol85ParserTO)
		}

	}
	p.SetState(1758)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1747)
			p.Match(Cobol85ParserDISK)
		}

	case 2:
		{
			p.SetState(1748)
			p.Match(Cobol85ParserDISPLAY)
		}

	case 3:
		{
			p.SetState(1749)
			p.Match(Cobol85ParserKEYBOARD)
		}

	case 4:
		{
			p.SetState(1750)
			p.Match(Cobol85ParserPORT)
		}

	case 5:
		{
			p.SetState(1751)
			p.Match(Cobol85ParserPRINTER)
		}

	case 6:
		{
			p.SetState(1752)
			p.Match(Cobol85ParserREADER)
		}

	case 7:
		{
			p.SetState(1753)
			p.Match(Cobol85ParserREMOTE)
		}

	case 8:
		{
			p.SetState(1754)
			p.Match(Cobol85ParserTAPE)
		}

	case 9:
		{
			p.SetState(1755)
			p.Match(Cobol85ParserVIRTUAL)
		}

	case 10:
		{
			p.SetState(1756)
			p.AssignmentName()
		}

	case 11:
		{
			p.SetState(1757)
			p.Literal()
		}

	}

	return localctx
}

// IReserveClauseContext is an interface to support dynamic dispatch.
type IReserveClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReserveClauseContext differentiates from other interfaces.
	IsReserveClauseContext()
}

type ReserveClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReserveClauseContext() *ReserveClauseContext {
	var p = new(ReserveClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reserveClause
	return p
}

func (*ReserveClauseContext) IsReserveClauseContext() {}

func NewReserveClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReserveClauseContext {
	var p = new(ReserveClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reserveClause

	return p
}

func (s *ReserveClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReserveClauseContext) RESERVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESERVE, 0)
}

func (s *ReserveClauseContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReserveClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReserveClauseContext) ALTERNATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTERNATE, 0)
}

func (s *ReserveClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *ReserveClauseContext) AREAS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREAS, 0)
}

func (s *ReserveClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReserveClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReserveClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReserveClause(s)
	}
}

func (s *ReserveClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReserveClause(s)
	}
}

func (s *ReserveClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReserveClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReserveClause() (localctx IReserveClauseContext) {
	this := p
	_ = this

	localctx = NewReserveClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, Cobol85ParserRULE_reserveClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1760)
		p.Match(Cobol85ParserRESERVE)
	}
	p.SetState(1763)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNO:
		{
			p.SetState(1761)
			p.Match(Cobol85ParserNO)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(1762)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(1766)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 118, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1765)
			p.Match(Cobol85ParserALTERNATE)
		}

	}
	p.SetState(1769)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAREA || _la == Cobol85ParserAREAS {
		{
			p.SetState(1768)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserAREA || _la == Cobol85ParserAREAS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IOrganizationClauseContext is an interface to support dynamic dispatch.
type IOrganizationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOrganizationClauseContext differentiates from other interfaces.
	IsOrganizationClauseContext()
}

type OrganizationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrganizationClauseContext() *OrganizationClauseContext {
	var p = new(OrganizationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_organizationClause
	return p
}

func (*OrganizationClauseContext) IsOrganizationClauseContext() {}

func NewOrganizationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrganizationClauseContext {
	var p = new(OrganizationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_organizationClause

	return p
}

func (s *OrganizationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrganizationClauseContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENTIAL, 0)
}

func (s *OrganizationClauseContext) RELATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELATIVE, 0)
}

func (s *OrganizationClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *OrganizationClauseContext) ORGANIZATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORGANIZATION, 0)
}

func (s *OrganizationClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *OrganizationClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *OrganizationClauseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *OrganizationClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *OrganizationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrganizationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrganizationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOrganizationClause(s)
	}
}

func (s *OrganizationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOrganizationClause(s)
	}
}

func (s *OrganizationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOrganizationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OrganizationClause() (localctx IOrganizationClauseContext) {
	this := p
	_ = this

	localctx = NewOrganizationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, Cobol85ParserRULE_organizationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1775)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserORGANIZATION {
		{
			p.SetState(1771)
			p.Match(Cobol85ParserORGANIZATION)
		}
		p.SetState(1773)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(1772)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(1782)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1777)
			p.Match(Cobol85ParserLINE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(1778)
			p.Match(Cobol85ParserRECORD)
		}
		{
			p.SetState(1779)
			p.Match(Cobol85ParserBINARY)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(1780)
			p.Match(Cobol85ParserRECORD)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 122, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(1781)
			p.Match(Cobol85ParserBINARY)
		}

	}
	{
		p.SetState(1784)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserINDEXED || _la == Cobol85ParserRELATIVE || _la == Cobol85ParserSEQUENTIAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPaddingCharacterClauseContext is an interface to support dynamic dispatch.
type IPaddingCharacterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPaddingCharacterClauseContext differentiates from other interfaces.
	IsPaddingCharacterClauseContext()
}

type PaddingCharacterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPaddingCharacterClauseContext() *PaddingCharacterClauseContext {
	var p = new(PaddingCharacterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paddingCharacterClause
	return p
}

func (*PaddingCharacterClauseContext) IsPaddingCharacterClauseContext() {}

func NewPaddingCharacterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PaddingCharacterClauseContext {
	var p = new(PaddingCharacterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paddingCharacterClause

	return p
}

func (s *PaddingCharacterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PaddingCharacterClauseContext) PADDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPADDING, 0)
}

func (s *PaddingCharacterClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *PaddingCharacterClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PaddingCharacterClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *PaddingCharacterClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *PaddingCharacterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PaddingCharacterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PaddingCharacterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPaddingCharacterClause(s)
	}
}

func (s *PaddingCharacterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPaddingCharacterClause(s)
	}
}

func (s *PaddingCharacterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPaddingCharacterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PaddingCharacterClause() (localctx IPaddingCharacterClauseContext) {
	this := p
	_ = this

	localctx = NewPaddingCharacterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, Cobol85ParserRULE_paddingCharacterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1786)
		p.Match(Cobol85ParserPADDING)
	}
	p.SetState(1788)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(1787)
			p.Match(Cobol85ParserCHARACTER)
		}

	}
	p.SetState(1791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1790)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1795)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 125, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1793)
			p.QualifiedDataName()
		}

	case 2:
		{
			p.SetState(1794)
			p.Literal()
		}

	}

	return localctx
}

// IRecordDelimiterClauseContext is an interface to support dynamic dispatch.
type IRecordDelimiterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordDelimiterClauseContext differentiates from other interfaces.
	IsRecordDelimiterClauseContext()
}

type RecordDelimiterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordDelimiterClauseContext() *RecordDelimiterClauseContext {
	var p = new(RecordDelimiterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordDelimiterClause
	return p
}

func (*RecordDelimiterClauseContext) IsRecordDelimiterClauseContext() {}

func NewRecordDelimiterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordDelimiterClauseContext {
	var p = new(RecordDelimiterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordDelimiterClause

	return p
}

func (s *RecordDelimiterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordDelimiterClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordDelimiterClauseContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITER, 0)
}

func (s *RecordDelimiterClauseContext) STANDARD_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD_1, 0)
}

func (s *RecordDelimiterClauseContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPLICIT, 0)
}

func (s *RecordDelimiterClauseContext) AssignmentName() IAssignmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *RecordDelimiterClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordDelimiterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordDelimiterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordDelimiterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordDelimiterClause(s)
	}
}

func (s *RecordDelimiterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordDelimiterClause(s)
	}
}

func (s *RecordDelimiterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordDelimiterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordDelimiterClause() (localctx IRecordDelimiterClauseContext) {
	this := p
	_ = this

	localctx = NewRecordDelimiterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, Cobol85ParserRULE_recordDelimiterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1797)
		p.Match(Cobol85ParserRECORD)
	}
	{
		p.SetState(1798)
		p.Match(Cobol85ParserDELIMITER)
	}
	p.SetState(1800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1799)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(1805)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 127, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1802)
			p.Match(Cobol85ParserSTANDARD_1)
		}

	case 2:
		{
			p.SetState(1803)
			p.Match(Cobol85ParserIMPLICIT)
		}

	case 3:
		{
			p.SetState(1804)
			p.AssignmentName()
		}

	}

	return localctx
}

// IAccessModeClauseContext is an interface to support dynamic dispatch.
type IAccessModeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAccessModeClauseContext differentiates from other interfaces.
	IsAccessModeClauseContext()
}

type AccessModeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModeClauseContext() *AccessModeClauseContext {
	var p = new(AccessModeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_accessModeClause
	return p
}

func (*AccessModeClauseContext) IsAccessModeClauseContext() {}

func NewAccessModeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModeClauseContext {
	var p = new(AccessModeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_accessModeClause

	return p
}

func (s *AccessModeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AccessModeClauseContext) ACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserACCESS, 0)
}

func (s *AccessModeClauseContext) SEQUENTIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENTIAL, 0)
}

func (s *AccessModeClauseContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRANDOM, 0)
}

func (s *AccessModeClauseContext) DYNAMIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDYNAMIC, 0)
}

func (s *AccessModeClauseContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCLUSIVE, 0)
}

func (s *AccessModeClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *AccessModeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AccessModeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccessModeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAccessModeClause(s)
	}
}

func (s *AccessModeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAccessModeClause(s)
	}
}

func (s *AccessModeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAccessModeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AccessModeClause() (localctx IAccessModeClauseContext) {
	this := p
	_ = this

	localctx = NewAccessModeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, Cobol85ParserRULE_accessModeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1807)
		p.Match(Cobol85ParserACCESS)
	}
	p.SetState(1809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODE {
		{
			p.SetState(1808)
			p.Match(Cobol85ParserMODE)
		}

	}
	p.SetState(1812)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1811)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1814)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDYNAMIC || _la == Cobol85ParserEXCLUSIVE || _la == Cobol85ParserRANDOM || _la == Cobol85ParserSEQUENTIAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRecordKeyClauseContext is an interface to support dynamic dispatch.
type IRecordKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordKeyClauseContext differentiates from other interfaces.
	IsRecordKeyClauseContext()
}

type RecordKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordKeyClauseContext() *RecordKeyClauseContext {
	var p = new(RecordKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordKeyClause
	return p
}

func (*RecordKeyClauseContext) IsRecordKeyClauseContext() {}

func NewRecordKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordKeyClauseContext {
	var p = new(RecordKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordKeyClause

	return p
}

func (s *RecordKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordKeyClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *RecordKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordKeyClauseContext) PasswordClause() IPasswordClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *RecordKeyClauseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *RecordKeyClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *RecordKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordKeyClause(s)
	}
}

func (s *RecordKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordKeyClause(s)
	}
}

func (s *RecordKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordKeyClause() (localctx IRecordKeyClauseContext) {
	this := p
	_ = this

	localctx = NewRecordKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, Cobol85ParserRULE_recordKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1816)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(1818)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1817)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1820)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1823)
		p.QualifiedDataName()
	}
	p.SetState(1825)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1824)
			p.PasswordClause()
		}

	}
	p.SetState(1831)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDUPLICATES || _la == Cobol85ParserWITH {
		p.SetState(1828)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1827)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1830)
			p.Match(Cobol85ParserDUPLICATES)
		}

	}

	return localctx
}

// IAlternateRecordKeyClauseContext is an interface to support dynamic dispatch.
type IAlternateRecordKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlternateRecordKeyClauseContext differentiates from other interfaces.
	IsAlternateRecordKeyClauseContext()
}

type AlternateRecordKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlternateRecordKeyClauseContext() *AlternateRecordKeyClauseContext {
	var p = new(AlternateRecordKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alternateRecordKeyClause
	return p
}

func (*AlternateRecordKeyClauseContext) IsAlternateRecordKeyClauseContext() {}

func NewAlternateRecordKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlternateRecordKeyClauseContext {
	var p = new(AlternateRecordKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alternateRecordKeyClause

	return p
}

func (s *AlternateRecordKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AlternateRecordKeyClauseContext) ALTERNATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTERNATE, 0)
}

func (s *AlternateRecordKeyClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *AlternateRecordKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *AlternateRecordKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *AlternateRecordKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *AlternateRecordKeyClauseContext) PasswordClause() IPasswordClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPasswordClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPasswordClauseContext)
}

func (s *AlternateRecordKeyClauseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *AlternateRecordKeyClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *AlternateRecordKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlternateRecordKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlternateRecordKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlternateRecordKeyClause(s)
	}
}

func (s *AlternateRecordKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlternateRecordKeyClause(s)
	}
}

func (s *AlternateRecordKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlternateRecordKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlternateRecordKeyClause() (localctx IAlternateRecordKeyClauseContext) {
	this := p
	_ = this

	localctx = NewAlternateRecordKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, Cobol85ParserRULE_alternateRecordKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1833)
		p.Match(Cobol85ParserALTERNATE)
	}
	{
		p.SetState(1834)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(1836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1835)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1838)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1841)
		p.QualifiedDataName()
	}
	p.SetState(1843)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 137, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1842)
			p.PasswordClause()
		}

	}
	p.SetState(1849)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDUPLICATES || _la == Cobol85ParserWITH {
		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(1845)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(1848)
			p.Match(Cobol85ParserDUPLICATES)
		}

	}

	return localctx
}

// IPasswordClauseContext is an interface to support dynamic dispatch.
type IPasswordClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPasswordClauseContext differentiates from other interfaces.
	IsPasswordClauseContext()
}

type PasswordClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPasswordClauseContext() *PasswordClauseContext {
	var p = new(PasswordClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_passwordClause
	return p
}

func (*PasswordClauseContext) IsPasswordClauseContext() {}

func NewPasswordClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PasswordClauseContext {
	var p = new(PasswordClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_passwordClause

	return p
}

func (s *PasswordClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PasswordClauseContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPASSWORD, 0)
}

func (s *PasswordClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *PasswordClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *PasswordClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PasswordClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PasswordClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPasswordClause(s)
	}
}

func (s *PasswordClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPasswordClause(s)
	}
}

func (s *PasswordClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPasswordClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PasswordClause() (localctx IPasswordClauseContext) {
	this := p
	_ = this

	localctx = NewPasswordClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, Cobol85ParserRULE_passwordClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1851)
		p.Match(Cobol85ParserPASSWORD)
	}
	p.SetState(1853)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1852)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1855)
		p.DataName()
	}

	return localctx
}

// IFileStatusClauseContext is an interface to support dynamic dispatch.
type IFileStatusClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileStatusClauseContext differentiates from other interfaces.
	IsFileStatusClauseContext()
}

type FileStatusClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileStatusClauseContext() *FileStatusClauseContext {
	var p = new(FileStatusClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileStatusClause
	return p
}

func (*FileStatusClauseContext) IsFileStatusClauseContext() {}

func NewFileStatusClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileStatusClauseContext {
	var p = new(FileStatusClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileStatusClause

	return p
}

func (s *FileStatusClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileStatusClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *FileStatusClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedDataNameContext); ok {
			tst[i] = t.(IQualifiedDataNameContext)
			i++
		}
	}

	return tst
}

func (s *FileStatusClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *FileStatusClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *FileStatusClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *FileStatusClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileStatusClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileStatusClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileStatusClause(s)
	}
}

func (s *FileStatusClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileStatusClause(s)
	}
}

func (s *FileStatusClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileStatusClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileStatusClause() (localctx IFileStatusClauseContext) {
	this := p
	_ = this

	localctx = NewFileStatusClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, Cobol85ParserRULE_fileStatusClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFILE {
		{
			p.SetState(1857)
			p.Match(Cobol85ParserFILE)
		}

	}
	{
		p.SetState(1860)
		p.Match(Cobol85ParserSTATUS)
	}
	p.SetState(1862)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1861)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1864)
		p.QualifiedDataName()
	}
	p.SetState(1866)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 143, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1865)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IRelativeKeyClauseContext is an interface to support dynamic dispatch.
type IRelativeKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelativeKeyClauseContext differentiates from other interfaces.
	IsRelativeKeyClauseContext()
}

type RelativeKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeKeyClauseContext() *RelativeKeyClauseContext {
	var p = new(RelativeKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relativeKeyClause
	return p
}

func (*RelativeKeyClauseContext) IsRelativeKeyClauseContext() {}

func NewRelativeKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeKeyClauseContext {
	var p = new(RelativeKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relativeKeyClause

	return p
}

func (s *RelativeKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RelativeKeyClauseContext) RELATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELATIVE, 0)
}

func (s *RelativeKeyClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RelativeKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *RelativeKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelativeKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelativeKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelativeKeyClause(s)
	}
}

func (s *RelativeKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelativeKeyClause(s)
	}
}

func (s *RelativeKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelativeKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelativeKeyClause() (localctx IRelativeKeyClauseContext) {
	this := p
	_ = this

	localctx = NewRelativeKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, Cobol85ParserRULE_relativeKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1868)
		p.Match(Cobol85ParserRELATIVE)
	}
	p.SetState(1870)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(1869)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(1873)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(1872)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(1875)
		p.QualifiedDataName()
	}

	return localctx
}

// IIoControlParagraphContext is an interface to support dynamic dispatch.
type IIoControlParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoControlParagraphContext differentiates from other interfaces.
	IsIoControlParagraphContext()
}

type IoControlParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoControlParagraphContext() *IoControlParagraphContext {
	var p = new(IoControlParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ioControlParagraph
	return p
}

func (*IoControlParagraphContext) IsIoControlParagraphContext() {}

func NewIoControlParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoControlParagraphContext {
	var p = new(IoControlParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ioControlParagraph

	return p
}

func (s *IoControlParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *IoControlParagraphContext) I_O_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O_CONTROL, 0)
}

func (s *IoControlParagraphContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *IoControlParagraphContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *IoControlParagraphContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *IoControlParagraphContext) AllIoControlClause() []IIoControlClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIoControlClauseContext); ok {
			len++
		}
	}

	tst := make([]IIoControlClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIoControlClauseContext); ok {
			tst[i] = t.(IIoControlClauseContext)
			i++
		}
	}

	return tst
}

func (s *IoControlParagraphContext) IoControlClause(i int) IIoControlClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIoControlClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIoControlClauseContext)
}

func (s *IoControlParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoControlParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoControlParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIoControlParagraph(s)
	}
}

func (s *IoControlParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIoControlParagraph(s)
	}
}

func (s *IoControlParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIoControlParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IoControlParagraph() (localctx IIoControlParagraphContext) {
	this := p
	_ = this

	localctx = NewIoControlParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, Cobol85ParserRULE_ioControlParagraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1877)
		p.Match(Cobol85ParserI_O_CONTROL)
	}
	{
		p.SetState(1878)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1882)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 146, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1879)
			p.FileName()
		}
		{
			p.SetState(1880)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(1891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMITMENT || _la == Cobol85ParserMULTIPLE || _la == Cobol85ParserRERUN || _la == Cobol85ParserSAME || _la == Cobol85ParserDOT_FS {
		p.SetState(1887)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserCOMMITMENT || _la == Cobol85ParserMULTIPLE || _la == Cobol85ParserRERUN || _la == Cobol85ParserSAME {
			{
				p.SetState(1884)
				p.IoControlClause()
			}

			p.SetState(1889)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(1890)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// IIoControlClauseContext is an interface to support dynamic dispatch.
type IIoControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIoControlClauseContext differentiates from other interfaces.
	IsIoControlClauseContext()
}

type IoControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIoControlClauseContext() *IoControlClauseContext {
	var p = new(IoControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ioControlClause
	return p
}

func (*IoControlClauseContext) IsIoControlClauseContext() {}

func NewIoControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IoControlClauseContext {
	var p = new(IoControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ioControlClause

	return p
}

func (s *IoControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IoControlClauseContext) RerunClause() IRerunClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRerunClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRerunClauseContext)
}

func (s *IoControlClauseContext) SameClause() ISameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISameClauseContext)
}

func (s *IoControlClauseContext) MultipleFileClause() IMultipleFileClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleFileClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleFileClauseContext)
}

func (s *IoControlClauseContext) CommitmentControlClause() ICommitmentControlClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommitmentControlClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommitmentControlClauseContext)
}

func (s *IoControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IoControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IoControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIoControlClause(s)
	}
}

func (s *IoControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIoControlClause(s)
	}
}

func (s *IoControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIoControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IoControlClause() (localctx IIoControlClauseContext) {
	this := p
	_ = this

	localctx = NewIoControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, Cobol85ParserRULE_ioControlClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1897)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRERUN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1893)
			p.RerunClause()
		}

	case Cobol85ParserSAME:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1894)
			p.SameClause()
		}

	case Cobol85ParserMULTIPLE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1895)
			p.MultipleFileClause()
		}

	case Cobol85ParserCOMMITMENT:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1896)
			p.CommitmentControlClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRerunClauseContext is an interface to support dynamic dispatch.
type IRerunClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunClauseContext differentiates from other interfaces.
	IsRerunClauseContext()
}

type RerunClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunClauseContext() *RerunClauseContext {
	var p = new(RerunClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunClause
	return p
}

func (*RerunClauseContext) IsRerunClauseContext() {}

func NewRerunClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunClauseContext {
	var p = new(RerunClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunClause

	return p
}

func (s *RerunClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunClauseContext) RERUN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRERUN, 0)
}

func (s *RerunClauseContext) EVERY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVERY, 0)
}

func (s *RerunClauseContext) RerunEveryRecords() IRerunEveryRecordsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRerunEveryRecordsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRerunEveryRecordsContext)
}

func (s *RerunClauseContext) RerunEveryOf() IRerunEveryOfContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRerunEveryOfContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRerunEveryOfContext)
}

func (s *RerunClauseContext) RerunEveryClock() IRerunEveryClockContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRerunEveryClockContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRerunEveryClockContext)
}

func (s *RerunClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *RerunClauseContext) AssignmentName() IAssignmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAssignmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAssignmentNameContext)
}

func (s *RerunClauseContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *RerunClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunClause(s)
	}
}

func (s *RerunClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunClause(s)
	}
}

func (s *RerunClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunClause() (localctx IRerunClauseContext) {
	this := p
	_ = this

	localctx = NewRerunClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, Cobol85ParserRULE_rerunClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1899)
		p.Match(Cobol85ParserRERUN)
	}
	p.SetState(1905)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(1900)
			p.Match(Cobol85ParserON)
		}
		p.SetState(1903)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 150, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1901)
				p.AssignmentName()
			}

		case 2:
			{
				p.SetState(1902)
				p.FileName()
			}

		}

	}
	{
		p.SetState(1907)
		p.Match(Cobol85ParserEVERY)
	}
	p.SetState(1911)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 152, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1908)
			p.RerunEveryRecords()
		}

	case 2:
		{
			p.SetState(1909)
			p.RerunEveryOf()
		}

	case 3:
		{
			p.SetState(1910)
			p.RerunEveryClock()
		}

	}

	return localctx
}

// IRerunEveryRecordsContext is an interface to support dynamic dispatch.
type IRerunEveryRecordsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryRecordsContext differentiates from other interfaces.
	IsRerunEveryRecordsContext()
}

type RerunEveryRecordsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryRecordsContext() *RerunEveryRecordsContext {
	var p = new(RerunEveryRecordsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryRecords
	return p
}

func (*RerunEveryRecordsContext) IsRerunEveryRecordsContext() {}

func NewRerunEveryRecordsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryRecordsContext {
	var p = new(RerunEveryRecordsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryRecords

	return p
}

func (s *RerunEveryRecordsContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryRecordsContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RerunEveryRecordsContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *RerunEveryRecordsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryRecordsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryRecordsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryRecords(s)
	}
}

func (s *RerunEveryRecordsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryRecords(s)
	}
}

func (s *RerunEveryRecordsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunEveryRecords(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunEveryRecords() (localctx IRerunEveryRecordsContext) {
	this := p
	_ = this

	localctx = NewRerunEveryRecordsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, Cobol85ParserRULE_rerunEveryRecords)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1913)
		p.IntegerLiteral()
	}
	{
		p.SetState(1914)
		p.Match(Cobol85ParserRECORDS)
	}

	return localctx
}

// IRerunEveryOfContext is an interface to support dynamic dispatch.
type IRerunEveryOfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryOfContext differentiates from other interfaces.
	IsRerunEveryOfContext()
}

type RerunEveryOfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryOfContext() *RerunEveryOfContext {
	var p = new(RerunEveryOfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryOf
	return p
}

func (*RerunEveryOfContext) IsRerunEveryOfContext() {}

func NewRerunEveryOfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryOfContext {
	var p = new(RerunEveryOfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryOf

	return p
}

func (s *RerunEveryOfContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryOfContext) AllOF() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserOF)
}

func (s *RerunEveryOfContext) OF(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, i)
}

func (s *RerunEveryOfContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *RerunEveryOfContext) REEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREEL, 0)
}

func (s *RerunEveryOfContext) UNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNIT, 0)
}

func (s *RerunEveryOfContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *RerunEveryOfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryOfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryOfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryOf(s)
	}
}

func (s *RerunEveryOfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryOf(s)
	}
}

func (s *RerunEveryOfContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunEveryOf(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunEveryOf() (localctx IRerunEveryOfContext) {
	this := p
	_ = this

	localctx = NewRerunEveryOfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, Cobol85ParserRULE_rerunEveryOf)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1917)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserEND {
		{
			p.SetState(1916)
			p.Match(Cobol85ParserEND)
		}

	}
	p.SetState(1920)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(1919)
			p.Match(Cobol85ParserOF)
		}

	}
	{
		p.SetState(1922)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserREEL || _la == Cobol85ParserUNIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1923)
		p.Match(Cobol85ParserOF)
	}
	{
		p.SetState(1924)
		p.FileName()
	}

	return localctx
}

// IRerunEveryClockContext is an interface to support dynamic dispatch.
type IRerunEveryClockContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRerunEveryClockContext differentiates from other interfaces.
	IsRerunEveryClockContext()
}

type RerunEveryClockContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRerunEveryClockContext() *RerunEveryClockContext {
	var p = new(RerunEveryClockContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rerunEveryClock
	return p
}

func (*RerunEveryClockContext) IsRerunEveryClockContext() {}

func NewRerunEveryClockContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RerunEveryClockContext {
	var p = new(RerunEveryClockContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rerunEveryClock

	return p
}

func (s *RerunEveryClockContext) GetParser() antlr.Parser { return s.parser }

func (s *RerunEveryClockContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RerunEveryClockContext) CLOCK_UNITS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOCK_UNITS, 0)
}

func (s *RerunEveryClockContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RerunEveryClockContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RerunEveryClockContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRerunEveryClock(s)
	}
}

func (s *RerunEveryClockContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRerunEveryClock(s)
	}
}

func (s *RerunEveryClockContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRerunEveryClock(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RerunEveryClock() (localctx IRerunEveryClockContext) {
	this := p
	_ = this

	localctx = NewRerunEveryClockContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, Cobol85ParserRULE_rerunEveryClock)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1926)
		p.IntegerLiteral()
	}
	p.SetState(1928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCLOCK_UNITS {
		{
			p.SetState(1927)
			p.Match(Cobol85ParserCLOCK_UNITS)
		}

	}

	return localctx
}

// ISameClauseContext is an interface to support dynamic dispatch.
type ISameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSameClauseContext differentiates from other interfaces.
	IsSameClauseContext()
}

type SameClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySameClauseContext() *SameClauseContext {
	var p = new(SameClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sameClause
	return p
}

func (*SameClauseContext) IsSameClauseContext() {}

func NewSameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SameClauseContext {
	var p = new(SameClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sameClause

	return p
}

func (s *SameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SameClauseContext) SAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAME, 0)
}

func (s *SameClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *SameClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SameClauseContext) AllFileName() []IFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileNameContext); ok {
			len++
		}
	}

	tst := make([]IFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileNameContext); ok {
			tst[i] = t.(IFileNameContext)
			i++
		}
	}

	return tst
}

func (s *SameClauseContext) FileName(i int) IFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SameClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *SameClauseContext) SORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT, 0)
}

func (s *SameClauseContext) SORT_MERGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MERGE, 0)
}

func (s *SameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSameClause(s)
	}
}

func (s *SameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSameClause(s)
	}
}

func (s *SameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SameClause() (localctx ISameClauseContext) {
	this := p
	_ = this

	localctx = NewSameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, Cobol85ParserRULE_sameClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1930)
		p.Match(Cobol85ParserSAME)
	}
	p.SetState(1932)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD || _la == Cobol85ParserSORT || _la == Cobol85ParserSORT_MERGE {
		{
			p.SetState(1931)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserRECORD || _la == Cobol85ParserSORT || _la == Cobol85ParserSORT_MERGE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(1935)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAREA {
		{
			p.SetState(1934)
			p.Match(Cobol85ParserAREA)
		}

	}
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1937)
			p.Match(Cobol85ParserFOR)
		}

	}
	p.SetState(1941)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1940)
				p.FileName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1943)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 159, p.GetParserRuleContext())
	}

	return localctx
}

// IMultipleFileClauseContext is an interface to support dynamic dispatch.
type IMultipleFileClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleFileClauseContext differentiates from other interfaces.
	IsMultipleFileClauseContext()
}

type MultipleFileClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleFileClauseContext() *MultipleFileClauseContext {
	var p = new(MultipleFileClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multipleFileClause
	return p
}

func (*MultipleFileClauseContext) IsMultipleFileClauseContext() {}

func NewMultipleFileClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleFileClauseContext {
	var p = new(MultipleFileClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multipleFileClause

	return p
}

func (s *MultipleFileClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleFileClauseContext) MULTIPLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMULTIPLE, 0)
}

func (s *MultipleFileClauseContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *MultipleFileClauseContext) TAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTAPE, 0)
}

func (s *MultipleFileClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *MultipleFileClauseContext) AllMultipleFilePosition() []IMultipleFilePositionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultipleFilePositionContext); ok {
			len++
		}
	}

	tst := make([]IMultipleFilePositionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultipleFilePositionContext); ok {
			tst[i] = t.(IMultipleFilePositionContext)
			i++
		}
	}

	return tst
}

func (s *MultipleFileClauseContext) MultipleFilePosition(i int) IMultipleFilePositionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultipleFilePositionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultipleFilePositionContext)
}

func (s *MultipleFileClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleFileClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleFileClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultipleFileClause(s)
	}
}

func (s *MultipleFileClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultipleFileClause(s)
	}
}

func (s *MultipleFileClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultipleFileClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultipleFileClause() (localctx IMultipleFileClauseContext) {
	this := p
	_ = this

	localctx = NewMultipleFileClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, Cobol85ParserRULE_multipleFileClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1945)
		p.Match(Cobol85ParserMULTIPLE)
	}
	{
		p.SetState(1946)
		p.Match(Cobol85ParserFILE)
	}
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTAPE {
		{
			p.SetState(1947)
			p.Match(Cobol85ParserTAPE)
		}

	}
	p.SetState(1951)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(1950)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	p.SetState(1954)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(1953)
				p.MultipleFilePosition()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(1956)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 162, p.GetParserRuleContext())
	}

	return localctx
}

// IMultipleFilePositionContext is an interface to support dynamic dispatch.
type IMultipleFilePositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultipleFilePositionContext differentiates from other interfaces.
	IsMultipleFilePositionContext()
}

type MultipleFilePositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultipleFilePositionContext() *MultipleFilePositionContext {
	var p = new(MultipleFilePositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multipleFilePosition
	return p
}

func (*MultipleFilePositionContext) IsMultipleFilePositionContext() {}

func NewMultipleFilePositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultipleFilePositionContext {
	var p = new(MultipleFilePositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multipleFilePosition

	return p
}

func (s *MultipleFilePositionContext) GetParser() antlr.Parser { return s.parser }

func (s *MultipleFilePositionContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MultipleFilePositionContext) POSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOSITION, 0)
}

func (s *MultipleFilePositionContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *MultipleFilePositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultipleFilePositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultipleFilePositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultipleFilePosition(s)
	}
}

func (s *MultipleFilePositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultipleFilePosition(s)
	}
}

func (s *MultipleFilePositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultipleFilePosition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultipleFilePosition() (localctx IMultipleFilePositionContext) {
	this := p
	_ = this

	localctx = NewMultipleFilePositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, Cobol85ParserRULE_multipleFilePosition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1958)
		p.FileName()
	}
	p.SetState(1961)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPOSITION {
		{
			p.SetState(1959)
			p.Match(Cobol85ParserPOSITION)
		}
		{
			p.SetState(1960)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// ICommitmentControlClauseContext is an interface to support dynamic dispatch.
type ICommitmentControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommitmentControlClauseContext differentiates from other interfaces.
	IsCommitmentControlClauseContext()
}

type CommitmentControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommitmentControlClauseContext() *CommitmentControlClauseContext {
	var p = new(CommitmentControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_commitmentControlClause
	return p
}

func (*CommitmentControlClauseContext) IsCommitmentControlClauseContext() {}

func NewCommitmentControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommitmentControlClauseContext {
	var p = new(CommitmentControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_commitmentControlClause

	return p
}

func (s *CommitmentControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CommitmentControlClauseContext) COMMITMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMITMENT, 0)
}

func (s *CommitmentControlClauseContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *CommitmentControlClauseContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CommitmentControlClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommitmentControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommitmentControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommitmentControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommitmentControlClause(s)
	}
}

func (s *CommitmentControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommitmentControlClause(s)
	}
}

func (s *CommitmentControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommitmentControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommitmentControlClause() (localctx ICommitmentControlClauseContext) {
	this := p
	_ = this

	localctx = NewCommitmentControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, Cobol85ParserRULE_commitmentControlClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1963)
		p.Match(Cobol85ParserCOMMITMENT)
	}
	{
		p.SetState(1964)
		p.Match(Cobol85ParserCONTROL)
	}
	p.SetState(1966)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(1965)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(1968)
		p.FileName()
	}

	return localctx
}

// IDataDivisionContext is an interface to support dynamic dispatch.
type IDataDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDivisionContext differentiates from other interfaces.
	IsDataDivisionContext()
}

type DataDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionContext() *DataDivisionContext {
	var p = new(DataDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDivision
	return p
}

func (*DataDivisionContext) IsDataDivisionContext() {}

func NewDataDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionContext {
	var p = new(DataDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDivision

	return p
}

func (s *DataDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *DataDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *DataDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDivisionContext) AllDataDivisionSection() []IDataDivisionSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDivisionSectionContext); ok {
			len++
		}
	}

	tst := make([]IDataDivisionSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDivisionSectionContext); ok {
			tst[i] = t.(IDataDivisionSectionContext)
			i++
		}
	}

	return tst
}

func (s *DataDivisionContext) DataDivisionSection(i int) IDataDivisionSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDivisionSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDivisionSectionContext)
}

func (s *DataDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDivision(s)
	}
}

func (s *DataDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDivision(s)
	}
}

func (s *DataDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDivision() (localctx IDataDivisionContext) {
	this := p
	_ = this

	localctx = NewDataDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, Cobol85ParserRULE_dataDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1970)
		p.Match(Cobol85ParserDATA)
	}
	{
		p.SetState(1971)
		p.Match(Cobol85ParserDIVISION)
	}
	{
		p.SetState(1972)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1976)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCOMMUNICATION || _la == Cobol85ParserDATA_BASE || _la == Cobol85ParserFILE || _la == Cobol85ParserLINKAGE || _la == Cobol85ParserLOCAL_STORAGE || (int64((_la-363)) & ^0x3f) == 0 && ((int64(1)<<(_la-363))&9007203549708289) != 0 || _la == Cobol85ParserWORKING_STORAGE {
		{
			p.SetState(1973)
			p.DataDivisionSection()
		}

		p.SetState(1978)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataDivisionSectionContext is an interface to support dynamic dispatch.
type IDataDivisionSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDivisionSectionContext differentiates from other interfaces.
	IsDataDivisionSectionContext()
}

type DataDivisionSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDivisionSectionContext() *DataDivisionSectionContext {
	var p = new(DataDivisionSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDivisionSection
	return p
}

func (*DataDivisionSectionContext) IsDataDivisionSectionContext() {}

func NewDataDivisionSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDivisionSectionContext {
	var p = new(DataDivisionSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDivisionSection

	return p
}

func (s *DataDivisionSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDivisionSectionContext) FileSection() IFileSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileSectionContext)
}

func (s *DataDivisionSectionContext) DataBaseSection() IDataBaseSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataBaseSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataBaseSectionContext)
}

func (s *DataDivisionSectionContext) WorkingStorageSection() IWorkingStorageSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWorkingStorageSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWorkingStorageSectionContext)
}

func (s *DataDivisionSectionContext) LinkageSection() ILinkageSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinkageSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinkageSectionContext)
}

func (s *DataDivisionSectionContext) CommunicationSection() ICommunicationSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommunicationSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommunicationSectionContext)
}

func (s *DataDivisionSectionContext) LocalStorageSection() ILocalStorageSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalStorageSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalStorageSectionContext)
}

func (s *DataDivisionSectionContext) ScreenSection() IScreenSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenSectionContext)
}

func (s *DataDivisionSectionContext) ReportSection() IReportSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportSectionContext)
}

func (s *DataDivisionSectionContext) ProgramLibrarySection() IProgramLibrarySectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramLibrarySectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramLibrarySectionContext)
}

func (s *DataDivisionSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDivisionSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDivisionSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDivisionSection(s)
	}
}

func (s *DataDivisionSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDivisionSection(s)
	}
}

func (s *DataDivisionSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDivisionSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDivisionSection() (localctx IDataDivisionSectionContext) {
	this := p
	_ = this

	localctx = NewDataDivisionSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, Cobol85ParserRULE_dataDivisionSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(1988)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFILE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1979)
			p.FileSection()
		}

	case Cobol85ParserDATA_BASE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1980)
			p.DataBaseSection()
		}

	case Cobol85ParserWORKING_STORAGE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1981)
			p.WorkingStorageSection()
		}

	case Cobol85ParserLINKAGE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1982)
			p.LinkageSection()
		}

	case Cobol85ParserCOMMUNICATION:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1983)
			p.CommunicationSection()
		}

	case Cobol85ParserLOCAL_STORAGE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1984)
			p.LocalStorageSection()
		}

	case Cobol85ParserSCREEN:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1985)
			p.ScreenSection()
		}

	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1986)
			p.ReportSection()
		}

	case Cobol85ParserPROGRAM_LIBRARY:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1987)
			p.ProgramLibrarySection()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IFileSectionContext is an interface to support dynamic dispatch.
type IFileSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileSectionContext differentiates from other interfaces.
	IsFileSectionContext()
}

type FileSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileSectionContext() *FileSectionContext {
	var p = new(FileSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileSection
	return p
}

func (*FileSectionContext) IsFileSectionContext() {}

func NewFileSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileSectionContext {
	var p = new(FileSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileSection

	return p
}

func (s *FileSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *FileSectionContext) FILE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILE, 0)
}

func (s *FileSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *FileSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *FileSectionContext) AllFileDescriptionEntry() []IFileDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IFileDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileDescriptionEntryContext); ok {
			tst[i] = t.(IFileDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *FileSectionContext) FileDescriptionEntry(i int) IFileDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileDescriptionEntryContext)
}

func (s *FileSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileSection(s)
	}
}

func (s *FileSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileSection(s)
	}
}

func (s *FileSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileSection() (localctx IFileSectionContext) {
	this := p
	_ = this

	localctx = NewFileSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, Cobol85ParserRULE_fileSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1990)
		p.Match(Cobol85ParserFILE)
	}
	{
		p.SetState(1991)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(1992)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(1996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserFD || _la == Cobol85ParserSD {
		{
			p.SetState(1993)
			p.FileDescriptionEntry()
		}

		p.SetState(1998)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFileDescriptionEntryContext is an interface to support dynamic dispatch.
type IFileDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDescriptionEntryContext differentiates from other interfaces.
	IsFileDescriptionEntryContext()
}

type FileDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDescriptionEntryContext() *FileDescriptionEntryContext {
	var p = new(FileDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntry
	return p
}

func (*FileDescriptionEntryContext) IsFileDescriptionEntryContext() {}

func NewFileDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDescriptionEntryContext {
	var p = new(FileDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntry

	return p
}

func (s *FileDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDescriptionEntryContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *FileDescriptionEntryContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *FileDescriptionEntryContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *FileDescriptionEntryContext) FD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFD, 0)
}

func (s *FileDescriptionEntryContext) SD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSD, 0)
}

func (s *FileDescriptionEntryContext) AllFileDescriptionEntryClause() []IFileDescriptionEntryClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileDescriptionEntryClauseContext); ok {
			len++
		}
	}

	tst := make([]IFileDescriptionEntryClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileDescriptionEntryClauseContext); ok {
			tst[i] = t.(IFileDescriptionEntryClauseContext)
			i++
		}
	}

	return tst
}

func (s *FileDescriptionEntryContext) FileDescriptionEntryClause(i int) IFileDescriptionEntryClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileDescriptionEntryClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileDescriptionEntryClauseContext)
}

func (s *FileDescriptionEntryContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescriptionEntryContext); ok {
			tst[i] = t.(IDataDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *FileDescriptionEntryContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *FileDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileDescriptionEntry(s)
	}
}

func (s *FileDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileDescriptionEntry(s)
	}
}

func (s *FileDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileDescriptionEntry() (localctx IFileDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewFileDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, Cobol85ParserRULE_fileDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1999)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFD || _la == Cobol85ParserSD) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2000)
		p.FileName()
	}
	p.SetState(2007)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2002)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserDOT_FS {
				{
					p.SetState(2001)
					p.Match(Cobol85ParserDOT_FS)
				}

			}
			{
				p.SetState(2004)
				p.FileDescriptionEntryClause()
			}

		}
		p.SetState(2009)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 169, p.GetParserRuleContext())
	}
	{
		p.SetState(2010)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2014)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&527) != 0 {
		{
			p.SetState(2011)
			p.DataDescriptionEntry()
		}

		p.SetState(2016)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IFileDescriptionEntryClauseContext is an interface to support dynamic dispatch.
type IFileDescriptionEntryClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileDescriptionEntryClauseContext differentiates from other interfaces.
	IsFileDescriptionEntryClauseContext()
}

type FileDescriptionEntryClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileDescriptionEntryClauseContext() *FileDescriptionEntryClauseContext {
	var p = new(FileDescriptionEntryClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntryClause
	return p
}

func (*FileDescriptionEntryClauseContext) IsFileDescriptionEntryClauseContext() {}

func NewFileDescriptionEntryClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileDescriptionEntryClauseContext {
	var p = new(FileDescriptionEntryClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileDescriptionEntryClause

	return p
}

func (s *FileDescriptionEntryClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FileDescriptionEntryClauseContext) ExternalClause() IExternalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalClauseContext)
}

func (s *FileDescriptionEntryClauseContext) GlobalClause() IGlobalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGlobalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGlobalClauseContext)
}

func (s *FileDescriptionEntryClauseContext) BlockContainsClause() IBlockContainsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContainsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContainsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) RecordContainsClause() IRecordContainsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordContainsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) LabelRecordsClause() ILabelRecordsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelRecordsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelRecordsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) ValueOfClause() IValueOfClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValueOfClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValueOfClauseContext)
}

func (s *FileDescriptionEntryClauseContext) DataRecordsClause() IDataRecordsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataRecordsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataRecordsClauseContext)
}

func (s *FileDescriptionEntryClauseContext) LinageClause() ILinageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinageClauseContext)
}

func (s *FileDescriptionEntryClauseContext) CodeSetClause() ICodeSetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeSetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeSetClauseContext)
}

func (s *FileDescriptionEntryClauseContext) ReportClause() IReportClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportClauseContext)
}

func (s *FileDescriptionEntryClauseContext) RecordingModeClause() IRecordingModeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordingModeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordingModeClauseContext)
}

func (s *FileDescriptionEntryClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileDescriptionEntryClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileDescriptionEntryClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileDescriptionEntryClause(s)
	}
}

func (s *FileDescriptionEntryClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileDescriptionEntryClause(s)
	}
}

func (s *FileDescriptionEntryClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileDescriptionEntryClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileDescriptionEntryClause() (localctx IFileDescriptionEntryClauseContext) {
	this := p
	_ = this

	localctx = NewFileDescriptionEntryClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, Cobol85ParserRULE_fileDescriptionEntryClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2028)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 171, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2017)
			p.ExternalClause()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2018)
			p.GlobalClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2019)
			p.BlockContainsClause()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2020)
			p.RecordContainsClause()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2021)
			p.LabelRecordsClause()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2022)
			p.ValueOfClause()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2023)
			p.DataRecordsClause()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2024)
			p.LinageClause()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2025)
			p.CodeSetClause()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2026)
			p.ReportClause()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2027)
			p.RecordingModeClause()
		}

	}

	return localctx
}

// IExternalClauseContext is an interface to support dynamic dispatch.
type IExternalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExternalClauseContext differentiates from other interfaces.
	IsExternalClauseContext()
}

type ExternalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalClauseContext() *ExternalClauseContext {
	var p = new(ExternalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_externalClause
	return p
}

func (*ExternalClauseContext) IsExternalClauseContext() {}

func NewExternalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalClauseContext {
	var p = new(ExternalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_externalClause

	return p
}

func (s *ExternalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTERNAL, 0)
}

func (s *ExternalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ExternalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExternalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExternalClause(s)
	}
}

func (s *ExternalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExternalClause(s)
	}
}

func (s *ExternalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExternalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExternalClause() (localctx IExternalClauseContext) {
	this := p
	_ = this

	localctx = NewExternalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, Cobol85ParserRULE_externalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2030)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2033)
		p.Match(Cobol85ParserEXTERNAL)
	}

	return localctx
}

// IGlobalClauseContext is an interface to support dynamic dispatch.
type IGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGlobalClauseContext differentiates from other interfaces.
	IsGlobalClauseContext()
}

type GlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGlobalClauseContext() *GlobalClauseContext {
	var p = new(GlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_globalClause
	return p
}

func (*GlobalClauseContext) IsGlobalClauseContext() {}

func NewGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GlobalClauseContext {
	var p = new(GlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_globalClause

	return p
}

func (s *GlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *GlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *GlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGlobalClause(s)
	}
}

func (s *GlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGlobalClause(s)
	}
}

func (s *GlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GlobalClause() (localctx IGlobalClauseContext) {
	this := p
	_ = this

	localctx = NewGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, Cobol85ParserRULE_globalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2036)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2035)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2038)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IBlockContainsClauseContext is an interface to support dynamic dispatch.
type IBlockContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContainsClauseContext differentiates from other interfaces.
	IsBlockContainsClauseContext()
}

type BlockContainsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContainsClauseContext() *BlockContainsClauseContext {
	var p = new(BlockContainsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_blockContainsClause
	return p
}

func (*BlockContainsClauseContext) IsBlockContainsClauseContext() {}

func NewBlockContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContainsClauseContext {
	var p = new(BlockContainsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_blockContainsClause

	return p
}

func (s *BlockContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContainsClauseContext) BLOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLOCK, 0)
}

func (s *BlockContainsClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *BlockContainsClauseContext) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *BlockContainsClauseContext) BlockContainsTo() IBlockContainsToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBlockContainsToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBlockContainsToContext)
}

func (s *BlockContainsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *BlockContainsClauseContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *BlockContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBlockContainsClause(s)
	}
}

func (s *BlockContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBlockContainsClause(s)
	}
}

func (s *BlockContainsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBlockContainsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BlockContainsClause() (localctx IBlockContainsClauseContext) {
	this := p
	_ = this

	localctx = NewBlockContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, Cobol85ParserRULE_blockContainsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2040)
		p.Match(Cobol85ParserBLOCK)
	}
	p.SetState(2042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2041)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2044)
		p.IntegerLiteral()
	}
	p.SetState(2046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(2045)
			p.BlockContainsTo()
		}

	}
	p.SetState(2049)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserRECORDS {
		{
			p.SetState(2048)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserCHARACTERS || _la == Cobol85ParserRECORDS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IBlockContainsToContext is an interface to support dynamic dispatch.
type IBlockContainsToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBlockContainsToContext differentiates from other interfaces.
	IsBlockContainsToContext()
}

type BlockContainsToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBlockContainsToContext() *BlockContainsToContext {
	var p = new(BlockContainsToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_blockContainsTo
	return p
}

func (*BlockContainsToContext) IsBlockContainsToContext() {}

func NewBlockContainsToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BlockContainsToContext {
	var p = new(BlockContainsToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_blockContainsTo

	return p
}

func (s *BlockContainsToContext) GetParser() antlr.Parser { return s.parser }

func (s *BlockContainsToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *BlockContainsToContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *BlockContainsToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BlockContainsToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BlockContainsToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBlockContainsTo(s)
	}
}

func (s *BlockContainsToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBlockContainsTo(s)
	}
}

func (s *BlockContainsToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBlockContainsTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BlockContainsTo() (localctx IBlockContainsToContext) {
	this := p
	_ = this

	localctx = NewBlockContainsToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, Cobol85ParserRULE_blockContainsTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2051)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2052)
		p.IntegerLiteral()
	}

	return localctx
}

// IRecordContainsClauseContext is an interface to support dynamic dispatch.
type IRecordContainsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseContext differentiates from other interfaces.
	IsRecordContainsClauseContext()
}

type RecordContainsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseContext() *RecordContainsClauseContext {
	var p = new(RecordContainsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClause
	return p
}

func (*RecordContainsClauseContext) IsRecordContainsClauseContext() {}

func NewRecordContainsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseContext {
	var p = new(RecordContainsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClause

	return p
}

func (s *RecordContainsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat1() IRecordContainsClauseFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordContainsClauseFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat1Context)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat2() IRecordContainsClauseFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordContainsClauseFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat2Context)
}

func (s *RecordContainsClauseContext) RecordContainsClauseFormat3() IRecordContainsClauseFormat3Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordContainsClauseFormat3Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordContainsClauseFormat3Context)
}

func (s *RecordContainsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClause(s)
	}
}

func (s *RecordContainsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClause(s)
	}
}

func (s *RecordContainsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClause() (localctx IRecordContainsClauseContext) {
	this := p
	_ = this

	localctx = NewRecordContainsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, Cobol85ParserRULE_recordContainsClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2054)
		p.Match(Cobol85ParserRECORD)
	}
	p.SetState(2058)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 177, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2055)
			p.RecordContainsClauseFormat1()
		}

	case 2:
		{
			p.SetState(2056)
			p.RecordContainsClauseFormat2()
		}

	case 3:
		{
			p.SetState(2057)
			p.RecordContainsClauseFormat3()
		}

	}

	return localctx
}

// IRecordContainsClauseFormat1Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat1Context differentiates from other interfaces.
	IsRecordContainsClauseFormat1Context()
}

type RecordContainsClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat1Context() *RecordContainsClauseFormat1Context {
	var p = new(RecordContainsClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat1
	return p
}

func (*RecordContainsClauseFormat1Context) IsRecordContainsClauseFormat1Context() {}

func NewRecordContainsClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat1Context {
	var p = new(RecordContainsClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat1

	return p
}

func (s *RecordContainsClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat1Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat1Context) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *RecordContainsClauseFormat1Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat1(s)
	}
}

func (s *RecordContainsClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat1(s)
	}
}

func (s *RecordContainsClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat1() (localctx IRecordContainsClauseFormat1Context) {
	this := p
	_ = this

	localctx = NewRecordContainsClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, Cobol85ParserRULE_recordContainsClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2060)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2063)
		p.IntegerLiteral()
	}
	p.SetState(2065)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(2064)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}

	return localctx
}

// IRecordContainsClauseFormat2Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat2Context differentiates from other interfaces.
	IsRecordContainsClauseFormat2Context()
}

type RecordContainsClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat2Context() *RecordContainsClauseFormat2Context {
	var p = new(RecordContainsClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat2
	return p
}

func (*RecordContainsClauseFormat2Context) IsRecordContainsClauseFormat2Context() {}

func NewRecordContainsClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat2Context {
	var p = new(RecordContainsClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat2

	return p
}

func (s *RecordContainsClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat2Context) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *RecordContainsClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordContainsClauseFormat2Context) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *RecordContainsClauseFormat2Context) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *RecordContainsClauseFormat2Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat2Context) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *RecordContainsClauseFormat2Context) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordContainsClauseFormat2Context) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *RecordContainsClauseFormat2Context) RecordContainsTo() IRecordContainsToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordContainsToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordContainsToContext)
}

func (s *RecordContainsClauseFormat2Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat2Context) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *RecordContainsClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat2(s)
	}
}

func (s *RecordContainsClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat2(s)
	}
}

func (s *RecordContainsClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat2() (localctx IRecordContainsClauseFormat2Context) {
	this := p
	_ = this

	localctx = NewRecordContainsClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, Cobol85ParserRULE_recordContainsClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2067)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2070)
		p.Match(Cobol85ParserVARYING)
	}
	p.SetState(2072)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(2071)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(2075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIZE {
		{
			p.SetState(2074)
			p.Match(Cobol85ParserSIZE)
		}

	}
	p.SetState(2087)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		p.SetState(2078)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFROM {
			{
				p.SetState(2077)
				p.Match(Cobol85ParserFROM)
			}

		}
		{
			p.SetState(2080)
			p.IntegerLiteral()
		}
		p.SetState(2082)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(2081)
				p.RecordContainsTo()
			}

		}
		p.SetState(2085)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTERS {
			{
				p.SetState(2084)
				p.Match(Cobol85ParserCHARACTERS)
			}

		}

	}
	p.SetState(2094)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEPENDING {
		{
			p.SetState(2089)
			p.Match(Cobol85ParserDEPENDING)
		}
		p.SetState(2091)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(2090)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(2093)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IRecordContainsClauseFormat3Context is an interface to support dynamic dispatch.
type IRecordContainsClauseFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsClauseFormat3Context differentiates from other interfaces.
	IsRecordContainsClauseFormat3Context()
}

type RecordContainsClauseFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsClauseFormat3Context() *RecordContainsClauseFormat3Context {
	var p = new(RecordContainsClauseFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat3
	return p
}

func (*RecordContainsClauseFormat3Context) IsRecordContainsClauseFormat3Context() {}

func NewRecordContainsClauseFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsClauseFormat3Context {
	var p = new(RecordContainsClauseFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsClauseFormat3

	return p
}

func (s *RecordContainsClauseFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsClauseFormat3Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsClauseFormat3Context) RecordContainsTo() IRecordContainsToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordContainsToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordContainsToContext)
}

func (s *RecordContainsClauseFormat3Context) CONTAINS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTAINS, 0)
}

func (s *RecordContainsClauseFormat3Context) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *RecordContainsClauseFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsClauseFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsClauseFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsClauseFormat3(s)
	}
}

func (s *RecordContainsClauseFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsClauseFormat3(s)
	}
}

func (s *RecordContainsClauseFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsClauseFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsClauseFormat3() (localctx IRecordContainsClauseFormat3Context) {
	this := p
	_ = this

	localctx = NewRecordContainsClauseFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, Cobol85ParserRULE_recordContainsClauseFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2097)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCONTAINS {
		{
			p.SetState(2096)
			p.Match(Cobol85ParserCONTAINS)
		}

	}
	{
		p.SetState(2099)
		p.IntegerLiteral()
	}
	{
		p.SetState(2100)
		p.RecordContainsTo()
	}
	p.SetState(2102)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTERS {
		{
			p.SetState(2101)
			p.Match(Cobol85ParserCHARACTERS)
		}

	}

	return localctx
}

// IRecordContainsToContext is an interface to support dynamic dispatch.
type IRecordContainsToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordContainsToContext differentiates from other interfaces.
	IsRecordContainsToContext()
}

type RecordContainsToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordContainsToContext() *RecordContainsToContext {
	var p = new(RecordContainsToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordContainsTo
	return p
}

func (*RecordContainsToContext) IsRecordContainsToContext() {}

func NewRecordContainsToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordContainsToContext {
	var p = new(RecordContainsToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordContainsTo

	return p
}

func (s *RecordContainsToContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordContainsToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *RecordContainsToContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *RecordContainsToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordContainsToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordContainsToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordContainsTo(s)
	}
}

func (s *RecordContainsToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordContainsTo(s)
	}
}

func (s *RecordContainsToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordContainsTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordContainsTo() (localctx IRecordContainsToContext) {
	this := p
	_ = this

	localctx = NewRecordContainsToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, Cobol85ParserRULE_recordContainsTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2104)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2105)
		p.IntegerLiteral()
	}

	return localctx
}

// ILabelRecordsClauseContext is an interface to support dynamic dispatch.
type ILabelRecordsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLabelRecordsClauseContext differentiates from other interfaces.
	IsLabelRecordsClauseContext()
}

type LabelRecordsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelRecordsClauseContext() *LabelRecordsClauseContext {
	var p = new(LabelRecordsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_labelRecordsClause
	return p
}

func (*LabelRecordsClauseContext) IsLabelRecordsClauseContext() {}

func NewLabelRecordsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelRecordsClauseContext {
	var p = new(LabelRecordsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_labelRecordsClause

	return p
}

func (s *LabelRecordsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelRecordsClauseContext) LABEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLABEL, 0)
}

func (s *LabelRecordsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *LabelRecordsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *LabelRecordsClauseContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *LabelRecordsClauseContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD, 0)
}

func (s *LabelRecordsClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LabelRecordsClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *LabelRecordsClauseContext) AllDataName() []IDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataNameContext); ok {
			len++
		}
	}

	tst := make([]IDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataNameContext); ok {
			tst[i] = t.(IDataNameContext)
			i++
		}
	}

	return tst
}

func (s *LabelRecordsClauseContext) DataName(i int) IDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LabelRecordsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelRecordsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelRecordsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLabelRecordsClause(s)
	}
}

func (s *LabelRecordsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLabelRecordsClause(s)
	}
}

func (s *LabelRecordsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLabelRecordsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LabelRecordsClause() (localctx ILabelRecordsClauseContext) {
	this := p
	_ = this

	localctx = NewLabelRecordsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, Cobol85ParserRULE_labelRecordsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2107)
		p.Match(Cobol85ParserLABEL)
	}
	p.SetState(2116)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRECORD:
		{
			p.SetState(2108)
			p.Match(Cobol85ParserRECORD)
		}
		p.SetState(2110)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2109)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserRECORDS:
		{
			p.SetState(2112)
			p.Match(Cobol85ParserRECORDS)
		}
		p.SetState(2114)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2113)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2125)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserOMITTED:
		{
			p.SetState(2118)
			p.Match(Cobol85ParserOMITTED)
		}

	case Cobol85ParserSTANDARD:
		{
			p.SetState(2119)
			p.Match(Cobol85ParserSTANDARD)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(2120)
				p.DataName()
			}

			p.SetState(2123)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IValueOfClauseContext is an interface to support dynamic dispatch.
type IValueOfClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValueOfClauseContext differentiates from other interfaces.
	IsValueOfClauseContext()
}

type ValueOfClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValueOfClauseContext() *ValueOfClauseContext {
	var p = new(ValueOfClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_valueOfClause
	return p
}

func (*ValueOfClauseContext) IsValueOfClauseContext() {}

func NewValueOfClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValueOfClauseContext {
	var p = new(ValueOfClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_valueOfClause

	return p
}

func (s *ValueOfClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ValueOfClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ValueOfClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ValueOfClauseContext) AllValuePair() []IValuePairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IValuePairContext); ok {
			len++
		}
	}

	tst := make([]IValuePairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IValuePairContext); ok {
			tst[i] = t.(IValuePairContext)
			i++
		}
	}

	return tst
}

func (s *ValueOfClauseContext) ValuePair(i int) IValuePairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuePairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuePairContext)
}

func (s *ValueOfClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValueOfClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValueOfClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterValueOfClause(s)
	}
}

func (s *ValueOfClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitValueOfClause(s)
	}
}

func (s *ValueOfClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitValueOfClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ValueOfClause() (localctx IValueOfClauseContext) {
	this := p
	_ = this

	localctx = NewValueOfClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, Cobol85ParserRULE_valueOfClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2127)
		p.Match(Cobol85ParserVALUE)
	}
	{
		p.SetState(2128)
		p.Match(Cobol85ParserOF)
	}
	p.SetState(2130)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2129)
			p.ValuePair()
		}

		p.SetState(2132)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IValuePairContext is an interface to support dynamic dispatch.
type IValuePairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsValuePairContext differentiates from other interfaces.
	IsValuePairContext()
}

type ValuePairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuePairContext() *ValuePairContext {
	var p = new(ValuePairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_valuePair
	return p
}

func (*ValuePairContext) IsValuePairContext() {}

func NewValuePairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuePairContext {
	var p = new(ValuePairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_valuePair

	return p
}

func (s *ValuePairContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuePairContext) SystemName() ISystemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *ValuePairContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ValuePairContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ValuePairContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ValuePairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuePairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuePairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterValuePair(s)
	}
}

func (s *ValuePairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitValuePair(s)
	}
}

func (s *ValuePairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitValuePair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ValuePair() (localctx IValuePairContext) {
	this := p
	_ = this

	localctx = NewValuePairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, Cobol85ParserRULE_valuePair)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2134)
		p.SystemName()
	}
	p.SetState(2136)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2135)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2140)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 198, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2138)
			p.QualifiedDataName()
		}

	case 2:
		{
			p.SetState(2139)
			p.Literal()
		}

	}

	return localctx
}

// IDataRecordsClauseContext is an interface to support dynamic dispatch.
type IDataRecordsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRecordsClauseContext differentiates from other interfaces.
	IsDataRecordsClauseContext()
}

type DataRecordsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRecordsClauseContext() *DataRecordsClauseContext {
	var p = new(DataRecordsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRecordsClause
	return p
}

func (*DataRecordsClauseContext) IsDataRecordsClauseContext() {}

func NewDataRecordsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRecordsClauseContext {
	var p = new(DataRecordsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRecordsClause

	return p
}

func (s *DataRecordsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRecordsClauseContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *DataRecordsClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DataRecordsClauseContext) RECORDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDS, 0)
}

func (s *DataRecordsClauseContext) AllDataName() []IDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataNameContext); ok {
			len++
		}
	}

	tst := make([]IDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataNameContext); ok {
			tst[i] = t.(IDataNameContext)
			i++
		}
	}

	return tst
}

func (s *DataRecordsClauseContext) DataName(i int) IDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataRecordsClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataRecordsClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *DataRecordsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRecordsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRecordsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRecordsClause(s)
	}
}

func (s *DataRecordsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRecordsClause(s)
	}
}

func (s *DataRecordsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRecordsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRecordsClause() (localctx IDataRecordsClauseContext) {
	this := p
	_ = this

	localctx = NewDataRecordsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, Cobol85ParserRULE_dataRecordsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2142)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(2151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRECORD:
		{
			p.SetState(2143)
			p.Match(Cobol85ParserRECORD)
		}
		p.SetState(2145)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2144)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserRECORDS:
		{
			p.SetState(2147)
			p.Match(Cobol85ParserRECORDS)
		}
		p.SetState(2149)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2148)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2154)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2153)
			p.DataName()
		}

		p.SetState(2156)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinageClauseContext is an interface to support dynamic dispatch.
type ILinageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageClauseContext differentiates from other interfaces.
	IsLinageClauseContext()
}

type LinageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageClauseContext() *LinageClauseContext {
	var p = new(LinageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageClause
	return p
}

func (*LinageClauseContext) IsLinageClauseContext() {}

func NewLinageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageClauseContext {
	var p = new(LinageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageClause

	return p
}

func (s *LinageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageClauseContext) LINAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE, 0)
}

func (s *LinageClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LinageClauseContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageClauseContext) AllLinageAt() []ILinageAtContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILinageAtContext); ok {
			len++
		}
	}

	tst := make([]ILinageAtContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILinageAtContext); ok {
			tst[i] = t.(ILinageAtContext)
			i++
		}
	}

	return tst
}

func (s *LinageClauseContext) LinageAt(i int) ILinageAtContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinageAtContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinageAtContext)
}

func (s *LinageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageClause(s)
	}
}

func (s *LinageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageClause(s)
	}
}

func (s *LinageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageClause() (localctx ILinageClauseContext) {
	this := p
	_ = this

	localctx = NewLinageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, Cobol85ParserRULE_linageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2158)
		p.Match(Cobol85ParserLINAGE)
	}
	p.SetState(2160)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2159)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2164)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2162)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2163)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2167)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 205, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2166)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAT || _la == Cobol85ParserBOTTOM || _la == Cobol85ParserFOOTING || _la == Cobol85ParserLINES || _la == Cobol85ParserTOP || _la == Cobol85ParserWITH {
		{
			p.SetState(2169)
			p.LinageAt()
		}

		p.SetState(2174)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinageAtContext is an interface to support dynamic dispatch.
type ILinageAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageAtContext differentiates from other interfaces.
	IsLinageAtContext()
}

type LinageAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageAtContext() *LinageAtContext {
	var p = new(LinageAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageAt
	return p
}

func (*LinageAtContext) IsLinageAtContext() {}

func NewLinageAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageAtContext {
	var p = new(LinageAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageAt

	return p
}

func (s *LinageAtContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageAtContext) LinageFootingAt() ILinageFootingAtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinageFootingAtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinageFootingAtContext)
}

func (s *LinageAtContext) LinageLinesAtTop() ILinageLinesAtTopContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinageLinesAtTopContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinageLinesAtTopContext)
}

func (s *LinageAtContext) LinageLinesAtBottom() ILinageLinesAtBottomContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinageLinesAtBottomContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinageLinesAtBottomContext)
}

func (s *LinageAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageAt(s)
	}
}

func (s *LinageAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageAt(s)
	}
}

func (s *LinageAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageAt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageAt() (localctx ILinageAtContext) {
	this := p
	_ = this

	localctx = NewLinageAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, Cobol85ParserRULE_linageAt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2178)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 207, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2175)
			p.LinageFootingAt()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2176)
			p.LinageLinesAtTop()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2177)
			p.LinageLinesAtBottom()
		}

	}

	return localctx
}

// ILinageFootingAtContext is an interface to support dynamic dispatch.
type ILinageFootingAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageFootingAtContext differentiates from other interfaces.
	IsLinageFootingAtContext()
}

type LinageFootingAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageFootingAtContext() *LinageFootingAtContext {
	var p = new(LinageFootingAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageFootingAt
	return p
}

func (*LinageFootingAtContext) IsLinageFootingAtContext() {}

func NewLinageFootingAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageFootingAtContext {
	var p = new(LinageFootingAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageFootingAt

	return p
}

func (s *LinageFootingAtContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageFootingAtContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *LinageFootingAtContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageFootingAtContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageFootingAtContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *LinageFootingAtContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageFootingAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageFootingAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageFootingAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageFootingAt(s)
	}
}

func (s *LinageFootingAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageFootingAt(s)
	}
}

func (s *LinageFootingAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageFootingAt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageFootingAt() (localctx ILinageFootingAtContext) {
	this := p
	_ = this

	localctx = NewLinageFootingAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, Cobol85ParserRULE_linageFootingAt)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(2180)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(2183)
		p.Match(Cobol85ParserFOOTING)
	}
	p.SetState(2185)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2184)
			p.Match(Cobol85ParserAT)
		}

	}
	p.SetState(2189)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2187)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2188)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinageLinesAtTopContext is an interface to support dynamic dispatch.
type ILinageLinesAtTopContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageLinesAtTopContext differentiates from other interfaces.
	IsLinageLinesAtTopContext()
}

type LinageLinesAtTopContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageLinesAtTopContext() *LinageLinesAtTopContext {
	var p = new(LinageLinesAtTopContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtTop
	return p
}

func (*LinageLinesAtTopContext) IsLinageLinesAtTopContext() {}

func NewLinageLinesAtTopContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageLinesAtTopContext {
	var p = new(LinageLinesAtTopContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtTop

	return p
}

func (s *LinageLinesAtTopContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageLinesAtTopContext) TOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTOP, 0)
}

func (s *LinageLinesAtTopContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageLinesAtTopContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageLinesAtTopContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageLinesAtTopContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageLinesAtTopContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageLinesAtTopContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageLinesAtTopContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageLinesAtTop(s)
	}
}

func (s *LinageLinesAtTopContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageLinesAtTop(s)
	}
}

func (s *LinageLinesAtTopContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageLinesAtTop(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageLinesAtTop() (localctx ILinageLinesAtTopContext) {
	this := p
	_ = this

	localctx = NewLinageLinesAtTopContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, Cobol85ParserRULE_linageLinesAtTop)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2192)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINES {
		{
			p.SetState(2191)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2195)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2194)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(2197)
		p.Match(Cobol85ParserTOP)
	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2198)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2199)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILinageLinesAtBottomContext is an interface to support dynamic dispatch.
type ILinageLinesAtBottomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinageLinesAtBottomContext differentiates from other interfaces.
	IsLinageLinesAtBottomContext()
}

type LinageLinesAtBottomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinageLinesAtBottomContext() *LinageLinesAtBottomContext {
	var p = new(LinageLinesAtBottomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtBottom
	return p
}

func (*LinageLinesAtBottomContext) IsLinageLinesAtBottomContext() {}

func NewLinageLinesAtBottomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinageLinesAtBottomContext {
	var p = new(LinageLinesAtBottomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linageLinesAtBottom

	return p
}

func (s *LinageLinesAtBottomContext) GetParser() antlr.Parser { return s.parser }

func (s *LinageLinesAtBottomContext) BOTTOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOTTOM, 0)
}

func (s *LinageLinesAtBottomContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LinageLinesAtBottomContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *LinageLinesAtBottomContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *LinageLinesAtBottomContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *LinageLinesAtBottomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinageLinesAtBottomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinageLinesAtBottomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinageLinesAtBottom(s)
	}
}

func (s *LinageLinesAtBottomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinageLinesAtBottom(s)
	}
}

func (s *LinageLinesAtBottomContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinageLinesAtBottom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinageLinesAtBottom() (localctx ILinageLinesAtBottomContext) {
	this := p
	_ = this

	localctx = NewLinageLinesAtBottomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, Cobol85ParserRULE_linageLinesAtBottom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2203)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINES {
		{
			p.SetState(2202)
			p.Match(Cobol85ParserLINES)
		}

	}
	p.SetState(2206)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(2205)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(2208)
		p.Match(Cobol85ParserBOTTOM)
	}
	p.SetState(2211)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2209)
			p.DataName()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2210)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecordingModeClauseContext is an interface to support dynamic dispatch.
type IRecordingModeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordingModeClauseContext differentiates from other interfaces.
	IsRecordingModeClauseContext()
}

type RecordingModeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordingModeClauseContext() *RecordingModeClauseContext {
	var p = new(RecordingModeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordingModeClause
	return p
}

func (*RecordingModeClauseContext) IsRecordingModeClauseContext() {}

func NewRecordingModeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordingModeClauseContext {
	var p = new(RecordingModeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordingModeClause

	return p
}

func (s *RecordingModeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordingModeClauseContext) RECORDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORDING, 0)
}

func (s *RecordingModeClauseContext) ModeStatement() IModeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModeStatementContext)
}

func (s *RecordingModeClauseContext) MODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMODE, 0)
}

func (s *RecordingModeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RecordingModeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordingModeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordingModeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordingModeClause(s)
	}
}

func (s *RecordingModeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordingModeClause(s)
	}
}

func (s *RecordingModeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordingModeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordingModeClause() (localctx IRecordingModeClauseContext) {
	this := p
	_ = this

	localctx = NewRecordingModeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, Cobol85ParserRULE_recordingModeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2213)
		p.Match(Cobol85ParserRECORDING)
	}
	p.SetState(2215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMODE {
		{
			p.SetState(2214)
			p.Match(Cobol85ParserMODE)
		}

	}
	p.SetState(2218)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2217)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2220)
		p.ModeStatement()
	}

	return localctx
}

// IModeStatementContext is an interface to support dynamic dispatch.
type IModeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsModeStatementContext differentiates from other interfaces.
	IsModeStatementContext()
}

type ModeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModeStatementContext() *ModeStatementContext {
	var p = new(ModeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_modeStatement
	return p
}

func (*ModeStatementContext) IsModeStatementContext() {}

func NewModeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModeStatementContext {
	var p = new(ModeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_modeStatement

	return p
}

func (s *ModeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ModeStatementContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ModeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ModeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterModeStatement(s)
	}
}

func (s *ModeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitModeStatement(s)
	}
}

func (s *ModeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitModeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ModeStatement() (localctx IModeStatementContext) {
	this := p
	_ = this

	localctx = NewModeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, Cobol85ParserRULE_modeStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2222)
		p.CobolWord()
	}

	return localctx
}

// ICodeSetClauseContext is an interface to support dynamic dispatch.
type ICodeSetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCodeSetClauseContext differentiates from other interfaces.
	IsCodeSetClauseContext()
}

type CodeSetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeSetClauseContext() *CodeSetClauseContext {
	var p = new(CodeSetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_codeSetClause
	return p
}

func (*CodeSetClauseContext) IsCodeSetClauseContext() {}

func NewCodeSetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeSetClauseContext {
	var p = new(CodeSetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_codeSetClause

	return p
}

func (s *CodeSetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeSetClauseContext) CODE_SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCODE_SET, 0)
}

func (s *CodeSetClauseContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *CodeSetClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *CodeSetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CodeSetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCodeSetClause(s)
	}
}

func (s *CodeSetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCodeSetClause(s)
	}
}

func (s *CodeSetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCodeSetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CodeSetClause() (localctx ICodeSetClauseContext) {
	this := p
	_ = this

	localctx = NewCodeSetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, Cobol85ParserRULE_codeSetClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2224)
		p.Match(Cobol85ParserCODE_SET)
	}
	p.SetState(2226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2225)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2228)
		p.AlphabetName()
	}

	return localctx
}

// IReportClauseContext is an interface to support dynamic dispatch.
type IReportClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportClauseContext differentiates from other interfaces.
	IsReportClauseContext()
}

type ReportClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportClauseContext() *ReportClauseContext {
	var p = new(ReportClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportClause
	return p
}

func (*ReportClauseContext) IsReportClauseContext() {}

func NewReportClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportClauseContext {
	var p = new(ReportClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportClause

	return p
}

func (s *ReportClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportClauseContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportClauseContext) REPORTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORTS, 0)
}

func (s *ReportClauseContext) AllReportName() []IReportNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportNameContext); ok {
			len++
		}
	}

	tst := make([]IReportNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportNameContext); ok {
			tst[i] = t.(IReportNameContext)
			i++
		}
	}

	return tst
}

func (s *ReportClauseContext) ReportName(i int) IReportNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *ReportClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *ReportClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportClause(s)
	}
}

func (s *ReportClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportClause(s)
	}
}

func (s *ReportClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportClause() (localctx IReportClauseContext) {
	this := p
	_ = this

	localctx = NewReportClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, Cobol85ParserRULE_reportClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2238)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		{
			p.SetState(2230)
			p.Match(Cobol85ParserREPORT)
		}
		p.SetState(2232)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2231)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserREPORTS:
		{
			p.SetState(2234)
			p.Match(Cobol85ParserREPORTS)
		}
		p.SetState(2236)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2235)
				p.Match(Cobol85ParserARE)
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2241)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178969483) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(2240)
			p.ReportName()
		}

		p.SetState(2243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataBaseSectionContext is an interface to support dynamic dispatch.
type IDataBaseSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBaseSectionContext differentiates from other interfaces.
	IsDataBaseSectionContext()
}

type DataBaseSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBaseSectionContext() *DataBaseSectionContext {
	var p = new(DataBaseSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBaseSection
	return p
}

func (*DataBaseSectionContext) IsDataBaseSectionContext() {}

func NewDataBaseSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBaseSectionContext {
	var p = new(DataBaseSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBaseSection

	return p
}

func (s *DataBaseSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBaseSectionContext) DATA_BASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA_BASE, 0)
}

func (s *DataBaseSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *DataBaseSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataBaseSectionContext) AllDataBaseSectionEntry() []IDataBaseSectionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataBaseSectionEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataBaseSectionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataBaseSectionEntryContext); ok {
			tst[i] = t.(IDataBaseSectionEntryContext)
			i++
		}
	}

	return tst
}

func (s *DataBaseSectionContext) DataBaseSectionEntry(i int) IDataBaseSectionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataBaseSectionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataBaseSectionEntryContext)
}

func (s *DataBaseSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBaseSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBaseSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBaseSection(s)
	}
}

func (s *DataBaseSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBaseSection(s)
	}
}

func (s *DataBaseSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataBaseSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataBaseSection() (localctx IDataBaseSectionContext) {
	this := p
	_ = this

	localctx = NewDataBaseSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, Cobol85ParserRULE_dataBaseSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2245)
		p.Match(Cobol85ParserDATA_BASE)
	}
	{
		p.SetState(2246)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2247)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		{
			p.SetState(2248)
			p.DataBaseSectionEntry()
		}

		p.SetState(2253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDataBaseSectionEntryContext is an interface to support dynamic dispatch.
type IDataBaseSectionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBaseSectionEntryContext differentiates from other interfaces.
	IsDataBaseSectionEntryContext()
}

type DataBaseSectionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBaseSectionEntryContext() *DataBaseSectionEntryContext {
	var p = new(DataBaseSectionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBaseSectionEntry
	return p
}

func (*DataBaseSectionEntryContext) IsDataBaseSectionEntryContext() {}

func NewDataBaseSectionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBaseSectionEntryContext {
	var p = new(DataBaseSectionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBaseSectionEntry

	return p
}

func (s *DataBaseSectionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBaseSectionEntryContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataBaseSectionEntryContext) AllLiteral() []ILiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILiteralContext); ok {
			len++
		}
	}

	tst := make([]ILiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILiteralContext); ok {
			tst[i] = t.(ILiteralContext)
			i++
		}
	}

	return tst
}

func (s *DataBaseSectionEntryContext) Literal(i int) ILiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataBaseSectionEntryContext) INVOKE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVOKE, 0)
}

func (s *DataBaseSectionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBaseSectionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBaseSectionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBaseSectionEntry(s)
	}
}

func (s *DataBaseSectionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBaseSectionEntry(s)
	}
}

func (s *DataBaseSectionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataBaseSectionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataBaseSectionEntry() (localctx IDataBaseSectionEntryContext) {
	this := p
	_ = this

	localctx = NewDataBaseSectionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, Cobol85ParserRULE_dataBaseSectionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2254)
		p.IntegerLiteral()
	}
	{
		p.SetState(2255)
		p.Literal()
	}
	{
		p.SetState(2256)
		p.Match(Cobol85ParserINVOKE)
	}
	{
		p.SetState(2257)
		p.Literal()
	}

	return localctx
}

// IWorkingStorageSectionContext is an interface to support dynamic dispatch.
type IWorkingStorageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWorkingStorageSectionContext differentiates from other interfaces.
	IsWorkingStorageSectionContext()
}

type WorkingStorageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWorkingStorageSectionContext() *WorkingStorageSectionContext {
	var p = new(WorkingStorageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_workingStorageSection
	return p
}

func (*WorkingStorageSectionContext) IsWorkingStorageSectionContext() {}

func NewWorkingStorageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WorkingStorageSectionContext {
	var p = new(WorkingStorageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_workingStorageSection

	return p
}

func (s *WorkingStorageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *WorkingStorageSectionContext) WORKING_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWORKING_STORAGE, 0)
}

func (s *WorkingStorageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *WorkingStorageSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *WorkingStorageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescriptionEntryContext); ok {
			tst[i] = t.(IDataDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *WorkingStorageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *WorkingStorageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WorkingStorageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WorkingStorageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWorkingStorageSection(s)
	}
}

func (s *WorkingStorageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWorkingStorageSection(s)
	}
}

func (s *WorkingStorageSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWorkingStorageSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WorkingStorageSection() (localctx IWorkingStorageSectionContext) {
	this := p
	_ = this

	localctx = NewWorkingStorageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, Cobol85ParserRULE_workingStorageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2259)
		p.Match(Cobol85ParserWORKING_STORAGE)
	}
	{
		p.SetState(2260)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2261)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&527) != 0 {
		{
			p.SetState(2262)
			p.DataDescriptionEntry()
		}

		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILinkageSectionContext is an interface to support dynamic dispatch.
type ILinkageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLinkageSectionContext differentiates from other interfaces.
	IsLinkageSectionContext()
}

type LinkageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinkageSectionContext() *LinkageSectionContext {
	var p = new(LinkageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_linkageSection
	return p
}

func (*LinkageSectionContext) IsLinkageSectionContext() {}

func NewLinkageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinkageSectionContext {
	var p = new(LinkageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_linkageSection

	return p
}

func (s *LinkageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LinkageSectionContext) LINKAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINKAGE, 0)
}

func (s *LinkageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *LinkageSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *LinkageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescriptionEntryContext); ok {
			tst[i] = t.(IDataDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *LinkageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *LinkageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinkageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinkageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLinkageSection(s)
	}
}

func (s *LinkageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLinkageSection(s)
	}
}

func (s *LinkageSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLinkageSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LinkageSection() (localctx ILinkageSectionContext) {
	this := p
	_ = this

	localctx = NewLinkageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, Cobol85ParserRULE_linkageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2268)
		p.Match(Cobol85ParserLINKAGE)
	}
	{
		p.SetState(2269)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2270)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&527) != 0 {
		{
			p.SetState(2271)
			p.DataDescriptionEntry()
		}

		p.SetState(2276)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommunicationSectionContext is an interface to support dynamic dispatch.
type ICommunicationSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationSectionContext differentiates from other interfaces.
	IsCommunicationSectionContext()
}

type CommunicationSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationSectionContext() *CommunicationSectionContext {
	var p = new(CommunicationSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationSection
	return p
}

func (*CommunicationSectionContext) IsCommunicationSectionContext() {}

func NewCommunicationSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationSectionContext {
	var p = new(CommunicationSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationSection

	return p
}

func (s *CommunicationSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationSectionContext) COMMUNICATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMUNICATION, 0)
}

func (s *CommunicationSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *CommunicationSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationSectionContext) AllCommunicationDescriptionEntry() []ICommunicationDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommunicationDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]ICommunicationDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommunicationDescriptionEntryContext); ok {
			tst[i] = t.(ICommunicationDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationSectionContext) CommunicationDescriptionEntry(i int) ICommunicationDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommunicationDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryContext)
}

func (s *CommunicationSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescriptionEntryContext); ok {
			tst[i] = t.(IDataDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *CommunicationSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationSection(s)
	}
}

func (s *CommunicationSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationSection(s)
	}
}

func (s *CommunicationSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationSection() (localctx ICommunicationSectionContext) {
	this := p
	_ = this

	localctx = NewCommunicationSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, Cobol85ParserRULE_communicationSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2277)
		p.Match(Cobol85ParserCOMMUNICATION)
	}
	{
		p.SetState(2278)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2279)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2284)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserCD || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&527) != 0 {
		p.SetState(2282)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCD:
			{
				p.SetState(2280)
				p.CommunicationDescriptionEntry()
			}

		case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserEXECSQLLINE:
			{
				p.SetState(2281)
				p.DataDescriptionEntry()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2286)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICommunicationDescriptionEntryContext is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryContext differentiates from other interfaces.
	IsCommunicationDescriptionEntryContext()
}

type CommunicationDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryContext() *CommunicationDescriptionEntryContext {
	var p = new(CommunicationDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntry
	return p
}

func (*CommunicationDescriptionEntryContext) IsCommunicationDescriptionEntryContext() {}

func NewCommunicationDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryContext {
	var p = new(CommunicationDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntry

	return p
}

func (s *CommunicationDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat1() ICommunicationDescriptionEntryFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommunicationDescriptionEntryFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat1Context)
}

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat2() ICommunicationDescriptionEntryFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommunicationDescriptionEntryFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat2Context)
}

func (s *CommunicationDescriptionEntryContext) CommunicationDescriptionEntryFormat3() ICommunicationDescriptionEntryFormat3Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommunicationDescriptionEntryFormat3Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommunicationDescriptionEntryFormat3Context)
}

func (s *CommunicationDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntry(s)
	}
}

func (s *CommunicationDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntry(s)
	}
}

func (s *CommunicationDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntry() (localctx ICommunicationDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewCommunicationDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, Cobol85ParserRULE_communicationDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2290)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 229, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2287)
			p.CommunicationDescriptionEntryFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2288)
			p.CommunicationDescriptionEntryFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2289)
			p.CommunicationDescriptionEntryFormat3()
		}

	}

	return localctx
}

// ICommunicationDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat1Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat1Context()
}

type CommunicationDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat1Context() *CommunicationDescriptionEntryFormat1Context {
	var p = new(CommunicationDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat1
	return p
}

func (*CommunicationDescriptionEntryFormat1Context) IsCommunicationDescriptionEntryFormat1Context() {}

func NewCommunicationDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat1Context {
	var p = new(CommunicationDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat1

	return p
}

func (s *CommunicationDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat1Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) CdName() ICdNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllDataDescName() []IDataDescNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescNameContext); ok {
			len++
		}
	}

	tst := make([]IDataDescNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescNameContext); ok {
			tst[i] = t.(IDataDescNameContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) DataDescName(i int) IDataDescNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicQueueClause() []ISymbolicQueueClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicQueueClauseContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicQueueClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicQueueClauseContext); ok {
			tst[i] = t.(ISymbolicQueueClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicQueueClause(i int) ISymbolicQueueClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicQueueClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicQueueClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicSubQueueClause() []ISymbolicSubQueueClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicSubQueueClauseContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicSubQueueClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicSubQueueClauseContext); ok {
			tst[i] = t.(ISymbolicSubQueueClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicSubQueueClause(i int) ISymbolicSubQueueClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicSubQueueClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicSubQueueClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageDateClause() []IMessageDateClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMessageDateClauseContext); ok {
			len++
		}
	}

	tst := make([]IMessageDateClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMessageDateClauseContext); ok {
			tst[i] = t.(IMessageDateClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageDateClause(i int) IMessageDateClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMessageDateClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMessageDateClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageTimeClause() []IMessageTimeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMessageTimeClauseContext); ok {
			len++
		}
	}

	tst := make([]IMessageTimeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMessageTimeClauseContext); ok {
			tst[i] = t.(IMessageTimeClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageTimeClause(i int) IMessageTimeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMessageTimeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMessageTimeClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllSymbolicSourceClause() []ISymbolicSourceClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicSourceClauseContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicSourceClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicSourceClauseContext); ok {
			tst[i] = t.(ISymbolicSourceClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) SymbolicSourceClause(i int) ISymbolicSourceClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicSourceClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicSourceClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllTextLengthClause() []ITextLengthClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextLengthClauseContext); ok {
			len++
		}
	}

	tst := make([]ITextLengthClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextLengthClauseContext); ok {
			tst[i] = t.(ITextLengthClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLengthClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllEndKeyClause() []IEndKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEndKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IEndKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEndKeyClauseContext); ok {
			tst[i] = t.(IEndKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) EndKeyClause(i int) IEndKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatusKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IStatusKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatusKeyClauseContext); ok {
			tst[i] = t.(IStatusKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) AllMessageCountClause() []IMessageCountClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMessageCountClauseContext); ok {
			len++
		}
	}

	tst := make([]IMessageCountClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMessageCountClauseContext); ok {
			tst[i] = t.(IMessageCountClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat1Context) MessageCountClause(i int) IMessageCountClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMessageCountClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMessageCountClauseContext)
}

func (s *CommunicationDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat1(s)
	}
}

func (s *CommunicationDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat1(s)
	}
}

func (s *CommunicationDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat1() (localctx ICommunicationDescriptionEntryFormat1Context) {
	this := p
	_ = this

	localctx = NewCommunicationDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, Cobol85ParserRULE_communicationDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2292)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2293)
		p.CdName()
	}
	p.SetState(2295)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2294)
			p.Match(Cobol85ParserFOR)
		}

	}
	p.SetState(2298)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINITIAL {
		{
			p.SetState(2297)
			p.Match(Cobol85ParserINITIAL)
		}

	}
	{
		p.SetState(2300)
		p.Match(Cobol85ParserINPUT)
	}
	p.SetState(2315)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070452049445126659) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893884388107) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761343) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752044752779) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874435004170307) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&4107423682476392449) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018459267) != 0 || _la == Cobol85ParserIDENTIFIER {
		p.SetState(2313)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCOUNT, Cobol85ParserEND, Cobol85ParserMESSAGE, Cobol85ParserQUEUE, Cobol85ParserSOURCE, Cobol85ParserSTATUS, Cobol85ParserSUB_QUEUE_1, Cobol85ParserSUB_QUEUE_2, Cobol85ParserSUB_QUEUE_3, Cobol85ParserSYMBOLIC, Cobol85ParserTEXT:
			p.SetState(2310)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 232, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2301)
					p.SymbolicQueueClause()
				}

			case 2:
				{
					p.SetState(2302)
					p.SymbolicSubQueueClause()
				}

			case 3:
				{
					p.SetState(2303)
					p.MessageDateClause()
				}

			case 4:
				{
					p.SetState(2304)
					p.MessageTimeClause()
				}

			case 5:
				{
					p.SetState(2305)
					p.SymbolicSourceClause()
				}

			case 6:
				{
					p.SetState(2306)
					p.TextLengthClause()
				}

			case 7:
				{
					p.SetState(2307)
					p.EndKeyClause()
				}

			case 8:
				{
					p.SetState(2308)
					p.StatusKeyClause()
				}

			case 9:
				{
					p.SetState(2309)
					p.MessageCountClause()
				}

			}

		case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFILLER, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
			{
				p.SetState(2312)
				p.DataDescName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2317)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2318)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICommunicationDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat2Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat2Context()
}

type CommunicationDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat2Context() *CommunicationDescriptionEntryFormat2Context {
	var p = new(CommunicationDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat2
	return p
}

func (*CommunicationDescriptionEntryFormat2Context) IsCommunicationDescriptionEntryFormat2Context() {}

func NewCommunicationDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat2Context {
	var p = new(CommunicationDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat2

	return p
}

func (s *CommunicationDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat2Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) CdName() ICdNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllDestinationCountClause() []IDestinationCountClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDestinationCountClauseContext); ok {
			len++
		}
	}

	tst := make([]IDestinationCountClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDestinationCountClauseContext); ok {
			tst[i] = t.(IDestinationCountClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) DestinationCountClause(i int) IDestinationCountClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationCountClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationCountClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllTextLengthClause() []ITextLengthClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextLengthClauseContext); ok {
			len++
		}
	}

	tst := make([]ITextLengthClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextLengthClauseContext); ok {
			tst[i] = t.(ITextLengthClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLengthClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatusKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IStatusKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatusKeyClauseContext); ok {
			tst[i] = t.(IStatusKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllDestinationTableClause() []IDestinationTableClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDestinationTableClauseContext); ok {
			len++
		}
	}

	tst := make([]IDestinationTableClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDestinationTableClauseContext); ok {
			tst[i] = t.(IDestinationTableClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) DestinationTableClause(i int) IDestinationTableClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDestinationTableClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDestinationTableClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllErrorKeyClause() []IErrorKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IErrorKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IErrorKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IErrorKeyClauseContext); ok {
			tst[i] = t.(IErrorKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) ErrorKeyClause(i int) IErrorKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IErrorKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IErrorKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) AllSymbolicDestinationClause() []ISymbolicDestinationClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicDestinationClauseContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicDestinationClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicDestinationClauseContext); ok {
			tst[i] = t.(ISymbolicDestinationClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat2Context) SymbolicDestinationClause(i int) ISymbolicDestinationClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicDestinationClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicDestinationClauseContext)
}

func (s *CommunicationDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat2(s)
	}
}

func (s *CommunicationDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat2(s)
	}
}

func (s *CommunicationDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat2() (localctx ICommunicationDescriptionEntryFormat2Context) {
	this := p
	_ = this

	localctx = NewCommunicationDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, Cobol85ParserRULE_communicationDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2320)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2321)
		p.CdName()
	}
	p.SetState(2323)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2322)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(2325)
		p.Match(Cobol85ParserOUTPUT)
	}
	p.SetState(2334)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserDESTINATION || _la == Cobol85ParserERROR || (int64((_la-457)) & ^0x3f) == 0 && ((int64(1)<<(_la-457))&2098177) != 0 {
		p.SetState(2332)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 236, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2326)
				p.DestinationCountClause()
			}

		case 2:
			{
				p.SetState(2327)
				p.TextLengthClause()
			}

		case 3:
			{
				p.SetState(2328)
				p.StatusKeyClause()
			}

		case 4:
			{
				p.SetState(2329)
				p.DestinationTableClause()
			}

		case 5:
			{
				p.SetState(2330)
				p.ErrorKeyClause()
			}

		case 6:
			{
				p.SetState(2331)
				p.SymbolicDestinationClause()
			}

		}

		p.SetState(2336)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2337)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// ICommunicationDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type ICommunicationDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommunicationDescriptionEntryFormat3Context differentiates from other interfaces.
	IsCommunicationDescriptionEntryFormat3Context()
}

type CommunicationDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommunicationDescriptionEntryFormat3Context() *CommunicationDescriptionEntryFormat3Context {
	var p = new(CommunicationDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat3
	return p
}

func (*CommunicationDescriptionEntryFormat3Context) IsCommunicationDescriptionEntryFormat3Context() {}

func NewCommunicationDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommunicationDescriptionEntryFormat3Context {
	var p = new(CommunicationDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_communicationDescriptionEntryFormat3

	return p
}

func (s *CommunicationDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *CommunicationDescriptionEntryFormat3Context) CD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCD, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) CdName() ICdNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllDataDescName() []IDataDescNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescNameContext); ok {
			len++
		}
	}

	tst := make([]IDataDescNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescNameContext); ok {
			tst[i] = t.(IDataDescNameContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) DataDescName(i int) IDataDescNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllMessageDateClause() []IMessageDateClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMessageDateClauseContext); ok {
			len++
		}
	}

	tst := make([]IMessageDateClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMessageDateClauseContext); ok {
			tst[i] = t.(IMessageDateClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) MessageDateClause(i int) IMessageDateClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMessageDateClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMessageDateClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllMessageTimeClause() []IMessageTimeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMessageTimeClauseContext); ok {
			len++
		}
	}

	tst := make([]IMessageTimeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMessageTimeClauseContext); ok {
			tst[i] = t.(IMessageTimeClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) MessageTimeClause(i int) IMessageTimeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMessageTimeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMessageTimeClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllSymbolicTerminalClause() []ISymbolicTerminalClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISymbolicTerminalClauseContext); ok {
			len++
		}
	}

	tst := make([]ISymbolicTerminalClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISymbolicTerminalClauseContext); ok {
			tst[i] = t.(ISymbolicTerminalClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) SymbolicTerminalClause(i int) ISymbolicTerminalClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISymbolicTerminalClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISymbolicTerminalClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllTextLengthClause() []ITextLengthClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextLengthClauseContext); ok {
			len++
		}
	}

	tst := make([]ITextLengthClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextLengthClauseContext); ok {
			tst[i] = t.(ITextLengthClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) TextLengthClause(i int) ITextLengthClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLengthClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLengthClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllEndKeyClause() []IEndKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEndKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IEndKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEndKeyClauseContext); ok {
			tst[i] = t.(IEndKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) EndKeyClause(i int) IEndKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEndKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEndKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) AllStatusKeyClause() []IStatusKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatusKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IStatusKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatusKeyClauseContext); ok {
			tst[i] = t.(IStatusKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *CommunicationDescriptionEntryFormat3Context) StatusKeyClause(i int) IStatusKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatusKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatusKeyClauseContext)
}

func (s *CommunicationDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommunicationDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommunicationDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommunicationDescriptionEntryFormat3(s)
	}
}

func (s *CommunicationDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommunicationDescriptionEntryFormat3(s)
	}
}

func (s *CommunicationDescriptionEntryFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommunicationDescriptionEntryFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommunicationDescriptionEntryFormat3() (localctx ICommunicationDescriptionEntryFormat3Context) {
	this := p
	_ = this

	localctx = NewCommunicationDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, Cobol85ParserRULE_communicationDescriptionEntryFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2339)
		p.Match(Cobol85ParserCD)
	}
	{
		p.SetState(2340)
		p.CdName()
	}
	p.SetState(2342)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(2341)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(2344)
		p.Match(Cobol85ParserINITIAL)
	}
	{
		p.SetState(2345)
		p.Match(Cobol85ParserI_O)
	}
	p.SetState(2357)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893884388107) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761343) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752044752779) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&72057678864072705) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018459779) != 0 || _la == Cobol85ParserIDENTIFIER {
		p.SetState(2355)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserEND, Cobol85ParserMESSAGE, Cobol85ParserSTATUS, Cobol85ParserSYMBOLIC, Cobol85ParserTERMINAL, Cobol85ParserTEXT:
			p.SetState(2352)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 239, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(2346)
					p.MessageDateClause()
				}

			case 2:
				{
					p.SetState(2347)
					p.MessageTimeClause()
				}

			case 3:
				{
					p.SetState(2348)
					p.SymbolicTerminalClause()
				}

			case 4:
				{
					p.SetState(2349)
					p.TextLengthClause()
				}

			case 5:
				{
					p.SetState(2350)
					p.EndKeyClause()
				}

			case 6:
				{
					p.SetState(2351)
					p.StatusKeyClause()
				}

			}

		case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFILLER, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
			{
				p.SetState(2354)
				p.DataDescName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2359)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2360)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDestinationCountClauseContext is an interface to support dynamic dispatch.
type IDestinationCountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationCountClauseContext differentiates from other interfaces.
	IsDestinationCountClauseContext()
}

type DestinationCountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationCountClauseContext() *DestinationCountClauseContext {
	var p = new(DestinationCountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_destinationCountClause
	return p
}

func (*DestinationCountClauseContext) IsDestinationCountClauseContext() {}

func NewDestinationCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationCountClauseContext {
	var p = new(DestinationCountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_destinationCountClause

	return p
}

func (s *DestinationCountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationCountClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *DestinationCountClauseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *DestinationCountClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *DestinationCountClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DestinationCountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationCountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationCountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDestinationCountClause(s)
	}
}

func (s *DestinationCountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDestinationCountClause(s)
	}
}

func (s *DestinationCountClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDestinationCountClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DestinationCountClause() (localctx IDestinationCountClauseContext) {
	this := p
	_ = this

	localctx = NewDestinationCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, Cobol85ParserRULE_destinationCountClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2362)
		p.Match(Cobol85ParserDESTINATION)
	}
	{
		p.SetState(2363)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(2365)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2364)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2367)
		p.DataDescName()
	}

	return localctx
}

// IDestinationTableClauseContext is an interface to support dynamic dispatch.
type IDestinationTableClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDestinationTableClauseContext differentiates from other interfaces.
	IsDestinationTableClauseContext()
}

type DestinationTableClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDestinationTableClauseContext() *DestinationTableClauseContext {
	var p = new(DestinationTableClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_destinationTableClause
	return p
}

func (*DestinationTableClauseContext) IsDestinationTableClauseContext() {}

func NewDestinationTableClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DestinationTableClauseContext {
	var p = new(DestinationTableClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_destinationTableClause

	return p
}

func (s *DestinationTableClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DestinationTableClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *DestinationTableClauseContext) TABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTABLE, 0)
}

func (s *DestinationTableClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *DestinationTableClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DestinationTableClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *DestinationTableClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *DestinationTableClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DestinationTableClauseContext) AllIndexName() []IIndexNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexNameContext); ok {
			tst[i] = t.(IIndexNameContext)
			i++
		}
	}

	return tst
}

func (s *DestinationTableClauseContext) IndexName(i int) IIndexNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DestinationTableClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DestinationTableClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DestinationTableClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDestinationTableClause(s)
	}
}

func (s *DestinationTableClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDestinationTableClause(s)
	}
}

func (s *DestinationTableClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDestinationTableClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DestinationTableClause() (localctx IDestinationTableClauseContext) {
	this := p
	_ = this

	localctx = NewDestinationTableClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, Cobol85ParserRULE_destinationTableClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2369)
		p.Match(Cobol85ParserDESTINATION)
	}
	{
		p.SetState(2370)
		p.Match(Cobol85ParserTABLE)
	}
	{
		p.SetState(2371)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(2372)
		p.IntegerLiteral()
	}
	{
		p.SetState(2373)
		p.Match(Cobol85ParserTIMES)
	}
	p.SetState(2381)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDEXED {
		{
			p.SetState(2374)
			p.Match(Cobol85ParserINDEXED)
		}
		{
			p.SetState(2375)
			p.Match(Cobol85ParserBY)
		}
		p.SetState(2377)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(2376)
				p.IndexName()
			}

			p.SetState(2379)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEndKeyClauseContext is an interface to support dynamic dispatch.
type IEndKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEndKeyClauseContext differentiates from other interfaces.
	IsEndKeyClauseContext()
}

type EndKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEndKeyClauseContext() *EndKeyClauseContext {
	var p = new(EndKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_endKeyClause
	return p
}

func (*EndKeyClauseContext) IsEndKeyClauseContext() {}

func NewEndKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EndKeyClauseContext {
	var p = new(EndKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_endKeyClause

	return p
}

func (s *EndKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *EndKeyClauseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *EndKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *EndKeyClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *EndKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *EndKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EndKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEndKeyClause(s)
	}
}

func (s *EndKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEndKeyClause(s)
	}
}

func (s *EndKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEndKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EndKeyClause() (localctx IEndKeyClauseContext) {
	this := p
	_ = this

	localctx = NewEndKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, Cobol85ParserRULE_endKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2383)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(2384)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2386)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2385)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2388)
		p.DataDescName()
	}

	return localctx
}

// IErrorKeyClauseContext is an interface to support dynamic dispatch.
type IErrorKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsErrorKeyClauseContext differentiates from other interfaces.
	IsErrorKeyClauseContext()
}

type ErrorKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyErrorKeyClauseContext() *ErrorKeyClauseContext {
	var p = new(ErrorKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_errorKeyClause
	return p
}

func (*ErrorKeyClauseContext) IsErrorKeyClauseContext() {}

func NewErrorKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ErrorKeyClauseContext {
	var p = new(ErrorKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_errorKeyClause

	return p
}

func (s *ErrorKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ErrorKeyClauseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *ErrorKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *ErrorKeyClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *ErrorKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ErrorKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ErrorKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ErrorKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterErrorKeyClause(s)
	}
}

func (s *ErrorKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitErrorKeyClause(s)
	}
}

func (s *ErrorKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitErrorKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ErrorKeyClause() (localctx IErrorKeyClauseContext) {
	this := p
	_ = this

	localctx = NewErrorKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, Cobol85ParserRULE_errorKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2390)
		p.Match(Cobol85ParserERROR)
	}
	{
		p.SetState(2391)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2393)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2392)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2395)
		p.DataDescName()
	}

	return localctx
}

// IMessageCountClauseContext is an interface to support dynamic dispatch.
type IMessageCountClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageCountClauseContext differentiates from other interfaces.
	IsMessageCountClauseContext()
}

type MessageCountClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageCountClauseContext() *MessageCountClauseContext {
	var p = new(MessageCountClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageCountClause
	return p
}

func (*MessageCountClauseContext) IsMessageCountClauseContext() {}

func NewMessageCountClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageCountClauseContext {
	var p = new(MessageCountClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageCountClause

	return p
}

func (s *MessageCountClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageCountClauseContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *MessageCountClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageCountClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageCountClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageCountClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageCountClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageCountClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageCountClause(s)
	}
}

func (s *MessageCountClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageCountClause(s)
	}
}

func (s *MessageCountClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMessageCountClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MessageCountClause() (localctx IMessageCountClauseContext) {
	this := p
	_ = this

	localctx = NewMessageCountClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, Cobol85ParserRULE_messageCountClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2398)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMESSAGE {
		{
			p.SetState(2397)
			p.Match(Cobol85ParserMESSAGE)
		}

	}
	{
		p.SetState(2400)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(2402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2401)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2404)
		p.DataDescName()
	}

	return localctx
}

// IMessageDateClauseContext is an interface to support dynamic dispatch.
type IMessageDateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageDateClauseContext differentiates from other interfaces.
	IsMessageDateClauseContext()
}

type MessageDateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageDateClauseContext() *MessageDateClauseContext {
	var p = new(MessageDateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageDateClause
	return p
}

func (*MessageDateClauseContext) IsMessageDateClauseContext() {}

func NewMessageDateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageDateClauseContext {
	var p = new(MessageDateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageDateClause

	return p
}

func (s *MessageDateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageDateClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageDateClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *MessageDateClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageDateClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageDateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageDateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageDateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageDateClause(s)
	}
}

func (s *MessageDateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageDateClause(s)
	}
}

func (s *MessageDateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMessageDateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MessageDateClause() (localctx IMessageDateClauseContext) {
	this := p
	_ = this

	localctx = NewMessageDateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, Cobol85ParserRULE_messageDateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2406)
		p.Match(Cobol85ParserMESSAGE)
	}
	{
		p.SetState(2407)
		p.Match(Cobol85ParserDATE)
	}
	p.SetState(2409)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2408)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2411)
		p.DataDescName()
	}

	return localctx
}

// IMessageTimeClauseContext is an interface to support dynamic dispatch.
type IMessageTimeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMessageTimeClauseContext differentiates from other interfaces.
	IsMessageTimeClauseContext()
}

type MessageTimeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMessageTimeClauseContext() *MessageTimeClauseContext {
	var p = new(MessageTimeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_messageTimeClause
	return p
}

func (*MessageTimeClauseContext) IsMessageTimeClauseContext() {}

func NewMessageTimeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MessageTimeClauseContext {
	var p = new(MessageTimeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_messageTimeClause

	return p
}

func (s *MessageTimeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MessageTimeClauseContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *MessageTimeClauseContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *MessageTimeClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *MessageTimeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MessageTimeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MessageTimeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MessageTimeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMessageTimeClause(s)
	}
}

func (s *MessageTimeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMessageTimeClause(s)
	}
}

func (s *MessageTimeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMessageTimeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MessageTimeClause() (localctx IMessageTimeClauseContext) {
	this := p
	_ = this

	localctx = NewMessageTimeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, Cobol85ParserRULE_messageTimeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2413)
		p.Match(Cobol85ParserMESSAGE)
	}
	{
		p.SetState(2414)
		p.Match(Cobol85ParserTIME)
	}
	p.SetState(2416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2415)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2418)
		p.DataDescName()
	}

	return localctx
}

// IStatusKeyClauseContext is an interface to support dynamic dispatch.
type IStatusKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatusKeyClauseContext differentiates from other interfaces.
	IsStatusKeyClauseContext()
}

type StatusKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatusKeyClauseContext() *StatusKeyClauseContext {
	var p = new(StatusKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_statusKeyClause
	return p
}

func (*StatusKeyClauseContext) IsStatusKeyClauseContext() {}

func NewStatusKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatusKeyClauseContext {
	var p = new(StatusKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_statusKeyClause

	return p
}

func (s *StatusKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *StatusKeyClauseContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *StatusKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *StatusKeyClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *StatusKeyClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *StatusKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatusKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatusKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStatusKeyClause(s)
	}
}

func (s *StatusKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStatusKeyClause(s)
	}
}

func (s *StatusKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStatusKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StatusKeyClause() (localctx IStatusKeyClauseContext) {
	this := p
	_ = this

	localctx = NewStatusKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, Cobol85ParserRULE_statusKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2420)
		p.Match(Cobol85ParserSTATUS)
	}
	{
		p.SetState(2421)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(2423)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2422)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2425)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicDestinationClauseContext is an interface to support dynamic dispatch.
type ISymbolicDestinationClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicDestinationClauseContext differentiates from other interfaces.
	IsSymbolicDestinationClauseContext()
}

type SymbolicDestinationClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicDestinationClauseContext() *SymbolicDestinationClauseContext {
	var p = new(SymbolicDestinationClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicDestinationClause
	return p
}

func (*SymbolicDestinationClauseContext) IsSymbolicDestinationClauseContext() {}

func NewSymbolicDestinationClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicDestinationClauseContext {
	var p = new(SymbolicDestinationClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicDestinationClause

	return p
}

func (s *SymbolicDestinationClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicDestinationClauseContext) DESTINATION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESTINATION, 0)
}

func (s *SymbolicDestinationClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicDestinationClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicDestinationClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicDestinationClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicDestinationClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicDestinationClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicDestinationClause(s)
	}
}

func (s *SymbolicDestinationClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicDestinationClause(s)
	}
}

func (s *SymbolicDestinationClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicDestinationClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicDestinationClause() (localctx ISymbolicDestinationClauseContext) {
	this := p
	_ = this

	localctx = NewSymbolicDestinationClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, Cobol85ParserRULE_symbolicDestinationClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2428)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2427)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2430)
		p.Match(Cobol85ParserDESTINATION)
	}
	p.SetState(2432)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2431)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2434)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicQueueClauseContext is an interface to support dynamic dispatch.
type ISymbolicQueueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicQueueClauseContext differentiates from other interfaces.
	IsSymbolicQueueClauseContext()
}

type SymbolicQueueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicQueueClauseContext() *SymbolicQueueClauseContext {
	var p = new(SymbolicQueueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicQueueClause
	return p
}

func (*SymbolicQueueClauseContext) IsSymbolicQueueClauseContext() {}

func NewSymbolicQueueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicQueueClauseContext {
	var p = new(SymbolicQueueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicQueueClause

	return p
}

func (s *SymbolicQueueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicQueueClauseContext) QUEUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUEUE, 0)
}

func (s *SymbolicQueueClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicQueueClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicQueueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicQueueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicQueueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicQueueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicQueueClause(s)
	}
}

func (s *SymbolicQueueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicQueueClause(s)
	}
}

func (s *SymbolicQueueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicQueueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicQueueClause() (localctx ISymbolicQueueClauseContext) {
	this := p
	_ = this

	localctx = NewSymbolicQueueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, Cobol85ParserRULE_symbolicQueueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2437)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2436)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2439)
		p.Match(Cobol85ParserQUEUE)
	}
	p.SetState(2441)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2440)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2443)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicSourceClauseContext is an interface to support dynamic dispatch.
type ISymbolicSourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicSourceClauseContext differentiates from other interfaces.
	IsSymbolicSourceClauseContext()
}

type SymbolicSourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicSourceClauseContext() *SymbolicSourceClauseContext {
	var p = new(SymbolicSourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicSourceClause
	return p
}

func (*SymbolicSourceClauseContext) IsSymbolicSourceClauseContext() {}

func NewSymbolicSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicSourceClauseContext {
	var p = new(SymbolicSourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicSourceClause

	return p
}

func (s *SymbolicSourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicSourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE, 0)
}

func (s *SymbolicSourceClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicSourceClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicSourceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicSourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicSourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicSourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicSourceClause(s)
	}
}

func (s *SymbolicSourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicSourceClause(s)
	}
}

func (s *SymbolicSourceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicSourceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicSourceClause() (localctx ISymbolicSourceClauseContext) {
	this := p
	_ = this

	localctx = NewSymbolicSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, Cobol85ParserRULE_symbolicSourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2445)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2448)
		p.Match(Cobol85ParserSOURCE)
	}
	p.SetState(2450)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2449)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2452)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicTerminalClauseContext is an interface to support dynamic dispatch.
type ISymbolicTerminalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicTerminalClauseContext differentiates from other interfaces.
	IsSymbolicTerminalClauseContext()
}

type SymbolicTerminalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicTerminalClauseContext() *SymbolicTerminalClauseContext {
	var p = new(SymbolicTerminalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicTerminalClause
	return p
}

func (*SymbolicTerminalClauseContext) IsSymbolicTerminalClauseContext() {}

func NewSymbolicTerminalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicTerminalClauseContext {
	var p = new(SymbolicTerminalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicTerminalClause

	return p
}

func (s *SymbolicTerminalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicTerminalClauseContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *SymbolicTerminalClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicTerminalClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicTerminalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicTerminalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicTerminalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicTerminalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicTerminalClause(s)
	}
}

func (s *SymbolicTerminalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicTerminalClause(s)
	}
}

func (s *SymbolicTerminalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicTerminalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicTerminalClause() (localctx ISymbolicTerminalClauseContext) {
	this := p
	_ = this

	localctx = NewSymbolicTerminalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, Cobol85ParserRULE_symbolicTerminalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2455)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2454)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2457)
		p.Match(Cobol85ParserTERMINAL)
	}
	p.SetState(2459)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2458)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2461)
		p.DataDescName()
	}

	return localctx
}

// ISymbolicSubQueueClauseContext is an interface to support dynamic dispatch.
type ISymbolicSubQueueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicSubQueueClauseContext differentiates from other interfaces.
	IsSymbolicSubQueueClauseContext()
}

type SymbolicSubQueueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicSubQueueClauseContext() *SymbolicSubQueueClauseContext {
	var p = new(SymbolicSubQueueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicSubQueueClause
	return p
}

func (*SymbolicSubQueueClauseContext) IsSymbolicSubQueueClauseContext() {}

func NewSymbolicSubQueueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicSubQueueClauseContext {
	var p = new(SymbolicSubQueueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicSubQueueClause

	return p
}

func (s *SymbolicSubQueueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicSubQueueClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_1, 0)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_2, 0)
}

func (s *SymbolicSubQueueClauseContext) SUB_QUEUE_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUB_QUEUE_3, 0)
}

func (s *SymbolicSubQueueClauseContext) SYMBOLIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOLIC, 0)
}

func (s *SymbolicSubQueueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SymbolicSubQueueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicSubQueueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicSubQueueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicSubQueueClause(s)
	}
}

func (s *SymbolicSubQueueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicSubQueueClause(s)
	}
}

func (s *SymbolicSubQueueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicSubQueueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicSubQueueClause() (localctx ISymbolicSubQueueClauseContext) {
	this := p
	_ = this

	localctx = NewSymbolicSubQueueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, Cobol85ParserRULE_symbolicSubQueueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2464)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSYMBOLIC {
		{
			p.SetState(2463)
			p.Match(Cobol85ParserSYMBOLIC)
		}

	}
	{
		p.SetState(2466)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-460)) & ^0x3f) == 0 && ((int64(1)<<(_la-460))&7) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2468)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2467)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2470)
		p.DataDescName()
	}

	return localctx
}

// ITextLengthClauseContext is an interface to support dynamic dispatch.
type ITextLengthClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextLengthClauseContext differentiates from other interfaces.
	IsTextLengthClauseContext()
}

type TextLengthClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextLengthClauseContext() *TextLengthClauseContext {
	var p = new(TextLengthClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_textLengthClause
	return p
}

func (*TextLengthClauseContext) IsTextLengthClauseContext() {}

func NewTextLengthClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextLengthClauseContext {
	var p = new(TextLengthClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_textLengthClause

	return p
}

func (s *TextLengthClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *TextLengthClauseContext) TEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTEXT, 0)
}

func (s *TextLengthClauseContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *TextLengthClauseContext) DataDescName() IDataDescNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescNameContext)
}

func (s *TextLengthClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *TextLengthClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextLengthClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextLengthClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTextLengthClause(s)
	}
}

func (s *TextLengthClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTextLengthClause(s)
	}
}

func (s *TextLengthClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTextLengthClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TextLengthClause() (localctx ITextLengthClauseContext) {
	this := p
	_ = this

	localctx = NewTextLengthClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, Cobol85ParserRULE_textLengthClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2472)
		p.Match(Cobol85ParserTEXT)
	}
	{
		p.SetState(2473)
		p.Match(Cobol85ParserLENGTH)
	}
	p.SetState(2475)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2474)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2477)
		p.DataDescName()
	}

	return localctx
}

// ILocalStorageSectionContext is an interface to support dynamic dispatch.
type ILocalStorageSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalStorageSectionContext differentiates from other interfaces.
	IsLocalStorageSectionContext()
}

type LocalStorageSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalStorageSectionContext() *LocalStorageSectionContext {
	var p = new(LocalStorageSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_localStorageSection
	return p
}

func (*LocalStorageSectionContext) IsLocalStorageSectionContext() {}

func NewLocalStorageSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalStorageSectionContext {
	var p = new(LocalStorageSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_localStorageSection

	return p
}

func (s *LocalStorageSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalStorageSectionContext) LOCAL_STORAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL_STORAGE, 0)
}

func (s *LocalStorageSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *LocalStorageSectionContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *LocalStorageSectionContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *LocalStorageSectionContext) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *LocalStorageSectionContext) LocalName() ILocalNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalNameContext)
}

func (s *LocalStorageSectionContext) AllDataDescriptionEntry() []IDataDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IDataDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataDescriptionEntryContext); ok {
			tst[i] = t.(IDataDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *LocalStorageSectionContext) DataDescriptionEntry(i int) IDataDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryContext)
}

func (s *LocalStorageSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalStorageSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalStorageSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLocalStorageSection(s)
	}
}

func (s *LocalStorageSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLocalStorageSection(s)
	}
}

func (s *LocalStorageSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLocalStorageSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LocalStorageSection() (localctx ILocalStorageSectionContext) {
	this := p
	_ = this

	localctx = NewLocalStorageSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, Cobol85ParserRULE_localStorageSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2479)
		p.Match(Cobol85ParserLOCAL_STORAGE)
	}
	{
		p.SetState(2480)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2481)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLD {
		{
			p.SetState(2482)
			p.Match(Cobol85ParserLD)
		}
		{
			p.SetState(2483)
			p.LocalName()
		}
		{
			p.SetState(2484)
			p.Match(Cobol85ParserDOT_FS)
		}

	}
	p.SetState(2491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&527) != 0 {
		{
			p.SetState(2488)
			p.DataDescriptionEntry()
		}

		p.SetState(2493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScreenSectionContext is an interface to support dynamic dispatch.
type IScreenSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenSectionContext differentiates from other interfaces.
	IsScreenSectionContext()
}

type ScreenSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenSectionContext() *ScreenSectionContext {
	var p = new(ScreenSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenSection
	return p
}

func (*ScreenSectionContext) IsScreenSectionContext() {}

func NewScreenSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenSectionContext {
	var p = new(ScreenSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenSection

	return p
}

func (s *ScreenSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenSectionContext) SCREEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSCREEN, 0)
}

func (s *ScreenSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ScreenSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ScreenSectionContext) AllScreenDescriptionEntry() []IScreenDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionEntryContext); ok {
			tst[i] = t.(IScreenDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *ScreenSectionContext) ScreenDescriptionEntry(i int) IScreenDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionEntryContext)
}

func (s *ScreenSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenSection(s)
	}
}

func (s *ScreenSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenSection(s)
	}
}

func (s *ScreenSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenSection() (localctx IScreenSectionContext) {
	this := p
	_ = this

	localctx = NewScreenSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, Cobol85ParserRULE_screenSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2494)
		p.Match(Cobol85ParserSCREEN)
	}
	{
		p.SetState(2495)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2496)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserINTEGERLITERAL {
		{
			p.SetState(2497)
			p.ScreenDescriptionEntry()
		}

		p.SetState(2502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IScreenDescriptionEntryContext is an interface to support dynamic dispatch.
type IScreenDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionEntryContext differentiates from other interfaces.
	IsScreenDescriptionEntryContext()
}

type ScreenDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionEntryContext() *ScreenDescriptionEntryContext {
	var p = new(ScreenDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEntry
	return p
}

func (*ScreenDescriptionEntryContext) IsScreenDescriptionEntryContext() {}

func NewScreenDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionEntryContext {
	var p = new(ScreenDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEntry

	return p
}

func (s *ScreenDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionEntryContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *ScreenDescriptionEntryContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ScreenDescriptionEntryContext) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *ScreenDescriptionEntryContext) ScreenName() IScreenNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenNameContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlankClause() []IScreenDescriptionBlankClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionBlankClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionBlankClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionBlankClauseContext); ok {
			tst[i] = t.(IScreenDescriptionBlankClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlankClause(i int) IScreenDescriptionBlankClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionBlankClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlankClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBellClause() []IScreenDescriptionBellClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionBellClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionBellClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionBellClauseContext); ok {
			tst[i] = t.(IScreenDescriptionBellClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBellClause(i int) IScreenDescriptionBellClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionBellClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBellClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlinkClause() []IScreenDescriptionBlinkClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionBlinkClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionBlinkClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionBlinkClauseContext); ok {
			tst[i] = t.(IScreenDescriptionBlinkClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlinkClause(i int) IScreenDescriptionBlinkClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionBlinkClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlinkClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionEraseClause() []IScreenDescriptionEraseClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionEraseClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionEraseClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionEraseClauseContext); ok {
			tst[i] = t.(IScreenDescriptionEraseClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionEraseClause(i int) IScreenDescriptionEraseClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionEraseClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionEraseClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionLightClause() []IScreenDescriptionLightClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionLightClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionLightClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionLightClauseContext); ok {
			tst[i] = t.(IScreenDescriptionLightClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionLightClause(i int) IScreenDescriptionLightClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionLightClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionLightClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionGridClause() []IScreenDescriptionGridClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionGridClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionGridClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionGridClauseContext); ok {
			tst[i] = t.(IScreenDescriptionGridClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionGridClause(i int) IScreenDescriptionGridClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionGridClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionGridClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionReverseVideoClause() []IScreenDescriptionReverseVideoClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionReverseVideoClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionReverseVideoClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionReverseVideoClauseContext); ok {
			tst[i] = t.(IScreenDescriptionReverseVideoClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionReverseVideoClause(i int) IScreenDescriptionReverseVideoClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionReverseVideoClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionReverseVideoClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUnderlineClause() []IScreenDescriptionUnderlineClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionUnderlineClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionUnderlineClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionUnderlineClauseContext); ok {
			tst[i] = t.(IScreenDescriptionUnderlineClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUnderlineClause(i int) IScreenDescriptionUnderlineClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionUnderlineClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUnderlineClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSizeClause() []IScreenDescriptionSizeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionSizeClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionSizeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionSizeClauseContext); ok {
			tst[i] = t.(IScreenDescriptionSizeClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSizeClause(i int) IScreenDescriptionSizeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionSizeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSizeClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionLineClause() []IScreenDescriptionLineClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionLineClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionLineClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionLineClauseContext); ok {
			tst[i] = t.(IScreenDescriptionLineClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionLineClause(i int) IScreenDescriptionLineClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionLineClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionLineClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionColumnClause() []IScreenDescriptionColumnClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionColumnClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionColumnClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionColumnClauseContext); ok {
			tst[i] = t.(IScreenDescriptionColumnClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionColumnClause(i int) IScreenDescriptionColumnClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionColumnClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionColumnClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionForegroundColorClause() []IScreenDescriptionForegroundColorClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionForegroundColorClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionForegroundColorClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionForegroundColorClauseContext); ok {
			tst[i] = t.(IScreenDescriptionForegroundColorClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionForegroundColorClause(i int) IScreenDescriptionForegroundColorClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionForegroundColorClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionForegroundColorClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBackgroundColorClause() []IScreenDescriptionBackgroundColorClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionBackgroundColorClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionBackgroundColorClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionBackgroundColorClauseContext); ok {
			tst[i] = t.(IScreenDescriptionBackgroundColorClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBackgroundColorClause(i int) IScreenDescriptionBackgroundColorClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionBackgroundColorClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBackgroundColorClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionControlClause() []IScreenDescriptionControlClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionControlClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionControlClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionControlClauseContext); ok {
			tst[i] = t.(IScreenDescriptionControlClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionControlClause(i int) IScreenDescriptionControlClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionControlClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionControlClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionValueClause() []IScreenDescriptionValueClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionValueClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionValueClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionValueClauseContext); ok {
			tst[i] = t.(IScreenDescriptionValueClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionValueClause(i int) IScreenDescriptionValueClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionValueClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionValueClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionPictureClause() []IScreenDescriptionPictureClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionPictureClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionPictureClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionPictureClauseContext); ok {
			tst[i] = t.(IScreenDescriptionPictureClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionPictureClause(i int) IScreenDescriptionPictureClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionPictureClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPictureClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUsageClause() []IScreenDescriptionUsageClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionUsageClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionUsageClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionUsageClauseContext); ok {
			tst[i] = t.(IScreenDescriptionUsageClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUsageClause(i int) IScreenDescriptionUsageClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionUsageClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUsageClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionBlankWhenZeroClause() []IScreenDescriptionBlankWhenZeroClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionBlankWhenZeroClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionBlankWhenZeroClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionBlankWhenZeroClauseContext); ok {
			tst[i] = t.(IScreenDescriptionBlankWhenZeroClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionBlankWhenZeroClause(i int) IScreenDescriptionBlankWhenZeroClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionBlankWhenZeroClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionBlankWhenZeroClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionJustifiedClause() []IScreenDescriptionJustifiedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionJustifiedClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionJustifiedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionJustifiedClauseContext); ok {
			tst[i] = t.(IScreenDescriptionJustifiedClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionJustifiedClause(i int) IScreenDescriptionJustifiedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionJustifiedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionJustifiedClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSignClause() []IScreenDescriptionSignClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionSignClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionSignClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionSignClauseContext); ok {
			tst[i] = t.(IScreenDescriptionSignClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSignClause(i int) IScreenDescriptionSignClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionSignClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSignClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionAutoClause() []IScreenDescriptionAutoClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionAutoClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionAutoClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionAutoClauseContext); ok {
			tst[i] = t.(IScreenDescriptionAutoClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionAutoClause(i int) IScreenDescriptionAutoClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionAutoClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionAutoClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionSecureClause() []IScreenDescriptionSecureClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionSecureClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionSecureClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionSecureClauseContext); ok {
			tst[i] = t.(IScreenDescriptionSecureClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionSecureClause(i int) IScreenDescriptionSecureClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionSecureClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionSecureClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionRequiredClause() []IScreenDescriptionRequiredClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionRequiredClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionRequiredClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionRequiredClauseContext); ok {
			tst[i] = t.(IScreenDescriptionRequiredClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionRequiredClause(i int) IScreenDescriptionRequiredClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionRequiredClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionRequiredClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionPromptClause() []IScreenDescriptionPromptClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionPromptClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionPromptClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionPromptClauseContext); ok {
			tst[i] = t.(IScreenDescriptionPromptClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionPromptClause(i int) IScreenDescriptionPromptClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionPromptClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPromptClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionFullClause() []IScreenDescriptionFullClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionFullClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionFullClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionFullClauseContext); ok {
			tst[i] = t.(IScreenDescriptionFullClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionFullClause(i int) IScreenDescriptionFullClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionFullClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionFullClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionZeroFillClause() []IScreenDescriptionZeroFillClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionZeroFillClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionZeroFillClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionZeroFillClauseContext); ok {
			tst[i] = t.(IScreenDescriptionZeroFillClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionZeroFillClause(i int) IScreenDescriptionZeroFillClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionZeroFillClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionZeroFillClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionFromClause() []IScreenDescriptionFromClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionFromClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionFromClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionFromClauseContext); ok {
			tst[i] = t.(IScreenDescriptionFromClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionFromClause(i int) IScreenDescriptionFromClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionFromClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionFromClauseContext)
}

func (s *ScreenDescriptionEntryContext) AllScreenDescriptionUsingClause() []IScreenDescriptionUsingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IScreenDescriptionUsingClauseContext); ok {
			len++
		}
	}

	tst := make([]IScreenDescriptionUsingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IScreenDescriptionUsingClauseContext); ok {
			tst[i] = t.(IScreenDescriptionUsingClauseContext)
			i++
		}
	}

	return tst
}

func (s *ScreenDescriptionEntryContext) ScreenDescriptionUsingClause(i int) IScreenDescriptionUsingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionUsingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionUsingClauseContext)
}

func (s *ScreenDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionEntry(s)
	}
}

func (s *ScreenDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionEntry(s)
	}
}

func (s *ScreenDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionEntry() (localctx IScreenDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, Cobol85ParserRULE_screenDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2503)
		p.Match(Cobol85ParserINTEGERLITERAL)
	}
	p.SetState(2506)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2504)
			p.Match(Cobol85ParserFILLER)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 266, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(2505)
			p.ScreenName()
		}

	}
	p.SetState(2540)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-33)) & ^0x3f) == 0 && ((int64(1)<<(_la-33))&3298534889775) != 0 || _la == Cobol85ParserCONTROL || _la == Cobol85ParserEMPTY_CHECK || (int64((_la-187)) & ^0x3f) == 0 && ((int64(1)<<(_la-187))&4948808957953) != 0 || (int64((_la-255)) & ^0x3f) == 0 && ((int64(1)<<(_la-255))&72057628414486531) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4611686018695826433) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&412317384705) != 0 || (int64((_la-493)) & ^0x3f) == 0 && ((int64(1)<<(_la-493))&536897569) != 0 {
		p.SetState(2538)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 268, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2508)
				p.ScreenDescriptionBlankClause()
			}

		case 2:
			{
				p.SetState(2509)
				p.ScreenDescriptionBellClause()
			}

		case 3:
			{
				p.SetState(2510)
				p.ScreenDescriptionBlinkClause()
			}

		case 4:
			{
				p.SetState(2511)
				p.ScreenDescriptionEraseClause()
			}

		case 5:
			{
				p.SetState(2512)
				p.ScreenDescriptionLightClause()
			}

		case 6:
			{
				p.SetState(2513)
				p.ScreenDescriptionGridClause()
			}

		case 7:
			{
				p.SetState(2514)
				p.ScreenDescriptionReverseVideoClause()
			}

		case 8:
			{
				p.SetState(2515)
				p.ScreenDescriptionUnderlineClause()
			}

		case 9:
			{
				p.SetState(2516)
				p.ScreenDescriptionSizeClause()
			}

		case 10:
			{
				p.SetState(2517)
				p.ScreenDescriptionLineClause()
			}

		case 11:
			{
				p.SetState(2518)
				p.ScreenDescriptionColumnClause()
			}

		case 12:
			{
				p.SetState(2519)
				p.ScreenDescriptionForegroundColorClause()
			}

		case 13:
			{
				p.SetState(2520)
				p.ScreenDescriptionBackgroundColorClause()
			}

		case 14:
			{
				p.SetState(2521)
				p.ScreenDescriptionControlClause()
			}

		case 15:
			{
				p.SetState(2522)
				p.ScreenDescriptionValueClause()
			}

		case 16:
			{
				p.SetState(2523)
				p.ScreenDescriptionPictureClause()
			}

		case 17:
			p.SetState(2526)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserFROM:
				{
					p.SetState(2524)
					p.ScreenDescriptionFromClause()
				}

			case Cobol85ParserUSING:
				{
					p.SetState(2525)
					p.ScreenDescriptionUsingClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case 18:
			{
				p.SetState(2528)
				p.ScreenDescriptionUsageClause()
			}

		case 19:
			{
				p.SetState(2529)
				p.ScreenDescriptionBlankWhenZeroClause()
			}

		case 20:
			{
				p.SetState(2530)
				p.ScreenDescriptionJustifiedClause()
			}

		case 21:
			{
				p.SetState(2531)
				p.ScreenDescriptionSignClause()
			}

		case 22:
			{
				p.SetState(2532)
				p.ScreenDescriptionAutoClause()
			}

		case 23:
			{
				p.SetState(2533)
				p.ScreenDescriptionSecureClause()
			}

		case 24:
			{
				p.SetState(2534)
				p.ScreenDescriptionRequiredClause()
			}

		case 25:
			{
				p.SetState(2535)
				p.ScreenDescriptionPromptClause()
			}

		case 26:
			{
				p.SetState(2536)
				p.ScreenDescriptionFullClause()
			}

		case 27:
			{
				p.SetState(2537)
				p.ScreenDescriptionZeroFillClause()
			}

		}

		p.SetState(2542)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2543)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IScreenDescriptionBlankClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlankClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlankClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlankClauseContext()
}

type ScreenDescriptionBlankClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlankClauseContext() *ScreenDescriptionBlankClauseContext {
	var p = new(ScreenDescriptionBlankClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankClause
	return p
}

func (*ScreenDescriptionBlankClauseContext) IsScreenDescriptionBlankClauseContext() {}

func NewScreenDescriptionBlankClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlankClauseContext {
	var p = new(ScreenDescriptionBlankClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankClause

	return p
}

func (s *ScreenDescriptionBlankClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlankClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ScreenDescriptionBlankClauseContext) SCREEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSCREEN, 0)
}

func (s *ScreenDescriptionBlankClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ScreenDescriptionBlankClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlankClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlankClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlankClause(s)
	}
}

func (s *ScreenDescriptionBlankClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlankClause(s)
	}
}

func (s *ScreenDescriptionBlankClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBlankClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlankClause() (localctx IScreenDescriptionBlankClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionBlankClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, Cobol85ParserRULE_screenDescriptionBlankClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2545)
		p.Match(Cobol85ParserBLANK)
	}
	{
		p.SetState(2546)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLINE || _la == Cobol85ParserSCREEN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionBellClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBellClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBellClauseContext differentiates from other interfaces.
	IsScreenDescriptionBellClauseContext()
}

type ScreenDescriptionBellClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBellClauseContext() *ScreenDescriptionBellClauseContext {
	var p = new(ScreenDescriptionBellClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBellClause
	return p
}

func (*ScreenDescriptionBellClauseContext) IsScreenDescriptionBellClauseContext() {}

func NewScreenDescriptionBellClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBellClauseContext {
	var p = new(ScreenDescriptionBellClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBellClause

	return p
}

func (s *ScreenDescriptionBellClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBellClauseContext) BELL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBELL, 0)
}

func (s *ScreenDescriptionBellClauseContext) BEEP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEEP, 0)
}

func (s *ScreenDescriptionBellClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBellClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBellClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBellClause(s)
	}
}

func (s *ScreenDescriptionBellClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBellClause(s)
	}
}

func (s *ScreenDescriptionBellClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBellClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBellClause() (localctx IScreenDescriptionBellClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionBellClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, Cobol85ParserRULE_screenDescriptionBellClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2548)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBEEP || _la == Cobol85ParserBELL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionBlinkClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlinkClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlinkClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlinkClauseContext()
}

type ScreenDescriptionBlinkClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlinkClauseContext() *ScreenDescriptionBlinkClauseContext {
	var p = new(ScreenDescriptionBlinkClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlinkClause
	return p
}

func (*ScreenDescriptionBlinkClauseContext) IsScreenDescriptionBlinkClauseContext() {}

func NewScreenDescriptionBlinkClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlinkClauseContext {
	var p = new(ScreenDescriptionBlinkClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlinkClause

	return p
}

func (s *ScreenDescriptionBlinkClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlinkClauseContext) BLINK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLINK, 0)
}

func (s *ScreenDescriptionBlinkClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlinkClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlinkClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlinkClause(s)
	}
}

func (s *ScreenDescriptionBlinkClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlinkClause(s)
	}
}

func (s *ScreenDescriptionBlinkClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBlinkClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlinkClause() (localctx IScreenDescriptionBlinkClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionBlinkClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, Cobol85ParserRULE_screenDescriptionBlinkClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2550)
		p.Match(Cobol85ParserBLINK)
	}

	return localctx
}

// IScreenDescriptionEraseClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionEraseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionEraseClauseContext differentiates from other interfaces.
	IsScreenDescriptionEraseClauseContext()
}

type ScreenDescriptionEraseClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionEraseClauseContext() *ScreenDescriptionEraseClauseContext {
	var p = new(ScreenDescriptionEraseClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEraseClause
	return p
}

func (*ScreenDescriptionEraseClauseContext) IsScreenDescriptionEraseClauseContext() {}

func NewScreenDescriptionEraseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionEraseClauseContext {
	var p = new(ScreenDescriptionEraseClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionEraseClause

	return p
}

func (s *ScreenDescriptionEraseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionEraseClauseContext) ERASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERASE, 0)
}

func (s *ScreenDescriptionEraseClauseContext) EOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOL, 0)
}

func (s *ScreenDescriptionEraseClauseContext) EOS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOS, 0)
}

func (s *ScreenDescriptionEraseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionEraseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionEraseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionEraseClause(s)
	}
}

func (s *ScreenDescriptionEraseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionEraseClause(s)
	}
}

func (s *ScreenDescriptionEraseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionEraseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionEraseClause() (localctx IScreenDescriptionEraseClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionEraseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, Cobol85ParserRULE_screenDescriptionEraseClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2552)
		p.Match(Cobol85ParserERASE)
	}
	{
		p.SetState(2553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEOL || _la == Cobol85ParserEOS) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionLightClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionLightClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionLightClauseContext differentiates from other interfaces.
	IsScreenDescriptionLightClauseContext()
}

type ScreenDescriptionLightClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionLightClauseContext() *ScreenDescriptionLightClauseContext {
	var p = new(ScreenDescriptionLightClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLightClause
	return p
}

func (*ScreenDescriptionLightClauseContext) IsScreenDescriptionLightClauseContext() {}

func NewScreenDescriptionLightClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionLightClauseContext {
	var p = new(ScreenDescriptionLightClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLightClause

	return p
}

func (s *ScreenDescriptionLightClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionLightClauseContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGHLIGHT, 0)
}

func (s *ScreenDescriptionLightClauseContext) LOWLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWLIGHT, 0)
}

func (s *ScreenDescriptionLightClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionLightClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionLightClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionLightClause(s)
	}
}

func (s *ScreenDescriptionLightClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionLightClause(s)
	}
}

func (s *ScreenDescriptionLightClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionLightClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionLightClause() (localctx IScreenDescriptionLightClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionLightClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, Cobol85ParserRULE_screenDescriptionLightClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2555)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserHIGHLIGHT || _la == Cobol85ParserLOWLIGHT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionGridClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionGridClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionGridClauseContext differentiates from other interfaces.
	IsScreenDescriptionGridClauseContext()
}

type ScreenDescriptionGridClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionGridClauseContext() *ScreenDescriptionGridClauseContext {
	var p = new(ScreenDescriptionGridClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionGridClause
	return p
}

func (*ScreenDescriptionGridClauseContext) IsScreenDescriptionGridClauseContext() {}

func NewScreenDescriptionGridClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionGridClauseContext {
	var p = new(ScreenDescriptionGridClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionGridClause

	return p
}

func (s *ScreenDescriptionGridClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionGridClauseContext) GRID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGRID, 0)
}

func (s *ScreenDescriptionGridClauseContext) LEFTLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFTLINE, 0)
}

func (s *ScreenDescriptionGridClauseContext) OVERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERLINE, 0)
}

func (s *ScreenDescriptionGridClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionGridClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionGridClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionGridClause(s)
	}
}

func (s *ScreenDescriptionGridClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionGridClause(s)
	}
}

func (s *ScreenDescriptionGridClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionGridClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionGridClause() (localctx IScreenDescriptionGridClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionGridClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, Cobol85ParserRULE_screenDescriptionGridClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2557)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserGRID || _la == Cobol85ParserLEFTLINE || _la == Cobol85ParserOVERLINE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionReverseVideoClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionReverseVideoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionReverseVideoClauseContext differentiates from other interfaces.
	IsScreenDescriptionReverseVideoClauseContext()
}

type ScreenDescriptionReverseVideoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionReverseVideoClauseContext() *ScreenDescriptionReverseVideoClauseContext {
	var p = new(ScreenDescriptionReverseVideoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionReverseVideoClause
	return p
}

func (*ScreenDescriptionReverseVideoClauseContext) IsScreenDescriptionReverseVideoClauseContext() {}

func NewScreenDescriptionReverseVideoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionReverseVideoClauseContext {
	var p = new(ScreenDescriptionReverseVideoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionReverseVideoClause

	return p
}

func (s *ScreenDescriptionReverseVideoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionReverseVideoClauseContext) REVERSE_VIDEO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSE_VIDEO, 0)
}

func (s *ScreenDescriptionReverseVideoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionReverseVideoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionReverseVideoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionReverseVideoClause(s)
	}
}

func (s *ScreenDescriptionReverseVideoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionReverseVideoClause(s)
	}
}

func (s *ScreenDescriptionReverseVideoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionReverseVideoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionReverseVideoClause() (localctx IScreenDescriptionReverseVideoClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionReverseVideoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, Cobol85ParserRULE_screenDescriptionReverseVideoClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2559)
		p.Match(Cobol85ParserREVERSE_VIDEO)
	}

	return localctx
}

// IScreenDescriptionUnderlineClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUnderlineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUnderlineClauseContext differentiates from other interfaces.
	IsScreenDescriptionUnderlineClauseContext()
}

type ScreenDescriptionUnderlineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUnderlineClauseContext() *ScreenDescriptionUnderlineClauseContext {
	var p = new(ScreenDescriptionUnderlineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUnderlineClause
	return p
}

func (*ScreenDescriptionUnderlineClauseContext) IsScreenDescriptionUnderlineClauseContext() {}

func NewScreenDescriptionUnderlineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUnderlineClauseContext {
	var p = new(ScreenDescriptionUnderlineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUnderlineClause

	return p
}

func (s *ScreenDescriptionUnderlineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUnderlineClauseContext) UNDERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNDERLINE, 0)
}

func (s *ScreenDescriptionUnderlineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUnderlineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUnderlineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUnderlineClause(s)
	}
}

func (s *ScreenDescriptionUnderlineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUnderlineClause(s)
	}
}

func (s *ScreenDescriptionUnderlineClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionUnderlineClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUnderlineClause() (localctx IScreenDescriptionUnderlineClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionUnderlineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, Cobol85ParserRULE_screenDescriptionUnderlineClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2561)
		p.Match(Cobol85ParserUNDERLINE)
	}

	return localctx
}

// IScreenDescriptionSizeClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSizeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSizeClauseContext differentiates from other interfaces.
	IsScreenDescriptionSizeClauseContext()
}

type ScreenDescriptionSizeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSizeClauseContext() *ScreenDescriptionSizeClauseContext {
	var p = new(ScreenDescriptionSizeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSizeClause
	return p
}

func (*ScreenDescriptionSizeClauseContext) IsScreenDescriptionSizeClauseContext() {}

func NewScreenDescriptionSizeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSizeClauseContext {
	var p = new(ScreenDescriptionSizeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSizeClause

	return p
}

func (s *ScreenDescriptionSizeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSizeClauseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *ScreenDescriptionSizeClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionSizeClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionSizeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionSizeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSizeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSizeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSizeClause(s)
	}
}

func (s *ScreenDescriptionSizeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSizeClause(s)
	}
}

func (s *ScreenDescriptionSizeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionSizeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSizeClause() (localctx IScreenDescriptionSizeClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionSizeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, Cobol85ParserRULE_screenDescriptionSizeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2563)
		p.Match(Cobol85ParserSIZE)
	}
	p.SetState(2565)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2564)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2569)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 271, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2567)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2568)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionLineClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionLineClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionLineClauseContext differentiates from other interfaces.
	IsScreenDescriptionLineClauseContext()
}

type ScreenDescriptionLineClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionLineClauseContext() *ScreenDescriptionLineClauseContext {
	var p = new(ScreenDescriptionLineClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLineClause
	return p
}

func (*ScreenDescriptionLineClauseContext) IsScreenDescriptionLineClauseContext() {}

func NewScreenDescriptionLineClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionLineClauseContext {
	var p = new(ScreenDescriptionLineClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionLineClause

	return p
}

func (s *ScreenDescriptionLineClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionLineClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ScreenDescriptionLineClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionLineClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionLineClauseContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ScreenDescriptionLineClauseContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *ScreenDescriptionLineClauseContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *ScreenDescriptionLineClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ScreenDescriptionLineClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionLineClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionLineClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionLineClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionLineClause(s)
	}
}

func (s *ScreenDescriptionLineClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionLineClause(s)
	}
}

func (s *ScreenDescriptionLineClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionLineClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionLineClause() (localctx IScreenDescriptionLineClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionLineClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, Cobol85ParserRULE_screenDescriptionLineClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2571)
		p.Match(Cobol85ParserLINE)
	}
	p.SetState(2579)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNUMBER {
			{
				p.SetState(2572)
				p.Match(Cobol85ParserNUMBER)
			}

		}
		p.SetState(2576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2575)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(2578)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2583)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 275, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2581)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2582)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionColumnClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionColumnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionColumnClauseContext differentiates from other interfaces.
	IsScreenDescriptionColumnClauseContext()
}

type ScreenDescriptionColumnClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionColumnClauseContext() *ScreenDescriptionColumnClauseContext {
	var p = new(ScreenDescriptionColumnClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionColumnClause
	return p
}

func (*ScreenDescriptionColumnClauseContext) IsScreenDescriptionColumnClauseContext() {}

func NewScreenDescriptionColumnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionColumnClauseContext {
	var p = new(ScreenDescriptionColumnClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionColumnClause

	return p
}

func (s *ScreenDescriptionColumnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionColumnClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLUMN, 0)
}

func (s *ScreenDescriptionColumnClauseContext) COL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOL, 0)
}

func (s *ScreenDescriptionColumnClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionColumnClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionColumnClauseContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ScreenDescriptionColumnClauseContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *ScreenDescriptionColumnClauseContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *ScreenDescriptionColumnClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ScreenDescriptionColumnClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionColumnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionColumnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionColumnClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionColumnClause(s)
	}
}

func (s *ScreenDescriptionColumnClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionColumnClause(s)
	}
}

func (s *ScreenDescriptionColumnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionColumnClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionColumnClause() (localctx IScreenDescriptionColumnClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionColumnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, Cobol85ParserRULE_screenDescriptionColumnClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2585)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCOL || _la == Cobol85ParserCOLUMN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS || _la == Cobol85ParserNUMBER || _la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		p.SetState(2587)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNUMBER {
			{
				p.SetState(2586)
				p.Match(Cobol85ParserNUMBER)
			}

		}
		p.SetState(2590)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2589)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(2592)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserPLUS || _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(2597)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 279, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2595)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2596)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionForegroundColorClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionForegroundColorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionForegroundColorClauseContext differentiates from other interfaces.
	IsScreenDescriptionForegroundColorClauseContext()
}

type ScreenDescriptionForegroundColorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionForegroundColorClauseContext() *ScreenDescriptionForegroundColorClauseContext {
	var p = new(ScreenDescriptionForegroundColorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionForegroundColorClause
	return p
}

func (*ScreenDescriptionForegroundColorClauseContext) IsScreenDescriptionForegroundColorClauseContext() {
}

func NewScreenDescriptionForegroundColorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionForegroundColorClauseContext {
	var p = new(ScreenDescriptionForegroundColorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionForegroundColorClause

	return p
}

func (s *ScreenDescriptionForegroundColorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionForegroundColorClauseContext) FOREGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOR, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) FOREGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOUR, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionForegroundColorClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionForegroundColorClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionForegroundColorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionForegroundColorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionForegroundColorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionForegroundColorClause(s)
	}
}

func (s *ScreenDescriptionForegroundColorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionForegroundColorClause(s)
	}
}

func (s *ScreenDescriptionForegroundColorClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionForegroundColorClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionForegroundColorClause() (localctx IScreenDescriptionForegroundColorClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionForegroundColorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, Cobol85ParserRULE_screenDescriptionForegroundColorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2599)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFOREGROUND_COLOR || _la == Cobol85ParserFOREGROUND_COLOUR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2601)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2600)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2605)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 281, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2603)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2604)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionBackgroundColorClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBackgroundColorClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBackgroundColorClauseContext differentiates from other interfaces.
	IsScreenDescriptionBackgroundColorClauseContext()
}

type ScreenDescriptionBackgroundColorClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBackgroundColorClauseContext() *ScreenDescriptionBackgroundColorClauseContext {
	var p = new(ScreenDescriptionBackgroundColorClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBackgroundColorClause
	return p
}

func (*ScreenDescriptionBackgroundColorClauseContext) IsScreenDescriptionBackgroundColorClauseContext() {
}

func NewScreenDescriptionBackgroundColorClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBackgroundColorClauseContext {
	var p = new(ScreenDescriptionBackgroundColorClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBackgroundColorClause

	return p
}

func (s *ScreenDescriptionBackgroundColorClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBackgroundColorClauseContext) BACKGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOR, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) BACKGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOUR, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBackgroundColorClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBackgroundColorClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBackgroundColorClause(s)
	}
}

func (s *ScreenDescriptionBackgroundColorClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBackgroundColorClause(s)
	}
}

func (s *ScreenDescriptionBackgroundColorClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBackgroundColorClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBackgroundColorClause() (localctx IScreenDescriptionBackgroundColorClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionBackgroundColorClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, Cobol85ParserRULE_screenDescriptionBackgroundColorClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2607)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBACKGROUND_COLOR || _la == Cobol85ParserBACKGROUND_COLOUR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2609)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2608)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 283, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2611)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2612)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IScreenDescriptionControlClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionControlClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionControlClauseContext differentiates from other interfaces.
	IsScreenDescriptionControlClauseContext()
}

type ScreenDescriptionControlClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionControlClauseContext() *ScreenDescriptionControlClauseContext {
	var p = new(ScreenDescriptionControlClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionControlClause
	return p
}

func (*ScreenDescriptionControlClauseContext) IsScreenDescriptionControlClauseContext() {}

func NewScreenDescriptionControlClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionControlClauseContext {
	var p = new(ScreenDescriptionControlClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionControlClause

	return p
}

func (s *ScreenDescriptionControlClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionControlClauseContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ScreenDescriptionControlClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionControlClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionControlClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionControlClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionControlClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionControlClause(s)
	}
}

func (s *ScreenDescriptionControlClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionControlClause(s)
	}
}

func (s *ScreenDescriptionControlClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionControlClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionControlClause() (localctx IScreenDescriptionControlClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionControlClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, Cobol85ParserRULE_screenDescriptionControlClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2615)
		p.Match(Cobol85ParserCONTROL)
	}
	p.SetState(2617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2616)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2619)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionValueClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionValueClauseContext differentiates from other interfaces.
	IsScreenDescriptionValueClauseContext()
}

type ScreenDescriptionValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionValueClauseContext() *ScreenDescriptionValueClauseContext {
	var p = new(ScreenDescriptionValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionValueClause
	return p
}

func (*ScreenDescriptionValueClauseContext) IsScreenDescriptionValueClauseContext() {}

func NewScreenDescriptionValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionValueClauseContext {
	var p = new(ScreenDescriptionValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionValueClause

	return p
}

func (s *ScreenDescriptionValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionValueClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ScreenDescriptionValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionValueClause(s)
	}
}

func (s *ScreenDescriptionValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionValueClause(s)
	}
}

func (s *ScreenDescriptionValueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionValueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionValueClause() (localctx IScreenDescriptionValueClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, Cobol85ParserRULE_screenDescriptionValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2621)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(2623)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2622)
			p.Match(Cobol85ParserIS)
		}

	}

	{
		p.SetState(2625)
		p.Literal()
	}

	return localctx
}

// IScreenDescriptionPictureClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPictureClauseContext differentiates from other interfaces.
	IsScreenDescriptionPictureClauseContext()
}

type ScreenDescriptionPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPictureClauseContext() *ScreenDescriptionPictureClauseContext {
	var p = new(ScreenDescriptionPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPictureClause
	return p
}

func (*ScreenDescriptionPictureClauseContext) IsScreenDescriptionPictureClauseContext() {}

func NewScreenDescriptionPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPictureClauseContext {
	var p = new(ScreenDescriptionPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPictureClause

	return p
}

func (s *ScreenDescriptionPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPictureClauseContext) PictureString() IPictureStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *ScreenDescriptionPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *ScreenDescriptionPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *ScreenDescriptionPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPictureClause(s)
	}
}

func (s *ScreenDescriptionPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPictureClause(s)
	}
}

func (s *ScreenDescriptionPictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPictureClause() (localctx IScreenDescriptionPictureClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, Cobol85ParserRULE_screenDescriptionPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2627)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2629)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2628)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2631)
		p.PictureString()
	}

	return localctx
}

// IScreenDescriptionFromClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionFromClauseContext differentiates from other interfaces.
	IsScreenDescriptionFromClauseContext()
}

type ScreenDescriptionFromClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionFromClauseContext() *ScreenDescriptionFromClauseContext {
	var p = new(ScreenDescriptionFromClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFromClause
	return p
}

func (*ScreenDescriptionFromClauseContext) IsScreenDescriptionFromClauseContext() {}

func NewScreenDescriptionFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionFromClauseContext {
	var p = new(ScreenDescriptionFromClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFromClause

	return p
}

func (s *ScreenDescriptionFromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionFromClauseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ScreenDescriptionFromClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionFromClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionFromClauseContext) ScreenDescriptionToClause() IScreenDescriptionToClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionToClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionToClauseContext)
}

func (s *ScreenDescriptionFromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionFromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionFromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionFromClause(s)
	}
}

func (s *ScreenDescriptionFromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionFromClause(s)
	}
}

func (s *ScreenDescriptionFromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionFromClause() (localctx IScreenDescriptionFromClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, Cobol85ParserRULE_screenDescriptionFromClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2633)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(2636)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 287, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2634)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2635)
			p.Literal()
		}

	}
	p.SetState(2639)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(2638)
			p.ScreenDescriptionToClause()
		}

	}

	return localctx
}

// IScreenDescriptionToClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionToClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionToClauseContext differentiates from other interfaces.
	IsScreenDescriptionToClauseContext()
}

type ScreenDescriptionToClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionToClauseContext() *ScreenDescriptionToClauseContext {
	var p = new(ScreenDescriptionToClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionToClause
	return p
}

func (*ScreenDescriptionToClauseContext) IsScreenDescriptionToClauseContext() {}

func NewScreenDescriptionToClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionToClauseContext {
	var p = new(ScreenDescriptionToClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionToClause

	return p
}

func (s *ScreenDescriptionToClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionToClauseContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *ScreenDescriptionToClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionToClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionToClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionToClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionToClause(s)
	}
}

func (s *ScreenDescriptionToClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionToClause(s)
	}
}

func (s *ScreenDescriptionToClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionToClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionToClause() (localctx IScreenDescriptionToClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionToClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, Cobol85ParserRULE_screenDescriptionToClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2641)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(2642)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionUsingClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUsingClauseContext differentiates from other interfaces.
	IsScreenDescriptionUsingClauseContext()
}

type ScreenDescriptionUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUsingClauseContext() *ScreenDescriptionUsingClauseContext {
	var p = new(ScreenDescriptionUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsingClause
	return p
}

func (*ScreenDescriptionUsingClauseContext) IsScreenDescriptionUsingClauseContext() {}

func NewScreenDescriptionUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUsingClauseContext {
	var p = new(ScreenDescriptionUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsingClause

	return p
}

func (s *ScreenDescriptionUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ScreenDescriptionUsingClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUsingClause(s)
	}
}

func (s *ScreenDescriptionUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUsingClause(s)
	}
}

func (s *ScreenDescriptionUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUsingClause() (localctx IScreenDescriptionUsingClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, Cobol85ParserRULE_screenDescriptionUsingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2644)
		p.Match(Cobol85ParserUSING)
	}
	{
		p.SetState(2645)
		p.Identifier()
	}

	return localctx
}

// IScreenDescriptionUsageClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionUsageClauseContext differentiates from other interfaces.
	IsScreenDescriptionUsageClauseContext()
}

type ScreenDescriptionUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionUsageClauseContext() *ScreenDescriptionUsageClauseContext {
	var p = new(ScreenDescriptionUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsageClause
	return p
}

func (*ScreenDescriptionUsageClauseContext) IsScreenDescriptionUsageClauseContext() {}

func NewScreenDescriptionUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionUsageClauseContext {
	var p = new(ScreenDescriptionUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionUsageClause

	return p
}

func (s *ScreenDescriptionUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *ScreenDescriptionUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *ScreenDescriptionUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *ScreenDescriptionUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionUsageClause(s)
	}
}

func (s *ScreenDescriptionUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionUsageClause(s)
	}
}

func (s *ScreenDescriptionUsageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionUsageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionUsageClause() (localctx IScreenDescriptionUsageClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, Cobol85ParserRULE_screenDescriptionUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2647)
		p.Match(Cobol85ParserUSAGE)
	}
	p.SetState(2649)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2648)
			p.Match(Cobol85ParserIS)
		}

	}

	{
		p.SetState(2651)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionBlankWhenZeroClauseContext differentiates from other interfaces.
	IsScreenDescriptionBlankWhenZeroClauseContext()
}

type ScreenDescriptionBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionBlankWhenZeroClauseContext() *ScreenDescriptionBlankWhenZeroClauseContext {
	var p = new(ScreenDescriptionBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause
	return p
}

func (*ScreenDescriptionBlankWhenZeroClauseContext) IsScreenDescriptionBlankWhenZeroClauseContext() {}

func NewScreenDescriptionBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionBlankWhenZeroClauseContext {
	var p = new(ScreenDescriptionBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause

	return p
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionBlankWhenZeroClause(s)
	}
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionBlankWhenZeroClause(s)
	}
}

func (s *ScreenDescriptionBlankWhenZeroClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionBlankWhenZeroClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionBlankWhenZeroClause() (localctx IScreenDescriptionBlankWhenZeroClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, Cobol85ParserRULE_screenDescriptionBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2653)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(2654)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(2657)
		p.Match(Cobol85ParserZERO)
	}

	return localctx
}

// IScreenDescriptionJustifiedClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionJustifiedClauseContext differentiates from other interfaces.
	IsScreenDescriptionJustifiedClauseContext()
}

type ScreenDescriptionJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionJustifiedClauseContext() *ScreenDescriptionJustifiedClauseContext {
	var p = new(ScreenDescriptionJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionJustifiedClause
	return p
}

func (*ScreenDescriptionJustifiedClauseContext) IsScreenDescriptionJustifiedClauseContext() {}

func NewScreenDescriptionJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionJustifiedClauseContext {
	var p = new(ScreenDescriptionJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionJustifiedClause

	return p
}

func (s *ScreenDescriptionJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *ScreenDescriptionJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionJustifiedClause(s)
	}
}

func (s *ScreenDescriptionJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionJustifiedClause(s)
	}
}

func (s *ScreenDescriptionJustifiedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionJustifiedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionJustifiedClause() (localctx IScreenDescriptionJustifiedClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, Cobol85ParserRULE_screenDescriptionJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2659)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2661)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(2660)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IScreenDescriptionSignClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSignClauseContext differentiates from other interfaces.
	IsScreenDescriptionSignClauseContext()
}

type ScreenDescriptionSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSignClauseContext() *ScreenDescriptionSignClauseContext {
	var p = new(ScreenDescriptionSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSignClause
	return p
}

func (*ScreenDescriptionSignClauseContext) IsScreenDescriptionSignClauseContext() {}

func NewScreenDescriptionSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSignClauseContext {
	var p = new(ScreenDescriptionSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSignClause

	return p
}

func (s *ScreenDescriptionSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *ScreenDescriptionSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *ScreenDescriptionSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *ScreenDescriptionSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *ScreenDescriptionSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ScreenDescriptionSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSignClause(s)
	}
}

func (s *ScreenDescriptionSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSignClause(s)
	}
}

func (s *ScreenDescriptionSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSignClause() (localctx IScreenDescriptionSignClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, Cobol85ParserRULE_screenDescriptionSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2667)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(2663)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(2665)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2664)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(2669)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2674)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(2670)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(2672)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(2671)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IScreenDescriptionAutoClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionAutoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionAutoClauseContext differentiates from other interfaces.
	IsScreenDescriptionAutoClauseContext()
}

type ScreenDescriptionAutoClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionAutoClauseContext() *ScreenDescriptionAutoClauseContext {
	var p = new(ScreenDescriptionAutoClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionAutoClause
	return p
}

func (*ScreenDescriptionAutoClauseContext) IsScreenDescriptionAutoClauseContext() {}

func NewScreenDescriptionAutoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionAutoClauseContext {
	var p = new(ScreenDescriptionAutoClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionAutoClause

	return p
}

func (s *ScreenDescriptionAutoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionAutoClauseContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO, 0)
}

func (s *ScreenDescriptionAutoClauseContext) AUTO_SKIP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO_SKIP, 0)
}

func (s *ScreenDescriptionAutoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionAutoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionAutoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionAutoClause(s)
	}
}

func (s *ScreenDescriptionAutoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionAutoClause(s)
	}
}

func (s *ScreenDescriptionAutoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionAutoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionAutoClause() (localctx IScreenDescriptionAutoClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionAutoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, Cobol85ParserRULE_screenDescriptionAutoClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2676)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAUTO || _la == Cobol85ParserAUTO_SKIP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionSecureClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionSecureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionSecureClauseContext differentiates from other interfaces.
	IsScreenDescriptionSecureClauseContext()
}

type ScreenDescriptionSecureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionSecureClauseContext() *ScreenDescriptionSecureClauseContext {
	var p = new(ScreenDescriptionSecureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSecureClause
	return p
}

func (*ScreenDescriptionSecureClauseContext) IsScreenDescriptionSecureClauseContext() {}

func NewScreenDescriptionSecureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionSecureClauseContext {
	var p = new(ScreenDescriptionSecureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionSecureClause

	return p
}

func (s *ScreenDescriptionSecureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionSecureClauseContext) SECURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURE, 0)
}

func (s *ScreenDescriptionSecureClauseContext) NO_ECHO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO_ECHO, 0)
}

func (s *ScreenDescriptionSecureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionSecureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionSecureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionSecureClause(s)
	}
}

func (s *ScreenDescriptionSecureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionSecureClause(s)
	}
}

func (s *ScreenDescriptionSecureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionSecureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionSecureClause() (localctx IScreenDescriptionSecureClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionSecureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, Cobol85ParserRULE_screenDescriptionSecureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2678)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserNO_ECHO || _la == Cobol85ParserSECURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionRequiredClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionRequiredClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionRequiredClauseContext differentiates from other interfaces.
	IsScreenDescriptionRequiredClauseContext()
}

type ScreenDescriptionRequiredClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionRequiredClauseContext() *ScreenDescriptionRequiredClauseContext {
	var p = new(ScreenDescriptionRequiredClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionRequiredClause
	return p
}

func (*ScreenDescriptionRequiredClauseContext) IsScreenDescriptionRequiredClauseContext() {}

func NewScreenDescriptionRequiredClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionRequiredClauseContext {
	var p = new(ScreenDescriptionRequiredClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionRequiredClause

	return p
}

func (s *ScreenDescriptionRequiredClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionRequiredClauseContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREQUIRED, 0)
}

func (s *ScreenDescriptionRequiredClauseContext) EMPTY_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMPTY_CHECK, 0)
}

func (s *ScreenDescriptionRequiredClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionRequiredClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionRequiredClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionRequiredClause(s)
	}
}

func (s *ScreenDescriptionRequiredClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionRequiredClause(s)
	}
}

func (s *ScreenDescriptionRequiredClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionRequiredClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionRequiredClause() (localctx IScreenDescriptionRequiredClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionRequiredClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, Cobol85ParserRULE_screenDescriptionRequiredClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2680)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEMPTY_CHECK || _la == Cobol85ParserREQUIRED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionPromptClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPromptClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPromptClauseContext differentiates from other interfaces.
	IsScreenDescriptionPromptClauseContext()
}

type ScreenDescriptionPromptClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPromptClauseContext() *ScreenDescriptionPromptClauseContext {
	var p = new(ScreenDescriptionPromptClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptClause
	return p
}

func (*ScreenDescriptionPromptClauseContext) IsScreenDescriptionPromptClauseContext() {}

func NewScreenDescriptionPromptClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPromptClauseContext {
	var p = new(ScreenDescriptionPromptClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptClause

	return p
}

func (s *ScreenDescriptionPromptClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPromptClauseContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROMPT, 0)
}

func (s *ScreenDescriptionPromptClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ScreenDescriptionPromptClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ScreenDescriptionPromptClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ScreenDescriptionPromptClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ScreenDescriptionPromptClauseContext) ScreenDescriptionPromptOccursClause() IScreenDescriptionPromptOccursClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IScreenDescriptionPromptOccursClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IScreenDescriptionPromptOccursClauseContext)
}

func (s *ScreenDescriptionPromptClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPromptClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPromptClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPromptClause(s)
	}
}

func (s *ScreenDescriptionPromptClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPromptClause(s)
	}
}

func (s *ScreenDescriptionPromptClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionPromptClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPromptClause() (localctx IScreenDescriptionPromptClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionPromptClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, Cobol85ParserRULE_screenDescriptionPromptClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2682)
		p.Match(Cobol85ParserPROMPT)
	}
	p.SetState(2684)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(2683)
			p.Match(Cobol85ParserCHARACTER)
		}

	}
	p.SetState(2687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2686)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2691)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 298, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2689)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(2690)
			p.Literal()
		}

	}
	p.SetState(2694)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOCCURS {
		{
			p.SetState(2693)
			p.ScreenDescriptionPromptOccursClause()
		}

	}

	return localctx
}

// IScreenDescriptionPromptOccursClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionPromptOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionPromptOccursClauseContext differentiates from other interfaces.
	IsScreenDescriptionPromptOccursClauseContext()
}

type ScreenDescriptionPromptOccursClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionPromptOccursClauseContext() *ScreenDescriptionPromptOccursClauseContext {
	var p = new(ScreenDescriptionPromptOccursClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptOccursClause
	return p
}

func (*ScreenDescriptionPromptOccursClauseContext) IsScreenDescriptionPromptOccursClauseContext() {}

func NewScreenDescriptionPromptOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionPromptOccursClauseContext {
	var p = new(ScreenDescriptionPromptOccursClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionPromptOccursClause

	return p
}

func (s *ScreenDescriptionPromptOccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionPromptOccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *ScreenDescriptionPromptOccursClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ScreenDescriptionPromptOccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *ScreenDescriptionPromptOccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionPromptOccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionPromptOccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionPromptOccursClause(s)
	}
}

func (s *ScreenDescriptionPromptOccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionPromptOccursClause(s)
	}
}

func (s *ScreenDescriptionPromptOccursClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionPromptOccursClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionPromptOccursClause() (localctx IScreenDescriptionPromptOccursClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionPromptOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, Cobol85ParserRULE_screenDescriptionPromptOccursClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2696)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(2697)
		p.IntegerLiteral()
	}
	p.SetState(2699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTIMES {
		{
			p.SetState(2698)
			p.Match(Cobol85ParserTIMES)
		}

	}

	return localctx
}

// IScreenDescriptionFullClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionFullClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionFullClauseContext differentiates from other interfaces.
	IsScreenDescriptionFullClauseContext()
}

type ScreenDescriptionFullClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionFullClauseContext() *ScreenDescriptionFullClauseContext {
	var p = new(ScreenDescriptionFullClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFullClause
	return p
}

func (*ScreenDescriptionFullClauseContext) IsScreenDescriptionFullClauseContext() {}

func NewScreenDescriptionFullClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionFullClauseContext {
	var p = new(ScreenDescriptionFullClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionFullClause

	return p
}

func (s *ScreenDescriptionFullClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionFullClauseContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *ScreenDescriptionFullClauseContext) LENGTH_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH_CHECK, 0)
}

func (s *ScreenDescriptionFullClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionFullClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionFullClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionFullClause(s)
	}
}

func (s *ScreenDescriptionFullClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionFullClause(s)
	}
}

func (s *ScreenDescriptionFullClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionFullClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionFullClause() (localctx IScreenDescriptionFullClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionFullClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, Cobol85ParserRULE_screenDescriptionFullClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2701)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFULL || _la == Cobol85ParserLENGTH_CHECK) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IScreenDescriptionZeroFillClauseContext is an interface to support dynamic dispatch.
type IScreenDescriptionZeroFillClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenDescriptionZeroFillClauseContext differentiates from other interfaces.
	IsScreenDescriptionZeroFillClauseContext()
}

type ScreenDescriptionZeroFillClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenDescriptionZeroFillClauseContext() *ScreenDescriptionZeroFillClauseContext {
	var p = new(ScreenDescriptionZeroFillClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionZeroFillClause
	return p
}

func (*ScreenDescriptionZeroFillClauseContext) IsScreenDescriptionZeroFillClauseContext() {}

func NewScreenDescriptionZeroFillClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenDescriptionZeroFillClauseContext {
	var p = new(ScreenDescriptionZeroFillClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenDescriptionZeroFillClause

	return p
}

func (s *ScreenDescriptionZeroFillClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenDescriptionZeroFillClauseContext) ZERO_FILL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO_FILL, 0)
}

func (s *ScreenDescriptionZeroFillClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenDescriptionZeroFillClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenDescriptionZeroFillClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenDescriptionZeroFillClause(s)
	}
}

func (s *ScreenDescriptionZeroFillClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenDescriptionZeroFillClause(s)
	}
}

func (s *ScreenDescriptionZeroFillClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenDescriptionZeroFillClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenDescriptionZeroFillClause() (localctx IScreenDescriptionZeroFillClauseContext) {
	this := p
	_ = this

	localctx = NewScreenDescriptionZeroFillClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, Cobol85ParserRULE_screenDescriptionZeroFillClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2703)
		p.Match(Cobol85ParserZERO_FILL)
	}

	return localctx
}

// IReportSectionContext is an interface to support dynamic dispatch.
type IReportSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportSectionContext differentiates from other interfaces.
	IsReportSectionContext()
}

type ReportSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportSectionContext() *ReportSectionContext {
	var p = new(ReportSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportSection
	return p
}

func (*ReportSectionContext) IsReportSectionContext() {}

func NewReportSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportSectionContext {
	var p = new(ReportSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportSection

	return p
}

func (s *ReportSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportSectionContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportSectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ReportSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportSectionContext) AllReportDescription() []IReportDescriptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportDescriptionContext); ok {
			len++
		}
	}

	tst := make([]IReportDescriptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportDescriptionContext); ok {
			tst[i] = t.(IReportDescriptionContext)
			i++
		}
	}

	return tst
}

func (s *ReportSectionContext) ReportDescription(i int) IReportDescriptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionContext)
}

func (s *ReportSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportSection(s)
	}
}

func (s *ReportSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportSection(s)
	}
}

func (s *ReportSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportSection() (localctx IReportSectionContext) {
	this := p
	_ = this

	localctx = NewReportSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, Cobol85ParserRULE_reportSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2705)
		p.Match(Cobol85ParserREPORT)
	}
	{
		p.SetState(2706)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(2707)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(2711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserRD {
		{
			p.SetState(2708)
			p.ReportDescription()
		}

		p.SetState(2713)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReportDescriptionContext is an interface to support dynamic dispatch.
type IReportDescriptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionContext differentiates from other interfaces.
	IsReportDescriptionContext()
}

type ReportDescriptionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionContext() *ReportDescriptionContext {
	var p = new(ReportDescriptionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescription
	return p
}

func (*ReportDescriptionContext) IsReportDescriptionContext() {}

func NewReportDescriptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionContext {
	var p = new(ReportDescriptionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescription

	return p
}

func (s *ReportDescriptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionContext) ReportDescriptionEntry() IReportDescriptionEntryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionEntryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionEntryContext)
}

func (s *ReportDescriptionContext) AllReportGroupDescriptionEntry() []IReportGroupDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupDescriptionEntryContext); ok {
			tst[i] = t.(IReportGroupDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *ReportDescriptionContext) ReportGroupDescriptionEntry(i int) IReportGroupDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryContext)
}

func (s *ReportDescriptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescription(s)
	}
}

func (s *ReportDescriptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescription(s)
	}
}

func (s *ReportDescriptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescription(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescription() (localctx IReportDescriptionContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, Cobol85ParserRULE_reportDescription)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2714)
		p.ReportDescriptionEntry()
	}
	p.SetState(2716)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		{
			p.SetState(2715)
			p.ReportGroupDescriptionEntry()
		}

		p.SetState(2718)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReportDescriptionEntryContext is an interface to support dynamic dispatch.
type IReportDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionEntryContext differentiates from other interfaces.
	IsReportDescriptionEntryContext()
}

type ReportDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionEntryContext() *ReportDescriptionEntryContext {
	var p = new(ReportDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionEntry
	return p
}

func (*ReportDescriptionEntryContext) IsReportDescriptionEntryContext() {}

func NewReportDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionEntryContext {
	var p = new(ReportDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionEntry

	return p
}

func (s *ReportDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionEntryContext) RD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRD, 0)
}

func (s *ReportDescriptionEntryContext) ReportName() IReportNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *ReportDescriptionEntryContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionGlobalClause() IReportDescriptionGlobalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionGlobalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionGlobalClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionPageLimitClause() IReportDescriptionPageLimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionPageLimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionPageLimitClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionHeadingClause() IReportDescriptionHeadingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionHeadingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionHeadingClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionFirstDetailClause() IReportDescriptionFirstDetailClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionFirstDetailClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionFirstDetailClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionLastDetailClause() IReportDescriptionLastDetailClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionLastDetailClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionLastDetailClauseContext)
}

func (s *ReportDescriptionEntryContext) ReportDescriptionFootingClause() IReportDescriptionFootingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportDescriptionFootingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportDescriptionFootingClauseContext)
}

func (s *ReportDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionEntry(s)
	}
}

func (s *ReportDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionEntry(s)
	}
}

func (s *ReportDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionEntry() (localctx IReportDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, Cobol85ParserRULE_reportDescriptionEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2720)
		p.Match(Cobol85ParserRD)
	}
	{
		p.SetState(2721)
		p.ReportName()
	}
	p.SetState(2723)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGLOBAL || _la == Cobol85ParserIS {
		{
			p.SetState(2722)
			p.ReportDescriptionGlobalClause()
		}

	}
	p.SetState(2738)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPAGE {
		{
			p.SetState(2725)
			p.ReportDescriptionPageLimitClause()
		}
		p.SetState(2727)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserHEADING {
			{
				p.SetState(2726)
				p.ReportDescriptionHeadingClause()
			}

		}
		p.SetState(2730)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFIRST {
			{
				p.SetState(2729)
				p.ReportDescriptionFirstDetailClause()
			}

		}
		p.SetState(2733)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserLAST {
			{
				p.SetState(2732)
				p.ReportDescriptionLastDetailClause()
			}

		}
		p.SetState(2736)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOOTING {
			{
				p.SetState(2735)
				p.ReportDescriptionFootingClause()
			}

		}

	}
	{
		p.SetState(2740)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportDescriptionGlobalClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionGlobalClauseContext differentiates from other interfaces.
	IsReportDescriptionGlobalClauseContext()
}

type ReportDescriptionGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionGlobalClauseContext() *ReportDescriptionGlobalClauseContext {
	var p = new(ReportDescriptionGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionGlobalClause
	return p
}

func (*ReportDescriptionGlobalClauseContext) IsReportDescriptionGlobalClauseContext() {}

func NewReportDescriptionGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionGlobalClauseContext {
	var p = new(ReportDescriptionGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionGlobalClause

	return p
}

func (s *ReportDescriptionGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *ReportDescriptionGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportDescriptionGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionGlobalClause(s)
	}
}

func (s *ReportDescriptionGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionGlobalClause(s)
	}
}

func (s *ReportDescriptionGlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionGlobalClause() (localctx IReportDescriptionGlobalClauseContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, Cobol85ParserRULE_reportDescriptionGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2742)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2745)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IReportDescriptionPageLimitClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionPageLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionPageLimitClauseContext differentiates from other interfaces.
	IsReportDescriptionPageLimitClauseContext()
}

type ReportDescriptionPageLimitClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionPageLimitClauseContext() *ReportDescriptionPageLimitClauseContext {
	var p = new(ReportDescriptionPageLimitClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionPageLimitClause
	return p
}

func (*ReportDescriptionPageLimitClauseContext) IsReportDescriptionPageLimitClauseContext() {}

func NewReportDescriptionPageLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionPageLimitClauseContext {
	var p = new(ReportDescriptionPageLimitClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionPageLimitClause

	return p
}

func (s *ReportDescriptionPageLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionPageLimitClauseContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionPageLimitClauseContext) LIMIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIMIT, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LIMITS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIMITS, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *ReportDescriptionPageLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionPageLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionPageLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionPageLimitClause(s)
	}
}

func (s *ReportDescriptionPageLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionPageLimitClause(s)
	}
}

func (s *ReportDescriptionPageLimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionPageLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionPageLimitClause() (localctx IReportDescriptionPageLimitClauseContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionPageLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, Cobol85ParserRULE_reportDescriptionPageLimitClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2747)
		p.Match(Cobol85ParserPAGE)
	}
	p.SetState(2756)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLIMIT:
		{
			p.SetState(2748)
			p.Match(Cobol85ParserLIMIT)
		}
		p.SetState(2750)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2749)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserLIMITS:
		{
			p.SetState(2752)
			p.Match(Cobol85ParserLIMITS)
		}
		p.SetState(2754)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(2753)
				p.Match(Cobol85ParserARE)
			}

		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:

	default:
	}
	{
		p.SetState(2758)
		p.IntegerLiteral()
	}
	p.SetState(2760)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		{
			p.SetState(2759)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IReportDescriptionHeadingClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionHeadingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionHeadingClauseContext differentiates from other interfaces.
	IsReportDescriptionHeadingClauseContext()
}

type ReportDescriptionHeadingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionHeadingClauseContext() *ReportDescriptionHeadingClauseContext {
	var p = new(ReportDescriptionHeadingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionHeadingClause
	return p
}

func (*ReportDescriptionHeadingClauseContext) IsReportDescriptionHeadingClauseContext() {}

func NewReportDescriptionHeadingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionHeadingClauseContext {
	var p = new(ReportDescriptionHeadingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionHeadingClause

	return p
}

func (s *ReportDescriptionHeadingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionHeadingClauseContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportDescriptionHeadingClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionHeadingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionHeadingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionHeadingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionHeadingClause(s)
	}
}

func (s *ReportDescriptionHeadingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionHeadingClause(s)
	}
}

func (s *ReportDescriptionHeadingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionHeadingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionHeadingClause() (localctx IReportDescriptionHeadingClauseContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionHeadingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, Cobol85ParserRULE_reportDescriptionHeadingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2762)
		p.Match(Cobol85ParserHEADING)
	}
	{
		p.SetState(2763)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionFirstDetailClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionFirstDetailClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionFirstDetailClauseContext differentiates from other interfaces.
	IsReportDescriptionFirstDetailClauseContext()
}

type ReportDescriptionFirstDetailClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionFirstDetailClauseContext() *ReportDescriptionFirstDetailClauseContext {
	var p = new(ReportDescriptionFirstDetailClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFirstDetailClause
	return p
}

func (*ReportDescriptionFirstDetailClauseContext) IsReportDescriptionFirstDetailClauseContext() {}

func NewReportDescriptionFirstDetailClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionFirstDetailClauseContext {
	var p = new(ReportDescriptionFirstDetailClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFirstDetailClause

	return p
}

func (s *ReportDescriptionFirstDetailClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionFirstDetailClauseContext) FIRST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFIRST, 0)
}

func (s *ReportDescriptionFirstDetailClauseContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportDescriptionFirstDetailClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionFirstDetailClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionFirstDetailClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionFirstDetailClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionFirstDetailClause(s)
	}
}

func (s *ReportDescriptionFirstDetailClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionFirstDetailClause(s)
	}
}

func (s *ReportDescriptionFirstDetailClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionFirstDetailClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionFirstDetailClause() (localctx IReportDescriptionFirstDetailClauseContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionFirstDetailClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, Cobol85ParserRULE_reportDescriptionFirstDetailClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2765)
		p.Match(Cobol85ParserFIRST)
	}
	{
		p.SetState(2766)
		p.Match(Cobol85ParserDETAIL)
	}
	{
		p.SetState(2767)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionLastDetailClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionLastDetailClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionLastDetailClauseContext differentiates from other interfaces.
	IsReportDescriptionLastDetailClauseContext()
}

type ReportDescriptionLastDetailClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionLastDetailClauseContext() *ReportDescriptionLastDetailClauseContext {
	var p = new(ReportDescriptionLastDetailClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionLastDetailClause
	return p
}

func (*ReportDescriptionLastDetailClauseContext) IsReportDescriptionLastDetailClauseContext() {}

func NewReportDescriptionLastDetailClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionLastDetailClauseContext {
	var p = new(ReportDescriptionLastDetailClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionLastDetailClause

	return p
}

func (s *ReportDescriptionLastDetailClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionLastDetailClauseContext) LAST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLAST, 0)
}

func (s *ReportDescriptionLastDetailClauseContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportDescriptionLastDetailClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionLastDetailClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionLastDetailClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionLastDetailClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionLastDetailClause(s)
	}
}

func (s *ReportDescriptionLastDetailClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionLastDetailClause(s)
	}
}

func (s *ReportDescriptionLastDetailClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionLastDetailClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionLastDetailClause() (localctx IReportDescriptionLastDetailClauseContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionLastDetailClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, Cobol85ParserRULE_reportDescriptionLastDetailClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2769)
		p.Match(Cobol85ParserLAST)
	}
	{
		p.SetState(2770)
		p.Match(Cobol85ParserDETAIL)
	}
	{
		p.SetState(2771)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportDescriptionFootingClauseContext is an interface to support dynamic dispatch.
type IReportDescriptionFootingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportDescriptionFootingClauseContext differentiates from other interfaces.
	IsReportDescriptionFootingClauseContext()
}

type ReportDescriptionFootingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportDescriptionFootingClauseContext() *ReportDescriptionFootingClauseContext {
	var p = new(ReportDescriptionFootingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFootingClause
	return p
}

func (*ReportDescriptionFootingClauseContext) IsReportDescriptionFootingClauseContext() {}

func NewReportDescriptionFootingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportDescriptionFootingClauseContext {
	var p = new(ReportDescriptionFootingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportDescriptionFootingClause

	return p
}

func (s *ReportDescriptionFootingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportDescriptionFootingClauseContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportDescriptionFootingClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportDescriptionFootingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportDescriptionFootingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportDescriptionFootingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportDescriptionFootingClause(s)
	}
}

func (s *ReportDescriptionFootingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportDescriptionFootingClause(s)
	}
}

func (s *ReportDescriptionFootingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportDescriptionFootingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportDescriptionFootingClause() (localctx IReportDescriptionFootingClauseContext) {
	this := p
	_ = this

	localctx = NewReportDescriptionFootingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, Cobol85ParserRULE_reportDescriptionFootingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2773)
		p.Match(Cobol85ParserFOOTING)
	}
	{
		p.SetState(2774)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupDescriptionEntryContext is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryContext differentiates from other interfaces.
	IsReportGroupDescriptionEntryContext()
}

type ReportGroupDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryContext() *ReportGroupDescriptionEntryContext {
	var p = new(ReportGroupDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntry
	return p
}

func (*ReportGroupDescriptionEntryContext) IsReportGroupDescriptionEntryContext() {}

func NewReportGroupDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryContext {
	var p = new(ReportGroupDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntry

	return p
}

func (s *ReportGroupDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat1() IReportGroupDescriptionEntryFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupDescriptionEntryFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat1Context)
}

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat2() IReportGroupDescriptionEntryFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupDescriptionEntryFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat2Context)
}

func (s *ReportGroupDescriptionEntryContext) ReportGroupDescriptionEntryFormat3() IReportGroupDescriptionEntryFormat3Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupDescriptionEntryFormat3Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupDescriptionEntryFormat3Context)
}

func (s *ReportGroupDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntry(s)
	}
}

func (s *ReportGroupDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntry(s)
	}
}

func (s *ReportGroupDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntry() (localctx IReportGroupDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewReportGroupDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, Cobol85ParserRULE_reportGroupDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2779)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 314, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2776)
			p.ReportGroupDescriptionEntryFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2777)
			p.ReportGroupDescriptionEntryFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2778)
			p.ReportGroupDescriptionEntryFormat3()
		}

	}

	return localctx
}

// IReportGroupDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat1Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat1Context()
}

type ReportGroupDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat1Context() *ReportGroupDescriptionEntryFormat1Context {
	var p = new(ReportGroupDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat1
	return p
}

func (*ReportGroupDescriptionEntryFormat1Context) IsReportGroupDescriptionEntryFormat1Context() {}

func NewReportGroupDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat1Context {
	var p = new(ReportGroupDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat1

	return p
}

func (s *ReportGroupDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat1Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupTypeClause() IReportGroupTypeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupLineNumberClause() IReportGroupLineNumberClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupLineNumberClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupNextGroupClause() IReportGroupNextGroupClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupNextGroupClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) ReportGroupUsageClause() IReportGroupUsageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupUsageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat1(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat1(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat1() (localctx IReportGroupDescriptionEntryFormat1Context) {
	this := p
	_ = this

	localctx = NewReportGroupDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, Cobol85ParserRULE_reportGroupDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2781)
		p.IntegerLiteral()
	}
	{
		p.SetState(2782)
		p.DataName()
	}
	p.SetState(2784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-254)) & ^0x3f) == 0 && ((int64(1)<<(_la-254))&2305843009247248385) != 0 || _la == Cobol85ParserPLUS || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		{
			p.SetState(2783)
			p.ReportGroupLineNumberClause()
		}

	}
	p.SetState(2787)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNEXT {
		{
			p.SetState(2786)
			p.ReportGroupNextGroupClause()
		}

	}
	{
		p.SetState(2789)
		p.ReportGroupTypeClause()
	}
	p.SetState(2791)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1 || _la == Cobol85ParserUSAGE {
		{
			p.SetState(2790)
			p.ReportGroupUsageClause()
		}

	}
	{
		p.SetState(2793)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat2Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat2Context()
}

type ReportGroupDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat2Context() *ReportGroupDescriptionEntryFormat2Context {
	var p = new(ReportGroupDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat2
	return p
}

func (*ReportGroupDescriptionEntryFormat2Context) IsReportGroupDescriptionEntryFormat2Context() {}

func NewReportGroupDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat2Context {
	var p = new(ReportGroupDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat2

	return p
}

func (s *ReportGroupDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat2Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) ReportGroupUsageClause() IReportGroupUsageClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupUsageClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat2Context) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) ReportGroupLineNumberClause() IReportGroupLineNumberClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupLineNumberClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat2(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat2(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat2() (localctx IReportGroupDescriptionEntryFormat2Context) {
	this := p
	_ = this

	localctx = NewReportGroupDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, Cobol85ParserRULE_reportGroupDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2795)
		p.IntegerLiteral()
	}
	p.SetState(2797)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2796)
			p.DataName()
		}

	}
	p.SetState(2800)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-254)) & ^0x3f) == 0 && ((int64(1)<<(_la-254))&2305843009247248385) != 0 || _la == Cobol85ParserPLUS || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		{
			p.SetState(2799)
			p.ReportGroupLineNumberClause()
		}

	}
	{
		p.SetState(2802)
		p.ReportGroupUsageClause()
	}
	{
		p.SetState(2803)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type IReportGroupDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupDescriptionEntryFormat3Context differentiates from other interfaces.
	IsReportGroupDescriptionEntryFormat3Context()
}

type ReportGroupDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupDescriptionEntryFormat3Context() *ReportGroupDescriptionEntryFormat3Context {
	var p = new(ReportGroupDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat3
	return p
}

func (*ReportGroupDescriptionEntryFormat3Context) IsReportGroupDescriptionEntryFormat3Context() {}

func NewReportGroupDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupDescriptionEntryFormat3Context {
	var p = new(ReportGroupDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupDescriptionEntryFormat3

	return p
}

func (s *ReportGroupDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupDescriptionEntryFormat3Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ReportGroupDescriptionEntryFormat3Context) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupPictureClause() []IReportGroupPictureClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupPictureClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupPictureClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupPictureClauseContext); ok {
			tst[i] = t.(IReportGroupPictureClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupPictureClause(i int) IReportGroupPictureClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupPictureClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupPictureClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupUsageClause() []IReportGroupUsageClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupUsageClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupUsageClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupUsageClauseContext); ok {
			tst[i] = t.(IReportGroupUsageClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupUsageClause(i int) IReportGroupUsageClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupUsageClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupUsageClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSignClause() []IReportGroupSignClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupSignClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupSignClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupSignClauseContext); ok {
			tst[i] = t.(IReportGroupSignClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSignClause(i int) IReportGroupSignClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupSignClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupSignClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupJustifiedClause() []IReportGroupJustifiedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupJustifiedClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupJustifiedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupJustifiedClauseContext); ok {
			tst[i] = t.(IReportGroupJustifiedClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupJustifiedClause(i int) IReportGroupJustifiedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupJustifiedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupJustifiedClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupBlankWhenZeroClause() []IReportGroupBlankWhenZeroClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupBlankWhenZeroClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupBlankWhenZeroClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupBlankWhenZeroClauseContext); ok {
			tst[i] = t.(IReportGroupBlankWhenZeroClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupBlankWhenZeroClause(i int) IReportGroupBlankWhenZeroClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupBlankWhenZeroClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupBlankWhenZeroClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupLineNumberClause() []IReportGroupLineNumberClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupLineNumberClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupLineNumberClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupLineNumberClauseContext); ok {
			tst[i] = t.(IReportGroupLineNumberClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupLineNumberClause(i int) IReportGroupLineNumberClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupLineNumberClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupColumnNumberClause() []IReportGroupColumnNumberClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupColumnNumberClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupColumnNumberClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupColumnNumberClauseContext); ok {
			tst[i] = t.(IReportGroupColumnNumberClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupColumnNumberClause(i int) IReportGroupColumnNumberClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupColumnNumberClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupColumnNumberClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupIndicateClause() []IReportGroupIndicateClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupIndicateClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupIndicateClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupIndicateClauseContext); ok {
			tst[i] = t.(IReportGroupIndicateClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupIndicateClause(i int) IReportGroupIndicateClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupIndicateClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupIndicateClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSourceClause() []IReportGroupSourceClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupSourceClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupSourceClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupSourceClauseContext); ok {
			tst[i] = t.(IReportGroupSourceClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSourceClause(i int) IReportGroupSourceClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupSourceClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupSourceClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupValueClause() []IReportGroupValueClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupValueClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupValueClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupValueClauseContext); ok {
			tst[i] = t.(IReportGroupValueClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupValueClause(i int) IReportGroupValueClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupValueClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupValueClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupSumClause() []IReportGroupSumClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupSumClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupSumClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupSumClauseContext); ok {
			tst[i] = t.(IReportGroupSumClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupSumClause(i int) IReportGroupSumClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupSumClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupSumClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) AllReportGroupResetClause() []IReportGroupResetClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportGroupResetClauseContext); ok {
			len++
		}
	}

	tst := make([]IReportGroupResetClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportGroupResetClauseContext); ok {
			tst[i] = t.(IReportGroupResetClauseContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupDescriptionEntryFormat3Context) ReportGroupResetClause(i int) IReportGroupResetClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupResetClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupResetClauseContext)
}

func (s *ReportGroupDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupDescriptionEntryFormat3(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupDescriptionEntryFormat3(s)
	}
}

func (s *ReportGroupDescriptionEntryFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupDescriptionEntryFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupDescriptionEntryFormat3() (localctx IReportGroupDescriptionEntryFormat3Context) {
	this := p
	_ = this

	localctx = NewReportGroupDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, Cobol85ParserRULE_reportGroupDescriptionEntryFormat3)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2805)
		p.IntegerLiteral()
	}
	p.SetState(2807)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(2806)
			p.DataName()
		}

	}
	p.SetState(2825)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserBLANK || _la == Cobol85ParserCOLUMN || _la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1 || (int64((_la-227)) & ^0x3f) == 0 && ((int64(1)<<(_la-227))&4503600566894593) != 0 || (int64((_la-315)) & ^0x3f) == 0 && ((int64(1)<<(_la-315))&15032385537) != 0 || (int64((_la-402)) & ^0x3f) == 0 && ((int64(1)<<(_la-402))&4611756455891042305) != 0 || (int64((_la-504)) & ^0x3f) == 0 && ((int64(1)<<(_la-504))&4222124650659849) != 0 {
		p.SetState(2823)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserPIC, Cobol85ParserPICTURE:
			{
				p.SetState(2809)
				p.ReportGroupPictureClause()
			}

		case Cobol85ParserDISPLAY, Cobol85ParserDISPLAY_1, Cobol85ParserUSAGE:
			{
				p.SetState(2810)
				p.ReportGroupUsageClause()
			}

		case Cobol85ParserSIGN:
			{
				p.SetState(2811)
				p.ReportGroupSignClause()
			}

		case Cobol85ParserJUST, Cobol85ParserJUSTIFIED:
			{
				p.SetState(2812)
				p.ReportGroupJustifiedClause()
			}

		case Cobol85ParserBLANK:
			{
				p.SetState(2813)
				p.ReportGroupBlankWhenZeroClause()
			}

		case Cobol85ParserIS, Cobol85ParserLINE, Cobol85ParserNUMBER, Cobol85ParserPLUS, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
			{
				p.SetState(2814)
				p.ReportGroupLineNumberClause()
			}

		case Cobol85ParserCOLUMN:
			{
				p.SetState(2815)
				p.ReportGroupColumnNumberClause()
			}

		case Cobol85ParserRESET, Cobol85ParserSOURCE, Cobol85ParserSUM, Cobol85ParserVALUE:
			p.SetState(2820)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserSOURCE:
				{
					p.SetState(2816)
					p.ReportGroupSourceClause()
				}

			case Cobol85ParserVALUE:
				{
					p.SetState(2817)
					p.ReportGroupValueClause()
				}

			case Cobol85ParserSUM:
				{
					p.SetState(2818)
					p.ReportGroupSumClause()
				}

			case Cobol85ParserRESET:
				{
					p.SetState(2819)
					p.ReportGroupResetClause()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		case Cobol85ParserGROUP:
			{
				p.SetState(2822)
				p.ReportGroupIndicateClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(2827)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(2828)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IReportGroupBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IReportGroupBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupBlankWhenZeroClauseContext differentiates from other interfaces.
	IsReportGroupBlankWhenZeroClauseContext()
}

type ReportGroupBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupBlankWhenZeroClauseContext() *ReportGroupBlankWhenZeroClauseContext {
	var p = new(ReportGroupBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupBlankWhenZeroClause
	return p
}

func (*ReportGroupBlankWhenZeroClauseContext) IsReportGroupBlankWhenZeroClauseContext() {}

func NewReportGroupBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupBlankWhenZeroClauseContext {
	var p = new(ReportGroupBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupBlankWhenZeroClause

	return p
}

func (s *ReportGroupBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *ReportGroupBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupBlankWhenZeroClause(s)
	}
}

func (s *ReportGroupBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupBlankWhenZeroClause(s)
	}
}

func (s *ReportGroupBlankWhenZeroClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupBlankWhenZeroClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupBlankWhenZeroClause() (localctx IReportGroupBlankWhenZeroClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, Cobol85ParserRULE_reportGroupBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2830)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(2832)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(2831)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(2834)
		p.Match(Cobol85ParserZERO)
	}

	return localctx
}

// IReportGroupColumnNumberClauseContext is an interface to support dynamic dispatch.
type IReportGroupColumnNumberClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupColumnNumberClauseContext differentiates from other interfaces.
	IsReportGroupColumnNumberClauseContext()
}

type ReportGroupColumnNumberClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupColumnNumberClauseContext() *ReportGroupColumnNumberClauseContext {
	var p = new(ReportGroupColumnNumberClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupColumnNumberClause
	return p
}

func (*ReportGroupColumnNumberClauseContext) IsReportGroupColumnNumberClauseContext() {}

func NewReportGroupColumnNumberClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupColumnNumberClauseContext {
	var p = new(ReportGroupColumnNumberClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupColumnNumberClause

	return p
}

func (s *ReportGroupColumnNumberClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupColumnNumberClauseContext) COLUMN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLUMN, 0)
}

func (s *ReportGroupColumnNumberClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupColumnNumberClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ReportGroupColumnNumberClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupColumnNumberClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupColumnNumberClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupColumnNumberClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupColumnNumberClause(s)
	}
}

func (s *ReportGroupColumnNumberClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupColumnNumberClause(s)
	}
}

func (s *ReportGroupColumnNumberClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupColumnNumberClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupColumnNumberClause() (localctx IReportGroupColumnNumberClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupColumnNumberClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, Cobol85ParserRULE_reportGroupColumnNumberClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2836)
		p.Match(Cobol85ParserCOLUMN)
	}
	p.SetState(2838)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNUMBER {
		{
			p.SetState(2837)
			p.Match(Cobol85ParserNUMBER)
		}

	}
	p.SetState(2841)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2840)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2843)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupIndicateClauseContext is an interface to support dynamic dispatch.
type IReportGroupIndicateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupIndicateClauseContext differentiates from other interfaces.
	IsReportGroupIndicateClauseContext()
}

type ReportGroupIndicateClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupIndicateClauseContext() *ReportGroupIndicateClauseContext {
	var p = new(ReportGroupIndicateClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupIndicateClause
	return p
}

func (*ReportGroupIndicateClauseContext) IsReportGroupIndicateClauseContext() {}

func NewReportGroupIndicateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupIndicateClauseContext {
	var p = new(ReportGroupIndicateClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupIndicateClause

	return p
}

func (s *ReportGroupIndicateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupIndicateClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGROUP, 0)
}

func (s *ReportGroupIndicateClauseContext) INDICATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDICATE, 0)
}

func (s *ReportGroupIndicateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupIndicateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupIndicateClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupIndicateClause(s)
	}
}

func (s *ReportGroupIndicateClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupIndicateClause(s)
	}
}

func (s *ReportGroupIndicateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupIndicateClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupIndicateClause() (localctx IReportGroupIndicateClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupIndicateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, Cobol85ParserRULE_reportGroupIndicateClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2845)
		p.Match(Cobol85ParserGROUP)
	}
	p.SetState(2847)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDICATE {
		{
			p.SetState(2846)
			p.Match(Cobol85ParserINDICATE)
		}

	}

	return localctx
}

// IReportGroupJustifiedClauseContext is an interface to support dynamic dispatch.
type IReportGroupJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupJustifiedClauseContext differentiates from other interfaces.
	IsReportGroupJustifiedClauseContext()
}

type ReportGroupJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupJustifiedClauseContext() *ReportGroupJustifiedClauseContext {
	var p = new(ReportGroupJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupJustifiedClause
	return p
}

func (*ReportGroupJustifiedClauseContext) IsReportGroupJustifiedClauseContext() {}

func NewReportGroupJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupJustifiedClauseContext {
	var p = new(ReportGroupJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupJustifiedClause

	return p
}

func (s *ReportGroupJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *ReportGroupJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *ReportGroupJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *ReportGroupJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupJustifiedClause(s)
	}
}

func (s *ReportGroupJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupJustifiedClause(s)
	}
}

func (s *ReportGroupJustifiedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupJustifiedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupJustifiedClause() (localctx IReportGroupJustifiedClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, Cobol85ParserRULE_reportGroupJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2849)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2851)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(2850)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IReportGroupLineNumberClauseContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberClauseContext differentiates from other interfaces.
	IsReportGroupLineNumberClauseContext()
}

type ReportGroupLineNumberClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberClauseContext() *ReportGroupLineNumberClauseContext {
	var p = new(ReportGroupLineNumberClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberClause
	return p
}

func (*ReportGroupLineNumberClauseContext) IsReportGroupLineNumberClauseContext() {}

func NewReportGroupLineNumberClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberClauseContext {
	var p = new(ReportGroupLineNumberClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberClause

	return p
}

func (s *ReportGroupLineNumberClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberClauseContext) ReportGroupLineNumberNextPage() IReportGroupLineNumberNextPageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupLineNumberNextPageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberNextPageContext)
}

func (s *ReportGroupLineNumberClauseContext) ReportGroupLineNumberPlus() IReportGroupLineNumberPlusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupLineNumberPlusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupLineNumberPlusContext)
}

func (s *ReportGroupLineNumberClauseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *ReportGroupLineNumberClauseContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMBER, 0)
}

func (s *ReportGroupLineNumberClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupLineNumberClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberClause(s)
	}
}

func (s *ReportGroupLineNumberClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberClause(s)
	}
}

func (s *ReportGroupLineNumberClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupLineNumberClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberClause() (localctx IReportGroupLineNumberClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupLineNumberClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, Cobol85ParserRULE_reportGroupLineNumberClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2854)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE {
		{
			p.SetState(2853)
			p.Match(Cobol85ParserLINE)
		}

	}
	p.SetState(2857)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNUMBER {
		{
			p.SetState(2856)
			p.Match(Cobol85ParserNUMBER)
		}

	}
	p.SetState(2860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2859)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2864)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2862)
			p.ReportGroupLineNumberNextPage()
		}

	case Cobol85ParserPLUS:
		{
			p.SetState(2863)
			p.ReportGroupLineNumberPlus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupLineNumberNextPageContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberNextPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberNextPageContext differentiates from other interfaces.
	IsReportGroupLineNumberNextPageContext()
}

type ReportGroupLineNumberNextPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberNextPageContext() *ReportGroupLineNumberNextPageContext {
	var p = new(ReportGroupLineNumberNextPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberNextPage
	return p
}

func (*ReportGroupLineNumberNextPageContext) IsReportGroupLineNumberNextPageContext() {}

func NewReportGroupLineNumberNextPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberNextPageContext {
	var p = new(ReportGroupLineNumberNextPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberNextPage

	return p
}

func (s *ReportGroupLineNumberNextPageContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberNextPageContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupLineNumberNextPageContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupLineNumberNextPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupLineNumberNextPageContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *ReportGroupLineNumberNextPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberNextPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberNextPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberNextPage(s)
	}
}

func (s *ReportGroupLineNumberNextPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberNextPage(s)
	}
}

func (s *ReportGroupLineNumberNextPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupLineNumberNextPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberNextPage() (localctx IReportGroupLineNumberNextPageContext) {
	this := p
	_ = this

	localctx = NewReportGroupLineNumberNextPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, Cobol85ParserRULE_reportGroupLineNumberNextPage)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2866)
		p.IntegerLiteral()
	}
	p.SetState(2872)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 334, p.GetParserRuleContext()) == 1 {
		p.SetState(2868)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(2867)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(2870)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(2871)
			p.Match(Cobol85ParserPAGE)
		}

	}

	return localctx
}

// IReportGroupLineNumberPlusContext is an interface to support dynamic dispatch.
type IReportGroupLineNumberPlusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupLineNumberPlusContext differentiates from other interfaces.
	IsReportGroupLineNumberPlusContext()
}

type ReportGroupLineNumberPlusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupLineNumberPlusContext() *ReportGroupLineNumberPlusContext {
	var p = new(ReportGroupLineNumberPlusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberPlus
	return p
}

func (*ReportGroupLineNumberPlusContext) IsReportGroupLineNumberPlusContext() {}

func NewReportGroupLineNumberPlusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupLineNumberPlusContext {
	var p = new(ReportGroupLineNumberPlusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupLineNumberPlus

	return p
}

func (s *ReportGroupLineNumberPlusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupLineNumberPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ReportGroupLineNumberPlusContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupLineNumberPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupLineNumberPlusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupLineNumberPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupLineNumberPlus(s)
	}
}

func (s *ReportGroupLineNumberPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupLineNumberPlus(s)
	}
}

func (s *ReportGroupLineNumberPlusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupLineNumberPlus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupLineNumberPlus() (localctx IReportGroupLineNumberPlusContext) {
	this := p
	_ = this

	localctx = NewReportGroupLineNumberPlusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, Cobol85ParserRULE_reportGroupLineNumberPlus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2874)
		p.Match(Cobol85ParserPLUS)
	}
	{
		p.SetState(2875)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupNextGroupClauseContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupClauseContext differentiates from other interfaces.
	IsReportGroupNextGroupClauseContext()
}

type ReportGroupNextGroupClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupClauseContext() *ReportGroupNextGroupClauseContext {
	var p = new(ReportGroupNextGroupClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupClause
	return p
}

func (*ReportGroupNextGroupClauseContext) IsReportGroupNextGroupClauseContext() {}

func NewReportGroupNextGroupClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupClauseContext {
	var p = new(ReportGroupNextGroupClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupClause

	return p
}

func (s *ReportGroupNextGroupClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupClauseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupNextGroupClauseContext) GROUP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGROUP, 0)
}

func (s *ReportGroupNextGroupClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupNextGroupClauseContext) ReportGroupNextGroupNextPage() IReportGroupNextGroupNextPageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupNextGroupNextPageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupNextPageContext)
}

func (s *ReportGroupNextGroupClauseContext) ReportGroupNextGroupPlus() IReportGroupNextGroupPlusContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupNextGroupPlusContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupNextGroupPlusContext)
}

func (s *ReportGroupNextGroupClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupNextGroupClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupClause(s)
	}
}

func (s *ReportGroupNextGroupClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupClause(s)
	}
}

func (s *ReportGroupNextGroupClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupNextGroupClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupClause() (localctx IReportGroupNextGroupClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupNextGroupClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, Cobol85ParserRULE_reportGroupNextGroupClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2877)
		p.Match(Cobol85ParserNEXT)
	}
	{
		p.SetState(2878)
		p.Match(Cobol85ParserGROUP)
	}
	p.SetState(2880)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2879)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2885)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		{
			p.SetState(2882)
			p.IntegerLiteral()
		}

	case Cobol85ParserNEXT:
		{
			p.SetState(2883)
			p.ReportGroupNextGroupNextPage()
		}

	case Cobol85ParserPLUS:
		{
			p.SetState(2884)
			p.ReportGroupNextGroupPlus()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupNextGroupPlusContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupPlusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupPlusContext differentiates from other interfaces.
	IsReportGroupNextGroupPlusContext()
}

type ReportGroupNextGroupPlusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupPlusContext() *ReportGroupNextGroupPlusContext {
	var p = new(ReportGroupNextGroupPlusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupPlus
	return p
}

func (*ReportGroupNextGroupPlusContext) IsReportGroupNextGroupPlusContext() {}

func NewReportGroupNextGroupPlusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupPlusContext {
	var p = new(ReportGroupNextGroupPlusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupPlus

	return p
}

func (s *ReportGroupNextGroupPlusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupPlusContext) PLUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUS, 0)
}

func (s *ReportGroupNextGroupPlusContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ReportGroupNextGroupPlusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupPlusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupPlusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupPlus(s)
	}
}

func (s *ReportGroupNextGroupPlusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupPlus(s)
	}
}

func (s *ReportGroupNextGroupPlusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupNextGroupPlus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupPlus() (localctx IReportGroupNextGroupPlusContext) {
	this := p
	_ = this

	localctx = NewReportGroupNextGroupPlusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, Cobol85ParserRULE_reportGroupNextGroupPlus)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2887)
		p.Match(Cobol85ParserPLUS)
	}
	{
		p.SetState(2888)
		p.IntegerLiteral()
	}

	return localctx
}

// IReportGroupNextGroupNextPageContext is an interface to support dynamic dispatch.
type IReportGroupNextGroupNextPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupNextGroupNextPageContext differentiates from other interfaces.
	IsReportGroupNextGroupNextPageContext()
}

type ReportGroupNextGroupNextPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupNextGroupNextPageContext() *ReportGroupNextGroupNextPageContext {
	var p = new(ReportGroupNextGroupNextPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupNextPage
	return p
}

func (*ReportGroupNextGroupNextPageContext) IsReportGroupNextGroupNextPageContext() {}

func NewReportGroupNextGroupNextPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupNextGroupNextPageContext {
	var p = new(ReportGroupNextGroupNextPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupNextGroupNextPage

	return p
}

func (s *ReportGroupNextGroupNextPageContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupNextGroupNextPageContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReportGroupNextGroupNextPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupNextGroupNextPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupNextGroupNextPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupNextGroupNextPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupNextGroupNextPage(s)
	}
}

func (s *ReportGroupNextGroupNextPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupNextGroupNextPage(s)
	}
}

func (s *ReportGroupNextGroupNextPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupNextGroupNextPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupNextGroupNextPage() (localctx IReportGroupNextGroupNextPageContext) {
	this := p
	_ = this

	localctx = NewReportGroupNextGroupNextPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, Cobol85ParserRULE_reportGroupNextGroupNextPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2890)
		p.Match(Cobol85ParserNEXT)
	}
	{
		p.SetState(2891)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// IReportGroupPictureClauseContext is an interface to support dynamic dispatch.
type IReportGroupPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupPictureClauseContext differentiates from other interfaces.
	IsReportGroupPictureClauseContext()
}

type ReportGroupPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupPictureClauseContext() *ReportGroupPictureClauseContext {
	var p = new(ReportGroupPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupPictureClause
	return p
}

func (*ReportGroupPictureClauseContext) IsReportGroupPictureClauseContext() {}

func NewReportGroupPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupPictureClauseContext {
	var p = new(ReportGroupPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupPictureClause

	return p
}

func (s *ReportGroupPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupPictureClauseContext) PictureString() IPictureStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *ReportGroupPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *ReportGroupPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *ReportGroupPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupPictureClause(s)
	}
}

func (s *ReportGroupPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupPictureClause(s)
	}
}

func (s *ReportGroupPictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupPictureClause() (localctx IReportGroupPictureClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, Cobol85ParserRULE_reportGroupPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2893)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(2895)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2894)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2897)
		p.PictureString()
	}

	return localctx
}

// IReportGroupResetClauseContext is an interface to support dynamic dispatch.
type IReportGroupResetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupResetClauseContext differentiates from other interfaces.
	IsReportGroupResetClauseContext()
}

type ReportGroupResetClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupResetClauseContext() *ReportGroupResetClauseContext {
	var p = new(ReportGroupResetClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupResetClause
	return p
}

func (*ReportGroupResetClauseContext) IsReportGroupResetClauseContext() {}

func NewReportGroupResetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupResetClauseContext {
	var p = new(ReportGroupResetClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupResetClause

	return p
}

func (s *ReportGroupResetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupResetClauseContext) RESET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRESET, 0)
}

func (s *ReportGroupResetClauseContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupResetClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupResetClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *ReportGroupResetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupResetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupResetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupResetClause(s)
	}
}

func (s *ReportGroupResetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupResetClause(s)
	}
}

func (s *ReportGroupResetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupResetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupResetClause() (localctx IReportGroupResetClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupResetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, Cobol85ParserRULE_reportGroupResetClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2899)
		p.Match(Cobol85ParserRESET)
	}
	p.SetState(2901)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(2900)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(2905)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2903)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2904)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupSignClauseContext is an interface to support dynamic dispatch.
type IReportGroupSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSignClauseContext differentiates from other interfaces.
	IsReportGroupSignClauseContext()
}

type ReportGroupSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSignClauseContext() *ReportGroupSignClauseContext {
	var p = new(ReportGroupSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSignClause
	return p
}

func (*ReportGroupSignClauseContext) IsReportGroupSignClauseContext() {}

func NewReportGroupSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSignClauseContext {
	var p = new(ReportGroupSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSignClause

	return p
}

func (s *ReportGroupSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *ReportGroupSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *ReportGroupSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *ReportGroupSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *ReportGroupSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *ReportGroupSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSignClause(s)
	}
}

func (s *ReportGroupSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSignClause(s)
	}
}

func (s *ReportGroupSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupSignClause() (localctx IReportGroupSignClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, Cobol85ParserRULE_reportGroupSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.Match(Cobol85ParserSIGN)
	}
	p.SetState(2909)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2908)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2911)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2912)
		p.Match(Cobol85ParserSEPARATE)
	}
	p.SetState(2914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHARACTER {
		{
			p.SetState(2913)
			p.Match(Cobol85ParserCHARACTER)
		}

	}

	return localctx
}

// IReportGroupSourceClauseContext is an interface to support dynamic dispatch.
type IReportGroupSourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSourceClauseContext differentiates from other interfaces.
	IsReportGroupSourceClauseContext()
}

type ReportGroupSourceClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSourceClauseContext() *ReportGroupSourceClauseContext {
	var p = new(ReportGroupSourceClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSourceClause
	return p
}

func (*ReportGroupSourceClauseContext) IsReportGroupSourceClauseContext() {}

func NewReportGroupSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSourceClauseContext {
	var p = new(ReportGroupSourceClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSourceClause

	return p
}

func (s *ReportGroupSourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSourceClauseContext) SOURCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSOURCE, 0)
}

func (s *ReportGroupSourceClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReportGroupSourceClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupSourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSourceClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSourceClause(s)
	}
}

func (s *ReportGroupSourceClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSourceClause(s)
	}
}

func (s *ReportGroupSourceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupSourceClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupSourceClause() (localctx IReportGroupSourceClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, Cobol85ParserRULE_reportGroupSourceClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2916)
		p.Match(Cobol85ParserSOURCE)
	}
	p.SetState(2918)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2917)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(2920)
		p.Identifier()
	}

	return localctx
}

// IReportGroupSumClauseContext is an interface to support dynamic dispatch.
type IReportGroupSumClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupSumClauseContext differentiates from other interfaces.
	IsReportGroupSumClauseContext()
}

type ReportGroupSumClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupSumClauseContext() *ReportGroupSumClauseContext {
	var p = new(ReportGroupSumClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupSumClause
	return p
}

func (*ReportGroupSumClauseContext) IsReportGroupSumClauseContext() {}

func NewReportGroupSumClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupSumClauseContext {
	var p = new(ReportGroupSumClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupSumClause

	return p
}

func (s *ReportGroupSumClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupSumClauseContext) SUM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUM, 0)
}

func (s *ReportGroupSumClauseContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupSumClauseContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReportGroupSumClauseContext) UPON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUPON, 0)
}

func (s *ReportGroupSumClauseContext) AllDataName() []IDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataNameContext); ok {
			len++
		}
	}

	tst := make([]IDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataNameContext); ok {
			tst[i] = t.(IDataNameContext)
			i++
		}
	}

	return tst
}

func (s *ReportGroupSumClauseContext) DataName(i int) IDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupSumClauseContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *ReportGroupSumClauseContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *ReportGroupSumClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupSumClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupSumClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupSumClause(s)
	}
}

func (s *ReportGroupSumClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupSumClause(s)
	}
}

func (s *ReportGroupSumClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupSumClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupSumClause() (localctx IReportGroupSumClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupSumClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, Cobol85ParserRULE_reportGroupSumClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2922)
		p.Match(Cobol85ParserSUM)
	}
	{
		p.SetState(2923)
		p.Identifier()
	}
	p.SetState(2930)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(2925)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(2924)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(2927)
				p.Identifier()
			}

		}
		p.SetState(2932)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 344, p.GetParserRuleContext())
	}
	p.SetState(2944)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUPON {
		{
			p.SetState(2933)
			p.Match(Cobol85ParserUPON)
		}
		{
			p.SetState(2934)
			p.DataName()
		}
		p.SetState(2941)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&-9119736461836320639) != 0 || _la == Cobol85ParserIDENTIFIER {
			p.SetState(2936)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(2935)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(2938)
				p.DataName()
			}

			p.SetState(2943)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IReportGroupTypeClauseContext is an interface to support dynamic dispatch.
type IReportGroupTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeClauseContext differentiates from other interfaces.
	IsReportGroupTypeClauseContext()
}

type ReportGroupTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeClauseContext() *ReportGroupTypeClauseContext {
	var p = new(ReportGroupTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeClause
	return p
}

func (*ReportGroupTypeClauseContext) IsReportGroupTypeClauseContext() {}

func NewReportGroupTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeClauseContext {
	var p = new(ReportGroupTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeClause

	return p
}

func (s *ReportGroupTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeClauseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPE, 0)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeReportHeading() IReportGroupTypeReportHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypeReportHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeReportHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypePageHeading() IReportGroupTypePageHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypePageHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypePageHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeControlHeading() IReportGroupTypeControlHeadingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypeControlHeadingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeControlHeadingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeDetail() IReportGroupTypeDetailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypeDetailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeDetailContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeControlFooting() IReportGroupTypeControlFootingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypeControlFootingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeControlFootingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypePageFooting() IReportGroupTypePageFootingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypePageFootingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypePageFootingContext)
}

func (s *ReportGroupTypeClauseContext) ReportGroupTypeReportFooting() IReportGroupTypeReportFootingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportGroupTypeReportFootingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportGroupTypeReportFootingContext)
}

func (s *ReportGroupTypeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeClause(s)
	}
}

func (s *ReportGroupTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeClause(s)
	}
}

func (s *ReportGroupTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeClause() (localctx IReportGroupTypeClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, Cobol85ParserRULE_reportGroupTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2946)
		p.Match(Cobol85ParserTYPE)
	}
	p.SetState(2948)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(2947)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(2957)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 349, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2950)
			p.ReportGroupTypeReportHeading()
		}

	case 2:
		{
			p.SetState(2951)
			p.ReportGroupTypePageHeading()
		}

	case 3:
		{
			p.SetState(2952)
			p.ReportGroupTypeControlHeading()
		}

	case 4:
		{
			p.SetState(2953)
			p.ReportGroupTypeDetail()
		}

	case 5:
		{
			p.SetState(2954)
			p.ReportGroupTypeControlFooting()
		}

	case 6:
		{
			p.SetState(2955)
			p.ReportGroupTypePageFooting()
		}

	case 7:
		{
			p.SetState(2956)
			p.ReportGroupTypeReportFooting()
		}

	}

	return localctx
}

// IReportGroupTypeReportHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypeReportHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeReportHeadingContext differentiates from other interfaces.
	IsReportGroupTypeReportHeadingContext()
}

type ReportGroupTypeReportHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeReportHeadingContext() *ReportGroupTypeReportHeadingContext {
	var p = new(ReportGroupTypeReportHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportHeading
	return p
}

func (*ReportGroupTypeReportHeadingContext) IsReportGroupTypeReportHeadingContext() {}

func NewReportGroupTypeReportHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeReportHeadingContext {
	var p = new(ReportGroupTypeReportHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportHeading

	return p
}

func (s *ReportGroupTypeReportHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeReportHeadingContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportGroupTypeReportHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypeReportHeadingContext) RH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRH, 0)
}

func (s *ReportGroupTypeReportHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeReportHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeReportHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeReportHeading(s)
	}
}

func (s *ReportGroupTypeReportHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeReportHeading(s)
	}
}

func (s *ReportGroupTypeReportHeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeReportHeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeReportHeading() (localctx IReportGroupTypeReportHeadingContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypeReportHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, Cobol85ParserRULE_reportGroupTypeReportHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2962)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2959)
			p.Match(Cobol85ParserREPORT)
		}
		{
			p.SetState(2960)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserRH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2961)
			p.Match(Cobol85ParserRH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypePageHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypePageHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypePageHeadingContext differentiates from other interfaces.
	IsReportGroupTypePageHeadingContext()
}

type ReportGroupTypePageHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypePageHeadingContext() *ReportGroupTypePageHeadingContext {
	var p = new(ReportGroupTypePageHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageHeading
	return p
}

func (*ReportGroupTypePageHeadingContext) IsReportGroupTypePageHeadingContext() {}

func NewReportGroupTypePageHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypePageHeadingContext {
	var p = new(ReportGroupTypePageHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageHeading

	return p
}

func (s *ReportGroupTypePageHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypePageHeadingContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupTypePageHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypePageHeadingContext) PH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPH, 0)
}

func (s *ReportGroupTypePageHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypePageHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypePageHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypePageHeading(s)
	}
}

func (s *ReportGroupTypePageHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypePageHeading(s)
	}
}

func (s *ReportGroupTypePageHeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypePageHeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypePageHeading() (localctx IReportGroupTypePageHeadingContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypePageHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 380, Cobol85ParserRULE_reportGroupTypePageHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(2967)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserPAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2964)
			p.Match(Cobol85ParserPAGE)
		}
		{
			p.SetState(2965)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserPH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2966)
			p.Match(Cobol85ParserPH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeControlHeadingContext is an interface to support dynamic dispatch.
type IReportGroupTypeControlHeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeControlHeadingContext differentiates from other interfaces.
	IsReportGroupTypeControlHeadingContext()
}

type ReportGroupTypeControlHeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeControlHeadingContext() *ReportGroupTypeControlHeadingContext {
	var p = new(ReportGroupTypeControlHeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlHeading
	return p
}

func (*ReportGroupTypeControlHeadingContext) IsReportGroupTypeControlHeadingContext() {}

func NewReportGroupTypeControlHeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeControlHeadingContext {
	var p = new(ReportGroupTypeControlHeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlHeading

	return p
}

func (s *ReportGroupTypeControlHeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeControlHeadingContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ReportGroupTypeControlHeadingContext) HEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHEADING, 0)
}

func (s *ReportGroupTypeControlHeadingContext) CH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCH, 0)
}

func (s *ReportGroupTypeControlHeadingContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupTypeControlHeadingContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupTypeControlHeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeControlHeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeControlHeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeControlHeading(s)
	}
}

func (s *ReportGroupTypeControlHeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeControlHeading(s)
	}
}

func (s *ReportGroupTypeControlHeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeControlHeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeControlHeading() (localctx IReportGroupTypeControlHeadingContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypeControlHeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 382, Cobol85ParserRULE_reportGroupTypeControlHeading)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2972)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONTROL:
		{
			p.SetState(2969)
			p.Match(Cobol85ParserCONTROL)
		}
		{
			p.SetState(2970)
			p.Match(Cobol85ParserHEADING)
		}

	case Cobol85ParserCH:
		{
			p.SetState(2971)
			p.Match(Cobol85ParserCH)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2976)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2974)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2975)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeDetailContext is an interface to support dynamic dispatch.
type IReportGroupTypeDetailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeDetailContext differentiates from other interfaces.
	IsReportGroupTypeDetailContext()
}

type ReportGroupTypeDetailContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeDetailContext() *ReportGroupTypeDetailContext {
	var p = new(ReportGroupTypeDetailContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeDetail
	return p
}

func (*ReportGroupTypeDetailContext) IsReportGroupTypeDetailContext() {}

func NewReportGroupTypeDetailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeDetailContext {
	var p = new(ReportGroupTypeDetailContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeDetail

	return p
}

func (s *ReportGroupTypeDetailContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeDetailContext) DETAIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDETAIL, 0)
}

func (s *ReportGroupTypeDetailContext) DE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDE, 0)
}

func (s *ReportGroupTypeDetailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeDetailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeDetailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeDetail(s)
	}
}

func (s *ReportGroupTypeDetailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeDetail(s)
	}
}

func (s *ReportGroupTypeDetailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeDetail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeDetail() (localctx IReportGroupTypeDetailContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypeDetailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, Cobol85ParserRULE_reportGroupTypeDetail)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2978)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDE || _la == Cobol85ParserDETAIL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReportGroupTypeControlFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypeControlFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeControlFootingContext differentiates from other interfaces.
	IsReportGroupTypeControlFootingContext()
}

type ReportGroupTypeControlFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeControlFootingContext() *ReportGroupTypeControlFootingContext {
	var p = new(ReportGroupTypeControlFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlFooting
	return p
}

func (*ReportGroupTypeControlFootingContext) IsReportGroupTypeControlFootingContext() {}

func NewReportGroupTypeControlFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeControlFootingContext {
	var p = new(ReportGroupTypeControlFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeControlFooting

	return p
}

func (s *ReportGroupTypeControlFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeControlFootingContext) CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL, 0)
}

func (s *ReportGroupTypeControlFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypeControlFootingContext) CF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCF, 0)
}

func (s *ReportGroupTypeControlFootingContext) FINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFINAL, 0)
}

func (s *ReportGroupTypeControlFootingContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReportGroupTypeControlFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeControlFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeControlFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeControlFooting(s)
	}
}

func (s *ReportGroupTypeControlFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeControlFooting(s)
	}
}

func (s *ReportGroupTypeControlFootingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeControlFooting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeControlFooting() (localctx IReportGroupTypeControlFootingContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypeControlFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, Cobol85ParserRULE_reportGroupTypeControlFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2983)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCONTROL:
		{
			p.SetState(2980)
			p.Match(Cobol85ParserCONTROL)
		}
		{
			p.SetState(2981)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserCF:
		{
			p.SetState(2982)
			p.Match(Cobol85ParserCF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(2987)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserFINAL:
		{
			p.SetState(2985)
			p.Match(Cobol85ParserFINAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(2986)
			p.DataName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupUsageClauseContext is an interface to support dynamic dispatch.
type IReportGroupUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupUsageClauseContext differentiates from other interfaces.
	IsReportGroupUsageClauseContext()
}

type ReportGroupUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupUsageClauseContext() *ReportGroupUsageClauseContext {
	var p = new(ReportGroupUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupUsageClause
	return p
}

func (*ReportGroupUsageClauseContext) IsReportGroupUsageClauseContext() {}

func NewReportGroupUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupUsageClauseContext {
	var p = new(ReportGroupUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupUsageClause

	return p
}

func (s *ReportGroupUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *ReportGroupUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *ReportGroupUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *ReportGroupUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupUsageClause(s)
	}
}

func (s *ReportGroupUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupUsageClause(s)
	}
}

func (s *ReportGroupUsageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupUsageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupUsageClause() (localctx IReportGroupUsageClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, Cobol85ParserRULE_reportGroupUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSAGE {
		{
			p.SetState(2989)
			p.Match(Cobol85ParserUSAGE)
		}
		p.SetState(2991)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(2990)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(2995)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserDISPLAY || _la == Cobol85ParserDISPLAY_1) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IReportGroupTypePageFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypePageFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypePageFootingContext differentiates from other interfaces.
	IsReportGroupTypePageFootingContext()
}

type ReportGroupTypePageFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypePageFootingContext() *ReportGroupTypePageFootingContext {
	var p = new(ReportGroupTypePageFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageFooting
	return p
}

func (*ReportGroupTypePageFootingContext) IsReportGroupTypePageFootingContext() {}

func NewReportGroupTypePageFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypePageFootingContext {
	var p = new(ReportGroupTypePageFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypePageFooting

	return p
}

func (s *ReportGroupTypePageFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypePageFootingContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *ReportGroupTypePageFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypePageFootingContext) PF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPF, 0)
}

func (s *ReportGroupTypePageFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypePageFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypePageFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypePageFooting(s)
	}
}

func (s *ReportGroupTypePageFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypePageFooting(s)
	}
}

func (s *ReportGroupTypePageFootingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypePageFooting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypePageFooting() (localctx IReportGroupTypePageFootingContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypePageFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 390, Cobol85ParserRULE_reportGroupTypePageFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3000)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserPAGE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2997)
			p.Match(Cobol85ParserPAGE)
		}
		{
			p.SetState(2998)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserPF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2999)
			p.Match(Cobol85ParserPF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupTypeReportFootingContext is an interface to support dynamic dispatch.
type IReportGroupTypeReportFootingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupTypeReportFootingContext differentiates from other interfaces.
	IsReportGroupTypeReportFootingContext()
}

type ReportGroupTypeReportFootingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupTypeReportFootingContext() *ReportGroupTypeReportFootingContext {
	var p = new(ReportGroupTypeReportFootingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportFooting
	return p
}

func (*ReportGroupTypeReportFootingContext) IsReportGroupTypeReportFootingContext() {}

func NewReportGroupTypeReportFootingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupTypeReportFootingContext {
	var p = new(ReportGroupTypeReportFootingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupTypeReportFooting

	return p
}

func (s *ReportGroupTypeReportFootingContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupTypeReportFootingContext) REPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPORT, 0)
}

func (s *ReportGroupTypeReportFootingContext) FOOTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOOTING, 0)
}

func (s *ReportGroupTypeReportFootingContext) RF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRF, 0)
}

func (s *ReportGroupTypeReportFootingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupTypeReportFootingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupTypeReportFootingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupTypeReportFooting(s)
	}
}

func (s *ReportGroupTypeReportFootingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupTypeReportFooting(s)
	}
}

func (s *ReportGroupTypeReportFootingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupTypeReportFooting(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupTypeReportFooting() (localctx IReportGroupTypeReportFootingContext) {
	this := p
	_ = this

	localctx = NewReportGroupTypeReportFootingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 392, Cobol85ParserRULE_reportGroupTypeReportFooting)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3005)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserREPORT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3002)
			p.Match(Cobol85ParserREPORT)
		}
		{
			p.SetState(3003)
			p.Match(Cobol85ParserFOOTING)
		}

	case Cobol85ParserRF:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3004)
			p.Match(Cobol85ParserRF)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReportGroupValueClauseContext is an interface to support dynamic dispatch.
type IReportGroupValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportGroupValueClauseContext differentiates from other interfaces.
	IsReportGroupValueClauseContext()
}

type ReportGroupValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportGroupValueClauseContext() *ReportGroupValueClauseContext {
	var p = new(ReportGroupValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportGroupValueClause
	return p
}

func (*ReportGroupValueClauseContext) IsReportGroupValueClauseContext() {}

func NewReportGroupValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportGroupValueClauseContext {
	var p = new(ReportGroupValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportGroupValueClause

	return p
}

func (s *ReportGroupValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportGroupValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ReportGroupValueClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ReportGroupValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReportGroupValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportGroupValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportGroupValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportGroupValueClause(s)
	}
}

func (s *ReportGroupValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportGroupValueClause(s)
	}
}

func (s *ReportGroupValueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportGroupValueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportGroupValueClause() (localctx IReportGroupValueClauseContext) {
	this := p
	_ = this

	localctx = NewReportGroupValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, Cobol85ParserRULE_reportGroupValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3007)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3009)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3008)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3011)
		p.Literal()
	}

	return localctx
}

// IProgramLibrarySectionContext is an interface to support dynamic dispatch.
type IProgramLibrarySectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramLibrarySectionContext differentiates from other interfaces.
	IsProgramLibrarySectionContext()
}

type ProgramLibrarySectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramLibrarySectionContext() *ProgramLibrarySectionContext {
	var p = new(ProgramLibrarySectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programLibrarySection
	return p
}

func (*ProgramLibrarySectionContext) IsProgramLibrarySectionContext() {}

func NewProgramLibrarySectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramLibrarySectionContext {
	var p = new(ProgramLibrarySectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programLibrarySection

	return p
}

func (s *ProgramLibrarySectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramLibrarySectionContext) PROGRAM_LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM_LIBRARY, 0)
}

func (s *ProgramLibrarySectionContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ProgramLibrarySectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProgramLibrarySectionContext) AllLibraryDescriptionEntry() []ILibraryDescriptionEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILibraryDescriptionEntryContext); ok {
			len++
		}
	}

	tst := make([]ILibraryDescriptionEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILibraryDescriptionEntryContext); ok {
			tst[i] = t.(ILibraryDescriptionEntryContext)
			i++
		}
	}

	return tst
}

func (s *ProgramLibrarySectionContext) LibraryDescriptionEntry(i int) ILibraryDescriptionEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryDescriptionEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryContext)
}

func (s *ProgramLibrarySectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramLibrarySectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramLibrarySectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramLibrarySection(s)
	}
}

func (s *ProgramLibrarySectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramLibrarySection(s)
	}
}

func (s *ProgramLibrarySectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramLibrarySection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramLibrarySection() (localctx IProgramLibrarySectionContext) {
	this := p
	_ = this

	localctx = NewProgramLibrarySectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, Cobol85ParserRULE_programLibrarySection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3013)
		p.Match(Cobol85ParserPROGRAM_LIBRARY)
	}
	{
		p.SetState(3014)
		p.Match(Cobol85ParserSECTION)
	}
	{
		p.SetState(3015)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3019)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserLB || _la == Cobol85ParserLD {
		{
			p.SetState(3016)
			p.LibraryDescriptionEntry()
		}

		p.SetState(3021)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryDescriptionEntryContext is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryContext differentiates from other interfaces.
	IsLibraryDescriptionEntryContext()
}

type LibraryDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryContext() *LibraryDescriptionEntryContext {
	var p = new(LibraryDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntry
	return p
}

func (*LibraryDescriptionEntryContext) IsLibraryDescriptionEntryContext() {}

func NewLibraryDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryContext {
	var p = new(LibraryDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntry

	return p
}

func (s *LibraryDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryContext) LibraryDescriptionEntryFormat1() ILibraryDescriptionEntryFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryDescriptionEntryFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryFormat1Context)
}

func (s *LibraryDescriptionEntryContext) LibraryDescriptionEntryFormat2() ILibraryDescriptionEntryFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryDescriptionEntryFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryDescriptionEntryFormat2Context)
}

func (s *LibraryDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntry(s)
	}
}

func (s *LibraryDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntry(s)
	}
}

func (s *LibraryDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntry() (localctx ILibraryDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewLibraryDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, Cobol85ParserRULE_libraryDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3022)
			p.LibraryDescriptionEntryFormat1()
		}

	case Cobol85ParserLB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3023)
			p.LibraryDescriptionEntryFormat2()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ILibraryDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryFormat1Context differentiates from other interfaces.
	IsLibraryDescriptionEntryFormat1Context()
}

type LibraryDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryFormat1Context() *LibraryDescriptionEntryFormat1Context {
	var p = new(LibraryDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat1
	return p
}

func (*LibraryDescriptionEntryFormat1Context) IsLibraryDescriptionEntryFormat1Context() {}

func NewLibraryDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryFormat1Context {
	var p = new(LibraryDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat1

	return p
}

func (s *LibraryDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryFormat1Context) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryName() ILibraryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDescriptionEntryFormat1Context) EXPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXPORT, 0)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryAttributeClauseFormat1() ILibraryAttributeClauseFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryAttributeClauseFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeClauseFormat1Context)
}

func (s *LibraryDescriptionEntryFormat1Context) LibraryEntryProcedureClauseFormat1() ILibraryEntryProcedureClauseFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureClauseFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureClauseFormat1Context)
}

func (s *LibraryDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntryFormat1(s)
	}
}

func (s *LibraryDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntryFormat1(s)
	}
}

func (s *LibraryDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntryFormat1() (localctx ILibraryDescriptionEntryFormat1Context) {
	this := p
	_ = this

	localctx = NewLibraryDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, Cobol85ParserRULE_libraryDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3026)
		p.Match(Cobol85ParserLD)
	}
	{
		p.SetState(3027)
		p.LibraryName()
	}
	{
		p.SetState(3028)
		p.Match(Cobol85ParserEXPORT)
	}
	p.SetState(3030)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserATTRIBUTE {
		{
			p.SetState(3029)
			p.LibraryAttributeClauseFormat1()
		}

	}
	p.SetState(3033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserENTRY_PROCEDURE {
		{
			p.SetState(3032)
			p.LibraryEntryProcedureClauseFormat1()
		}

	}

	return localctx
}

// ILibraryDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type ILibraryDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryDescriptionEntryFormat2Context differentiates from other interfaces.
	IsLibraryDescriptionEntryFormat2Context()
}

type LibraryDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDescriptionEntryFormat2Context() *LibraryDescriptionEntryFormat2Context {
	var p = new(LibraryDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat2
	return p
}

func (*LibraryDescriptionEntryFormat2Context) IsLibraryDescriptionEntryFormat2Context() {}

func NewLibraryDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDescriptionEntryFormat2Context {
	var p = new(LibraryDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryDescriptionEntryFormat2

	return p
}

func (s *LibraryDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDescriptionEntryFormat2Context) LB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLB, 0)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryName() ILibraryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *LibraryDescriptionEntryFormat2Context) IMPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPORT, 0)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryIsGlobalClause() ILibraryIsGlobalClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryIsGlobalClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryIsGlobalClauseContext)
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryIsCommonClause() ILibraryIsCommonClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryIsCommonClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryIsCommonClauseContext)
}

func (s *LibraryDescriptionEntryFormat2Context) AllLibraryAttributeClauseFormat2() []ILibraryAttributeClauseFormat2Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILibraryAttributeClauseFormat2Context); ok {
			len++
		}
	}

	tst := make([]ILibraryAttributeClauseFormat2Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILibraryAttributeClauseFormat2Context); ok {
			tst[i] = t.(ILibraryAttributeClauseFormat2Context)
			i++
		}
	}

	return tst
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryAttributeClauseFormat2(i int) ILibraryAttributeClauseFormat2Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryAttributeClauseFormat2Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeClauseFormat2Context)
}

func (s *LibraryDescriptionEntryFormat2Context) AllLibraryEntryProcedureClauseFormat2() []ILibraryEntryProcedureClauseFormat2Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILibraryEntryProcedureClauseFormat2Context); ok {
			len++
		}
	}

	tst := make([]ILibraryEntryProcedureClauseFormat2Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILibraryEntryProcedureClauseFormat2Context); ok {
			tst[i] = t.(ILibraryEntryProcedureClauseFormat2Context)
			i++
		}
	}

	return tst
}

func (s *LibraryDescriptionEntryFormat2Context) LibraryEntryProcedureClauseFormat2(i int) ILibraryEntryProcedureClauseFormat2Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureClauseFormat2Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureClauseFormat2Context)
}

func (s *LibraryDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryDescriptionEntryFormat2(s)
	}
}

func (s *LibraryDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryDescriptionEntryFormat2(s)
	}
}

func (s *LibraryDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryDescriptionEntryFormat2() (localctx ILibraryDescriptionEntryFormat2Context) {
	this := p
	_ = this

	localctx = NewLibraryDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, Cobol85ParserRULE_libraryDescriptionEntryFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3035)
		p.Match(Cobol85ParserLB)
	}
	{
		p.SetState(3036)
		p.LibraryName()
	}
	{
		p.SetState(3037)
		p.Match(Cobol85ParserIMPORT)
	}
	p.SetState(3039)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 365, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3038)
			p.LibraryIsGlobalClause()
		}

	}
	p.SetState(3042)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOMMON || _la == Cobol85ParserIS {
		{
			p.SetState(3041)
			p.LibraryIsCommonClause()
		}

	}
	p.SetState(3048)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserATTRIBUTE || _la == Cobol85ParserENTRY_PROCEDURE {
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserATTRIBUTE:
			{
				p.SetState(3044)
				p.LibraryAttributeClauseFormat2()
			}

		case Cobol85ParserENTRY_PROCEDURE:
			{
				p.SetState(3045)
				p.LibraryEntryProcedureClauseFormat2()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3050)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILibraryAttributeClauseFormat1Context is an interface to support dynamic dispatch.
type ILibraryAttributeClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeClauseFormat1Context differentiates from other interfaces.
	IsLibraryAttributeClauseFormat1Context()
}

type LibraryAttributeClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeClauseFormat1Context() *LibraryAttributeClauseFormat1Context {
	var p = new(LibraryAttributeClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat1
	return p
}

func (*LibraryAttributeClauseFormat1Context) IsLibraryAttributeClauseFormat1Context() {}

func NewLibraryAttributeClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeClauseFormat1Context {
	var p = new(LibraryAttributeClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat1

	return p
}

func (s *LibraryAttributeClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeClauseFormat1Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHARING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARING, 0)
}

func (s *LibraryAttributeClauseFormat1Context) DONTCARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDONTCARE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRIVATE, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHAREDBYRUNUNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYRUNUNIT, 0)
}

func (s *LibraryAttributeClauseFormat1Context) SHAREDBYALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYALL, 0)
}

func (s *LibraryAttributeClauseFormat1Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeClauseFormat1(s)
	}
}

func (s *LibraryAttributeClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeClauseFormat1(s)
	}
}

func (s *LibraryAttributeClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeClauseFormat1() (localctx ILibraryAttributeClauseFormat1Context) {
	this := p
	_ = this

	localctx = NewLibraryAttributeClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, Cobol85ParserRULE_libraryAttributeClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3051)
		p.Match(Cobol85ParserATTRIBUTE)
	}
	p.SetState(3057)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSHARING {
		{
			p.SetState(3052)
			p.Match(Cobol85ParserSHARING)
		}
		p.SetState(3054)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3053)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(3056)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserDONTCARE || _la == Cobol85ParserPRIVATE || _la == Cobol85ParserSHAREDBYALL || _la == Cobol85ParserSHAREDBYRUNUNIT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ILibraryAttributeClauseFormat2Context is an interface to support dynamic dispatch.
type ILibraryAttributeClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeClauseFormat2Context differentiates from other interfaces.
	IsLibraryAttributeClauseFormat2Context()
}

type LibraryAttributeClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeClauseFormat2Context() *LibraryAttributeClauseFormat2Context {
	var p = new(LibraryAttributeClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat2
	return p
}

func (*LibraryAttributeClauseFormat2Context) IsLibraryAttributeClauseFormat2Context() {}

func NewLibraryAttributeClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeClauseFormat2Context {
	var p = new(LibraryAttributeClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeClauseFormat2

	return p
}

func (s *LibraryAttributeClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeClauseFormat2Context) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeFunction() ILibraryAttributeFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryAttributeFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeFunctionContext)
}

func (s *LibraryAttributeClauseFormat2Context) LIBACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBACCESS, 0)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeParameter() ILibraryAttributeParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryAttributeParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeParameterContext)
}

func (s *LibraryAttributeClauseFormat2Context) LibraryAttributeTitle() ILibraryAttributeTitleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryAttributeTitleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryAttributeTitleContext)
}

func (s *LibraryAttributeClauseFormat2Context) BYFUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYFUNCTION, 0)
}

func (s *LibraryAttributeClauseFormat2Context) BYTITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYTITLE, 0)
}

func (s *LibraryAttributeClauseFormat2Context) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeClauseFormat2(s)
	}
}

func (s *LibraryAttributeClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeClauseFormat2(s)
	}
}

func (s *LibraryAttributeClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeClauseFormat2() (localctx ILibraryAttributeClauseFormat2Context) {
	this := p
	_ = this

	localctx = NewLibraryAttributeClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, Cobol85ParserRULE_libraryAttributeClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3059)
		p.Match(Cobol85ParserATTRIBUTE)
	}
	p.SetState(3061)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFUNCTIONNAME {
		{
			p.SetState(3060)
			p.LibraryAttributeFunction()
		}

	}
	p.SetState(3068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIBACCESS {
		{
			p.SetState(3063)
			p.Match(Cobol85ParserLIBACCESS)
		}
		p.SetState(3065)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3064)
				p.Match(Cobol85ParserIS)
			}

		}
		{
			p.SetState(3067)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserBYFUNCTION || _la == Cobol85ParserBYTITLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(3071)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLIBPARAMETER {
		{
			p.SetState(3070)
			p.LibraryAttributeParameter()
		}

	}
	p.SetState(3074)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTITLE {
		{
			p.SetState(3073)
			p.LibraryAttributeTitle()
		}

	}

	return localctx
}

// ILibraryAttributeFunctionContext is an interface to support dynamic dispatch.
type ILibraryAttributeFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeFunctionContext differentiates from other interfaces.
	IsLibraryAttributeFunctionContext()
}

type LibraryAttributeFunctionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeFunctionContext() *LibraryAttributeFunctionContext {
	var p = new(LibraryAttributeFunctionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeFunction
	return p
}

func (*LibraryAttributeFunctionContext) IsLibraryAttributeFunctionContext() {}

func NewLibraryAttributeFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeFunctionContext {
	var p = new(LibraryAttributeFunctionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeFunction

	return p
}

func (s *LibraryAttributeFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeFunctionContext) FUNCTIONNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTIONNAME, 0)
}

func (s *LibraryAttributeFunctionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeFunctionContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeFunction(s)
	}
}

func (s *LibraryAttributeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeFunction(s)
	}
}

func (s *LibraryAttributeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeFunction() (localctx ILibraryAttributeFunctionContext) {
	this := p
	_ = this

	localctx = NewLibraryAttributeFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, Cobol85ParserRULE_libraryAttributeFunction)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3076)
		p.Match(Cobol85ParserFUNCTIONNAME)
	}
	{
		p.SetState(3077)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(3078)
		p.Literal()
	}

	return localctx
}

// ILibraryAttributeParameterContext is an interface to support dynamic dispatch.
type ILibraryAttributeParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeParameterContext differentiates from other interfaces.
	IsLibraryAttributeParameterContext()
}

type LibraryAttributeParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeParameterContext() *LibraryAttributeParameterContext {
	var p = new(LibraryAttributeParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeParameter
	return p
}

func (*LibraryAttributeParameterContext) IsLibraryAttributeParameterContext() {}

func NewLibraryAttributeParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeParameterContext {
	var p = new(LibraryAttributeParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeParameter

	return p
}

func (s *LibraryAttributeParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeParameterContext) LIBPARAMETER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBPARAMETER, 0)
}

func (s *LibraryAttributeParameterContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeParameterContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeParameter(s)
	}
}

func (s *LibraryAttributeParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeParameter(s)
	}
}

func (s *LibraryAttributeParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeParameter() (localctx ILibraryAttributeParameterContext) {
	this := p
	_ = this

	localctx = NewLibraryAttributeParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, Cobol85ParserRULE_libraryAttributeParameter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3080)
		p.Match(Cobol85ParserLIBPARAMETER)
	}
	p.SetState(3082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3081)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3084)
		p.Literal()
	}

	return localctx
}

// ILibraryAttributeTitleContext is an interface to support dynamic dispatch.
type ILibraryAttributeTitleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryAttributeTitleContext differentiates from other interfaces.
	IsLibraryAttributeTitleContext()
}

type LibraryAttributeTitleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryAttributeTitleContext() *LibraryAttributeTitleContext {
	var p = new(LibraryAttributeTitleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeTitle
	return p
}

func (*LibraryAttributeTitleContext) IsLibraryAttributeTitleContext() {}

func NewLibraryAttributeTitleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryAttributeTitleContext {
	var p = new(LibraryAttributeTitleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryAttributeTitle

	return p
}

func (s *LibraryAttributeTitleContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryAttributeTitleContext) TITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTITLE, 0)
}

func (s *LibraryAttributeTitleContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryAttributeTitleContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryAttributeTitleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryAttributeTitleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryAttributeTitleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryAttributeTitle(s)
	}
}

func (s *LibraryAttributeTitleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryAttributeTitle(s)
	}
}

func (s *LibraryAttributeTitleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryAttributeTitle(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryAttributeTitle() (localctx ILibraryAttributeTitleContext) {
	this := p
	_ = this

	localctx = NewLibraryAttributeTitleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, Cobol85ParserRULE_libraryAttributeTitle)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3086)
		p.Match(Cobol85ParserTITLE)
	}
	p.SetState(3088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3087)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3090)
		p.Literal()
	}

	return localctx
}

// ILibraryEntryProcedureClauseFormat1Context is an interface to support dynamic dispatch.
type ILibraryEntryProcedureClauseFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureClauseFormat1Context differentiates from other interfaces.
	IsLibraryEntryProcedureClauseFormat1Context()
}

type LibraryEntryProcedureClauseFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureClauseFormat1Context() *LibraryEntryProcedureClauseFormat1Context {
	var p = new(LibraryEntryProcedureClauseFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat1
	return p
}

func (*LibraryEntryProcedureClauseFormat1Context) IsLibraryEntryProcedureClauseFormat1Context() {}

func NewLibraryEntryProcedureClauseFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureClauseFormat1Context {
	var p = new(LibraryEntryProcedureClauseFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat1

	return p
}

func (s *LibraryEntryProcedureClauseFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureClauseFormat1Context) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *LibraryEntryProcedureClauseFormat1Context) ProgramName() IProgramNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *LibraryEntryProcedureClauseFormat1Context) LibraryEntryProcedureForClause() ILibraryEntryProcedureForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureForClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureClauseFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureClauseFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureClauseFormat1(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureClauseFormat1(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureClauseFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureClauseFormat1() (localctx ILibraryEntryProcedureClauseFormat1Context) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureClauseFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, Cobol85ParserRULE_libraryEntryProcedureClauseFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3092)
		p.Match(Cobol85ParserENTRY_PROCEDURE)
	}
	{
		p.SetState(3093)
		p.ProgramName()
	}
	p.SetState(3095)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(3094)
			p.LibraryEntryProcedureForClause()
		}

	}

	return localctx
}

// ILibraryEntryProcedureClauseFormat2Context is an interface to support dynamic dispatch.
type ILibraryEntryProcedureClauseFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureClauseFormat2Context differentiates from other interfaces.
	IsLibraryEntryProcedureClauseFormat2Context()
}

type LibraryEntryProcedureClauseFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureClauseFormat2Context() *LibraryEntryProcedureClauseFormat2Context {
	var p = new(LibraryEntryProcedureClauseFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat2
	return p
}

func (*LibraryEntryProcedureClauseFormat2Context) IsLibraryEntryProcedureClauseFormat2Context() {}

func NewLibraryEntryProcedureClauseFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureClauseFormat2Context {
	var p = new(LibraryEntryProcedureClauseFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureClauseFormat2

	return p
}

func (s *LibraryEntryProcedureClauseFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureClauseFormat2Context) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *LibraryEntryProcedureClauseFormat2Context) ProgramName() IProgramNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureForClause() ILibraryEntryProcedureForClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureForClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureForClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureWithClause() ILibraryEntryProcedureWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureWithClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureUsingClause() ILibraryEntryProcedureUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureUsingClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) LibraryEntryProcedureGivingClause() ILibraryEntryProcedureGivingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureGivingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureGivingClauseContext)
}

func (s *LibraryEntryProcedureClauseFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureClauseFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureClauseFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureClauseFormat2(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureClauseFormat2(s)
	}
}

func (s *LibraryEntryProcedureClauseFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureClauseFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureClauseFormat2() (localctx ILibraryEntryProcedureClauseFormat2Context) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureClauseFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, Cobol85ParserRULE_libraryEntryProcedureClauseFormat2)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3097)
		p.Match(Cobol85ParserENTRY_PROCEDURE)
	}
	{
		p.SetState(3098)
		p.ProgramName()
	}
	p.SetState(3100)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(3099)
			p.LibraryEntryProcedureForClause()
		}

	}
	p.SetState(3103)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3102)
			p.LibraryEntryProcedureWithClause()
		}

	}
	p.SetState(3106)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3105)
			p.LibraryEntryProcedureUsingClause()
		}

	}
	p.SetState(3109)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(3108)
			p.LibraryEntryProcedureGivingClause()
		}

	}

	return localctx
}

// ILibraryEntryProcedureForClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureForClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureForClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureForClauseContext()
}

type LibraryEntryProcedureForClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureForClauseContext() *LibraryEntryProcedureForClauseContext {
	var p = new(LibraryEntryProcedureForClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureForClause
	return p
}

func (*LibraryEntryProcedureForClauseContext) IsLibraryEntryProcedureForClauseContext() {}

func NewLibraryEntryProcedureForClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureForClauseContext {
	var p = new(LibraryEntryProcedureForClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureForClause

	return p
}

func (s *LibraryEntryProcedureForClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureForClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *LibraryEntryProcedureForClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *LibraryEntryProcedureForClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureForClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureForClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureForClause(s)
	}
}

func (s *LibraryEntryProcedureForClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureForClause(s)
	}
}

func (s *LibraryEntryProcedureForClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureForClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureForClause() (localctx ILibraryEntryProcedureForClauseContext) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureForClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, Cobol85ParserRULE_libraryEntryProcedureForClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3111)
		p.Match(Cobol85ParserFOR)
	}
	{
		p.SetState(3112)
		p.Literal()
	}

	return localctx
}

// ILibraryEntryProcedureGivingClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureGivingClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureGivingClauseContext()
}

type LibraryEntryProcedureGivingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureGivingClauseContext() *LibraryEntryProcedureGivingClauseContext {
	var p = new(LibraryEntryProcedureGivingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureGivingClause
	return p
}

func (*LibraryEntryProcedureGivingClauseContext) IsLibraryEntryProcedureGivingClauseContext() {}

func NewLibraryEntryProcedureGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureGivingClauseContext {
	var p = new(LibraryEntryProcedureGivingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureGivingClause

	return p
}

func (s *LibraryEntryProcedureGivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureGivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *LibraryEntryProcedureGivingClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LibraryEntryProcedureGivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureGivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureGivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureGivingClause(s)
	}
}

func (s *LibraryEntryProcedureGivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureGivingClause(s)
	}
}

func (s *LibraryEntryProcedureGivingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureGivingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureGivingClause() (localctx ILibraryEntryProcedureGivingClauseContext) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, Cobol85ParserRULE_libraryEntryProcedureGivingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3114)
		p.Match(Cobol85ParserGIVING)
	}
	{
		p.SetState(3115)
		p.DataName()
	}

	return localctx
}

// ILibraryEntryProcedureUsingClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureUsingClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureUsingClauseContext()
}

type LibraryEntryProcedureUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureUsingClauseContext() *LibraryEntryProcedureUsingClauseContext {
	var p = new(LibraryEntryProcedureUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingClause
	return p
}

func (*LibraryEntryProcedureUsingClauseContext) IsLibraryEntryProcedureUsingClauseContext() {}

func NewLibraryEntryProcedureUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureUsingClauseContext {
	var p = new(LibraryEntryProcedureUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingClause

	return p
}

func (s *LibraryEntryProcedureUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *LibraryEntryProcedureUsingClauseContext) AllLibraryEntryProcedureUsingName() []ILibraryEntryProcedureUsingNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILibraryEntryProcedureUsingNameContext); ok {
			len++
		}
	}

	tst := make([]ILibraryEntryProcedureUsingNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILibraryEntryProcedureUsingNameContext); ok {
			tst[i] = t.(ILibraryEntryProcedureUsingNameContext)
			i++
		}
	}

	return tst
}

func (s *LibraryEntryProcedureUsingClauseContext) LibraryEntryProcedureUsingName(i int) ILibraryEntryProcedureUsingNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureUsingNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureUsingNameContext)
}

func (s *LibraryEntryProcedureUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureUsingClause(s)
	}
}

func (s *LibraryEntryProcedureUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureUsingClause(s)
	}
}

func (s *LibraryEntryProcedureUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureUsingClause() (localctx ILibraryEntryProcedureUsingClauseContext) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, Cobol85ParserRULE_libraryEntryProcedureUsingClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3117)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3119)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3118)
				p.LibraryEntryProcedureUsingName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3121)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 383, p.GetParserRuleContext())
	}

	return localctx
}

// ILibraryEntryProcedureUsingNameContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureUsingNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureUsingNameContext differentiates from other interfaces.
	IsLibraryEntryProcedureUsingNameContext()
}

type LibraryEntryProcedureUsingNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureUsingNameContext() *LibraryEntryProcedureUsingNameContext {
	var p = new(LibraryEntryProcedureUsingNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingName
	return p
}

func (*LibraryEntryProcedureUsingNameContext) IsLibraryEntryProcedureUsingNameContext() {}

func NewLibraryEntryProcedureUsingNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureUsingNameContext {
	var p = new(LibraryEntryProcedureUsingNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureUsingName

	return p
}

func (s *LibraryEntryProcedureUsingNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureUsingNameContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *LibraryEntryProcedureUsingNameContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *LibraryEntryProcedureUsingNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureUsingNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureUsingNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureUsingName(s)
	}
}

func (s *LibraryEntryProcedureUsingNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureUsingName(s)
	}
}

func (s *LibraryEntryProcedureUsingNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureUsingName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureUsingName() (localctx ILibraryEntryProcedureUsingNameContext) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureUsingNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, Cobol85ParserRULE_libraryEntryProcedureUsingName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3125)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 384, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3123)
			p.DataName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3124)
			p.FileName()
		}

	}

	return localctx
}

// ILibraryEntryProcedureWithClauseContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureWithClauseContext differentiates from other interfaces.
	IsLibraryEntryProcedureWithClauseContext()
}

type LibraryEntryProcedureWithClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureWithClauseContext() *LibraryEntryProcedureWithClauseContext {
	var p = new(LibraryEntryProcedureWithClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithClause
	return p
}

func (*LibraryEntryProcedureWithClauseContext) IsLibraryEntryProcedureWithClauseContext() {}

func NewLibraryEntryProcedureWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureWithClauseContext {
	var p = new(LibraryEntryProcedureWithClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithClause

	return p
}

func (s *LibraryEntryProcedureWithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureWithClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *LibraryEntryProcedureWithClauseContext) AllLibraryEntryProcedureWithName() []ILibraryEntryProcedureWithNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILibraryEntryProcedureWithNameContext); ok {
			len++
		}
	}

	tst := make([]ILibraryEntryProcedureWithNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILibraryEntryProcedureWithNameContext); ok {
			tst[i] = t.(ILibraryEntryProcedureWithNameContext)
			i++
		}
	}

	return tst
}

func (s *LibraryEntryProcedureWithClauseContext) LibraryEntryProcedureWithName(i int) ILibraryEntryProcedureWithNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryEntryProcedureWithNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryEntryProcedureWithNameContext)
}

func (s *LibraryEntryProcedureWithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureWithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureWithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureWithClause(s)
	}
}

func (s *LibraryEntryProcedureWithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureWithClause(s)
	}
}

func (s *LibraryEntryProcedureWithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureWithClause() (localctx ILibraryEntryProcedureWithClauseContext) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, Cobol85ParserRULE_libraryEntryProcedureWithClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3127)
		p.Match(Cobol85ParserWITH)
	}
	p.SetState(3129)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3128)
				p.LibraryEntryProcedureWithName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3131)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 385, p.GetParserRuleContext())
	}

	return localctx
}

// ILibraryEntryProcedureWithNameContext is an interface to support dynamic dispatch.
type ILibraryEntryProcedureWithNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryEntryProcedureWithNameContext differentiates from other interfaces.
	IsLibraryEntryProcedureWithNameContext()
}

type LibraryEntryProcedureWithNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryEntryProcedureWithNameContext() *LibraryEntryProcedureWithNameContext {
	var p = new(LibraryEntryProcedureWithNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithName
	return p
}

func (*LibraryEntryProcedureWithNameContext) IsLibraryEntryProcedureWithNameContext() {}

func NewLibraryEntryProcedureWithNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryEntryProcedureWithNameContext {
	var p = new(LibraryEntryProcedureWithNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryEntryProcedureWithName

	return p
}

func (s *LibraryEntryProcedureWithNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryEntryProcedureWithNameContext) LocalName() ILocalNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalNameContext)
}

func (s *LibraryEntryProcedureWithNameContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *LibraryEntryProcedureWithNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryEntryProcedureWithNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryEntryProcedureWithNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryEntryProcedureWithName(s)
	}
}

func (s *LibraryEntryProcedureWithNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryEntryProcedureWithName(s)
	}
}

func (s *LibraryEntryProcedureWithNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryEntryProcedureWithName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryEntryProcedureWithName() (localctx ILibraryEntryProcedureWithNameContext) {
	this := p
	_ = this

	localctx = NewLibraryEntryProcedureWithNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, Cobol85ParserRULE_libraryEntryProcedureWithName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3135)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 386, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3133)
			p.LocalName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3134)
			p.FileName()
		}

	}

	return localctx
}

// ILibraryIsCommonClauseContext is an interface to support dynamic dispatch.
type ILibraryIsCommonClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryIsCommonClauseContext differentiates from other interfaces.
	IsLibraryIsCommonClauseContext()
}

type LibraryIsCommonClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIsCommonClauseContext() *LibraryIsCommonClauseContext {
	var p = new(LibraryIsCommonClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryIsCommonClause
	return p
}

func (*LibraryIsCommonClauseContext) IsLibraryIsCommonClauseContext() {}

func NewLibraryIsCommonClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIsCommonClauseContext {
	var p = new(LibraryIsCommonClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryIsCommonClause

	return p
}

func (s *LibraryIsCommonClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIsCommonClauseContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *LibraryIsCommonClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryIsCommonClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIsCommonClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIsCommonClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryIsCommonClause(s)
	}
}

func (s *LibraryIsCommonClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryIsCommonClause(s)
	}
}

func (s *LibraryIsCommonClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryIsCommonClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryIsCommonClause() (localctx ILibraryIsCommonClauseContext) {
	this := p
	_ = this

	localctx = NewLibraryIsCommonClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, Cobol85ParserRULE_libraryIsCommonClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3138)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3137)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3140)
		p.Match(Cobol85ParserCOMMON)
	}

	return localctx
}

// ILibraryIsGlobalClauseContext is an interface to support dynamic dispatch.
type ILibraryIsGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryIsGlobalClauseContext differentiates from other interfaces.
	IsLibraryIsGlobalClauseContext()
}

type LibraryIsGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIsGlobalClauseContext() *LibraryIsGlobalClauseContext {
	var p = new(LibraryIsGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryIsGlobalClause
	return p
}

func (*LibraryIsGlobalClauseContext) IsLibraryIsGlobalClauseContext() {}

func NewLibraryIsGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIsGlobalClauseContext {
	var p = new(LibraryIsGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryIsGlobalClause

	return p
}

func (s *LibraryIsGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIsGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *LibraryIsGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *LibraryIsGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIsGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryIsGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryIsGlobalClause(s)
	}
}

func (s *LibraryIsGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryIsGlobalClause(s)
	}
}

func (s *LibraryIsGlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryIsGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryIsGlobalClause() (localctx ILibraryIsGlobalClauseContext) {
	this := p
	_ = this

	localctx = NewLibraryIsGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, Cobol85ParserRULE_libraryIsGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3143)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3142)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3145)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IDataDescriptionEntryContext is an interface to support dynamic dispatch.
type IDataDescriptionEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryContext differentiates from other interfaces.
	IsDataDescriptionEntryContext()
}

type DataDescriptionEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryContext() *DataDescriptionEntryContext {
	var p = new(DataDescriptionEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntry
	return p
}

func (*DataDescriptionEntryContext) IsDataDescriptionEntryContext() {}

func NewDataDescriptionEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryContext {
	var p = new(DataDescriptionEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntry

	return p
}

func (s *DataDescriptionEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat1() IDataDescriptionEntryFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat1Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat2() IDataDescriptionEntryFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat2Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryFormat3() IDataDescriptionEntryFormat3Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryFormat3Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryFormat3Context)
}

func (s *DataDescriptionEntryContext) DataDescriptionEntryExecSql() IDataDescriptionEntryExecSqlContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDescriptionEntryExecSqlContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDescriptionEntryExecSqlContext)
}

func (s *DataDescriptionEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntry(s)
	}
}

func (s *DataDescriptionEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntry(s)
	}
}

func (s *DataDescriptionEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntry() (localctx IDataDescriptionEntryContext) {
	this := p
	_ = this

	localctx = NewDataDescriptionEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, Cobol85ParserRULE_dataDescriptionEntry)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3151)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3147)
			p.DataDescriptionEntryFormat1()
		}

	case Cobol85ParserLEVEL_NUMBER_66:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3148)
			p.DataDescriptionEntryFormat2()
		}

	case Cobol85ParserLEVEL_NUMBER_88:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3149)
			p.DataDescriptionEntryFormat3()
		}

	case Cobol85ParserEXECSQLLINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3150)
			p.DataDescriptionEntryExecSql()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataDescriptionEntryFormat1Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat1Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat1Context()
}

type DataDescriptionEntryFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat1Context() *DataDescriptionEntryFormat1Context {
	var p = new(DataDescriptionEntryFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat1
	return p
}

func (*DataDescriptionEntryFormat1Context) IsDataDescriptionEntryFormat1Context() {}

func NewDataDescriptionEntryFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat1Context {
	var p = new(DataDescriptionEntryFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat1

	return p
}

func (s *DataDescriptionEntryFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat1Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat1Context) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *DataDescriptionEntryFormat1Context) LEVEL_NUMBER_77() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_77, 0)
}

func (s *DataDescriptionEntryFormat1Context) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *DataDescriptionEntryFormat1Context) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataRedefinesClause() []IDataRedefinesClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataRedefinesClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataRedefinesClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataRedefinesClauseContext); ok {
			tst[i] = t.(IDataRedefinesClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataRedefinesClause(i int) IDataRedefinesClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataRedefinesClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataRedefinesClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataIntegerStringClause() []IDataIntegerStringClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataIntegerStringClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataIntegerStringClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataIntegerStringClauseContext); ok {
			tst[i] = t.(IDataIntegerStringClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataIntegerStringClause(i int) IDataIntegerStringClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataIntegerStringClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataIntegerStringClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataExternalClause() []IDataExternalClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataExternalClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataExternalClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataExternalClauseContext); ok {
			tst[i] = t.(IDataExternalClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataExternalClause(i int) IDataExternalClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataExternalClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataExternalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataGlobalClause() []IDataGlobalClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataGlobalClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataGlobalClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataGlobalClauseContext); ok {
			tst[i] = t.(IDataGlobalClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataGlobalClause(i int) IDataGlobalClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataGlobalClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataGlobalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataTypeDefClause() []IDataTypeDefClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeDefClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeDefClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeDefClauseContext); ok {
			tst[i] = t.(IDataTypeDefClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataTypeDefClause(i int) IDataTypeDefClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeDefClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeDefClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataThreadLocalClause() []IDataThreadLocalClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataThreadLocalClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataThreadLocalClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataThreadLocalClauseContext); ok {
			tst[i] = t.(IDataThreadLocalClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataThreadLocalClause(i int) IDataThreadLocalClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataThreadLocalClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataThreadLocalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataPictureClause() []IDataPictureClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataPictureClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataPictureClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataPictureClauseContext); ok {
			tst[i] = t.(IDataPictureClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataPictureClause(i int) IDataPictureClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataPictureClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataPictureClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataCommonOwnLocalClause() []IDataCommonOwnLocalClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataCommonOwnLocalClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataCommonOwnLocalClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataCommonOwnLocalClauseContext); ok {
			tst[i] = t.(IDataCommonOwnLocalClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataCommonOwnLocalClause(i int) IDataCommonOwnLocalClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataCommonOwnLocalClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataCommonOwnLocalClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataTypeClause() []IDataTypeClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataTypeClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataTypeClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataTypeClauseContext); ok {
			tst[i] = t.(IDataTypeClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataTypeClause(i int) IDataTypeClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataUsingClause() []IDataUsingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataUsingClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataUsingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataUsingClauseContext); ok {
			tst[i] = t.(IDataUsingClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataUsingClause(i int) IDataUsingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataUsingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataUsingClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataUsageClause() []IDataUsageClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataUsageClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataUsageClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataUsageClauseContext); ok {
			tst[i] = t.(IDataUsageClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataUsageClause(i int) IDataUsageClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataUsageClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataUsageClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataValueClause() []IDataValueClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataValueClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataValueClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataValueClauseContext); ok {
			tst[i] = t.(IDataValueClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataValueClause(i int) IDataValueClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataValueClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataValueClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataReceivedByClause() []IDataReceivedByClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataReceivedByClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataReceivedByClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataReceivedByClauseContext); ok {
			tst[i] = t.(IDataReceivedByClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataReceivedByClause(i int) IDataReceivedByClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataReceivedByClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataReceivedByClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataOccursClause() []IDataOccursClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataOccursClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataOccursClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataOccursClauseContext); ok {
			tst[i] = t.(IDataOccursClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataOccursClause(i int) IDataOccursClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataOccursClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataOccursClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataSignClause() []IDataSignClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataSignClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataSignClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataSignClauseContext); ok {
			tst[i] = t.(IDataSignClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataSignClause(i int) IDataSignClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSignClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSignClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataSynchronizedClause() []IDataSynchronizedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataSynchronizedClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataSynchronizedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataSynchronizedClauseContext); ok {
			tst[i] = t.(IDataSynchronizedClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataSynchronizedClause(i int) IDataSynchronizedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataSynchronizedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataSynchronizedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataJustifiedClause() []IDataJustifiedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataJustifiedClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataJustifiedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataJustifiedClauseContext); ok {
			tst[i] = t.(IDataJustifiedClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataJustifiedClause(i int) IDataJustifiedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataJustifiedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataJustifiedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataBlankWhenZeroClause() []IDataBlankWhenZeroClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataBlankWhenZeroClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataBlankWhenZeroClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataBlankWhenZeroClauseContext); ok {
			tst[i] = t.(IDataBlankWhenZeroClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataBlankWhenZeroClause(i int) IDataBlankWhenZeroClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataBlankWhenZeroClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataBlankWhenZeroClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataWithLowerBoundsClause() []IDataWithLowerBoundsClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataWithLowerBoundsClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataWithLowerBoundsClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataWithLowerBoundsClauseContext); ok {
			tst[i] = t.(IDataWithLowerBoundsClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataWithLowerBoundsClause(i int) IDataWithLowerBoundsClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataWithLowerBoundsClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataWithLowerBoundsClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataAlignedClause() []IDataAlignedClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataAlignedClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataAlignedClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataAlignedClauseContext); ok {
			tst[i] = t.(IDataAlignedClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataAlignedClause(i int) IDataAlignedClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataAlignedClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataAlignedClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) AllDataRecordAreaClause() []IDataRecordAreaClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataRecordAreaClauseContext); ok {
			len++
		}
	}

	tst := make([]IDataRecordAreaClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataRecordAreaClauseContext); ok {
			tst[i] = t.(IDataRecordAreaClauseContext)
			i++
		}
	}

	return tst
}

func (s *DataDescriptionEntryFormat1Context) DataRecordAreaClause(i int) IDataRecordAreaClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataRecordAreaClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataRecordAreaClauseContext)
}

func (s *DataDescriptionEntryFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat1(s)
	}
}

func (s *DataDescriptionEntryFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat1(s)
	}
}

func (s *DataDescriptionEntryFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat1() (localctx IDataDescriptionEntryFormat1Context) {
	this := p
	_ = this

	localctx = NewDataDescriptionEntryFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, Cobol85ParserRULE_dataDescriptionEntryFormat1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3153)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEVEL_NUMBER_77 || _la == Cobol85ParserINTEGERLITERAL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3154)
			p.Match(Cobol85ParserFILLER)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 390, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3155)
			p.DataName()
		}

	}
	p.SetState(3181)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3513579973275288322) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070460708250187267) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339579) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3030640695327893497) != 0 || (int64((_la-266)) & ^0x3f) == 0 && ((int64(1)<<(_la-266))&119808148288963029) != 0 || (int64((_la-331)) & ^0x3f) == 0 && ((int64(1)<<(_la-331))&1168232970228959457) != 0 || (int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&2319355586216591369) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572299384177393805) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		p.SetState(3179)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 391, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3158)
				p.DataRedefinesClause()
			}

		case 2:
			{
				p.SetState(3159)
				p.DataIntegerStringClause()
			}

		case 3:
			{
				p.SetState(3160)
				p.DataExternalClause()
			}

		case 4:
			{
				p.SetState(3161)
				p.DataGlobalClause()
			}

		case 5:
			{
				p.SetState(3162)
				p.DataTypeDefClause()
			}

		case 6:
			{
				p.SetState(3163)
				p.DataThreadLocalClause()
			}

		case 7:
			{
				p.SetState(3164)
				p.DataPictureClause()
			}

		case 8:
			{
				p.SetState(3165)
				p.DataCommonOwnLocalClause()
			}

		case 9:
			{
				p.SetState(3166)
				p.DataTypeClause()
			}

		case 10:
			{
				p.SetState(3167)
				p.DataUsingClause()
			}

		case 11:
			{
				p.SetState(3168)
				p.DataUsageClause()
			}

		case 12:
			{
				p.SetState(3169)
				p.DataValueClause()
			}

		case 13:
			{
				p.SetState(3170)
				p.DataReceivedByClause()
			}

		case 14:
			{
				p.SetState(3171)
				p.DataOccursClause()
			}

		case 15:
			{
				p.SetState(3172)
				p.DataSignClause()
			}

		case 16:
			{
				p.SetState(3173)
				p.DataSynchronizedClause()
			}

		case 17:
			{
				p.SetState(3174)
				p.DataJustifiedClause()
			}

		case 18:
			{
				p.SetState(3175)
				p.DataBlankWhenZeroClause()
			}

		case 19:
			{
				p.SetState(3176)
				p.DataWithLowerBoundsClause()
			}

		case 20:
			{
				p.SetState(3177)
				p.DataAlignedClause()
			}

		case 21:
			{
				p.SetState(3178)
				p.DataRecordAreaClause()
			}

		}

		p.SetState(3183)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3184)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryFormat2Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat2Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat2Context()
}

type DataDescriptionEntryFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat2Context() *DataDescriptionEntryFormat2Context {
	var p = new(DataDescriptionEntryFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat2
	return p
}

func (*DataDescriptionEntryFormat2Context) IsDataDescriptionEntryFormat2Context() {}

func NewDataDescriptionEntryFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat2Context {
	var p = new(DataDescriptionEntryFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat2

	return p
}

func (s *DataDescriptionEntryFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat2Context) LEVEL_NUMBER_66() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_66, 0)
}

func (s *DataDescriptionEntryFormat2Context) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescriptionEntryFormat2Context) DataRenamesClause() IDataRenamesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataRenamesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataRenamesClauseContext)
}

func (s *DataDescriptionEntryFormat2Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat2(s)
	}
}

func (s *DataDescriptionEntryFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat2(s)
	}
}

func (s *DataDescriptionEntryFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat2() (localctx IDataDescriptionEntryFormat2Context) {
	this := p
	_ = this

	localctx = NewDataDescriptionEntryFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, Cobol85ParserRULE_dataDescriptionEntryFormat2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3186)
		p.Match(Cobol85ParserLEVEL_NUMBER_66)
	}
	{
		p.SetState(3187)
		p.DataName()
	}
	{
		p.SetState(3188)
		p.DataRenamesClause()
	}
	{
		p.SetState(3189)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryFormat3Context is an interface to support dynamic dispatch.
type IDataDescriptionEntryFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryFormat3Context differentiates from other interfaces.
	IsDataDescriptionEntryFormat3Context()
}

type DataDescriptionEntryFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryFormat3Context() *DataDescriptionEntryFormat3Context {
	var p = new(DataDescriptionEntryFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat3
	return p
}

func (*DataDescriptionEntryFormat3Context) IsDataDescriptionEntryFormat3Context() {}

func NewDataDescriptionEntryFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryFormat3Context {
	var p = new(DataDescriptionEntryFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryFormat3

	return p
}

func (s *DataDescriptionEntryFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryFormat3Context) LEVEL_NUMBER_88() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_88, 0)
}

func (s *DataDescriptionEntryFormat3Context) ConditionName() IConditionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *DataDescriptionEntryFormat3Context) DataValueClause() IDataValueClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataValueClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataValueClauseContext)
}

func (s *DataDescriptionEntryFormat3Context) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryFormat3(s)
	}
}

func (s *DataDescriptionEntryFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryFormat3(s)
	}
}

func (s *DataDescriptionEntryFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryFormat3() (localctx IDataDescriptionEntryFormat3Context) {
	this := p
	_ = this

	localctx = NewDataDescriptionEntryFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, Cobol85ParserRULE_dataDescriptionEntryFormat3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3191)
		p.Match(Cobol85ParserLEVEL_NUMBER_88)
	}
	{
		p.SetState(3192)
		p.ConditionName()
	}
	{
		p.SetState(3193)
		p.DataValueClause()
	}
	{
		p.SetState(3194)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IDataDescriptionEntryExecSqlContext is an interface to support dynamic dispatch.
type IDataDescriptionEntryExecSqlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescriptionEntryExecSqlContext differentiates from other interfaces.
	IsDataDescriptionEntryExecSqlContext()
}

type DataDescriptionEntryExecSqlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescriptionEntryExecSqlContext() *DataDescriptionEntryExecSqlContext {
	var p = new(DataDescriptionEntryExecSqlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryExecSql
	return p
}

func (*DataDescriptionEntryExecSqlContext) IsDataDescriptionEntryExecSqlContext() {}

func NewDataDescriptionEntryExecSqlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescriptionEntryExecSqlContext {
	var p = new(DataDescriptionEntryExecSqlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescriptionEntryExecSql

	return p
}

func (s *DataDescriptionEntryExecSqlContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescriptionEntryExecSqlContext) AllEXECSQLLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLLINE)
}

func (s *DataDescriptionEntryExecSqlContext) EXECSQLLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLLINE, i)
}

func (s *DataDescriptionEntryExecSqlContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *DataDescriptionEntryExecSqlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescriptionEntryExecSqlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescriptionEntryExecSqlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescriptionEntryExecSql(s)
	}
}

func (s *DataDescriptionEntryExecSqlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescriptionEntryExecSql(s)
	}
}

func (s *DataDescriptionEntryExecSqlContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescriptionEntryExecSql(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescriptionEntryExecSql() (localctx IDataDescriptionEntryExecSqlContext) {
	this := p
	_ = this

	localctx = NewDataDescriptionEntryExecSqlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, Cobol85ParserRULE_dataDescriptionEntryExecSql)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3196)
				p.Match(Cobol85ParserEXECSQLLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3199)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 393, p.GetParserRuleContext())
	}
	p.SetState(3202)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDOT_FS {
		{
			p.SetState(3201)
			p.Match(Cobol85ParserDOT_FS)
		}

	}

	return localctx
}

// IDataAlignedClauseContext is an interface to support dynamic dispatch.
type IDataAlignedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataAlignedClauseContext differentiates from other interfaces.
	IsDataAlignedClauseContext()
}

type DataAlignedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataAlignedClauseContext() *DataAlignedClauseContext {
	var p = new(DataAlignedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataAlignedClause
	return p
}

func (*DataAlignedClauseContext) IsDataAlignedClauseContext() {}

func NewDataAlignedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataAlignedClauseContext {
	var p = new(DataAlignedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataAlignedClause

	return p
}

func (s *DataAlignedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataAlignedClauseContext) ALIGNED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALIGNED, 0)
}

func (s *DataAlignedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataAlignedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataAlignedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataAlignedClause(s)
	}
}

func (s *DataAlignedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataAlignedClause(s)
	}
}

func (s *DataAlignedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataAlignedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataAlignedClause() (localctx IDataAlignedClauseContext) {
	this := p
	_ = this

	localctx = NewDataAlignedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, Cobol85ParserRULE_dataAlignedClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3204)
		p.Match(Cobol85ParserALIGNED)
	}

	return localctx
}

// IDataBlankWhenZeroClauseContext is an interface to support dynamic dispatch.
type IDataBlankWhenZeroClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataBlankWhenZeroClauseContext differentiates from other interfaces.
	IsDataBlankWhenZeroClauseContext()
}

type DataBlankWhenZeroClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataBlankWhenZeroClauseContext() *DataBlankWhenZeroClauseContext {
	var p = new(DataBlankWhenZeroClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataBlankWhenZeroClause
	return p
}

func (*DataBlankWhenZeroClauseContext) IsDataBlankWhenZeroClauseContext() {}

func NewDataBlankWhenZeroClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataBlankWhenZeroClauseContext {
	var p = new(DataBlankWhenZeroClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataBlankWhenZeroClause

	return p
}

func (s *DataBlankWhenZeroClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataBlankWhenZeroClauseContext) BLANK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLANK, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZEROS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROS, 0)
}

func (s *DataBlankWhenZeroClauseContext) ZEROES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROES, 0)
}

func (s *DataBlankWhenZeroClauseContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *DataBlankWhenZeroClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataBlankWhenZeroClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataBlankWhenZeroClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataBlankWhenZeroClause(s)
	}
}

func (s *DataBlankWhenZeroClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataBlankWhenZeroClause(s)
	}
}

func (s *DataBlankWhenZeroClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataBlankWhenZeroClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataBlankWhenZeroClause() (localctx IDataBlankWhenZeroClauseContext) {
	this := p
	_ = this

	localctx = NewDataBlankWhenZeroClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, Cobol85ParserRULE_dataBlankWhenZeroClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3206)
		p.Match(Cobol85ParserBLANK)
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWHEN {
		{
			p.SetState(3207)
			p.Match(Cobol85ParserWHEN)
		}

	}
	{
		p.SetState(3210)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-521)) & ^0x3f) == 0 && ((int64(1)<<(_la-521))&13) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataCommonOwnLocalClauseContext is an interface to support dynamic dispatch.
type IDataCommonOwnLocalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataCommonOwnLocalClauseContext differentiates from other interfaces.
	IsDataCommonOwnLocalClauseContext()
}

type DataCommonOwnLocalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataCommonOwnLocalClauseContext() *DataCommonOwnLocalClauseContext {
	var p = new(DataCommonOwnLocalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataCommonOwnLocalClause
	return p
}

func (*DataCommonOwnLocalClauseContext) IsDataCommonOwnLocalClauseContext() {}

func NewDataCommonOwnLocalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataCommonOwnLocalClauseContext {
	var p = new(DataCommonOwnLocalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataCommonOwnLocalClause

	return p
}

func (s *DataCommonOwnLocalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataCommonOwnLocalClauseContext) COMMON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMON, 0)
}

func (s *DataCommonOwnLocalClauseContext) OWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOWN, 0)
}

func (s *DataCommonOwnLocalClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *DataCommonOwnLocalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataCommonOwnLocalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataCommonOwnLocalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataCommonOwnLocalClause(s)
	}
}

func (s *DataCommonOwnLocalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataCommonOwnLocalClause(s)
	}
}

func (s *DataCommonOwnLocalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataCommonOwnLocalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataCommonOwnLocalClause() (localctx IDataCommonOwnLocalClauseContext) {
	this := p
	_ = this

	localctx = NewDataCommonOwnLocalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, Cobol85ParserRULE_dataCommonOwnLocalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3212)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCOMMON || _la == Cobol85ParserLOCAL || _la == Cobol85ParserOWN) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataExternalClauseContext is an interface to support dynamic dispatch.
type IDataExternalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataExternalClauseContext differentiates from other interfaces.
	IsDataExternalClauseContext()
}

type DataExternalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataExternalClauseContext() *DataExternalClauseContext {
	var p = new(DataExternalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataExternalClause
	return p
}

func (*DataExternalClauseContext) IsDataExternalClauseContext() {}

func NewDataExternalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataExternalClauseContext {
	var p = new(DataExternalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataExternalClause

	return p
}

func (s *DataExternalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataExternalClauseContext) EXTERNAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTERNAL, 0)
}

func (s *DataExternalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataExternalClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataExternalClauseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataExternalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataExternalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataExternalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataExternalClause(s)
	}
}

func (s *DataExternalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataExternalClause(s)
	}
}

func (s *DataExternalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataExternalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataExternalClause() (localctx IDataExternalClauseContext) {
	this := p
	_ = this

	localctx = NewDataExternalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, Cobol85ParserRULE_dataExternalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3214)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3217)
		p.Match(Cobol85ParserEXTERNAL)
	}
	p.SetState(3220)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 397, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3218)
			p.Match(Cobol85ParserBY)
		}
		{
			p.SetState(3219)
			p.Literal()
		}

	}

	return localctx
}

// IDataGlobalClauseContext is an interface to support dynamic dispatch.
type IDataGlobalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataGlobalClauseContext differentiates from other interfaces.
	IsDataGlobalClauseContext()
}

type DataGlobalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataGlobalClauseContext() *DataGlobalClauseContext {
	var p = new(DataGlobalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataGlobalClause
	return p
}

func (*DataGlobalClauseContext) IsDataGlobalClauseContext() {}

func NewDataGlobalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataGlobalClauseContext {
	var p = new(DataGlobalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataGlobalClause

	return p
}

func (s *DataGlobalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataGlobalClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *DataGlobalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataGlobalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataGlobalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataGlobalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataGlobalClause(s)
	}
}

func (s *DataGlobalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataGlobalClause(s)
	}
}

func (s *DataGlobalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataGlobalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataGlobalClause() (localctx IDataGlobalClauseContext) {
	this := p
	_ = this

	localctx = NewDataGlobalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, Cobol85ParserRULE_dataGlobalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3223)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3222)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3225)
		p.Match(Cobol85ParserGLOBAL)
	}

	return localctx
}

// IDataIntegerStringClauseContext is an interface to support dynamic dispatch.
type IDataIntegerStringClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataIntegerStringClauseContext differentiates from other interfaces.
	IsDataIntegerStringClauseContext()
}

type DataIntegerStringClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataIntegerStringClauseContext() *DataIntegerStringClauseContext {
	var p = new(DataIntegerStringClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataIntegerStringClause
	return p
}

func (*DataIntegerStringClauseContext) IsDataIntegerStringClauseContext() {}

func NewDataIntegerStringClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataIntegerStringClauseContext {
	var p = new(DataIntegerStringClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataIntegerStringClause

	return p
}

func (s *DataIntegerStringClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataIntegerStringClauseContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *DataIntegerStringClauseContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *DataIntegerStringClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataIntegerStringClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataIntegerStringClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataIntegerStringClause(s)
	}
}

func (s *DataIntegerStringClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataIntegerStringClause(s)
	}
}

func (s *DataIntegerStringClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataIntegerStringClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataIntegerStringClause() (localctx IDataIntegerStringClauseContext) {
	this := p
	_ = this

	localctx = NewDataIntegerStringClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, Cobol85ParserRULE_dataIntegerStringClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserINTEGER || _la == Cobol85ParserSTRING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataJustifiedClauseContext is an interface to support dynamic dispatch.
type IDataJustifiedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataJustifiedClauseContext differentiates from other interfaces.
	IsDataJustifiedClauseContext()
}

type DataJustifiedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataJustifiedClauseContext() *DataJustifiedClauseContext {
	var p = new(DataJustifiedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataJustifiedClause
	return p
}

func (*DataJustifiedClauseContext) IsDataJustifiedClauseContext() {}

func NewDataJustifiedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataJustifiedClauseContext {
	var p = new(DataJustifiedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataJustifiedClause

	return p
}

func (s *DataJustifiedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataJustifiedClauseContext) JUSTIFIED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUSTIFIED, 0)
}

func (s *DataJustifiedClauseContext) JUST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserJUST, 0)
}

func (s *DataJustifiedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *DataJustifiedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataJustifiedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataJustifiedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataJustifiedClause(s)
	}
}

func (s *DataJustifiedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataJustifiedClause(s)
	}
}

func (s *DataJustifiedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataJustifiedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataJustifiedClause() (localctx IDataJustifiedClauseContext) {
	this := p
	_ = this

	localctx = NewDataJustifiedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, Cobol85ParserRULE_dataJustifiedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3229)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserJUST || _la == Cobol85ParserJUSTIFIED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3231)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRIGHT {
		{
			p.SetState(3230)
			p.Match(Cobol85ParserRIGHT)
		}

	}

	return localctx
}

// IDataOccursClauseContext is an interface to support dynamic dispatch.
type IDataOccursClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursClauseContext differentiates from other interfaces.
	IsDataOccursClauseContext()
}

type DataOccursClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursClauseContext() *DataOccursClauseContext {
	var p = new(DataOccursClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursClause
	return p
}

func (*DataOccursClauseContext) IsDataOccursClauseContext() {}

func NewDataOccursClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursClauseContext {
	var p = new(DataOccursClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursClause

	return p
}

func (s *DataOccursClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursClauseContext) OCCURS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOCCURS, 0)
}

func (s *DataOccursClauseContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataOccursClauseContext) DataOccursTo() IDataOccursToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataOccursToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataOccursToContext)
}

func (s *DataOccursClauseContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *DataOccursClauseContext) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *DataOccursClauseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataOccursClauseContext) AllDataOccursSort() []IDataOccursSortContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataOccursSortContext); ok {
			len++
		}
	}

	tst := make([]IDataOccursSortContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataOccursSortContext); ok {
			tst[i] = t.(IDataOccursSortContext)
			i++
		}
	}

	return tst
}

func (s *DataOccursClauseContext) DataOccursSort(i int) IDataOccursSortContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataOccursSortContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataOccursSortContext)
}

func (s *DataOccursClauseContext) INDEXED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEXED, 0)
}

func (s *DataOccursClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *DataOccursClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataOccursClauseContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *DataOccursClauseContext) AllIndexName() []IIndexNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexNameContext); ok {
			len++
		}
	}

	tst := make([]IIndexNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexNameContext); ok {
			tst[i] = t.(IIndexNameContext)
			i++
		}
	}

	return tst
}

func (s *DataOccursClauseContext) IndexName(i int) IIndexNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *DataOccursClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursClause(s)
	}
}

func (s *DataOccursClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursClause(s)
	}
}

func (s *DataOccursClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataOccursClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataOccursClause() (localctx IDataOccursClauseContext) {
	this := p
	_ = this

	localctx = NewDataOccursClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, Cobol85ParserRULE_dataOccursClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3233)
		p.Match(Cobol85ParserOCCURS)
	}
	{
		p.SetState(3234)
		p.IntegerLiteral()
	}
	p.SetState(3236)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3235)
			p.DataOccursTo()
		}

	}
	p.SetState(3239)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTIMES {
		{
			p.SetState(3238)
			p.Match(Cobol85ParserTIMES)
		}

	}
	p.SetState(3246)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDEPENDING {
		{
			p.SetState(3241)
			p.Match(Cobol85ParserDEPENDING)
		}
		p.SetState(3243)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserON {
			{
				p.SetState(3242)
				p.Match(Cobol85ParserON)
			}

		}
		{
			p.SetState(3245)
			p.QualifiedDataName()
		}

	}
	p.SetState(3251)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING {
		{
			p.SetState(3248)
			p.DataOccursSort()
		}

		p.SetState(3253)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3266)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINDEXED {
		{
			p.SetState(3254)
			p.Match(Cobol85ParserINDEXED)
		}
		p.SetState(3256)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3255)
				p.Match(Cobol85ParserBY)
			}

		}
		p.SetState(3259)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3258)
				p.Match(Cobol85ParserLOCAL)
			}

		}
		p.SetState(3262)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3261)
					p.IndexName()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3264)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 407, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IDataOccursToContext is an interface to support dynamic dispatch.
type IDataOccursToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursToContext differentiates from other interfaces.
	IsDataOccursToContext()
}

type DataOccursToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursToContext() *DataOccursToContext {
	var p = new(DataOccursToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursTo
	return p
}

func (*DataOccursToContext) IsDataOccursToContext() {}

func NewDataOccursToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursToContext {
	var p = new(DataOccursToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursTo

	return p
}

func (s *DataOccursToContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *DataOccursToContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *DataOccursToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursTo(s)
	}
}

func (s *DataOccursToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursTo(s)
	}
}

func (s *DataOccursToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataOccursTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataOccursTo() (localctx IDataOccursToContext) {
	this := p
	_ = this

	localctx = NewDataOccursToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, Cobol85ParserRULE_dataOccursTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3268)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(3269)
		p.IntegerLiteral()
	}

	return localctx
}

// IDataOccursSortContext is an interface to support dynamic dispatch.
type IDataOccursSortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataOccursSortContext differentiates from other interfaces.
	IsDataOccursSortContext()
}

type DataOccursSortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataOccursSortContext() *DataOccursSortContext {
	var p = new(DataOccursSortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataOccursSort
	return p
}

func (*DataOccursSortContext) IsDataOccursSortContext() {}

func NewDataOccursSortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataOccursSortContext {
	var p = new(DataOccursSortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataOccursSort

	return p
}

func (s *DataOccursSortContext) GetParser() antlr.Parser { return s.parser }

func (s *DataOccursSortContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *DataOccursSortContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *DataOccursSortContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *DataOccursSortContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataOccursSortContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedDataNameContext); ok {
			tst[i] = t.(IQualifiedDataNameContext)
			i++
		}
	}

	return tst
}

func (s *DataOccursSortContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataOccursSortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataOccursSortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataOccursSortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataOccursSort(s)
	}
}

func (s *DataOccursSortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataOccursSort(s)
	}
}

func (s *DataOccursSortContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataOccursSort(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataOccursSort() (localctx IDataOccursSortContext) {
	this := p
	_ = this

	localctx = NewDataOccursSortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, Cobol85ParserRULE_dataOccursSort)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3271)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3273)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(3272)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(3276)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3275)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(3279)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3278)
				p.QualifiedDataName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3281)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 411, p.GetParserRuleContext())
	}

	return localctx
}

// IDataPictureClauseContext is an interface to support dynamic dispatch.
type IDataPictureClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataPictureClauseContext differentiates from other interfaces.
	IsDataPictureClauseContext()
}

type DataPictureClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataPictureClauseContext() *DataPictureClauseContext {
	var p = new(DataPictureClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataPictureClause
	return p
}

func (*DataPictureClauseContext) IsDataPictureClauseContext() {}

func NewDataPictureClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataPictureClauseContext {
	var p = new(DataPictureClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataPictureClause

	return p
}

func (s *DataPictureClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataPictureClauseContext) PictureString() IPictureStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureStringContext)
}

func (s *DataPictureClauseContext) PICTURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPICTURE, 0)
}

func (s *DataPictureClauseContext) PIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPIC, 0)
}

func (s *DataPictureClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataPictureClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataPictureClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataPictureClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataPictureClause(s)
	}
}

func (s *DataPictureClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataPictureClause(s)
	}
}

func (s *DataPictureClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataPictureClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataPictureClause() (localctx IDataPictureClauseContext) {
	this := p
	_ = this

	localctx = NewDataPictureClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, Cobol85ParserRULE_dataPictureClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3283)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserPIC || _la == Cobol85ParserPICTURE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3285)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3284)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3287)
		p.PictureString()
	}

	return localctx
}

// IPictureStringContext is an interface to support dynamic dispatch.
type IPictureStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureStringContext differentiates from other interfaces.
	IsPictureStringContext()
}

type PictureStringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureStringContext() *PictureStringContext {
	var p = new(PictureStringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureString
	return p
}

func (*PictureStringContext) IsPictureStringContext() {}

func NewPictureStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureStringContext {
	var p = new(PictureStringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureString

	return p
}

func (s *PictureStringContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureStringContext) AllPictureChars() []IPictureCharsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPictureCharsContext); ok {
			len++
		}
	}

	tst := make([]IPictureCharsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPictureCharsContext); ok {
			tst[i] = t.(IPictureCharsContext)
			i++
		}
	}

	return tst
}

func (s *PictureStringContext) PictureChars(i int) IPictureCharsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureCharsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureCharsContext)
}

func (s *PictureStringContext) AllPictureCardinality() []IPictureCardinalityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPictureCardinalityContext); ok {
			len++
		}
	}

	tst := make([]IPictureCardinalityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPictureCardinalityContext); ok {
			tst[i] = t.(IPictureCardinalityContext)
			i++
		}
	}

	return tst
}

func (s *PictureStringContext) PictureCardinality(i int) IPictureCardinalityContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPictureCardinalityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPictureCardinalityContext)
}

func (s *PictureStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureString(s)
	}
}

func (s *PictureStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureString(s)
	}
}

func (s *PictureStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureString() (localctx IPictureStringContext) {
	this := p
	_ = this

	localctx = NewPictureStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, Cobol85ParserRULE_pictureString)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3297)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(3290)
			p.GetErrorHandler().Sync(p)
			_alt = 1
			for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
				switch _alt {
				case 1:
					{
						p.SetState(3289)
						p.PictureChars()
					}

				default:
					panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				}

				p.SetState(3292)
				p.GetErrorHandler().Sync(p)
				_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 413, p.GetParserRuleContext())
			}
			p.SetState(3295)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 414, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3294)
					p.PictureCardinality()
				}

			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3299)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 415, p.GetParserRuleContext())
	}

	return localctx
}

// IPictureCharsContext is an interface to support dynamic dispatch.
type IPictureCharsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCharsContext differentiates from other interfaces.
	IsPictureCharsContext()
}

type PictureCharsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCharsContext() *PictureCharsContext {
	var p = new(PictureCharsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureChars
	return p
}

func (*PictureCharsContext) IsPictureCharsContext() {}

func NewPictureCharsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCharsContext {
	var p = new(PictureCharsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureChars

	return p
}

func (s *PictureCharsContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCharsContext) DOLLARCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOLLARCHAR, 0)
}

func (s *PictureCharsContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFIER, 0)
}

func (s *PictureCharsContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERICLITERAL, 0)
}

func (s *PictureCharsContext) SLASHCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSLASHCHAR, 0)
}

func (s *PictureCharsContext) COMMACHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, 0)
}

func (s *PictureCharsContext) DOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT, 0)
}

func (s *PictureCharsContext) COLONCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLONCHAR, 0)
}

func (s *PictureCharsContext) ASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASTERISKCHAR, 0)
}

func (s *PictureCharsContext) DOUBLEASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLEASTERISKCHAR, 0)
}

func (s *PictureCharsContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *PictureCharsContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *PictureCharsContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PictureCharsContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PictureCharsContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *PictureCharsContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *PictureCharsContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PictureCharsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCharsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCharsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureChars(s)
	}
}

func (s *PictureCharsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureChars(s)
	}
}

func (s *PictureCharsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureChars(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureChars() (localctx IPictureCharsContext) {
	this := p
	_ = this

	localctx = NewPictureCharsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, Cobol85ParserRULE_pictureChars)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDOLLARCHAR:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3301)
			p.Match(Cobol85ParserDOLLARCHAR)
		}

	case Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3302)
			p.Match(Cobol85ParserIDENTIFIER)
		}

	case Cobol85ParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3303)
			p.Match(Cobol85ParserNUMERICLITERAL)
		}

	case Cobol85ParserSLASHCHAR:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3304)
			p.Match(Cobol85ParserSLASHCHAR)
		}

	case Cobol85ParserCOMMACHAR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3305)
			p.Match(Cobol85ParserCOMMACHAR)
		}

	case Cobol85ParserDOT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3306)
			p.Match(Cobol85ParserDOT)
		}

	case Cobol85ParserCOLONCHAR:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3307)
			p.Match(Cobol85ParserCOLONCHAR)
		}

	case Cobol85ParserASTERISKCHAR:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3308)
			p.Match(Cobol85ParserASTERISKCHAR)
		}

	case Cobol85ParserDOUBLEASTERISKCHAR:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3309)
			p.Match(Cobol85ParserDOUBLEASTERISKCHAR)
		}

	case Cobol85ParserLPARENCHAR:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3310)
			p.Match(Cobol85ParserLPARENCHAR)
		}

	case Cobol85ParserRPARENCHAR:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3311)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case Cobol85ParserPLUSCHAR:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3312)
			p.Match(Cobol85ParserPLUSCHAR)
		}

	case Cobol85ParserMINUSCHAR:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3313)
			p.Match(Cobol85ParserMINUSCHAR)
		}

	case Cobol85ParserLESSTHANCHAR:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3314)
			p.Match(Cobol85ParserLESSTHANCHAR)
		}

	case Cobol85ParserMORETHANCHAR:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3315)
			p.Match(Cobol85ParserMORETHANCHAR)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3316)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPictureCardinalityContext is an interface to support dynamic dispatch.
type IPictureCardinalityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPictureCardinalityContext differentiates from other interfaces.
	IsPictureCardinalityContext()
}

type PictureCardinalityContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPictureCardinalityContext() *PictureCardinalityContext {
	var p = new(PictureCardinalityContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_pictureCardinality
	return p
}

func (*PictureCardinalityContext) IsPictureCardinalityContext() {}

func NewPictureCardinalityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PictureCardinalityContext {
	var p = new(PictureCardinalityContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_pictureCardinality

	return p
}

func (s *PictureCardinalityContext) GetParser() antlr.Parser { return s.parser }

func (s *PictureCardinalityContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *PictureCardinalityContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PictureCardinalityContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *PictureCardinalityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PictureCardinalityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PictureCardinalityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPictureCardinality(s)
	}
}

func (s *PictureCardinalityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPictureCardinality(s)
	}
}

func (s *PictureCardinalityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPictureCardinality(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PictureCardinality() (localctx IPictureCardinalityContext) {
	this := p
	_ = this

	localctx = NewPictureCardinalityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, Cobol85ParserRULE_pictureCardinality)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3319)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(3320)
		p.IntegerLiteral()
	}
	{
		p.SetState(3321)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IDataReceivedByClauseContext is an interface to support dynamic dispatch.
type IDataReceivedByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataReceivedByClauseContext differentiates from other interfaces.
	IsDataReceivedByClauseContext()
}

type DataReceivedByClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataReceivedByClauseContext() *DataReceivedByClauseContext {
	var p = new(DataReceivedByClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataReceivedByClause
	return p
}

func (*DataReceivedByClauseContext) IsDataReceivedByClauseContext() {}

func NewDataReceivedByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataReceivedByClauseContext {
	var p = new(DataReceivedByClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataReceivedByClause

	return p
}

func (s *DataReceivedByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataReceivedByClauseContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTENT, 0)
}

func (s *DataReceivedByClauseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *DataReceivedByClauseContext) REF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREF, 0)
}

func (s *DataReceivedByClauseContext) RECEIVED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVED, 0)
}

func (s *DataReceivedByClauseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DataReceivedByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataReceivedByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataReceivedByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataReceivedByClause(s)
	}
}

func (s *DataReceivedByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataReceivedByClause(s)
	}
}

func (s *DataReceivedByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataReceivedByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataReceivedByClause() (localctx IDataReceivedByClauseContext) {
	this := p
	_ = this

	localctx = NewDataReceivedByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, Cobol85ParserRULE_dataReceivedByClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3324)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECEIVED {
		{
			p.SetState(3323)
			p.Match(Cobol85ParserRECEIVED)
		}

	}
	p.SetState(3327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3326)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3329)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCONTENT || _la == Cobol85ParserREF || _la == Cobol85ParserREFERENCE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataRecordAreaClauseContext is an interface to support dynamic dispatch.
type IDataRecordAreaClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRecordAreaClauseContext differentiates from other interfaces.
	IsDataRecordAreaClauseContext()
}

type DataRecordAreaClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRecordAreaClauseContext() *DataRecordAreaClauseContext {
	var p = new(DataRecordAreaClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRecordAreaClause
	return p
}

func (*DataRecordAreaClauseContext) IsDataRecordAreaClauseContext() {}

func NewDataRecordAreaClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRecordAreaClauseContext {
	var p = new(DataRecordAreaClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRecordAreaClause

	return p
}

func (s *DataRecordAreaClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRecordAreaClauseContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DataRecordAreaClauseContext) AREA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAREA, 0)
}

func (s *DataRecordAreaClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRecordAreaClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRecordAreaClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRecordAreaClause(s)
	}
}

func (s *DataRecordAreaClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRecordAreaClause(s)
	}
}

func (s *DataRecordAreaClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRecordAreaClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRecordAreaClause() (localctx IDataRecordAreaClauseContext) {
	this := p
	_ = this

	localctx = NewDataRecordAreaClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, Cobol85ParserRULE_dataRecordAreaClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3331)
		p.Match(Cobol85ParserRECORD)
	}
	{
		p.SetState(3332)
		p.Match(Cobol85ParserAREA)
	}

	return localctx
}

// IDataRedefinesClauseContext is an interface to support dynamic dispatch.
type IDataRedefinesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRedefinesClauseContext differentiates from other interfaces.
	IsDataRedefinesClauseContext()
}

type DataRedefinesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRedefinesClauseContext() *DataRedefinesClauseContext {
	var p = new(DataRedefinesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRedefinesClause
	return p
}

func (*DataRedefinesClauseContext) IsDataRedefinesClauseContext() {}

func NewDataRedefinesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRedefinesClauseContext {
	var p = new(DataRedefinesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRedefinesClause

	return p
}

func (s *DataRedefinesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRedefinesClauseContext) REDEFINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREDEFINES, 0)
}

func (s *DataRedefinesClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataRedefinesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRedefinesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRedefinesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRedefinesClause(s)
	}
}

func (s *DataRedefinesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRedefinesClause(s)
	}
}

func (s *DataRedefinesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRedefinesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRedefinesClause() (localctx IDataRedefinesClauseContext) {
	this := p
	_ = this

	localctx = NewDataRedefinesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, Cobol85ParserRULE_dataRedefinesClause)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3334)
		p.Match(Cobol85ParserREDEFINES)
	}
	{
		p.SetState(3335)
		p.DataName()
	}

	return localctx
}

// IDataRenamesClauseContext is an interface to support dynamic dispatch.
type IDataRenamesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataRenamesClauseContext differentiates from other interfaces.
	IsDataRenamesClauseContext()
}

type DataRenamesClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataRenamesClauseContext() *DataRenamesClauseContext {
	var p = new(DataRenamesClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataRenamesClause
	return p
}

func (*DataRenamesClauseContext) IsDataRenamesClauseContext() {}

func NewDataRenamesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataRenamesClauseContext {
	var p = new(DataRenamesClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataRenamesClause

	return p
}

func (s *DataRenamesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataRenamesClauseContext) RENAMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRENAMES, 0)
}

func (s *DataRenamesClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedDataNameContext); ok {
			tst[i] = t.(IQualifiedDataNameContext)
			i++
		}
	}

	return tst
}

func (s *DataRenamesClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *DataRenamesClauseContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *DataRenamesClauseContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *DataRenamesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataRenamesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataRenamesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataRenamesClause(s)
	}
}

func (s *DataRenamesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataRenamesClause(s)
	}
}

func (s *DataRenamesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataRenamesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataRenamesClause() (localctx IDataRenamesClauseContext) {
	this := p
	_ = this

	localctx = NewDataRenamesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, Cobol85ParserRULE_dataRenamesClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3337)
		p.Match(Cobol85ParserRENAMES)
	}
	{
		p.SetState(3338)
		p.QualifiedDataName()
	}
	p.SetState(3341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(3339)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3340)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IDataSignClauseContext is an interface to support dynamic dispatch.
type IDataSignClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataSignClauseContext differentiates from other interfaces.
	IsDataSignClauseContext()
}

type DataSignClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSignClauseContext() *DataSignClauseContext {
	var p = new(DataSignClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataSignClause
	return p
}

func (*DataSignClauseContext) IsDataSignClauseContext() {}

func NewDataSignClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSignClauseContext {
	var p = new(DataSignClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataSignClause

	return p
}

func (s *DataSignClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSignClauseContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *DataSignClauseContext) TRAILING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRAILING, 0)
}

func (s *DataSignClauseContext) SIGN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIGN, 0)
}

func (s *DataSignClauseContext) SEPARATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEPARATE, 0)
}

func (s *DataSignClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataSignClauseContext) CHARACTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTER, 0)
}

func (s *DataSignClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSignClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSignClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataSignClause(s)
	}
}

func (s *DataSignClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataSignClause(s)
	}
}

func (s *DataSignClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataSignClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataSignClause() (localctx IDataSignClauseContext) {
	this := p
	_ = this

	localctx = NewDataSignClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, Cobol85ParserRULE_dataSignClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSIGN {
		{
			p.SetState(3343)
			p.Match(Cobol85ParserSIGN)
		}
		p.SetState(3345)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3344)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	{
		p.SetState(3349)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserLEADING || _la == Cobol85ParserTRAILING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3354)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSEPARATE {
		{
			p.SetState(3350)
			p.Match(Cobol85ParserSEPARATE)
		}
		p.SetState(3352)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCHARACTER {
			{
				p.SetState(3351)
				p.Match(Cobol85ParserCHARACTER)
			}

		}

	}

	return localctx
}

// IDataSynchronizedClauseContext is an interface to support dynamic dispatch.
type IDataSynchronizedClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataSynchronizedClauseContext differentiates from other interfaces.
	IsDataSynchronizedClauseContext()
}

type DataSynchronizedClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataSynchronizedClauseContext() *DataSynchronizedClauseContext {
	var p = new(DataSynchronizedClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataSynchronizedClause
	return p
}

func (*DataSynchronizedClauseContext) IsDataSynchronizedClauseContext() {}

func NewDataSynchronizedClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataSynchronizedClauseContext {
	var p = new(DataSynchronizedClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataSynchronizedClause

	return p
}

func (s *DataSynchronizedClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataSynchronizedClauseContext) SYNCHRONIZED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYNCHRONIZED, 0)
}

func (s *DataSynchronizedClauseContext) SYNC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYNC, 0)
}

func (s *DataSynchronizedClauseContext) LEFT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFT, 0)
}

func (s *DataSynchronizedClauseContext) RIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRIGHT, 0)
}

func (s *DataSynchronizedClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataSynchronizedClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataSynchronizedClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataSynchronizedClause(s)
	}
}

func (s *DataSynchronizedClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataSynchronizedClause(s)
	}
}

func (s *DataSynchronizedClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataSynchronizedClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataSynchronizedClause() (localctx IDataSynchronizedClauseContext) {
	this := p
	_ = this

	localctx = NewDataSynchronizedClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, Cobol85ParserRULE_dataSynchronizedClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3356)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserSYNC || _la == Cobol85ParserSYNCHRONIZED) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3358)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLEFT || _la == Cobol85ParserRIGHT {
		{
			p.SetState(3357)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLEFT || _la == Cobol85ParserRIGHT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDataThreadLocalClauseContext is an interface to support dynamic dispatch.
type IDataThreadLocalClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataThreadLocalClauseContext differentiates from other interfaces.
	IsDataThreadLocalClauseContext()
}

type DataThreadLocalClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataThreadLocalClauseContext() *DataThreadLocalClauseContext {
	var p = new(DataThreadLocalClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataThreadLocalClause
	return p
}

func (*DataThreadLocalClauseContext) IsDataThreadLocalClauseContext() {}

func NewDataThreadLocalClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataThreadLocalClauseContext {
	var p = new(DataThreadLocalClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataThreadLocalClause

	return p
}

func (s *DataThreadLocalClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataThreadLocalClauseContext) THREAD_LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD_LOCAL, 0)
}

func (s *DataThreadLocalClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataThreadLocalClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataThreadLocalClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataThreadLocalClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataThreadLocalClause(s)
	}
}

func (s *DataThreadLocalClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataThreadLocalClause(s)
	}
}

func (s *DataThreadLocalClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataThreadLocalClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataThreadLocalClause() (localctx IDataThreadLocalClauseContext) {
	this := p
	_ = this

	localctx = NewDataThreadLocalClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, Cobol85ParserRULE_dataThreadLocalClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3361)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3360)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3363)
		p.Match(Cobol85ParserTHREAD_LOCAL)
	}

	return localctx
}

// IDataTypeClauseContext is an interface to support dynamic dispatch.
type IDataTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeClauseContext differentiates from other interfaces.
	IsDataTypeClauseContext()
}

type DataTypeClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeClauseContext() *DataTypeClauseContext {
	var p = new(DataTypeClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataTypeClause
	return p
}

func (*DataTypeClauseContext) IsDataTypeClauseContext() {}

func NewDataTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeClauseContext {
	var p = new(DataTypeClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataTypeClause

	return p
}

func (s *DataTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeClauseContext) TYPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPE, 0)
}

func (s *DataTypeClauseContext) SHORT_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHORT_DATE, 0)
}

func (s *DataTypeClauseContext) LONG_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_DATE, 0)
}

func (s *DataTypeClauseContext) NUMERIC_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_DATE, 0)
}

func (s *DataTypeClauseContext) NUMERIC_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_TIME, 0)
}

func (s *DataTypeClauseContext) LONG_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_TIME, 0)
}

func (s *DataTypeClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataTypeClause(s)
	}
}

func (s *DataTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataTypeClause(s)
	}
}

func (s *DataTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataTypeClause() (localctx IDataTypeClauseContext) {
	this := p
	_ = this

	localctx = NewDataTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, Cobol85ParserRULE_dataTypeClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3365)
		p.Match(Cobol85ParserTYPE)
	}
	p.SetState(3367)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3366)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3369)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-287)) & ^0x3f) == 0 && ((int64(1)<<(_la-287))&5368709123) != 0 || _la == Cobol85ParserSHORT_DATE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDataTypeDefClauseContext is an interface to support dynamic dispatch.
type IDataTypeDefClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataTypeDefClauseContext differentiates from other interfaces.
	IsDataTypeDefClauseContext()
}

type DataTypeDefClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefClauseContext() *DataTypeDefClauseContext {
	var p = new(DataTypeDefClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataTypeDefClause
	return p
}

func (*DataTypeDefClauseContext) IsDataTypeDefClauseContext() {}

func NewDataTypeDefClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefClauseContext {
	var p = new(DataTypeDefClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataTypeDefClause

	return p
}

func (s *DataTypeDefClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefClauseContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPEDEF, 0)
}

func (s *DataTypeDefClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataTypeDefClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataTypeDefClause(s)
	}
}

func (s *DataTypeDefClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataTypeDefClause(s)
	}
}

func (s *DataTypeDefClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataTypeDefClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataTypeDefClause() (localctx IDataTypeDefClauseContext) {
	this := p
	_ = this

	localctx = NewDataTypeDefClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, Cobol85ParserRULE_dataTypeDefClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3372)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(3371)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(3374)
		p.Match(Cobol85ParserTYPEDEF)
	}

	return localctx
}

// IDataUsageClauseContext is an interface to support dynamic dispatch.
type IDataUsageClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataUsageClauseContext differentiates from other interfaces.
	IsDataUsageClauseContext()
}

type DataUsageClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataUsageClauseContext() *DataUsageClauseContext {
	var p = new(DataUsageClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataUsageClause
	return p
}

func (*DataUsageClauseContext) IsDataUsageClauseContext() {}

func NewDataUsageClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataUsageClauseContext {
	var p = new(DataUsageClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataUsageClause

	return p
}

func (s *DataUsageClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataUsageClauseContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *DataUsageClauseContext) BIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBIT, 0)
}

func (s *DataUsageClauseContext) COMP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP, 0)
}

func (s *DataUsageClauseContext) COMP_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_1, 0)
}

func (s *DataUsageClauseContext) COMP_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_2, 0)
}

func (s *DataUsageClauseContext) COMP_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_3, 0)
}

func (s *DataUsageClauseContext) COMP_4() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_4, 0)
}

func (s *DataUsageClauseContext) COMP_5() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMP_5, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_1, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_2, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_3, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_4() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_4, 0)
}

func (s *DataUsageClauseContext) COMPUTATIONAL_5() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTATIONAL_5, 0)
}

func (s *DataUsageClauseContext) CONTROL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL_POINT, 0)
}

func (s *DataUsageClauseContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *DataUsageClauseContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *DataUsageClauseContext) DISPLAY_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY_1, 0)
}

func (s *DataUsageClauseContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLE, 0)
}

func (s *DataUsageClauseContext) EVENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVENT, 0)
}

func (s *DataUsageClauseContext) FUNCTION_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION_POINTER, 0)
}

func (s *DataUsageClauseContext) INDEX() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINDEX, 0)
}

func (s *DataUsageClauseContext) KANJI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKANJI, 0)
}

func (s *DataUsageClauseContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *DataUsageClauseContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *DataUsageClauseContext) PACKED_DECIMAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPACKED_DECIMAL, 0)
}

func (s *DataUsageClauseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *DataUsageClauseContext) PROCEDURE_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE_POINTER, 0)
}

func (s *DataUsageClauseContext) REAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAL, 0)
}

func (s *DataUsageClauseContext) TASK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTASK, 0)
}

func (s *DataUsageClauseContext) USAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSAGE, 0)
}

func (s *DataUsageClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataUsageClauseContext) TRUNCATED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUNCATED, 0)
}

func (s *DataUsageClauseContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTENDED, 0)
}

func (s *DataUsageClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataUsageClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataUsageClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataUsageClause(s)
	}
}

func (s *DataUsageClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataUsageClause(s)
	}
}

func (s *DataUsageClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataUsageClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataUsageClause() (localctx IDataUsageClauseContext) {
	this := p
	_ = this

	localctx = NewDataUsageClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, Cobol85ParserRULE_dataUsageClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3380)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSAGE {
		{
			p.SetState(3376)
			p.Match(Cobol85ParserUSAGE)
		}
		p.SetState(3378)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3377)
				p.Match(Cobol85ParserIS)
			}

		}

	}
	p.SetState(3415)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserBINARY:
		{
			p.SetState(3382)
			p.Match(Cobol85ParserBINARY)
		}
		p.SetState(3384)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 430, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3383)
				_la = p.GetTokenStream().LA(1)

				if !(_la == Cobol85ParserEXTENDED || _la == Cobol85ParserTRUNCATED) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case Cobol85ParserBIT:
		{
			p.SetState(3386)
			p.Match(Cobol85ParserBIT)
		}

	case Cobol85ParserCOMP:
		{
			p.SetState(3387)
			p.Match(Cobol85ParserCOMP)
		}

	case Cobol85ParserCOMP_1:
		{
			p.SetState(3388)
			p.Match(Cobol85ParserCOMP_1)
		}

	case Cobol85ParserCOMP_2:
		{
			p.SetState(3389)
			p.Match(Cobol85ParserCOMP_2)
		}

	case Cobol85ParserCOMP_3:
		{
			p.SetState(3390)
			p.Match(Cobol85ParserCOMP_3)
		}

	case Cobol85ParserCOMP_4:
		{
			p.SetState(3391)
			p.Match(Cobol85ParserCOMP_4)
		}

	case Cobol85ParserCOMP_5:
		{
			p.SetState(3392)
			p.Match(Cobol85ParserCOMP_5)
		}

	case Cobol85ParserCOMPUTATIONAL:
		{
			p.SetState(3393)
			p.Match(Cobol85ParserCOMPUTATIONAL)
		}

	case Cobol85ParserCOMPUTATIONAL_1:
		{
			p.SetState(3394)
			p.Match(Cobol85ParserCOMPUTATIONAL_1)
		}

	case Cobol85ParserCOMPUTATIONAL_2:
		{
			p.SetState(3395)
			p.Match(Cobol85ParserCOMPUTATIONAL_2)
		}

	case Cobol85ParserCOMPUTATIONAL_3:
		{
			p.SetState(3396)
			p.Match(Cobol85ParserCOMPUTATIONAL_3)
		}

	case Cobol85ParserCOMPUTATIONAL_4:
		{
			p.SetState(3397)
			p.Match(Cobol85ParserCOMPUTATIONAL_4)
		}

	case Cobol85ParserCOMPUTATIONAL_5:
		{
			p.SetState(3398)
			p.Match(Cobol85ParserCOMPUTATIONAL_5)
		}

	case Cobol85ParserCONTROL_POINT:
		{
			p.SetState(3399)
			p.Match(Cobol85ParserCONTROL_POINT)
		}

	case Cobol85ParserDATE:
		{
			p.SetState(3400)
			p.Match(Cobol85ParserDATE)
		}

	case Cobol85ParserDISPLAY:
		{
			p.SetState(3401)
			p.Match(Cobol85ParserDISPLAY)
		}

	case Cobol85ParserDISPLAY_1:
		{
			p.SetState(3402)
			p.Match(Cobol85ParserDISPLAY_1)
		}

	case Cobol85ParserDOUBLE:
		{
			p.SetState(3403)
			p.Match(Cobol85ParserDOUBLE)
		}

	case Cobol85ParserEVENT:
		{
			p.SetState(3404)
			p.Match(Cobol85ParserEVENT)
		}

	case Cobol85ParserFUNCTION_POINTER:
		{
			p.SetState(3405)
			p.Match(Cobol85ParserFUNCTION_POINTER)
		}

	case Cobol85ParserINDEX:
		{
			p.SetState(3406)
			p.Match(Cobol85ParserINDEX)
		}

	case Cobol85ParserKANJI:
		{
			p.SetState(3407)
			p.Match(Cobol85ParserKANJI)
		}

	case Cobol85ParserLOCK:
		{
			p.SetState(3408)
			p.Match(Cobol85ParserLOCK)
		}

	case Cobol85ParserNATIONAL:
		{
			p.SetState(3409)
			p.Match(Cobol85ParserNATIONAL)
		}

	case Cobol85ParserPACKED_DECIMAL:
		{
			p.SetState(3410)
			p.Match(Cobol85ParserPACKED_DECIMAL)
		}

	case Cobol85ParserPOINTER:
		{
			p.SetState(3411)
			p.Match(Cobol85ParserPOINTER)
		}

	case Cobol85ParserPROCEDURE_POINTER:
		{
			p.SetState(3412)
			p.Match(Cobol85ParserPROCEDURE_POINTER)
		}

	case Cobol85ParserREAL:
		{
			p.SetState(3413)
			p.Match(Cobol85ParserREAL)
		}

	case Cobol85ParserTASK:
		{
			p.SetState(3414)
			p.Match(Cobol85ParserTASK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDataUsingClauseContext is an interface to support dynamic dispatch.
type IDataUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataUsingClauseContext differentiates from other interfaces.
	IsDataUsingClauseContext()
}

type DataUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataUsingClauseContext() *DataUsingClauseContext {
	var p = new(DataUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataUsingClause
	return p
}

func (*DataUsingClauseContext) IsDataUsingClauseContext() {}

func NewDataUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataUsingClauseContext {
	var p = new(DataUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataUsingClause

	return p
}

func (s *DataUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *DataUsingClauseContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLANGUAGE, 0)
}

func (s *DataUsingClauseContext) CONVENTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVENTION, 0)
}

func (s *DataUsingClauseContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataUsingClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataUsingClauseContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *DataUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataUsingClause(s)
	}
}

func (s *DataUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataUsingClause(s)
	}
}

func (s *DataUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataUsingClause() (localctx IDataUsingClauseContext) {
	this := p
	_ = this

	localctx = NewDataUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, Cobol85ParserRULE_dataUsingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3417)
		p.Match(Cobol85ParserUSING)
	}
	{
		p.SetState(3418)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCONVENTION || _la == Cobol85ParserLANGUAGE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3420)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3419)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3424)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 433, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3422)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(3423)
			p.DataName()
		}

	}

	return localctx
}

// IDataValueClauseContext is an interface to support dynamic dispatch.
type IDataValueClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueClauseContext differentiates from other interfaces.
	IsDataValueClauseContext()
}

type DataValueClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueClauseContext() *DataValueClauseContext {
	var p = new(DataValueClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueClause
	return p
}

func (*DataValueClauseContext) IsDataValueClauseContext() {}

func NewDataValueClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueClauseContext {
	var p = new(DataValueClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueClause

	return p
}

func (s *DataValueClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueClauseContext) AllDataValueInterval() []IDataValueIntervalContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDataValueIntervalContext); ok {
			len++
		}
	}

	tst := make([]IDataValueIntervalContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDataValueIntervalContext); ok {
			tst[i] = t.(IDataValueIntervalContext)
			i++
		}
	}

	return tst
}

func (s *DataValueClauseContext) DataValueInterval(i int) IDataValueIntervalContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataValueIntervalContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalContext)
}

func (s *DataValueClauseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *DataValueClauseContext) VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUES, 0)
}

func (s *DataValueClauseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *DataValueClauseContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *DataValueClauseContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *DataValueClauseContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *DataValueClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueClause(s)
	}
}

func (s *DataValueClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueClause(s)
	}
}

func (s *DataValueClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueClause() (localctx IDataValueClauseContext) {
	this := p
	_ = this

	localctx = NewDataValueClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, Cobol85ParserRULE_dataValueClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3434)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserVALUE:
		{
			p.SetState(3426)
			p.Match(Cobol85ParserVALUE)
		}
		p.SetState(3428)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIS {
			{
				p.SetState(3427)
				p.Match(Cobol85ParserIS)
			}

		}

	case Cobol85ParserVALUES:
		{
			p.SetState(3430)
			p.Match(Cobol85ParserVALUES)
		}
		p.SetState(3432)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserARE {
			{
				p.SetState(3431)
				p.Match(Cobol85ParserARE)
			}

		}

	case Cobol85ParserABORT, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL_, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:

	default:
	}
	{
		p.SetState(3436)
		p.DataValueInterval()
	}
	p.SetState(3443)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 438, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(3438)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserCOMMACHAR {
				{
					p.SetState(3437)
					p.Match(Cobol85ParserCOMMACHAR)
				}

			}
			{
				p.SetState(3440)
				p.DataValueInterval()
			}

		}
		p.SetState(3445)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 438, p.GetParserRuleContext())
	}

	return localctx
}

// IDataValueIntervalContext is an interface to support dynamic dispatch.
type IDataValueIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalContext differentiates from other interfaces.
	IsDataValueIntervalContext()
}

type DataValueIntervalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalContext() *DataValueIntervalContext {
	var p = new(DataValueIntervalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueInterval
	return p
}

func (*DataValueIntervalContext) IsDataValueIntervalContext() {}

func NewDataValueIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalContext {
	var p = new(DataValueIntervalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueInterval

	return p
}

func (s *DataValueIntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalContext) DataValueIntervalFrom() IDataValueIntervalFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataValueIntervalFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalFromContext)
}

func (s *DataValueIntervalContext) DataValueIntervalTo() IDataValueIntervalToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataValueIntervalToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataValueIntervalToContext)
}

func (s *DataValueIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueInterval(s)
	}
}

func (s *DataValueIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueInterval(s)
	}
}

func (s *DataValueIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueInterval() (localctx IDataValueIntervalContext) {
	this := p
	_ = this

	localctx = NewDataValueIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, Cobol85ParserRULE_dataValueInterval)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3446)
		p.DataValueIntervalFrom()
	}
	p.SetState(3448)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(3447)
			p.DataValueIntervalTo()
		}

	}

	return localctx
}

// IDataValueIntervalFromContext is an interface to support dynamic dispatch.
type IDataValueIntervalFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalFromContext differentiates from other interfaces.
	IsDataValueIntervalFromContext()
}

type DataValueIntervalFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalFromContext() *DataValueIntervalFromContext {
	var p = new(DataValueIntervalFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalFrom
	return p
}

func (*DataValueIntervalFromContext) IsDataValueIntervalFromContext() {}

func NewDataValueIntervalFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalFromContext {
	var p = new(DataValueIntervalFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalFrom

	return p
}

func (s *DataValueIntervalFromContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalFromContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataValueIntervalFromContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataValueIntervalFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueIntervalFrom(s)
	}
}

func (s *DataValueIntervalFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueIntervalFrom(s)
	}
}

func (s *DataValueIntervalFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueIntervalFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueIntervalFrom() (localctx IDataValueIntervalFromContext) {
	this := p
	_ = this

	localctx = NewDataValueIntervalFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, Cobol85ParserRULE_dataValueIntervalFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3452)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 440, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3450)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3451)
			p.CobolWord()
		}

	}

	return localctx
}

// IDataValueIntervalToContext is an interface to support dynamic dispatch.
type IDataValueIntervalToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataValueIntervalToContext differentiates from other interfaces.
	IsDataValueIntervalToContext()
}

type DataValueIntervalToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataValueIntervalToContext() *DataValueIntervalToContext {
	var p = new(DataValueIntervalToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalTo
	return p
}

func (*DataValueIntervalToContext) IsDataValueIntervalToContext() {}

func NewDataValueIntervalToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataValueIntervalToContext {
	var p = new(DataValueIntervalToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataValueIntervalTo

	return p
}

func (s *DataValueIntervalToContext) GetParser() antlr.Parser { return s.parser }

func (s *DataValueIntervalToContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DataValueIntervalToContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *DataValueIntervalToContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *DataValueIntervalToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataValueIntervalToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataValueIntervalToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataValueIntervalTo(s)
	}
}

func (s *DataValueIntervalToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataValueIntervalTo(s)
	}
}

func (s *DataValueIntervalToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataValueIntervalTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataValueIntervalTo() (localctx IDataValueIntervalToContext) {
	this := p
	_ = this

	localctx = NewDataValueIntervalToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, Cobol85ParserRULE_dataValueIntervalTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3454)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3455)
		p.Literal()
	}

	return localctx
}

// IDataWithLowerBoundsClauseContext is an interface to support dynamic dispatch.
type IDataWithLowerBoundsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataWithLowerBoundsClauseContext differentiates from other interfaces.
	IsDataWithLowerBoundsClauseContext()
}

type DataWithLowerBoundsClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataWithLowerBoundsClauseContext() *DataWithLowerBoundsClauseContext {
	var p = new(DataWithLowerBoundsClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataWithLowerBoundsClause
	return p
}

func (*DataWithLowerBoundsClauseContext) IsDataWithLowerBoundsClauseContext() {}

func NewDataWithLowerBoundsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataWithLowerBoundsClauseContext {
	var p = new(DataWithLowerBoundsClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataWithLowerBoundsClause

	return p
}

func (s *DataWithLowerBoundsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DataWithLowerBoundsClauseContext) LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWER, 0)
}

func (s *DataWithLowerBoundsClauseContext) BOUNDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOUNDS, 0)
}

func (s *DataWithLowerBoundsClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DataWithLowerBoundsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataWithLowerBoundsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataWithLowerBoundsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataWithLowerBoundsClause(s)
	}
}

func (s *DataWithLowerBoundsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataWithLowerBoundsClause(s)
	}
}

func (s *DataWithLowerBoundsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataWithLowerBoundsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataWithLowerBoundsClause() (localctx IDataWithLowerBoundsClauseContext) {
	this := p
	_ = this

	localctx = NewDataWithLowerBoundsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, Cobol85ParserRULE_dataWithLowerBoundsClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3458)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3457)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(3460)
		p.Match(Cobol85ParserLOWER)
	}
	{
		p.SetState(3461)
		p.Match(Cobol85ParserBOUNDS)
	}

	return localctx
}

// IProcedureDivisionContext is an interface to support dynamic dispatch.
type IProcedureDivisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionContext differentiates from other interfaces.
	IsProcedureDivisionContext()
}

type ProcedureDivisionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionContext() *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivision
	return p
}

func (*ProcedureDivisionContext) IsProcedureDivisionContext() {}

func NewProcedureDivisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionContext {
	var p = new(ProcedureDivisionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivision

	return p
}

func (s *ProcedureDivisionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *ProcedureDivisionContext) DIVISION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVISION, 0)
}

func (s *ProcedureDivisionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProcedureDivisionContext) ProcedureDivisionBody() IProcedureDivisionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionBodyContext)
}

func (s *ProcedureDivisionContext) ProcedureDivisionUsingClause() IProcedureDivisionUsingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionUsingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionUsingClauseContext)
}

func (s *ProcedureDivisionContext) ProcedureDivisionGivingClause() IProcedureDivisionGivingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionGivingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionGivingClauseContext)
}

func (s *ProcedureDivisionContext) ProcedureDeclaratives() IProcedureDeclarativesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarativesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarativesContext)
}

func (s *ProcedureDivisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivision(s)
	}
}

func (s *ProcedureDivisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivision() (localctx IProcedureDivisionContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, Cobol85ParserRULE_procedureDivision)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3463)
		p.Match(Cobol85ParserPROCEDURE)
	}
	{
		p.SetState(3464)
		p.Match(Cobol85ParserDIVISION)
	}
	p.SetState(3466)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCHAINING || _la == Cobol85ParserUSING {
		{
			p.SetState(3465)
			p.ProcedureDivisionUsingClause()
		}

	}
	p.SetState(3469)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING {
		{
			p.SetState(3468)
			p.ProcedureDivisionGivingClause()
		}

	}
	{
		p.SetState(3471)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDECLARATIVES {
		{
			p.SetState(3472)
			p.ProcedureDeclaratives()
		}

	}
	{
		p.SetState(3475)
		p.ProcedureDivisionBody()
	}

	return localctx
}

// IProcedureDivisionUsingClauseContext is an interface to support dynamic dispatch.
type IProcedureDivisionUsingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionUsingClauseContext differentiates from other interfaces.
	IsProcedureDivisionUsingClauseContext()
}

type ProcedureDivisionUsingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionUsingClauseContext() *ProcedureDivisionUsingClauseContext {
	var p = new(ProcedureDivisionUsingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingClause
	return p
}

func (*ProcedureDivisionUsingClauseContext) IsProcedureDivisionUsingClauseContext() {}

func NewProcedureDivisionUsingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionUsingClauseContext {
	var p = new(ProcedureDivisionUsingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingClause

	return p
}

func (s *ProcedureDivisionUsingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionUsingClauseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ProcedureDivisionUsingClauseContext) CHAINING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHAINING, 0)
}

func (s *ProcedureDivisionUsingClauseContext) AllProcedureDivisionUsingParameter() []IProcedureDivisionUsingParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureDivisionUsingParameterContext); ok {
			len++
		}
	}

	tst := make([]IProcedureDivisionUsingParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureDivisionUsingParameterContext); ok {
			tst[i] = t.(IProcedureDivisionUsingParameterContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionUsingClauseContext) ProcedureDivisionUsingParameter(i int) IProcedureDivisionUsingParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionUsingParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionUsingParameterContext)
}

func (s *ProcedureDivisionUsingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionUsingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionUsingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionUsingClause(s)
	}
}

func (s *ProcedureDivisionUsingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionUsingClause(s)
	}
}

func (s *ProcedureDivisionUsingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionUsingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionUsingClause() (localctx IProcedureDivisionUsingClauseContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionUsingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, Cobol85ParserRULE_procedureDivisionUsingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3477)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCHAINING || _la == Cobol85ParserUSING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3479)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3513562381090291746) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-8049611247572114313) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4648155908907139171) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103778511530590369) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3478)
			p.ProcedureDivisionUsingParameter()
		}

		p.SetState(3481)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedureDivisionGivingClauseContext is an interface to support dynamic dispatch.
type IProcedureDivisionGivingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionGivingClauseContext differentiates from other interfaces.
	IsProcedureDivisionGivingClauseContext()
}

type ProcedureDivisionGivingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionGivingClauseContext() *ProcedureDivisionGivingClauseContext {
	var p = new(ProcedureDivisionGivingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionGivingClause
	return p
}

func (*ProcedureDivisionGivingClauseContext) IsProcedureDivisionGivingClauseContext() {}

func NewProcedureDivisionGivingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionGivingClauseContext {
	var p = new(ProcedureDivisionGivingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionGivingClause

	return p
}

func (s *ProcedureDivisionGivingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionGivingClauseContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ProcedureDivisionGivingClauseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *ProcedureDivisionGivingClauseContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURNING, 0)
}

func (s *ProcedureDivisionGivingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionGivingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionGivingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionGivingClause(s)
	}
}

func (s *ProcedureDivisionGivingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionGivingClause(s)
	}
}

func (s *ProcedureDivisionGivingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionGivingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionGivingClause() (localctx IProcedureDivisionGivingClauseContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionGivingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, Cobol85ParserRULE_procedureDivisionGivingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3483)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3484)
		p.DataName()
	}

	return localctx
}

// IProcedureDivisionUsingParameterContext is an interface to support dynamic dispatch.
type IProcedureDivisionUsingParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionUsingParameterContext differentiates from other interfaces.
	IsProcedureDivisionUsingParameterContext()
}

type ProcedureDivisionUsingParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionUsingParameterContext() *ProcedureDivisionUsingParameterContext {
	var p = new(ProcedureDivisionUsingParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingParameter
	return p
}

func (*ProcedureDivisionUsingParameterContext) IsProcedureDivisionUsingParameterContext() {}

func NewProcedureDivisionUsingParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionUsingParameterContext {
	var p = new(ProcedureDivisionUsingParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionUsingParameter

	return p
}

func (s *ProcedureDivisionUsingParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionUsingParameterContext) ProcedureDivisionByReferencePhrase() IProcedureDivisionByReferencePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionByReferencePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByReferencePhraseContext)
}

func (s *ProcedureDivisionUsingParameterContext) ProcedureDivisionByValuePhrase() IProcedureDivisionByValuePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionByValuePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByValuePhraseContext)
}

func (s *ProcedureDivisionUsingParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionUsingParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionUsingParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionUsingParameter(s)
	}
}

func (s *ProcedureDivisionUsingParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionUsingParameter(s)
	}
}

func (s *ProcedureDivisionUsingParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionUsingParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionUsingParameter() (localctx IProcedureDivisionUsingParameterContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionUsingParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, Cobol85ParserRULE_procedureDivisionUsingParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3488)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 446, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3486)
			p.ProcedureDivisionByReferencePhrase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3487)
			p.ProcedureDivisionByValuePhrase()
		}

	}

	return localctx
}

// IProcedureDivisionByReferencePhraseContext is an interface to support dynamic dispatch.
type IProcedureDivisionByReferencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByReferencePhraseContext differentiates from other interfaces.
	IsProcedureDivisionByReferencePhraseContext()
}

type ProcedureDivisionByReferencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByReferencePhraseContext() *ProcedureDivisionByReferencePhraseContext {
	var p = new(ProcedureDivisionByReferencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReferencePhrase
	return p
}

func (*ProcedureDivisionByReferencePhraseContext) IsProcedureDivisionByReferencePhraseContext() {}

func NewProcedureDivisionByReferencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByReferencePhraseContext {
	var p = new(ProcedureDivisionByReferencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReferencePhrase

	return p
}

func (s *ProcedureDivisionByReferencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByReferencePhraseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *ProcedureDivisionByReferencePhraseContext) AllProcedureDivisionByReference() []IProcedureDivisionByReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureDivisionByReferenceContext); ok {
			len++
		}
	}

	tst := make([]IProcedureDivisionByReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureDivisionByReferenceContext); ok {
			tst[i] = t.(IProcedureDivisionByReferenceContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionByReferencePhraseContext) ProcedureDivisionByReference(i int) IProcedureDivisionByReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionByReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByReferenceContext)
}

func (s *ProcedureDivisionByReferencePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *ProcedureDivisionByReferencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByReferencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByReferencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByReferencePhrase(s)
	}
}

func (s *ProcedureDivisionByReferencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByReferencePhrase(s)
	}
}

func (s *ProcedureDivisionByReferencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionByReferencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByReferencePhrase() (localctx IProcedureDivisionByReferencePhraseContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionByReferencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, Cobol85ParserRULE_procedureDivisionByReferencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3494)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY || _la == Cobol85ParserREFERENCE {
		p.SetState(3491)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3490)
				p.Match(Cobol85ParserBY)
			}

		}
		{
			p.SetState(3493)
			p.Match(Cobol85ParserREFERENCE)
		}

	}
	p.SetState(3497)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3496)
				p.ProcedureDivisionByReference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3499)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 449, p.GetParserRuleContext())
	}

	return localctx
}

// IProcedureDivisionByReferenceContext is an interface to support dynamic dispatch.
type IProcedureDivisionByReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByReferenceContext differentiates from other interfaces.
	IsProcedureDivisionByReferenceContext()
}

type ProcedureDivisionByReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByReferenceContext() *ProcedureDivisionByReferenceContext {
	var p = new(ProcedureDivisionByReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReference
	return p
}

func (*ProcedureDivisionByReferenceContext) IsProcedureDivisionByReferenceContext() {}

func NewProcedureDivisionByReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByReferenceContext {
	var p = new(ProcedureDivisionByReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByReference

	return p
}

func (s *ProcedureDivisionByReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureDivisionByReferenceContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ProcedureDivisionByReferenceContext) OPTIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPTIONAL, 0)
}

func (s *ProcedureDivisionByReferenceContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ProcedureDivisionByReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByReference(s)
	}
}

func (s *ProcedureDivisionByReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByReference(s)
	}
}

func (s *ProcedureDivisionByReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionByReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByReference() (localctx IProcedureDivisionByReferenceContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionByReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, Cobol85ParserRULE_procedureDivisionByReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3509)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserOPTIONAL, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOPTIONAL {
			{
				p.SetState(3501)
				p.Match(Cobol85ParserOPTIONAL)
			}

		}
		p.SetState(3506)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 451, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3504)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3505)
				p.FileName()
			}

		}

	case Cobol85ParserANY:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3508)
			p.Match(Cobol85ParserANY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureDivisionByValuePhraseContext is an interface to support dynamic dispatch.
type IProcedureDivisionByValuePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByValuePhraseContext differentiates from other interfaces.
	IsProcedureDivisionByValuePhraseContext()
}

type ProcedureDivisionByValuePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByValuePhraseContext() *ProcedureDivisionByValuePhraseContext {
	var p = new(ProcedureDivisionByValuePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValuePhrase
	return p
}

func (*ProcedureDivisionByValuePhraseContext) IsProcedureDivisionByValuePhraseContext() {}

func NewProcedureDivisionByValuePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByValuePhraseContext {
	var p = new(ProcedureDivisionByValuePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValuePhrase

	return p
}

func (s *ProcedureDivisionByValuePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByValuePhraseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *ProcedureDivisionByValuePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *ProcedureDivisionByValuePhraseContext) AllProcedureDivisionByValue() []IProcedureDivisionByValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureDivisionByValueContext); ok {
			len++
		}
	}

	tst := make([]IProcedureDivisionByValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureDivisionByValueContext); ok {
			tst[i] = t.(IProcedureDivisionByValueContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionByValuePhraseContext) ProcedureDivisionByValue(i int) IProcedureDivisionByValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDivisionByValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDivisionByValueContext)
}

func (s *ProcedureDivisionByValuePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByValuePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByValuePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByValuePhrase(s)
	}
}

func (s *ProcedureDivisionByValuePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByValuePhrase(s)
	}
}

func (s *ProcedureDivisionByValuePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionByValuePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByValuePhrase() (localctx IProcedureDivisionByValuePhraseContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionByValuePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, Cobol85ParserRULE_procedureDivisionByValuePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3512)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3511)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3514)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3516)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3515)
				p.ProcedureDivisionByValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3518)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 454, p.GetParserRuleContext())
	}

	return localctx
}

// IProcedureDivisionByValueContext is an interface to support dynamic dispatch.
type IProcedureDivisionByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionByValueContext differentiates from other interfaces.
	IsProcedureDivisionByValueContext()
}

type ProcedureDivisionByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionByValueContext() *ProcedureDivisionByValueContext {
	var p = new(ProcedureDivisionByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValue
	return p
}

func (*ProcedureDivisionByValueContext) IsProcedureDivisionByValueContext() {}

func NewProcedureDivisionByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionByValueContext {
	var p = new(ProcedureDivisionByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionByValue

	return p
}

func (s *ProcedureDivisionByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionByValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ProcedureDivisionByValueContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ProcedureDivisionByValueContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ProcedureDivisionByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionByValue(s)
	}
}

func (s *ProcedureDivisionByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionByValue(s)
	}
}

func (s *ProcedureDivisionByValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionByValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionByValue() (localctx IProcedureDivisionByValueContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, Cobol85ParserRULE_procedureDivisionByValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3523)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 455, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3520)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3521)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3522)
			p.Match(Cobol85ParserANY)
		}

	}

	return localctx
}

// IProcedureDeclarativesContext is an interface to support dynamic dispatch.
type IProcedureDeclarativesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDeclarativesContext differentiates from other interfaces.
	IsProcedureDeclarativesContext()
}

type ProcedureDeclarativesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarativesContext() *ProcedureDeclarativesContext {
	var p = new(ProcedureDeclarativesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDeclaratives
	return p
}

func (*ProcedureDeclarativesContext) IsProcedureDeclarativesContext() {}

func NewProcedureDeclarativesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarativesContext {
	var p = new(ProcedureDeclarativesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDeclaratives

	return p
}

func (s *ProcedureDeclarativesContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarativesContext) AllDECLARATIVES() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDECLARATIVES)
}

func (s *ProcedureDeclarativesContext) DECLARATIVES(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDECLARATIVES, i)
}

func (s *ProcedureDeclarativesContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProcedureDeclarativesContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProcedureDeclarativesContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *ProcedureDeclarativesContext) AllProcedureDeclarative() []IProcedureDeclarativeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureDeclarativeContext); ok {
			len++
		}
	}

	tst := make([]IProcedureDeclarativeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureDeclarativeContext); ok {
			tst[i] = t.(IProcedureDeclarativeContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDeclarativesContext) ProcedureDeclarative(i int) IProcedureDeclarativeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureDeclarativeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureDeclarativeContext)
}

func (s *ProcedureDeclarativesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarativesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarativesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDeclaratives(s)
	}
}

func (s *ProcedureDeclarativesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDeclaratives(s)
	}
}

func (s *ProcedureDeclarativesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDeclaratives(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDeclaratives() (localctx IProcedureDeclarativesContext) {
	this := p
	_ = this

	localctx = NewProcedureDeclarativesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, Cobol85ParserRULE_procedureDeclaratives)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3525)
		p.Match(Cobol85ParserDECLARATIVES)
	}
	{
		p.SetState(3526)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3528)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3527)
			p.ProcedureDeclarative()
		}

		p.SetState(3530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3532)
		p.Match(Cobol85ParserEND)
	}
	{
		p.SetState(3533)
		p.Match(Cobol85ParserDECLARATIVES)
	}
	{
		p.SetState(3534)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IProcedureDeclarativeContext is an interface to support dynamic dispatch.
type IProcedureDeclarativeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDeclarativeContext differentiates from other interfaces.
	IsProcedureDeclarativeContext()
}

type ProcedureDeclarativeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDeclarativeContext() *ProcedureDeclarativeContext {
	var p = new(ProcedureDeclarativeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDeclarative
	return p
}

func (*ProcedureDeclarativeContext) IsProcedureDeclarativeContext() {}

func NewProcedureDeclarativeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDeclarativeContext {
	var p = new(ProcedureDeclarativeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDeclarative

	return p
}

func (s *ProcedureDeclarativeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDeclarativeContext) ProcedureSectionHeader() IProcedureSectionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSectionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionHeaderContext)
}

func (s *ProcedureDeclarativeContext) AllDOT_FS() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserDOT_FS)
}

func (s *ProcedureDeclarativeContext) DOT_FS(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, i)
}

func (s *ProcedureDeclarativeContext) UseStatement() IUseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseStatementContext)
}

func (s *ProcedureDeclarativeContext) Paragraphs() IParagraphsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureDeclarativeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDeclarativeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDeclarativeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDeclarative(s)
	}
}

func (s *ProcedureDeclarativeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDeclarative(s)
	}
}

func (s *ProcedureDeclarativeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDeclarative(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDeclarative() (localctx IProcedureDeclarativeContext) {
	this := p
	_ = this

	localctx = NewProcedureDeclarativeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, Cobol85ParserRULE_procedureDeclarative)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3536)
		p.ProcedureSectionHeader()
	}
	{
		p.SetState(3537)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3538)
		p.UseStatement()
	}
	{
		p.SetState(3539)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3540)
		p.Paragraphs()
	}

	return localctx
}

// IProcedureSectionHeaderContext is an interface to support dynamic dispatch.
type IProcedureSectionHeaderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureSectionHeaderContext differentiates from other interfaces.
	IsProcedureSectionHeaderContext()
}

type ProcedureSectionHeaderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSectionHeaderContext() *ProcedureSectionHeaderContext {
	var p = new(ProcedureSectionHeaderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureSectionHeader
	return p
}

func (*ProcedureSectionHeaderContext) IsProcedureSectionHeaderContext() {}

func NewProcedureSectionHeaderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSectionHeaderContext {
	var p = new(ProcedureSectionHeaderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureSectionHeader

	return p
}

func (s *ProcedureSectionHeaderContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSectionHeaderContext) SectionName() ISectionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISectionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *ProcedureSectionHeaderContext) SECTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECTION, 0)
}

func (s *ProcedureSectionHeaderContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ProcedureSectionHeaderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSectionHeaderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSectionHeaderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureSectionHeader(s)
	}
}

func (s *ProcedureSectionHeaderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureSectionHeader(s)
	}
}

func (s *ProcedureSectionHeaderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureSectionHeader(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureSectionHeader() (localctx IProcedureSectionHeaderContext) {
	this := p
	_ = this

	localctx = NewProcedureSectionHeaderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, Cobol85ParserRULE_procedureSectionHeader)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3542)
		p.SectionName()
	}
	{
		p.SetState(3543)
		p.Match(Cobol85ParserSECTION)
	}
	p.SetState(3545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0 {
		{
			p.SetState(3544)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IProcedureDivisionBodyContext is an interface to support dynamic dispatch.
type IProcedureDivisionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureDivisionBodyContext differentiates from other interfaces.
	IsProcedureDivisionBodyContext()
}

type ProcedureDivisionBodyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureDivisionBodyContext() *ProcedureDivisionBodyContext {
	var p = new(ProcedureDivisionBodyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionBody
	return p
}

func (*ProcedureDivisionBodyContext) IsProcedureDivisionBodyContext() {}

func NewProcedureDivisionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureDivisionBodyContext {
	var p = new(ProcedureDivisionBodyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureDivisionBody

	return p
}

func (s *ProcedureDivisionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureDivisionBodyContext) Paragraphs() IParagraphsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureDivisionBodyContext) AllProcedureSection() []IProcedureSectionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureSectionContext); ok {
			len++
		}
	}

	tst := make([]IProcedureSectionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureSectionContext); ok {
			tst[i] = t.(IProcedureSectionContext)
			i++
		}
	}

	return tst
}

func (s *ProcedureDivisionBodyContext) ProcedureSection(i int) IProcedureSectionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSectionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionContext)
}

func (s *ProcedureDivisionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureDivisionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureDivisionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureDivisionBody(s)
	}
}

func (s *ProcedureDivisionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureDivisionBody(s)
	}
}

func (s *ProcedureDivisionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureDivisionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureDivisionBody() (localctx IProcedureDivisionBodyContext) {
	this := p
	_ = this

	localctx = NewProcedureDivisionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, Cobol85ParserRULE_procedureDivisionBody)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3547)
		p.Paragraphs()
	}
	p.SetState(3551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3548)
			p.ProcedureSection()
		}

		p.SetState(3553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IProcedureSectionContext is an interface to support dynamic dispatch.
type IProcedureSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureSectionContext differentiates from other interfaces.
	IsProcedureSectionContext()
}

type ProcedureSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureSectionContext() *ProcedureSectionContext {
	var p = new(ProcedureSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureSection
	return p
}

func (*ProcedureSectionContext) IsProcedureSectionContext() {}

func NewProcedureSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureSectionContext {
	var p = new(ProcedureSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureSection

	return p
}

func (s *ProcedureSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureSectionContext) ProcedureSectionHeader() IProcedureSectionHeaderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureSectionHeaderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureSectionHeaderContext)
}

func (s *ProcedureSectionContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ProcedureSectionContext) Paragraphs() IParagraphsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphsContext)
}

func (s *ProcedureSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureSection(s)
	}
}

func (s *ProcedureSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureSection(s)
	}
}

func (s *ProcedureSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureSection() (localctx IProcedureSectionContext) {
	this := p
	_ = this

	localctx = NewProcedureSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, Cobol85ParserRULE_procedureSection)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3554)
		p.ProcedureSectionHeader()
	}
	{
		p.SetState(3555)
		p.Match(Cobol85ParserDOT_FS)
	}
	{
		p.SetState(3556)
		p.Paragraphs()
	}

	return localctx
}

// IParagraphsContext is an interface to support dynamic dispatch.
type IParagraphsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphsContext differentiates from other interfaces.
	IsParagraphsContext()
}

type ParagraphsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphsContext() *ParagraphsContext {
	var p = new(ParagraphsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraphs
	return p
}

func (*ParagraphsContext) IsParagraphsContext() {}

func NewParagraphsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphsContext {
	var p = new(ParagraphsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraphs

	return p
}

func (s *ParagraphsContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphsContext) AllSentence() []ISentenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISentenceContext); ok {
			len++
		}
	}

	tst := make([]ISentenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISentenceContext); ok {
			tst[i] = t.(ISentenceContext)
			i++
		}
	}

	return tst
}

func (s *ParagraphsContext) Sentence(i int) ISentenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphsContext) AllParagraph() []IParagraphContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IParagraphContext); ok {
			len++
		}
	}

	tst := make([]IParagraphContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IParagraphContext); ok {
			tst[i] = t.(IParagraphContext)
			i++
		}
	}

	return tst
}

func (s *ParagraphsContext) Paragraph(i int) IParagraphContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphContext)
}

func (s *ParagraphsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraphs(s)
	}
}

func (s *ParagraphsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraphs(s)
	}
}

func (s *ParagraphsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitParagraphs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Paragraphs() (localctx IParagraphsContext) {
	this := p
	_ = this

	localctx = NewParagraphsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, Cobol85ParserRULE_paragraphs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3561)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&13510798882242580) != 0 || (int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&570425345) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&4613937818308192769) != 0 || (int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&1337281096974339) != 0 || (int64((_la-294)) & ^0x3f) == 0 && ((int64(1)<<(_la-294))&562958543356225) != 0 || (int64((_la-365)) & ^0x3f) == 0 && ((int64(1)<<(_la-365))&1161937774836712961) != 0 || (int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&70378206528513) != 0 || (int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&4035225283303964673) != 0 {
		{
			p.SetState(3558)
			p.Sentence()
		}

		p.SetState(3563)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3567)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(3564)
				p.Paragraph()
			}

		}
		p.SetState(3569)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 460, p.GetParserRuleContext())
	}

	return localctx
}

// IParagraphContext is an interface to support dynamic dispatch.
type IParagraphContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphContext differentiates from other interfaces.
	IsParagraphContext()
}

type ParagraphContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphContext() *ParagraphContext {
	var p = new(ParagraphContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraph
	return p
}

func (*ParagraphContext) IsParagraphContext() {}

func NewParagraphContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphContext {
	var p = new(ParagraphContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraph

	return p
}

func (s *ParagraphContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphContext) ParagraphName() IParagraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *ParagraphContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *ParagraphContext) AlteredGoTo() IAlteredGoToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlteredGoToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlteredGoToContext)
}

func (s *ParagraphContext) AllSentence() []ISentenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISentenceContext); ok {
			len++
		}
	}

	tst := make([]ISentenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISentenceContext); ok {
			tst[i] = t.(ISentenceContext)
			i++
		}
	}

	return tst
}

func (s *ParagraphContext) Sentence(i int) ISentenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISentenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISentenceContext)
}

func (s *ParagraphContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraph(s)
	}
}

func (s *ParagraphContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraph(s)
	}
}

func (s *ParagraphContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitParagraph(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Paragraph() (localctx IParagraphContext) {
	this := p
	_ = this

	localctx = NewParagraphContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, Cobol85ParserRULE_paragraph)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3570)
		p.ParagraphName()
	}
	{
		p.SetState(3571)
		p.Match(Cobol85ParserDOT_FS)
	}
	p.SetState(3579)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 462, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3572)
			p.AlteredGoTo()
		}

	case 2:
		p.SetState(3576)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&13510798882242580) != 0 || (int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&570425345) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&4613937818308192769) != 0 || (int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&1337281096974339) != 0 || (int64((_la-294)) & ^0x3f) == 0 && ((int64(1)<<(_la-294))&562958543356225) != 0 || (int64((_la-365)) & ^0x3f) == 0 && ((int64(1)<<(_la-365))&1161937774836712961) != 0 || (int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&70378206528513) != 0 || (int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&4035225283303964673) != 0 {
			{
				p.SetState(3573)
				p.Sentence()
			}

			p.SetState(3578)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// ISentenceContext is an interface to support dynamic dispatch.
type ISentenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSentenceContext differentiates from other interfaces.
	IsSentenceContext()
}

type SentenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySentenceContext() *SentenceContext {
	var p = new(SentenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sentence
	return p
}

func (*SentenceContext) IsSentenceContext() {}

func NewSentenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SentenceContext {
	var p = new(SentenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sentence

	return p
}

func (s *SentenceContext) GetParser() antlr.Parser { return s.parser }

func (s *SentenceContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *SentenceContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SentenceContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SentenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SentenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SentenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSentence(s)
	}
}

func (s *SentenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSentence(s)
	}
}

func (s *SentenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSentence(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Sentence() (localctx ISentenceContext) {
	this := p
	_ = this

	localctx = NewSentenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, Cobol85ParserRULE_sentence)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3584)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&13510798882242580) != 0 || (int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&570425345) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&4613937818308192769) != 0 || (int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&1337281096974339) != 0 || (int64((_la-294)) & ^0x3f) == 0 && ((int64(1)<<(_la-294))&562958543356225) != 0 || (int64((_la-365)) & ^0x3f) == 0 && ((int64(1)<<(_la-365))&1161937774836712961) != 0 || (int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&70378206528513) != 0 || (int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&4035225266124095489) != 0 {
		{
			p.SetState(3581)
			p.Statement()
		}

		p.SetState(3586)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3587)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_statement
	return p
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) AcceptStatement() IAcceptStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptStatementContext)
}

func (s *StatementContext) AddStatement() IAddStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddStatementContext)
}

func (s *StatementContext) AlterStatement() IAlterStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterStatementContext)
}

func (s *StatementContext) CallStatement() ICallStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallStatementContext)
}

func (s *StatementContext) CancelStatement() ICancelStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelStatementContext)
}

func (s *StatementContext) CloseStatement() ICloseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseStatementContext)
}

func (s *StatementContext) ComputeStatement() IComputeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComputeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComputeStatementContext)
}

func (s *StatementContext) ContinueStatement() IContinueStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContinueStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContinueStatementContext)
}

func (s *StatementContext) DeleteStatement() IDeleteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteStatementContext)
}

func (s *StatementContext) DisableStatement() IDisableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisableStatementContext)
}

func (s *StatementContext) DisplayStatement() IDisplayStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayStatementContext)
}

func (s *StatementContext) DivideStatement() IDivideStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideStatementContext)
}

func (s *StatementContext) EnableStatement() IEnableStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnableStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnableStatementContext)
}

func (s *StatementContext) EntryStatement() IEntryStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEntryStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEntryStatementContext)
}

func (s *StatementContext) EvaluateStatement() IEvaluateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateStatementContext)
}

func (s *StatementContext) ExhibitStatement() IExhibitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExhibitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExhibitStatementContext)
}

func (s *StatementContext) ExecCicsStatement() IExecCicsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecCicsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecCicsStatementContext)
}

func (s *StatementContext) ExecSqlStatement() IExecSqlStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecSqlStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecSqlStatementContext)
}

func (s *StatementContext) ExecSqlImsStatement() IExecSqlImsStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecSqlImsStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecSqlImsStatementContext)
}

func (s *StatementContext) ExitStatement() IExitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExitStatementContext)
}

func (s *StatementContext) GenerateStatement() IGenerateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGenerateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGenerateStatementContext)
}

func (s *StatementContext) GobackStatement() IGobackStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGobackStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGobackStatementContext)
}

func (s *StatementContext) GoToStatement() IGoToStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoToStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoToStatementContext)
}

func (s *StatementContext) IfStatement() IIfStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfStatementContext)
}

func (s *StatementContext) InitializeStatement() IInitializeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializeStatementContext)
}

func (s *StatementContext) InitiateStatement() IInitiateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitiateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitiateStatementContext)
}

func (s *StatementContext) InspectStatement() IInspectStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectStatementContext)
}

func (s *StatementContext) MergeStatement() IMergeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeStatementContext)
}

func (s *StatementContext) MoveStatement() IMoveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveStatementContext)
}

func (s *StatementContext) MultiplyStatement() IMultiplyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyStatementContext)
}

func (s *StatementContext) OpenStatement() IOpenStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenStatementContext)
}

func (s *StatementContext) PerformStatement() IPerformStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformStatementContext)
}

func (s *StatementContext) PurgeStatement() IPurgeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPurgeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPurgeStatementContext)
}

func (s *StatementContext) ReadStatement() IReadStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadStatementContext)
}

func (s *StatementContext) ReceiveStatement() IReceiveStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveStatementContext)
}

func (s *StatementContext) ReleaseStatement() IReleaseStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReleaseStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReleaseStatementContext)
}

func (s *StatementContext) ReturnStatement() IReturnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnStatementContext)
}

func (s *StatementContext) RewriteStatement() IRewriteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRewriteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRewriteStatementContext)
}

func (s *StatementContext) SearchStatement() ISearchStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchStatementContext)
}

func (s *StatementContext) SendStatement() ISendStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStatementContext)
}

func (s *StatementContext) SetStatement() ISetStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetStatementContext)
}

func (s *StatementContext) SortStatement() ISortStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortStatementContext)
}

func (s *StatementContext) StartStatement() IStartStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartStatementContext)
}

func (s *StatementContext) StopStatement() IStopStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStopStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStopStatementContext)
}

func (s *StatementContext) StringStatement() IStringStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringStatementContext)
}

func (s *StatementContext) SubtractStatement() ISubtractStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractStatementContext)
}

func (s *StatementContext) TerminateStatement() ITerminateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerminateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerminateStatementContext)
}

func (s *StatementContext) UnstringStatement() IUnstringStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringStatementContext)
}

func (s *StatementContext) WriteStatement() IWriteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteStatementContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStatement(s)
	}
}

func (s *StatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStatement(s)
	}
}

func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Statement() (localctx IStatementContext) {
	this := p
	_ = this

	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, Cobol85ParserRULE_statement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3638)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserACCEPT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3589)
			p.AcceptStatement()
		}

	case Cobol85ParserADD:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3590)
			p.AddStatement()
		}

	case Cobol85ParserALTER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3591)
			p.AlterStatement()
		}

	case Cobol85ParserCALL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3592)
			p.CallStatement()
		}

	case Cobol85ParserCANCEL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3593)
			p.CancelStatement()
		}

	case Cobol85ParserCLOSE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3594)
			p.CloseStatement()
		}

	case Cobol85ParserCOMPUTE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3595)
			p.ComputeStatement()
		}

	case Cobol85ParserCONTINUE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3596)
			p.ContinueStatement()
		}

	case Cobol85ParserDELETE:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3597)
			p.DeleteStatement()
		}

	case Cobol85ParserDISABLE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3598)
			p.DisableStatement()
		}

	case Cobol85ParserDISPLAY:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3599)
			p.DisplayStatement()
		}

	case Cobol85ParserDIVIDE:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3600)
			p.DivideStatement()
		}

	case Cobol85ParserENABLE:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3601)
			p.EnableStatement()
		}

	case Cobol85ParserENTRY:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3602)
			p.EntryStatement()
		}

	case Cobol85ParserEVALUATE:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3603)
			p.EvaluateStatement()
		}

	case Cobol85ParserEXHIBIT:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3604)
			p.ExhibitStatement()
		}

	case Cobol85ParserEXECCICSLINE:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3605)
			p.ExecCicsStatement()
		}

	case Cobol85ParserEXECSQLLINE:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3606)
			p.ExecSqlStatement()
		}

	case Cobol85ParserEXECSQLIMSLINE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3607)
			p.ExecSqlImsStatement()
		}

	case Cobol85ParserEXIT:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3608)
			p.ExitStatement()
		}

	case Cobol85ParserGENERATE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3609)
			p.GenerateStatement()
		}

	case Cobol85ParserGOBACK:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3610)
			p.GobackStatement()
		}

	case Cobol85ParserGO:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3611)
			p.GoToStatement()
		}

	case Cobol85ParserIF:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3612)
			p.IfStatement()
		}

	case Cobol85ParserINITIALIZE:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3613)
			p.InitializeStatement()
		}

	case Cobol85ParserINITIATE:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3614)
			p.InitiateStatement()
		}

	case Cobol85ParserINSPECT:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(3615)
			p.InspectStatement()
		}

	case Cobol85ParserMERGE:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(3616)
			p.MergeStatement()
		}

	case Cobol85ParserMOVE:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(3617)
			p.MoveStatement()
		}

	case Cobol85ParserMULTIPLY:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(3618)
			p.MultiplyStatement()
		}

	case Cobol85ParserOPEN:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(3619)
			p.OpenStatement()
		}

	case Cobol85ParserPERFORM:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(3620)
			p.PerformStatement()
		}

	case Cobol85ParserPURGE:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(3621)
			p.PurgeStatement()
		}

	case Cobol85ParserREAD:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(3622)
			p.ReadStatement()
		}

	case Cobol85ParserRECEIVE:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(3623)
			p.ReceiveStatement()
		}

	case Cobol85ParserRELEASE:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(3624)
			p.ReleaseStatement()
		}

	case Cobol85ParserRETURN:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(3625)
			p.ReturnStatement()
		}

	case Cobol85ParserREWRITE:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(3626)
			p.RewriteStatement()
		}

	case Cobol85ParserSEARCH:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(3627)
			p.SearchStatement()
		}

	case Cobol85ParserSEND:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(3628)
			p.SendStatement()
		}

	case Cobol85ParserSET:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(3629)
			p.SetStatement()
		}

	case Cobol85ParserSORT:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(3630)
			p.SortStatement()
		}

	case Cobol85ParserSTART:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(3631)
			p.StartStatement()
		}

	case Cobol85ParserSTOP:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(3632)
			p.StopStatement()
		}

	case Cobol85ParserSTRING:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(3633)
			p.StringStatement()
		}

	case Cobol85ParserSUBTRACT:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(3634)
			p.SubtractStatement()
		}

	case Cobol85ParserTERMINATE:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(3635)
			p.TerminateStatement()
		}

	case Cobol85ParserUNSTRING:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(3636)
			p.UnstringStatement()
		}

	case Cobol85ParserWRITE:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(3637)
			p.WriteStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcceptStatementContext is an interface to support dynamic dispatch.
type IAcceptStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptStatementContext differentiates from other interfaces.
	IsAcceptStatementContext()
}

type AcceptStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptStatementContext() *AcceptStatementContext {
	var p = new(AcceptStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptStatement
	return p
}

func (*AcceptStatementContext) IsAcceptStatementContext() {}

func NewAcceptStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptStatementContext {
	var p = new(AcceptStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptStatement

	return p
}

func (s *AcceptStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptStatementContext) ACCEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserACCEPT, 0)
}

func (s *AcceptStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AcceptStatementContext) AcceptFromDateStatement() IAcceptFromDateStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptFromDateStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptFromDateStatementContext)
}

func (s *AcceptStatementContext) AcceptFromEscapeKeyStatement() IAcceptFromEscapeKeyStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptFromEscapeKeyStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptFromEscapeKeyStatementContext)
}

func (s *AcceptStatementContext) AcceptFromMnemonicStatement() IAcceptFromMnemonicStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptFromMnemonicStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptFromMnemonicStatementContext)
}

func (s *AcceptStatementContext) AcceptMessageCountStatement() IAcceptMessageCountStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAcceptMessageCountStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAcceptMessageCountStatementContext)
}

func (s *AcceptStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *AcceptStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *AcceptStatementContext) END_ACCEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_ACCEPT, 0)
}

func (s *AcceptStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptStatement(s)
	}
}

func (s *AcceptStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptStatement(s)
	}
}

func (s *AcceptStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptStatement() (localctx IAcceptStatementContext) {
	this := p
	_ = this

	localctx = NewAcceptStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, Cobol85ParserRULE_acceptStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3640)
		p.Match(Cobol85ParserACCEPT)
	}
	{
		p.SetState(3641)
		p.Identifier()
	}
	p.SetState(3646)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3642)
			p.AcceptFromDateStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3643)
			p.AcceptFromEscapeKeyStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3644)
			p.AcceptFromMnemonicStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 465, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(3645)
			p.AcceptMessageCountStatement()
		}

	}
	p.SetState(3649)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3648)
			p.OnExceptionClause()
		}

	}
	p.SetState(3652)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 467, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3651)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(3655)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 468, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3654)
			p.Match(Cobol85ParserEND_ACCEPT)
		}

	}

	return localctx
}

// IAcceptFromDateStatementContext is an interface to support dynamic dispatch.
type IAcceptFromDateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromDateStatementContext differentiates from other interfaces.
	IsAcceptFromDateStatementContext()
}

type AcceptFromDateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromDateStatementContext() *AcceptFromDateStatementContext {
	var p = new(AcceptFromDateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromDateStatement
	return p
}

func (*AcceptFromDateStatementContext) IsAcceptFromDateStatementContext() {}

func NewAcceptFromDateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromDateStatementContext {
	var p = new(AcceptFromDateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromDateStatement

	return p
}

func (s *AcceptFromDateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromDateStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromDateStatementContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *AcceptFromDateStatementContext) DAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY, 0)
}

func (s *AcceptFromDateStatementContext) DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY_OF_WEEK, 0)
}

func (s *AcceptFromDateStatementContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *AcceptFromDateStatementContext) TIMER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMER, 0)
}

func (s *AcceptFromDateStatementContext) TODAYS_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_DATE, 0)
}

func (s *AcceptFromDateStatementContext) TODAYS_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_NAME, 0)
}

func (s *AcceptFromDateStatementContext) YEAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYEAR, 0)
}

func (s *AcceptFromDateStatementContext) YYYYMMDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYMMDD, 0)
}

func (s *AcceptFromDateStatementContext) YYYYDDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYDDD, 0)
}

func (s *AcceptFromDateStatementContext) MMDDYYYY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMMDDYYYY, 0)
}

func (s *AcceptFromDateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromDateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromDateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromDateStatement(s)
	}
}

func (s *AcceptFromDateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromDateStatement(s)
	}
}

func (s *AcceptFromDateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptFromDateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptFromDateStatement() (localctx IAcceptFromDateStatementContext) {
	this := p
	_ = this

	localctx = NewAcceptFromDateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, Cobol85ParserRULE_acceptFromDateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3657)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(3677)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDATE:
		{
			p.SetState(3658)
			p.Match(Cobol85ParserDATE)
		}
		p.SetState(3660)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserYYYYMMDD {
			{
				p.SetState(3659)
				p.Match(Cobol85ParserYYYYMMDD)
			}

		}

	case Cobol85ParserDAY:
		{
			p.SetState(3662)
			p.Match(Cobol85ParserDAY)
		}
		p.SetState(3664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserYYYYDDD {
			{
				p.SetState(3663)
				p.Match(Cobol85ParserYYYYDDD)
			}

		}

	case Cobol85ParserDAY_OF_WEEK:
		{
			p.SetState(3666)
			p.Match(Cobol85ParserDAY_OF_WEEK)
		}

	case Cobol85ParserTIME:
		{
			p.SetState(3667)
			p.Match(Cobol85ParserTIME)
		}

	case Cobol85ParserTIMER:
		{
			p.SetState(3668)
			p.Match(Cobol85ParserTIMER)
		}

	case Cobol85ParserTODAYS_DATE:
		{
			p.SetState(3669)
			p.Match(Cobol85ParserTODAYS_DATE)
		}
		p.SetState(3671)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserMMDDYYYY {
			{
				p.SetState(3670)
				p.Match(Cobol85ParserMMDDYYYY)
			}

		}

	case Cobol85ParserTODAYS_NAME:
		{
			p.SetState(3673)
			p.Match(Cobol85ParserTODAYS_NAME)
		}

	case Cobol85ParserYEAR:
		{
			p.SetState(3674)
			p.Match(Cobol85ParserYEAR)
		}

	case Cobol85ParserYYYYMMDD:
		{
			p.SetState(3675)
			p.Match(Cobol85ParserYYYYMMDD)
		}

	case Cobol85ParserYYYYDDD:
		{
			p.SetState(3676)
			p.Match(Cobol85ParserYYYYDDD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAcceptFromMnemonicStatementContext is an interface to support dynamic dispatch.
type IAcceptFromMnemonicStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromMnemonicStatementContext differentiates from other interfaces.
	IsAcceptFromMnemonicStatementContext()
}

type AcceptFromMnemonicStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromMnemonicStatementContext() *AcceptFromMnemonicStatementContext {
	var p = new(AcceptFromMnemonicStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromMnemonicStatement
	return p
}

func (*AcceptFromMnemonicStatementContext) IsAcceptFromMnemonicStatementContext() {}

func NewAcceptFromMnemonicStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromMnemonicStatementContext {
	var p = new(AcceptFromMnemonicStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromMnemonicStatement

	return p
}

func (s *AcceptFromMnemonicStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromMnemonicStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromMnemonicStatementContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *AcceptFromMnemonicStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromMnemonicStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromMnemonicStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromMnemonicStatement(s)
	}
}

func (s *AcceptFromMnemonicStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromMnemonicStatement(s)
	}
}

func (s *AcceptFromMnemonicStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptFromMnemonicStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptFromMnemonicStatement() (localctx IAcceptFromMnemonicStatementContext) {
	this := p
	_ = this

	localctx = NewAcceptFromMnemonicStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, Cobol85ParserRULE_acceptFromMnemonicStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3679)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(3680)
		p.MnemonicName()
	}

	return localctx
}

// IAcceptFromEscapeKeyStatementContext is an interface to support dynamic dispatch.
type IAcceptFromEscapeKeyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptFromEscapeKeyStatementContext differentiates from other interfaces.
	IsAcceptFromEscapeKeyStatementContext()
}

type AcceptFromEscapeKeyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptFromEscapeKeyStatementContext() *AcceptFromEscapeKeyStatementContext {
	var p = new(AcceptFromEscapeKeyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptFromEscapeKeyStatement
	return p
}

func (*AcceptFromEscapeKeyStatementContext) IsAcceptFromEscapeKeyStatementContext() {}

func NewAcceptFromEscapeKeyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptFromEscapeKeyStatementContext {
	var p = new(AcceptFromEscapeKeyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptFromEscapeKeyStatement

	return p
}

func (s *AcceptFromEscapeKeyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptFromEscapeKeyStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESCAPE, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *AcceptFromEscapeKeyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptFromEscapeKeyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptFromEscapeKeyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptFromEscapeKeyStatement(s)
	}
}

func (s *AcceptFromEscapeKeyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptFromEscapeKeyStatement(s)
	}
}

func (s *AcceptFromEscapeKeyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptFromEscapeKeyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptFromEscapeKeyStatement() (localctx IAcceptFromEscapeKeyStatementContext) {
	this := p
	_ = this

	localctx = NewAcceptFromEscapeKeyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, Cobol85ParserRULE_acceptFromEscapeKeyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3682)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(3683)
		p.Match(Cobol85ParserESCAPE)
	}
	{
		p.SetState(3684)
		p.Match(Cobol85ParserKEY)
	}

	return localctx
}

// IAcceptMessageCountStatementContext is an interface to support dynamic dispatch.
type IAcceptMessageCountStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAcceptMessageCountStatementContext differentiates from other interfaces.
	IsAcceptMessageCountStatementContext()
}

type AcceptMessageCountStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAcceptMessageCountStatementContext() *AcceptMessageCountStatementContext {
	var p = new(AcceptMessageCountStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_acceptMessageCountStatement
	return p
}

func (*AcceptMessageCountStatementContext) IsAcceptMessageCountStatementContext() {}

func NewAcceptMessageCountStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AcceptMessageCountStatementContext {
	var p = new(AcceptMessageCountStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_acceptMessageCountStatement

	return p
}

func (s *AcceptMessageCountStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AcceptMessageCountStatementContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *AcceptMessageCountStatementContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *AcceptMessageCountStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AcceptMessageCountStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AcceptMessageCountStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAcceptMessageCountStatement(s)
	}
}

func (s *AcceptMessageCountStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAcceptMessageCountStatement(s)
	}
}

func (s *AcceptMessageCountStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAcceptMessageCountStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AcceptMessageCountStatement() (localctx IAcceptMessageCountStatementContext) {
	this := p
	_ = this

	localctx = NewAcceptMessageCountStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, Cobol85ParserRULE_acceptMessageCountStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3687)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMESSAGE {
		{
			p.SetState(3686)
			p.Match(Cobol85ParserMESSAGE)
		}

	}
	{
		p.SetState(3689)
		p.Match(Cobol85ParserCOUNT)
	}

	return localctx
}

// IAddStatementContext is an interface to support dynamic dispatch.
type IAddStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddStatementContext differentiates from other interfaces.
	IsAddStatementContext()
}

type AddStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddStatementContext() *AddStatementContext {
	var p = new(AddStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addStatement
	return p
}

func (*AddStatementContext) IsAddStatementContext() {}

func NewAddStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddStatementContext {
	var p = new(AddStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addStatement

	return p
}

func (s *AddStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddStatementContext) ADD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADD, 0)
}

func (s *AddStatementContext) AddToStatement() IAddToStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddToStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddToStatementContext)
}

func (s *AddStatementContext) AddToGivingStatement() IAddToGivingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddToGivingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddToGivingStatementContext)
}

func (s *AddStatementContext) AddCorrespondingStatement() IAddCorrespondingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddCorrespondingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddCorrespondingStatementContext)
}

func (s *AddStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *AddStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *AddStatementContext) END_ADD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_ADD, 0)
}

func (s *AddStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddStatement(s)
	}
}

func (s *AddStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddStatement(s)
	}
}

func (s *AddStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddStatement() (localctx IAddStatementContext) {
	this := p
	_ = this

	localctx = NewAddStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, Cobol85ParserRULE_addStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3691)
		p.Match(Cobol85ParserADD)
	}
	p.SetState(3695)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 474, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3692)
			p.AddToStatement()
		}

	case 2:
		{
			p.SetState(3693)
			p.AddToGivingStatement()
		}

	case 3:
		{
			p.SetState(3694)
			p.AddCorrespondingStatement()
		}

	}
	p.SetState(3698)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 475, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3697)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(3701)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 476, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3700)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(3704)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 477, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3703)
			p.Match(Cobol85ParserEND_ADD)
		}

	}

	return localctx
}

// IAddToStatementContext is an interface to support dynamic dispatch.
type IAddToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToStatementContext differentiates from other interfaces.
	IsAddToStatementContext()
}

type AddToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToStatementContext() *AddToStatementContext {
	var p = new(AddToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToStatement
	return p
}

func (*AddToStatementContext) IsAddToStatementContext() {}

func NewAddToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToStatementContext {
	var p = new(AddToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToStatement

	return p
}

func (s *AddToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddToStatementContext) AllAddFrom() []IAddFromContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddFromContext); ok {
			len++
		}
	}

	tst := make([]IAddFromContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddFromContext); ok {
			tst[i] = t.(IAddFromContext)
			i++
		}
	}

	return tst
}

func (s *AddToStatementContext) AddFrom(i int) IAddFromContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFromContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFromContext)
}

func (s *AddToStatementContext) AllAddTo() []IAddToContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddToContext); ok {
			len++
		}
	}

	tst := make([]IAddToContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddToContext); ok {
			tst[i] = t.(IAddToContext)
			i++
		}
	}

	return tst
}

func (s *AddToStatementContext) AddTo(i int) IAddToContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddToContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToStatement(s)
	}
}

func (s *AddToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToStatement(s)
	}
}

func (s *AddToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddToStatement() (localctx IAddToStatementContext) {
	this := p
	_ = this

	localctx = NewAddToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, Cobol85ParserRULE_addToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(3706)
			p.AddFrom()
		}

		p.SetState(3709)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3711)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(3713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3712)
			p.AddTo()
		}

		p.SetState(3715)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddToGivingStatementContext is an interface to support dynamic dispatch.
type IAddToGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToGivingStatementContext differentiates from other interfaces.
	IsAddToGivingStatementContext()
}

type AddToGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToGivingStatementContext() *AddToGivingStatementContext {
	var p = new(AddToGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToGivingStatement
	return p
}

func (*AddToGivingStatementContext) IsAddToGivingStatementContext() {}

func NewAddToGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToGivingStatementContext {
	var p = new(AddToGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToGivingStatement

	return p
}

func (s *AddToGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToGivingStatementContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *AddToGivingStatementContext) AllAddFrom() []IAddFromContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddFromContext); ok {
			len++
		}
	}

	tst := make([]IAddFromContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddFromContext); ok {
			tst[i] = t.(IAddFromContext)
			i++
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddFrom(i int) IAddFromContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddFromContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddFromContext)
}

func (s *AddToGivingStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddToGivingStatementContext) AllAddGiving() []IAddGivingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddGivingContext); ok {
			len++
		}
	}

	tst := make([]IAddGivingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddGivingContext); ok {
			tst[i] = t.(IAddGivingContext)
			i++
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddGiving(i int) IAddGivingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddGivingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddGivingContext)
}

func (s *AddToGivingStatementContext) AllAddToGiving() []IAddToGivingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAddToGivingContext); ok {
			len++
		}
	}

	tst := make([]IAddToGivingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAddToGivingContext); ok {
			tst[i] = t.(IAddToGivingContext)
			i++
		}
	}

	return tst
}

func (s *AddToGivingStatementContext) AddToGiving(i int) IAddToGivingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddToGivingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddToGivingContext)
}

func (s *AddToGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToGivingStatement(s)
	}
}

func (s *AddToGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToGivingStatement(s)
	}
}

func (s *AddToGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddToGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddToGivingStatement() (localctx IAddToGivingStatementContext) {
	this := p
	_ = this

	localctx = NewAddToGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, Cobol85ParserRULE_addToGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(3717)
			p.AddFrom()
		}

		p.SetState(3720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(3728)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3722)
			p.Match(Cobol85ParserTO)
		}
		p.SetState(3724)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
			{
				p.SetState(3723)
				p.AddToGiving()
			}

			p.SetState(3726)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(3730)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(3732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3731)
			p.AddGiving()
		}

		p.SetState(3734)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAddCorrespondingStatementContext is an interface to support dynamic dispatch.
type IAddCorrespondingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddCorrespondingStatementContext differentiates from other interfaces.
	IsAddCorrespondingStatementContext()
}

type AddCorrespondingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddCorrespondingStatementContext() *AddCorrespondingStatementContext {
	var p = new(AddCorrespondingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addCorrespondingStatement
	return p
}

func (*AddCorrespondingStatementContext) IsAddCorrespondingStatementContext() {}

func NewAddCorrespondingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddCorrespondingStatementContext {
	var p = new(AddCorrespondingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addCorrespondingStatement

	return p
}

func (s *AddCorrespondingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AddCorrespondingStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddCorrespondingStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AddCorrespondingStatementContext) AddTo() IAddToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAddToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAddToContext)
}

func (s *AddCorrespondingStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *AddCorrespondingStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *AddCorrespondingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddCorrespondingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddCorrespondingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddCorrespondingStatement(s)
	}
}

func (s *AddCorrespondingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddCorrespondingStatement(s)
	}
}

func (s *AddCorrespondingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddCorrespondingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddCorrespondingStatement() (localctx IAddCorrespondingStatementContext) {
	this := p
	_ = this

	localctx = NewAddCorrespondingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, Cobol85ParserRULE_addCorrespondingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3736)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3737)
		p.Identifier()
	}
	{
		p.SetState(3738)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(3739)
		p.AddTo()
	}

	return localctx
}

// IAddFromContext is an interface to support dynamic dispatch.
type IAddFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddFromContext differentiates from other interfaces.
	IsAddFromContext()
}

type AddFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddFromContext() *AddFromContext {
	var p = new(AddFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addFrom
	return p
}

func (*AddFromContext) IsAddFromContext() {}

func NewAddFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddFromContext {
	var p = new(AddFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addFrom

	return p
}

func (s *AddFromContext) GetParser() antlr.Parser { return s.parser }

func (s *AddFromContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddFromContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AddFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddFrom(s)
	}
}

func (s *AddFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddFrom(s)
	}
}

func (s *AddFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddFrom() (localctx IAddFromContext) {
	this := p
	_ = this

	localctx = NewAddFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, Cobol85ParserRULE_addFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3743)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 484, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3741)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3742)
			p.Literal()
		}

	}

	return localctx
}

// IAddToContext is an interface to support dynamic dispatch.
type IAddToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToContext differentiates from other interfaces.
	IsAddToContext()
}

type AddToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToContext() *AddToContext {
	var p = new(AddToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addTo
	return p
}

func (*AddToContext) IsAddToContext() {}

func NewAddToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToContext {
	var p = new(AddToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addTo

	return p
}

func (s *AddToContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddToContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *AddToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddTo(s)
	}
}

func (s *AddToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddTo(s)
	}
}

func (s *AddToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddTo() (localctx IAddToContext) {
	this := p
	_ = this

	localctx = NewAddToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, Cobol85ParserRULE_addTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3745)
		p.Identifier()
	}
	p.SetState(3747)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3746)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IAddToGivingContext is an interface to support dynamic dispatch.
type IAddToGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddToGivingContext differentiates from other interfaces.
	IsAddToGivingContext()
}

type AddToGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddToGivingContext() *AddToGivingContext {
	var p = new(AddToGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addToGiving
	return p
}

func (*AddToGivingContext) IsAddToGivingContext() {}

func NewAddToGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddToGivingContext {
	var p = new(AddToGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addToGiving

	return p
}

func (s *AddToGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *AddToGivingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddToGivingContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *AddToGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddToGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddToGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddToGiving(s)
	}
}

func (s *AddToGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddToGiving(s)
	}
}

func (s *AddToGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddToGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddToGiving() (localctx IAddToGivingContext) {
	this := p
	_ = this

	localctx = NewAddToGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, Cobol85ParserRULE_addToGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3751)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 486, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3749)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3750)
			p.Literal()
		}

	}

	return localctx
}

// IAddGivingContext is an interface to support dynamic dispatch.
type IAddGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddGivingContext differentiates from other interfaces.
	IsAddGivingContext()
}

type AddGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddGivingContext() *AddGivingContext {
	var p = new(AddGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_addGiving
	return p
}

func (*AddGivingContext) IsAddGivingContext() {}

func NewAddGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddGivingContext {
	var p = new(AddGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_addGiving

	return p
}

func (s *AddGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *AddGivingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AddGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *AddGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAddGiving(s)
	}
}

func (s *AddGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAddGiving(s)
	}
}

func (s *AddGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAddGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AddGiving() (localctx IAddGivingContext) {
	this := p
	_ = this

	localctx = NewAddGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, Cobol85ParserRULE_addGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3753)
		p.Identifier()
	}
	p.SetState(3755)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3754)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IAlteredGoToContext is an interface to support dynamic dispatch.
type IAlteredGoToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlteredGoToContext differentiates from other interfaces.
	IsAlteredGoToContext()
}

type AlteredGoToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlteredGoToContext() *AlteredGoToContext {
	var p = new(AlteredGoToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alteredGoTo
	return p
}

func (*AlteredGoToContext) IsAlteredGoToContext() {}

func NewAlteredGoToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlteredGoToContext {
	var p = new(AlteredGoToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alteredGoTo

	return p
}

func (s *AlteredGoToContext) GetParser() antlr.Parser { return s.parser }

func (s *AlteredGoToContext) GO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGO, 0)
}

func (s *AlteredGoToContext) DOT_FS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOT_FS, 0)
}

func (s *AlteredGoToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *AlteredGoToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlteredGoToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlteredGoToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlteredGoTo(s)
	}
}

func (s *AlteredGoToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlteredGoTo(s)
	}
}

func (s *AlteredGoToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlteredGoTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlteredGoTo() (localctx IAlteredGoToContext) {
	this := p
	_ = this

	localctx = NewAlteredGoToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, Cobol85ParserRULE_alteredGoTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3757)
		p.Match(Cobol85ParserGO)
	}
	p.SetState(3759)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(3758)
			p.Match(Cobol85ParserTO)
		}

	}
	{
		p.SetState(3761)
		p.Match(Cobol85ParserDOT_FS)
	}

	return localctx
}

// IAlterStatementContext is an interface to support dynamic dispatch.
type IAlterStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterStatementContext differentiates from other interfaces.
	IsAlterStatementContext()
}

type AlterStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterStatementContext() *AlterStatementContext {
	var p = new(AlterStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alterStatement
	return p
}

func (*AlterStatementContext) IsAlterStatementContext() {}

func NewAlterStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterStatementContext {
	var p = new(AlterStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alterStatement

	return p
}

func (s *AlterStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterStatementContext) ALTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALTER, 0)
}

func (s *AlterStatementContext) AllAlterProceedTo() []IAlterProceedToContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterProceedToContext); ok {
			len++
		}
	}

	tst := make([]IAlterProceedToContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterProceedToContext); ok {
			tst[i] = t.(IAlterProceedToContext)
			i++
		}
	}

	return tst
}

func (s *AlterStatementContext) AlterProceedTo(i int) IAlterProceedToContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterProceedToContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterProceedToContext)
}

func (s *AlterStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlterStatement(s)
	}
}

func (s *AlterStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlterStatement(s)
	}
}

func (s *AlterStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlterStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlterStatement() (localctx IAlterStatementContext) {
	this := p
	_ = this

	localctx = NewAlterStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, Cobol85ParserRULE_alterStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3763)
		p.Match(Cobol85ParserALTER)
	}
	p.SetState(3765)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3764)
			p.AlterProceedTo()
		}

		p.SetState(3767)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAlterProceedToContext is an interface to support dynamic dispatch.
type IAlterProceedToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlterProceedToContext differentiates from other interfaces.
	IsAlterProceedToContext()
}

type AlterProceedToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterProceedToContext() *AlterProceedToContext {
	var p = new(AlterProceedToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alterProceedTo
	return p
}

func (*AlterProceedToContext) IsAlterProceedToContext() {}

func NewAlterProceedToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterProceedToContext {
	var p = new(AlterProceedToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alterProceedTo

	return p
}

func (s *AlterProceedToContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterProceedToContext) AllProcedureName() []IProcedureNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureNameContext); ok {
			len++
		}
	}

	tst := make([]IProcedureNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureNameContext); ok {
			tst[i] = t.(IProcedureNameContext)
			i++
		}
	}

	return tst
}

func (s *AlterProceedToContext) ProcedureName(i int) IProcedureNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *AlterProceedToContext) AllTO() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserTO)
}

func (s *AlterProceedToContext) TO(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, i)
}

func (s *AlterProceedToContext) PROCEED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEED, 0)
}

func (s *AlterProceedToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterProceedToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterProceedToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlterProceedTo(s)
	}
}

func (s *AlterProceedToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlterProceedTo(s)
	}
}

func (s *AlterProceedToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlterProceedTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlterProceedTo() (localctx IAlterProceedToContext) {
	this := p
	_ = this

	localctx = NewAlterProceedToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, Cobol85ParserRULE_alterProceedTo)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3769)
		p.ProcedureName()
	}
	{
		p.SetState(3770)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(3773)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROCEED {
		{
			p.SetState(3771)
			p.Match(Cobol85ParserPROCEED)
		}
		{
			p.SetState(3772)
			p.Match(Cobol85ParserTO)
		}

	}
	{
		p.SetState(3775)
		p.ProcedureName()
	}

	return localctx
}

// ICallStatementContext is an interface to support dynamic dispatch.
type ICallStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallStatementContext differentiates from other interfaces.
	IsCallStatementContext()
}

type CallStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallStatementContext() *CallStatementContext {
	var p = new(CallStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callStatement
	return p
}

func (*CallStatementContext) IsCallStatementContext() {}

func NewCallStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallStatementContext {
	var p = new(CallStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callStatement

	return p
}

func (s *CallStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CallStatementContext) CALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCALL, 0)
}

func (s *CallStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallStatementContext) CallUsingPhrase() ICallUsingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallUsingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallUsingPhraseContext)
}

func (s *CallStatementContext) CallGivingPhrase() ICallGivingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallGivingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallGivingPhraseContext)
}

func (s *CallStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnOverflowPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *CallStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *CallStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *CallStatementContext) END_CALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_CALL, 0)
}

func (s *CallStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallStatement(s)
	}
}

func (s *CallStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallStatement(s)
	}
}

func (s *CallStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallStatement() (localctx ICallStatementContext) {
	this := p
	_ = this

	localctx = NewCallStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, Cobol85ParserRULE_callStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3777)
		p.Match(Cobol85ParserCALL)
	}
	p.SetState(3780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 491, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3778)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3779)
			p.Literal()
		}

	}
	p.SetState(3783)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3782)
			p.CallUsingPhrase()
		}

	}
	p.SetState(3786)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING {
		{
			p.SetState(3785)
			p.CallGivingPhrase()
		}

	}
	p.SetState(3789)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 494, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3788)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(3792)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 495, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3791)
			p.OnExceptionClause()
		}

	}
	p.SetState(3795)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 496, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3794)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(3798)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 497, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3797)
			p.Match(Cobol85ParserEND_CALL)
		}

	}

	return localctx
}

// ICallUsingPhraseContext is an interface to support dynamic dispatch.
type ICallUsingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallUsingPhraseContext differentiates from other interfaces.
	IsCallUsingPhraseContext()
}

type CallUsingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallUsingPhraseContext() *CallUsingPhraseContext {
	var p = new(CallUsingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callUsingPhrase
	return p
}

func (*CallUsingPhraseContext) IsCallUsingPhraseContext() {}

func NewCallUsingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallUsingPhraseContext {
	var p = new(CallUsingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callUsingPhrase

	return p
}

func (s *CallUsingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallUsingPhraseContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *CallUsingPhraseContext) AllCallUsingParameter() []ICallUsingParameterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallUsingParameterContext); ok {
			len++
		}
	}

	tst := make([]ICallUsingParameterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallUsingParameterContext); ok {
			tst[i] = t.(ICallUsingParameterContext)
			i++
		}
	}

	return tst
}

func (s *CallUsingPhraseContext) CallUsingParameter(i int) ICallUsingParameterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallUsingParameterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallUsingParameterContext)
}

func (s *CallUsingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallUsingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallUsingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallUsingPhrase(s)
	}
}

func (s *CallUsingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallUsingPhrase(s)
	}
}

func (s *CallUsingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallUsingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallUsingPhrase() (localctx ICallUsingPhraseContext) {
	this := p
	_ = this

	localctx = NewCallUsingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, Cobol85ParserRULE_callUsingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3800)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(3802)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3801)
				p.CallUsingParameter()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 498, p.GetParserRuleContext())
	}

	return localctx
}

// ICallUsingParameterContext is an interface to support dynamic dispatch.
type ICallUsingParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallUsingParameterContext differentiates from other interfaces.
	IsCallUsingParameterContext()
}

type CallUsingParameterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallUsingParameterContext() *CallUsingParameterContext {
	var p = new(CallUsingParameterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callUsingParameter
	return p
}

func (*CallUsingParameterContext) IsCallUsingParameterContext() {}

func NewCallUsingParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallUsingParameterContext {
	var p = new(CallUsingParameterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callUsingParameter

	return p
}

func (s *CallUsingParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *CallUsingParameterContext) CallByReferencePhrase() ICallByReferencePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallByReferencePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallByReferencePhraseContext)
}

func (s *CallUsingParameterContext) CallByValuePhrase() ICallByValuePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallByValuePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallByValuePhraseContext)
}

func (s *CallUsingParameterContext) CallByContentPhrase() ICallByContentPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallByContentPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallByContentPhraseContext)
}

func (s *CallUsingParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallUsingParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallUsingParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallUsingParameter(s)
	}
}

func (s *CallUsingParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallUsingParameter(s)
	}
}

func (s *CallUsingParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallUsingParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallUsingParameter() (localctx ICallUsingParameterContext) {
	this := p
	_ = this

	localctx = NewCallUsingParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, Cobol85ParserRULE_callUsingParameter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3809)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 499, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3806)
			p.CallByReferencePhrase()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3807)
			p.CallByValuePhrase()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3808)
			p.CallByContentPhrase()
		}

	}

	return localctx
}

// ICallByReferencePhraseContext is an interface to support dynamic dispatch.
type ICallByReferencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByReferencePhraseContext differentiates from other interfaces.
	IsCallByReferencePhraseContext()
}

type CallByReferencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByReferencePhraseContext() *CallByReferencePhraseContext {
	var p = new(CallByReferencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByReferencePhrase
	return p
}

func (*CallByReferencePhraseContext) IsCallByReferencePhraseContext() {}

func NewCallByReferencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByReferencePhraseContext {
	var p = new(CallByReferencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByReferencePhrase

	return p
}

func (s *CallByReferencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByReferencePhraseContext) REFERENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCE, 0)
}

func (s *CallByReferencePhraseContext) AllCallByReference() []ICallByReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallByReferenceContext); ok {
			len++
		}
	}

	tst := make([]ICallByReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallByReferenceContext); ok {
			tst[i] = t.(ICallByReferenceContext)
			i++
		}
	}

	return tst
}

func (s *CallByReferencePhraseContext) CallByReference(i int) ICallByReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallByReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallByReferenceContext)
}

func (s *CallByReferencePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByReferencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByReferencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByReferencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByReferencePhrase(s)
	}
}

func (s *CallByReferencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByReferencePhrase(s)
	}
}

func (s *CallByReferencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByReferencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByReferencePhrase() (localctx ICallByReferencePhraseContext) {
	this := p
	_ = this

	localctx = NewCallByReferencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, Cobol85ParserRULE_callByReferencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY || _la == Cobol85ParserREFERENCE {
		p.SetState(3812)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserBY {
			{
				p.SetState(3811)
				p.Match(Cobol85ParserBY)
			}

		}
		{
			p.SetState(3814)
			p.Match(Cobol85ParserREFERENCE)
		}

	}
	p.SetState(3818)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3817)
				p.CallByReference()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3820)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 502, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByReferenceContext is an interface to support dynamic dispatch.
type ICallByReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByReferenceContext differentiates from other interfaces.
	IsCallByReferenceContext()
}

type CallByReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByReferenceContext() *CallByReferenceContext {
	var p = new(CallByReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByReference
	return p
}

func (*CallByReferenceContext) IsCallByReferenceContext() {}

func NewCallByReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByReferenceContext {
	var p = new(CallByReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByReference

	return p
}

func (s *CallByReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByReferenceContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByReferenceContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CallByReferenceContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByReferenceContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByReferenceContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *CallByReferenceContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *CallByReferenceContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *CallByReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByReference(s)
	}
}

func (s *CallByReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByReference(s)
	}
}

func (s *CallByReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByReference() (localctx ICallByReferenceContext) {
	this := p
	_ = this

	localctx = NewCallByReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, Cobol85ParserRULE_callByReference)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3834)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL_, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSTRING, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3831)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 504, p.GetParserRuleContext()) {
		case 1:
			p.SetState(3826)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(3822)
					p.Match(Cobol85ParserADDRESS)
				}
				{
					p.SetState(3823)
					p.Match(Cobol85ParserOF)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(3824)
					p.Match(Cobol85ParserINTEGER)
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 503, p.GetParserRuleContext()) == 3 {
				{
					p.SetState(3825)
					p.Match(Cobol85ParserSTRING)
				}

			}
			{
				p.SetState(3828)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(3829)
				p.Literal()
			}

		case 3:
			{
				p.SetState(3830)
				p.FileName()
			}

		}

	case Cobol85ParserOMITTED:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3833)
			p.Match(Cobol85ParserOMITTED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICallByValuePhraseContext is an interface to support dynamic dispatch.
type ICallByValuePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByValuePhraseContext differentiates from other interfaces.
	IsCallByValuePhraseContext()
}

type CallByValuePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByValuePhraseContext() *CallByValuePhraseContext {
	var p = new(CallByValuePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByValuePhrase
	return p
}

func (*CallByValuePhraseContext) IsCallByValuePhraseContext() {}

func NewCallByValuePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByValuePhraseContext {
	var p = new(CallByValuePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByValuePhrase

	return p
}

func (s *CallByValuePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByValuePhraseContext) VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVALUE, 0)
}

func (s *CallByValuePhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByValuePhraseContext) AllCallByValue() []ICallByValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallByValueContext); ok {
			len++
		}
	}

	tst := make([]ICallByValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallByValueContext); ok {
			tst[i] = t.(ICallByValueContext)
			i++
		}
	}

	return tst
}

func (s *CallByValuePhraseContext) CallByValue(i int) ICallByValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallByValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallByValueContext)
}

func (s *CallByValuePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByValuePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByValuePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByValuePhrase(s)
	}
}

func (s *CallByValuePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByValuePhrase(s)
	}
}

func (s *CallByValuePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByValuePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByValuePhrase() (localctx ICallByValuePhraseContext) {
	this := p
	_ = this

	localctx = NewCallByValuePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, Cobol85ParserRULE_callByValuePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3837)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3836)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3839)
		p.Match(Cobol85ParserVALUE)
	}
	p.SetState(3841)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3840)
				p.CallByValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3843)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 507, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByValueContext is an interface to support dynamic dispatch.
type ICallByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByValueContext differentiates from other interfaces.
	IsCallByValueContext()
}

type CallByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByValueContext() *CallByValueContext {
	var p = new(CallByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByValue
	return p
}

func (*CallByValueContext) IsCallByValueContext() {}

func NewCallByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByValueContext {
	var p = new(CallByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByValue

	return p
}

func (s *CallByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByValueContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByValueContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByValueContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByValueContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *CallByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByValue(s)
	}
}

func (s *CallByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByValue(s)
	}
}

func (s *CallByValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByValue() (localctx ICallByValueContext) {
	this := p
	_ = this

	localctx = NewCallByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, Cobol85ParserRULE_callByValue)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3851)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3845)
			p.Match(Cobol85ParserADDRESS)
		}
		{
			p.SetState(3846)
			p.Match(Cobol85ParserOF)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 509, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3847)
			p.Match(Cobol85ParserLENGTH)
		}
		p.SetState(3849)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(3848)
				p.Match(Cobol85ParserOF)
			}

		}

	}
	p.SetState(3855)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 510, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3853)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3854)
			p.Literal()
		}

	}

	return localctx
}

// ICallByContentPhraseContext is an interface to support dynamic dispatch.
type ICallByContentPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByContentPhraseContext differentiates from other interfaces.
	IsCallByContentPhraseContext()
}

type CallByContentPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByContentPhraseContext() *CallByContentPhraseContext {
	var p = new(CallByContentPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByContentPhrase
	return p
}

func (*CallByContentPhraseContext) IsCallByContentPhraseContext() {}

func NewCallByContentPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByContentPhraseContext {
	var p = new(CallByContentPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByContentPhrase

	return p
}

func (s *CallByContentPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByContentPhraseContext) CONTENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTENT, 0)
}

func (s *CallByContentPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *CallByContentPhraseContext) AllCallByContent() []ICallByContentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICallByContentContext); ok {
			len++
		}
	}

	tst := make([]ICallByContentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICallByContentContext); ok {
			tst[i] = t.(ICallByContentContext)
			i++
		}
	}

	return tst
}

func (s *CallByContentPhraseContext) CallByContent(i int) ICallByContentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICallByContentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICallByContentContext)
}

func (s *CallByContentPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByContentPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByContentPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByContentPhrase(s)
	}
}

func (s *CallByContentPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByContentPhrase(s)
	}
}

func (s *CallByContentPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByContentPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByContentPhrase() (localctx ICallByContentPhraseContext) {
	this := p
	_ = this

	localctx = NewCallByContentPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, Cobol85ParserRULE_callByContentPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3858)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(3857)
			p.Match(Cobol85ParserBY)
		}

	}
	{
		p.SetState(3860)
		p.Match(Cobol85ParserCONTENT)
	}
	p.SetState(3862)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(3861)
				p.CallByContent()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(3864)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 512, p.GetParserRuleContext())
	}

	return localctx
}

// ICallByContentContext is an interface to support dynamic dispatch.
type ICallByContentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallByContentContext differentiates from other interfaces.
	IsCallByContentContext()
}

type CallByContentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallByContentContext() *CallByContentContext {
	var p = new(CallByContentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callByContent
	return p
}

func (*CallByContentContext) IsCallByContentContext() {}

func NewCallByContentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallByContentContext {
	var p = new(CallByContentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callByContent

	return p
}

func (s *CallByContentContext) GetParser() antlr.Parser { return s.parser }

func (s *CallByContentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallByContentContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *CallByContentContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *CallByContentContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *CallByContentContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CallByContentContext) OMITTED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOMITTED, 0)
}

func (s *CallByContentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallByContentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallByContentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallByContent(s)
	}
}

func (s *CallByContentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallByContent(s)
	}
}

func (s *CallByContentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallByContent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallByContent() (localctx ICallByContentContext) {
	this := p
	_ = this

	localctx = NewCallByContentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, Cobol85ParserRULE_callByContent)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3877)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 515, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3872)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3866)
				p.Match(Cobol85ParserADDRESS)
			}
			{
				p.SetState(3867)
				p.Match(Cobol85ParserOF)
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 514, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(3868)
				p.Match(Cobol85ParserLENGTH)
			}
			p.SetState(3870)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserOF {
				{
					p.SetState(3869)
					p.Match(Cobol85ParserOF)
				}

			}

		}
		{
			p.SetState(3874)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3875)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3876)
			p.Match(Cobol85ParserOMITTED)
		}

	}

	return localctx
}

// ICallGivingPhraseContext is an interface to support dynamic dispatch.
type ICallGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCallGivingPhraseContext differentiates from other interfaces.
	IsCallGivingPhraseContext()
}

type CallGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCallGivingPhraseContext() *CallGivingPhraseContext {
	var p = new(CallGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_callGivingPhrase
	return p
}

func (*CallGivingPhraseContext) IsCallGivingPhraseContext() {}

func NewCallGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CallGivingPhraseContext {
	var p = new(CallGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_callGivingPhrase

	return p
}

func (s *CallGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *CallGivingPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CallGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *CallGivingPhraseContext) RETURNING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURNING, 0)
}

func (s *CallGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CallGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CallGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCallGivingPhrase(s)
	}
}

func (s *CallGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCallGivingPhrase(s)
	}
}

func (s *CallGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCallGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CallGivingPhrase() (localctx ICallGivingPhraseContext) {
	this := p
	_ = this

	localctx = NewCallGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, Cobol85ParserRULE_callGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3879)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserGIVING || _la == Cobol85ParserRETURNING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3880)
		p.Identifier()
	}

	return localctx
}

// ICancelStatementContext is an interface to support dynamic dispatch.
type ICancelStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCancelStatementContext differentiates from other interfaces.
	IsCancelStatementContext()
}

type CancelStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelStatementContext() *CancelStatementContext {
	var p = new(CancelStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cancelStatement
	return p
}

func (*CancelStatementContext) IsCancelStatementContext() {}

func NewCancelStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelStatementContext {
	var p = new(CancelStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cancelStatement

	return p
}

func (s *CancelStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelStatementContext) CANCEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCANCEL, 0)
}

func (s *CancelStatementContext) AllCancelCall() []ICancelCallContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICancelCallContext); ok {
			len++
		}
	}

	tst := make([]ICancelCallContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICancelCallContext); ok {
			tst[i] = t.(ICancelCallContext)
			i++
		}
	}

	return tst
}

func (s *CancelStatementContext) CancelCall(i int) ICancelCallContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICancelCallContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICancelCallContext)
}

func (s *CancelStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCancelStatement(s)
	}
}

func (s *CancelStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCancelStatement(s)
	}
}

func (s *CancelStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCancelStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CancelStatement() (localctx ICancelStatementContext) {
	this := p
	_ = this

	localctx = NewCancelStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, Cobol85ParserRULE_cancelStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3882)
		p.Match(Cobol85ParserCANCEL)
	}
	p.SetState(3884)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(3883)
			p.CancelCall()
		}

		p.SetState(3886)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICancelCallContext is an interface to support dynamic dispatch.
type ICancelCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCancelCallContext differentiates from other interfaces.
	IsCancelCallContext()
}

type CancelCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCancelCallContext() *CancelCallContext {
	var p = new(CancelCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cancelCall
	return p
}

func (*CancelCallContext) IsCancelCallContext() {}

func NewCancelCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CancelCallContext {
	var p = new(CancelCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cancelCall

	return p
}

func (s *CancelCallContext) GetParser() antlr.Parser { return s.parser }

func (s *CancelCallContext) LibraryName() ILibraryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *CancelCallContext) BYTITLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYTITLE, 0)
}

func (s *CancelCallContext) BYFUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBYFUNCTION, 0)
}

func (s *CancelCallContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CancelCallContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CancelCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CancelCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CancelCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCancelCall(s)
	}
}

func (s *CancelCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCancelCall(s)
	}
}

func (s *CancelCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCancelCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CancelCall() (localctx ICancelCallContext) {
	this := p
	_ = this

	localctx = NewCancelCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, Cobol85ParserRULE_cancelCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3893)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 517, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3888)
			p.LibraryName()
		}
		{
			p.SetState(3889)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserBYFUNCTION || _la == Cobol85ParserBYTITLE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3891)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3892)
			p.Literal()
		}

	}

	return localctx
}

// ICloseStatementContext is an interface to support dynamic dispatch.
type ICloseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseStatementContext differentiates from other interfaces.
	IsCloseStatementContext()
}

type CloseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseStatementContext() *CloseStatementContext {
	var p = new(CloseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeStatement
	return p
}

func (*CloseStatementContext) IsCloseStatementContext() {}

func NewCloseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseStatementContext {
	var p = new(CloseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeStatement

	return p
}

func (s *CloseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseStatementContext) CLOSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE, 0)
}

func (s *CloseStatementContext) AllCloseFile() []ICloseFileContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICloseFileContext); ok {
			len++
		}
	}

	tst := make([]ICloseFileContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICloseFileContext); ok {
			tst[i] = t.(ICloseFileContext)
			i++
		}
	}

	return tst
}

func (s *CloseStatementContext) CloseFile(i int) ICloseFileContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseFileContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseFileContext)
}

func (s *CloseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseStatement(s)
	}
}

func (s *CloseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseStatement(s)
	}
}

func (s *CloseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseStatement() (localctx ICloseStatementContext) {
	this := p
	_ = this

	localctx = NewCloseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, Cobol85ParserRULE_closeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3895)
		p.Match(Cobol85ParserCLOSE)
	}
	p.SetState(3897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(3896)
			p.CloseFile()
		}

		p.SetState(3899)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ICloseFileContext is an interface to support dynamic dispatch.
type ICloseFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseFileContext differentiates from other interfaces.
	IsCloseFileContext()
}

type CloseFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseFileContext() *CloseFileContext {
	var p = new(CloseFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeFile
	return p
}

func (*CloseFileContext) IsCloseFileContext() {}

func NewCloseFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseFileContext {
	var p = new(CloseFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeFile

	return p
}

func (s *CloseFileContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseFileContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *CloseFileContext) CloseReelUnitStatement() ICloseReelUnitStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseReelUnitStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseReelUnitStatementContext)
}

func (s *CloseFileContext) CloseRelativeStatement() ICloseRelativeStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICloseRelativeStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICloseRelativeStatementContext)
}

func (s *CloseFileContext) ClosePortFileIOStatement() IClosePortFileIOStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosePortFileIOStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOStatementContext)
}

func (s *CloseFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseFile(s)
	}
}

func (s *CloseFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseFile(s)
	}
}

func (s *CloseFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseFile() (localctx ICloseFileContext) {
	this := p
	_ = this

	localctx = NewCloseFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, Cobol85ParserRULE_closeFile)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3901)
		p.FileName()
	}
	p.SetState(3905)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3902)
			p.CloseReelUnitStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3903)
			p.CloseRelativeStatement()
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 519, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3904)
			p.ClosePortFileIOStatement()
		}

	}

	return localctx
}

// ICloseReelUnitStatementContext is an interface to support dynamic dispatch.
type ICloseReelUnitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseReelUnitStatementContext differentiates from other interfaces.
	IsCloseReelUnitStatementContext()
}

type CloseReelUnitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseReelUnitStatementContext() *CloseReelUnitStatementContext {
	var p = new(CloseReelUnitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeReelUnitStatement
	return p
}

func (*CloseReelUnitStatementContext) IsCloseReelUnitStatementContext() {}

func NewCloseReelUnitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseReelUnitStatementContext {
	var p = new(CloseReelUnitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeReelUnitStatement

	return p
}

func (s *CloseReelUnitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseReelUnitStatementContext) REEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREEL, 0)
}

func (s *CloseReelUnitStatementContext) UNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNIT, 0)
}

func (s *CloseReelUnitStatementContext) REMOVAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVAL, 0)
}

func (s *CloseReelUnitStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *CloseReelUnitStatementContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *CloseReelUnitStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *CloseReelUnitStatementContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *CloseReelUnitStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CloseReelUnitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseReelUnitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseReelUnitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseReelUnitStatement(s)
	}
}

func (s *CloseReelUnitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseReelUnitStatement(s)
	}
}

func (s *CloseReelUnitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseReelUnitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseReelUnitStatement() (localctx ICloseReelUnitStatementContext) {
	this := p
	_ = this

	localctx = NewCloseReelUnitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, Cobol85ParserRULE_closeReelUnitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3907)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserREEL || _la == Cobol85ParserUNIT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3912)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserREMOVAL {
		p.SetState(3909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserFOR {
			{
				p.SetState(3908)
				p.Match(Cobol85ParserFOR)
			}

		}
		{
			p.SetState(3911)
			p.Match(Cobol85ParserREMOVAL)
		}

	}
	p.SetState(3922)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 524, p.GetParserRuleContext()) == 1 {
		p.SetState(3915)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(3914)
				p.Match(Cobol85ParserWITH)
			}

		}
		p.SetState(3920)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserNO:
			{
				p.SetState(3917)
				p.Match(Cobol85ParserNO)
			}
			{
				p.SetState(3918)
				p.Match(Cobol85ParserREWIND)
			}

		case Cobol85ParserLOCK:
			{
				p.SetState(3919)
				p.Match(Cobol85ParserLOCK)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	}

	return localctx
}

// ICloseRelativeStatementContext is an interface to support dynamic dispatch.
type ICloseRelativeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCloseRelativeStatementContext differentiates from other interfaces.
	IsCloseRelativeStatementContext()
}

type CloseRelativeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloseRelativeStatementContext() *CloseRelativeStatementContext {
	var p = new(CloseRelativeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closeRelativeStatement
	return p
}

func (*CloseRelativeStatementContext) IsCloseRelativeStatementContext() {}

func NewCloseRelativeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloseRelativeStatementContext {
	var p = new(CloseRelativeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closeRelativeStatement

	return p
}

func (s *CloseRelativeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloseRelativeStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *CloseRelativeStatementContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *CloseRelativeStatementContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *CloseRelativeStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *CloseRelativeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloseRelativeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloseRelativeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCloseRelativeStatement(s)
	}
}

func (s *CloseRelativeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCloseRelativeStatement(s)
	}
}

func (s *CloseRelativeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCloseRelativeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CloseRelativeStatement() (localctx ICloseRelativeStatementContext) {
	this := p
	_ = this

	localctx = NewCloseRelativeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, Cobol85ParserRULE_closeRelativeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3925)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(3924)
			p.Match(Cobol85ParserWITH)
		}

	}
	p.SetState(3930)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNO:
		{
			p.SetState(3927)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(3928)
			p.Match(Cobol85ParserREWIND)
		}

	case Cobol85ParserLOCK:
		{
			p.SetState(3929)
			p.Match(Cobol85ParserLOCK)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClosePortFileIOStatementContext is an interface to support dynamic dispatch.
type IClosePortFileIOStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOStatementContext differentiates from other interfaces.
	IsClosePortFileIOStatementContext()
}

type ClosePortFileIOStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOStatementContext() *ClosePortFileIOStatementContext {
	var p = new(ClosePortFileIOStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOStatement
	return p
}

func (*ClosePortFileIOStatementContext) IsClosePortFileIOStatementContext() {}

func NewClosePortFileIOStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOStatementContext {
	var p = new(ClosePortFileIOStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOStatement

	return p
}

func (s *ClosePortFileIOStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOStatementContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ClosePortFileIOStatementContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ClosePortFileIOStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ClosePortFileIOStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *ClosePortFileIOStatementContext) AllClosePortFileIOUsing() []IClosePortFileIOUsingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IClosePortFileIOUsingContext); ok {
			len++
		}
	}

	tst := make([]IClosePortFileIOUsingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IClosePortFileIOUsingContext); ok {
			tst[i] = t.(IClosePortFileIOUsingContext)
			i++
		}
	}

	return tst
}

func (s *ClosePortFileIOStatementContext) ClosePortFileIOUsing(i int) IClosePortFileIOUsingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosePortFileIOUsingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingContext)
}

func (s *ClosePortFileIOStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOStatement(s)
	}
}

func (s *ClosePortFileIOStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOStatement(s)
	}
}

func (s *ClosePortFileIOStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOStatement() (localctx IClosePortFileIOStatementContext) {
	this := p
	_ = this

	localctx = NewClosePortFileIOStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, Cobol85ParserRULE_closePortFileIOStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3939)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 528, p.GetParserRuleContext()) {
	case 1:
		p.SetState(3933)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(3932)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(3935)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(3936)
			p.Match(Cobol85ParserWAIT)
		}

	case 2:
		{
			p.SetState(3937)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(3938)
			p.Match(Cobol85ParserWAIT)
		}

	}
	p.SetState(3947)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(3941)
			p.Match(Cobol85ParserUSING)
		}
		p.SetState(3943)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(3942)
					p.ClosePortFileIOUsing()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(3945)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 529, p.GetParserRuleContext())
		}

	}

	return localctx
}

// IClosePortFileIOUsingContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingContext differentiates from other interfaces.
	IsClosePortFileIOUsingContext()
}

type ClosePortFileIOUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingContext() *ClosePortFileIOUsingContext {
	var p = new(ClosePortFileIOUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsing
	return p
}

func (*ClosePortFileIOUsingContext) IsClosePortFileIOUsingContext() {}

func NewClosePortFileIOUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingContext {
	var p = new(ClosePortFileIOUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsing

	return p
}

func (s *ClosePortFileIOUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingCloseDisposition() IClosePortFileIOUsingCloseDispositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosePortFileIOUsingCloseDispositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingCloseDispositionContext)
}

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingAssociatedData() IClosePortFileIOUsingAssociatedDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosePortFileIOUsingAssociatedDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingAssociatedDataContext)
}

func (s *ClosePortFileIOUsingContext) ClosePortFileIOUsingAssociatedDataLength() IClosePortFileIOUsingAssociatedDataLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClosePortFileIOUsingAssociatedDataLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClosePortFileIOUsingAssociatedDataLengthContext)
}

func (s *ClosePortFileIOUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsing(s)
	}
}

func (s *ClosePortFileIOUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsing(s)
	}
}

func (s *ClosePortFileIOUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsing() (localctx IClosePortFileIOUsingContext) {
	this := p
	_ = this

	localctx = NewClosePortFileIOUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, Cobol85ParserRULE_closePortFileIOUsing)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(3952)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserCLOSE_DISPOSITION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3949)
			p.ClosePortFileIOUsingCloseDisposition()
		}

	case Cobol85ParserASSOCIATED_DATA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3950)
			p.ClosePortFileIOUsingAssociatedData()
		}

	case Cobol85ParserASSOCIATED_DATA_LENGTH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3951)
			p.ClosePortFileIOUsingAssociatedDataLength()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IClosePortFileIOUsingCloseDispositionContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingCloseDispositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingCloseDispositionContext differentiates from other interfaces.
	IsClosePortFileIOUsingCloseDispositionContext()
}

type ClosePortFileIOUsingCloseDispositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingCloseDispositionContext() *ClosePortFileIOUsingCloseDispositionContext {
	var p = new(ClosePortFileIOUsingCloseDispositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingCloseDisposition
	return p
}

func (*ClosePortFileIOUsingCloseDispositionContext) IsClosePortFileIOUsingCloseDispositionContext() {}

func NewClosePortFileIOUsingCloseDispositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingCloseDispositionContext {
	var p = new(ClosePortFileIOUsingCloseDispositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingCloseDisposition

	return p
}

func (s *ClosePortFileIOUsingCloseDispositionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingCloseDispositionContext) CLOSE_DISPOSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE_DISPOSITION, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ABORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserABORT, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ORDERLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDERLY, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingCloseDispositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingCloseDisposition(s)
	}
}

func (s *ClosePortFileIOUsingCloseDispositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingCloseDisposition(s)
	}
}

func (s *ClosePortFileIOUsingCloseDispositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsingCloseDisposition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingCloseDisposition() (localctx IClosePortFileIOUsingCloseDispositionContext) {
	this := p
	_ = this

	localctx = NewClosePortFileIOUsingCloseDispositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, Cobol85ParserRULE_closePortFileIOUsingCloseDisposition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3954)
		p.Match(Cobol85ParserCLOSE_DISPOSITION)
	}
	p.SetState(3956)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3955)
			p.Match(Cobol85ParserOF)
		}

	}
	{
		p.SetState(3958)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserABORT || _la == Cobol85ParserORDERLY) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IClosePortFileIOUsingAssociatedDataContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingAssociatedDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingAssociatedDataContext differentiates from other interfaces.
	IsClosePortFileIOUsingAssociatedDataContext()
}

type ClosePortFileIOUsingAssociatedDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingAssociatedDataContext() *ClosePortFileIOUsingAssociatedDataContext {
	var p = new(ClosePortFileIOUsingAssociatedDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedData
	return p
}

func (*ClosePortFileIOUsingAssociatedDataContext) IsClosePortFileIOUsingAssociatedDataContext() {}

func NewClosePortFileIOUsingAssociatedDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingAssociatedDataContext {
	var p = new(ClosePortFileIOUsingAssociatedDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedData

	return p
}

func (s *ClosePortFileIOUsingAssociatedDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingAssociatedDataContext) ASSOCIATED_DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingAssociatedDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingAssociatedDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingAssociatedData(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingAssociatedData(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsingAssociatedData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingAssociatedData() (localctx IClosePortFileIOUsingAssociatedDataContext) {
	this := p
	_ = this

	localctx = NewClosePortFileIOUsingAssociatedDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, Cobol85ParserRULE_closePortFileIOUsingAssociatedData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3960)
		p.Match(Cobol85ParserASSOCIATED_DATA)
	}
	p.SetState(3963)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 533, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3961)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3962)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IClosePortFileIOUsingAssociatedDataLengthContext is an interface to support dynamic dispatch.
type IClosePortFileIOUsingAssociatedDataLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClosePortFileIOUsingAssociatedDataLengthContext differentiates from other interfaces.
	IsClosePortFileIOUsingAssociatedDataLengthContext()
}

type ClosePortFileIOUsingAssociatedDataLengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClosePortFileIOUsingAssociatedDataLengthContext() *ClosePortFileIOUsingAssociatedDataLengthContext {
	var p = new(ClosePortFileIOUsingAssociatedDataLengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength
	return p
}

func (*ClosePortFileIOUsingAssociatedDataLengthContext) IsClosePortFileIOUsingAssociatedDataLengthContext() {
}

func NewClosePortFileIOUsingAssociatedDataLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClosePortFileIOUsingAssociatedDataLengthContext {
	var p = new(ClosePortFileIOUsingAssociatedDataLengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength

	return p
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ASSOCIATED_DATA_LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA_LENGTH, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClosePortFileIOUsingAssociatedDataLength(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClosePortFileIOUsingAssociatedDataLength(s)
	}
}

func (s *ClosePortFileIOUsingAssociatedDataLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClosePortFileIOUsingAssociatedDataLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClosePortFileIOUsingAssociatedDataLength() (localctx IClosePortFileIOUsingAssociatedDataLengthContext) {
	this := p
	_ = this

	localctx = NewClosePortFileIOUsingAssociatedDataLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, Cobol85ParserRULE_closePortFileIOUsingAssociatedDataLength)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3965)
		p.Match(Cobol85ParserASSOCIATED_DATA_LENGTH)
	}
	p.SetState(3967)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOF {
		{
			p.SetState(3966)
			p.Match(Cobol85ParserOF)
		}

	}
	p.SetState(3971)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 535, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(3969)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(3970)
			p.IntegerLiteral()
		}

	}

	return localctx
}

// IComputeStatementContext is an interface to support dynamic dispatch.
type IComputeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeStatementContext differentiates from other interfaces.
	IsComputeStatementContext()
}

type ComputeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeStatementContext() *ComputeStatementContext {
	var p = new(ComputeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computeStatement
	return p
}

func (*ComputeStatementContext) IsComputeStatementContext() {}

func NewComputeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeStatementContext {
	var p = new(ComputeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computeStatement

	return p
}

func (s *ComputeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeStatementContext) COMPUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMPUTE, 0)
}

func (s *ComputeStatementContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ComputeStatementContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *ComputeStatementContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *ComputeStatementContext) AllComputeStore() []IComputeStoreContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComputeStoreContext); ok {
			len++
		}
	}

	tst := make([]IComputeStoreContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComputeStoreContext); ok {
			tst[i] = t.(IComputeStoreContext)
			i++
		}
	}

	return tst
}

func (s *ComputeStatementContext) ComputeStore(i int) IComputeStoreContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComputeStoreContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComputeStoreContext)
}

func (s *ComputeStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *ComputeStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *ComputeStatementContext) END_COMPUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_COMPUTE, 0)
}

func (s *ComputeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputeStatement(s)
	}
}

func (s *ComputeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputeStatement(s)
	}
}

func (s *ComputeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitComputeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ComputeStatement() (localctx IComputeStatementContext) {
	this := p
	_ = this

	localctx = NewComputeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, Cobol85ParserRULE_computeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3973)
		p.Match(Cobol85ParserCOMPUTE)
	}
	p.SetState(3975)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(3974)
			p.ComputeStore()
		}

		p.SetState(3977)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(3979)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEQUAL || _la == Cobol85ParserEQUALCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3980)
		p.ArithmeticExpression()
	}
	p.SetState(3982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 537, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3981)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(3985)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 538, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3984)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(3988)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 539, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(3987)
			p.Match(Cobol85ParserEND_COMPUTE)
		}

	}

	return localctx
}

// IComputeStoreContext is an interface to support dynamic dispatch.
type IComputeStoreContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputeStoreContext differentiates from other interfaces.
	IsComputeStoreContext()
}

type ComputeStoreContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputeStoreContext() *ComputeStoreContext {
	var p = new(ComputeStoreContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computeStore
	return p
}

func (*ComputeStoreContext) IsComputeStoreContext() {}

func NewComputeStoreContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputeStoreContext {
	var p = new(ComputeStoreContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computeStore

	return p
}

func (s *ComputeStoreContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputeStoreContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ComputeStoreContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *ComputeStoreContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputeStoreContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputeStoreContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputeStore(s)
	}
}

func (s *ComputeStoreContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputeStore(s)
	}
}

func (s *ComputeStoreContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitComputeStore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ComputeStore() (localctx IComputeStoreContext) {
	this := p
	_ = this

	localctx = NewComputeStoreContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, Cobol85ParserRULE_computeStore)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3990)
		p.Identifier()
	}
	p.SetState(3992)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(3991)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IContinueStatementContext is an interface to support dynamic dispatch.
type IContinueStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsContinueStatementContext differentiates from other interfaces.
	IsContinueStatementContext()
}

type ContinueStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContinueStatementContext() *ContinueStatementContext {
	var p = new(ContinueStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_continueStatement
	return p
}

func (*ContinueStatementContext) IsContinueStatementContext() {}

func NewContinueStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContinueStatementContext {
	var p = new(ContinueStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_continueStatement

	return p
}

func (s *ContinueStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ContinueStatementContext) CONTINUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTINUE, 0)
}

func (s *ContinueStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContinueStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ContinueStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterContinueStatement(s)
	}
}

func (s *ContinueStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitContinueStatement(s)
	}
}

func (s *ContinueStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitContinueStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ContinueStatement() (localctx IContinueStatementContext) {
	this := p
	_ = this

	localctx = NewContinueStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, Cobol85ParserRULE_continueStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3994)
		p.Match(Cobol85ParserCONTINUE)
	}

	return localctx
}

// IDeleteStatementContext is an interface to support dynamic dispatch.
type IDeleteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDeleteStatementContext differentiates from other interfaces.
	IsDeleteStatementContext()
}

type DeleteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteStatementContext() *DeleteStatementContext {
	var p = new(DeleteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_deleteStatement
	return p
}

func (*DeleteStatementContext) IsDeleteStatementContext() {}

func NewDeleteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteStatementContext {
	var p = new(DeleteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_deleteStatement

	return p
}

func (s *DeleteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteStatementContext) DELETE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELETE, 0)
}

func (s *DeleteStatementContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *DeleteStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *DeleteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *DeleteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *DeleteStatementContext) END_DELETE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_DELETE, 0)
}

func (s *DeleteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDeleteStatement(s)
	}
}

func (s *DeleteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDeleteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DeleteStatement() (localctx IDeleteStatementContext) {
	this := p
	_ = this

	localctx = NewDeleteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, Cobol85ParserRULE_deleteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3996)
		p.Match(Cobol85ParserDELETE)
	}
	{
		p.SetState(3997)
		p.FileName()
	}
	p.SetState(3999)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(3998)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4002)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 542, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4001)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4005)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 543, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4004)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4008)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 544, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4007)
			p.Match(Cobol85ParserEND_DELETE)
		}

	}

	return localctx
}

// IDisableStatementContext is an interface to support dynamic dispatch.
type IDisableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisableStatementContext differentiates from other interfaces.
	IsDisableStatementContext()
}

type DisableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisableStatementContext() *DisableStatementContext {
	var p = new(DisableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_disableStatement
	return p
}

func (*DisableStatementContext) IsDisableStatementContext() {}

func NewDisableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisableStatementContext {
	var p = new(DisableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_disableStatement

	return p
}

func (s *DisableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisableStatementContext) DISABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISABLE, 0)
}

func (s *DisableStatementContext) CdName() ICdNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *DisableStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *DisableStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *DisableStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *DisableStatementContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *DisableStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *DisableStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisableStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisableStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DisableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisableStatement(s)
	}
}

func (s *DisableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisableStatement(s)
	}
}

func (s *DisableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisableStatement() (localctx IDisableStatementContext) {
	this := p
	_ = this

	localctx = NewDisableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, Cobol85ParserRULE_disableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4010)
		p.Match(Cobol85ParserDISABLE)
	}
	p.SetState(4018)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		{
			p.SetState(4011)
			p.Match(Cobol85ParserINPUT)
		}
		p.SetState(4013)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTERMINAL {
			{
				p.SetState(4012)
				p.Match(Cobol85ParserTERMINAL)
			}

		}

	case Cobol85ParserI_O:
		{
			p.SetState(4015)
			p.Match(Cobol85ParserI_O)
		}
		{
			p.SetState(4016)
			p.Match(Cobol85ParserTERMINAL)
		}

	case Cobol85ParserOUTPUT:
		{
			p.SetState(4017)
			p.Match(Cobol85ParserOUTPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4020)
		p.CdName()
	}
	p.SetState(4022)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4021)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4024)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4027)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 548, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4025)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4026)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayStatementContext is an interface to support dynamic dispatch.
type IDisplayStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayStatementContext differentiates from other interfaces.
	IsDisplayStatementContext()
}

type DisplayStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayStatementContext() *DisplayStatementContext {
	var p = new(DisplayStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayStatement
	return p
}

func (*DisplayStatementContext) IsDisplayStatementContext() {}

func NewDisplayStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayStatementContext {
	var p = new(DisplayStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayStatement

	return p
}

func (s *DisplayStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayStatementContext) DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISPLAY, 0)
}

func (s *DisplayStatementContext) AllDisplayOperand() []IDisplayOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDisplayOperandContext); ok {
			len++
		}
	}

	tst := make([]IDisplayOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDisplayOperandContext); ok {
			tst[i] = t.(IDisplayOperandContext)
			i++
		}
	}

	return tst
}

func (s *DisplayStatementContext) DisplayOperand(i int) IDisplayOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayOperandContext)
}

func (s *DisplayStatementContext) DisplayAt() IDisplayAtContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayAtContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayAtContext)
}

func (s *DisplayStatementContext) DisplayUpon() IDisplayUponContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayUponContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayUponContext)
}

func (s *DisplayStatementContext) DisplayWith() IDisplayWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayWithContext)
}

func (s *DisplayStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayStatement(s)
	}
}

func (s *DisplayStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayStatement(s)
	}
}

func (s *DisplayStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayStatement() (localctx IDisplayStatementContext) {
	this := p
	_ = this

	localctx = NewDisplayStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, Cobol85ParserRULE_displayStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4029)
		p.Match(Cobol85ParserDISPLAY)
	}
	p.SetState(4031)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(4030)
			p.DisplayOperand()
		}

		p.SetState(4033)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4036)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 550, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4035)
			p.DisplayAt()
		}

	}
	p.SetState(4039)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUPON {
		{
			p.SetState(4038)
			p.DisplayUpon()
		}

	}
	p.SetState(4042)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 552, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4041)
			p.DisplayWith()
		}

	}

	return localctx
}

// IDisplayOperandContext is an interface to support dynamic dispatch.
type IDisplayOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayOperandContext differentiates from other interfaces.
	IsDisplayOperandContext()
}

type DisplayOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayOperandContext() *DisplayOperandContext {
	var p = new(DisplayOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayOperand
	return p
}

func (*DisplayOperandContext) IsDisplayOperandContext() {}

func NewDisplayOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayOperandContext {
	var p = new(DisplayOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayOperand

	return p
}

func (s *DisplayOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayOperandContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisplayOperandContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisplayOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayOperand(s)
	}
}

func (s *DisplayOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayOperand(s)
	}
}

func (s *DisplayOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayOperand() (localctx IDisplayOperandContext) {
	this := p
	_ = this

	localctx = NewDisplayOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, Cobol85ParserRULE_displayOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4046)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 553, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4044)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4045)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayAtContext is an interface to support dynamic dispatch.
type IDisplayAtContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayAtContext differentiates from other interfaces.
	IsDisplayAtContext()
}

type DisplayAtContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayAtContext() *DisplayAtContext {
	var p = new(DisplayAtContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayAt
	return p
}

func (*DisplayAtContext) IsDisplayAtContext() {}

func NewDisplayAtContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayAtContext {
	var p = new(DisplayAtContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayAt

	return p
}

func (s *DisplayAtContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayAtContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *DisplayAtContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DisplayAtContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DisplayAtContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayAtContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayAtContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayAt(s)
	}
}

func (s *DisplayAtContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayAt(s)
	}
}

func (s *DisplayAtContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayAt(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayAt() (localctx IDisplayAtContext) {
	this := p
	_ = this

	localctx = NewDisplayAtContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, Cobol85ParserRULE_displayAt)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4048)
		p.Match(Cobol85ParserAT)
	}
	p.SetState(4051)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 554, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4049)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4050)
			p.Literal()
		}

	}

	return localctx
}

// IDisplayUponContext is an interface to support dynamic dispatch.
type IDisplayUponContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayUponContext differentiates from other interfaces.
	IsDisplayUponContext()
}

type DisplayUponContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayUponContext() *DisplayUponContext {
	var p = new(DisplayUponContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayUpon
	return p
}

func (*DisplayUponContext) IsDisplayUponContext() {}

func NewDisplayUponContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayUponContext {
	var p = new(DisplayUponContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayUpon

	return p
}

func (s *DisplayUponContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayUponContext) UPON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUPON, 0)
}

func (s *DisplayUponContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *DisplayUponContext) EnvironmentName() IEnvironmentNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEnvironmentNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEnvironmentNameContext)
}

func (s *DisplayUponContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayUponContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayUponContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayUpon(s)
	}
}

func (s *DisplayUponContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayUpon(s)
	}
}

func (s *DisplayUponContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayUpon(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayUpon() (localctx IDisplayUponContext) {
	this := p
	_ = this

	localctx = NewDisplayUponContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, Cobol85ParserRULE_displayUpon)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4053)
		p.Match(Cobol85ParserUPON)
	}
	p.SetState(4056)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 555, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4054)
			p.MnemonicName()
		}

	case 2:
		{
			p.SetState(4055)
			p.EnvironmentName()
		}

	}

	return localctx
}

// IDisplayWithContext is an interface to support dynamic dispatch.
type IDisplayWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplayWithContext differentiates from other interfaces.
	IsDisplayWithContext()
}

type DisplayWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayWithContext() *DisplayWithContext {
	var p = new(DisplayWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_displayWith
	return p
}

func (*DisplayWithContext) IsDisplayWithContext() {}

func NewDisplayWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayWithContext {
	var p = new(DisplayWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_displayWith

	return p
}

func (s *DisplayWithContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *DisplayWithContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *DisplayWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *DisplayWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DisplayWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDisplayWith(s)
	}
}

func (s *DisplayWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDisplayWith(s)
	}
}

func (s *DisplayWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDisplayWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DisplayWith() (localctx IDisplayWithContext) {
	this := p
	_ = this

	localctx = NewDisplayWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, Cobol85ParserRULE_displayWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4059)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4058)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4061)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4062)
		p.Match(Cobol85ParserADVANCING)
	}

	return localctx
}

// IDivideStatementContext is an interface to support dynamic dispatch.
type IDivideStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideStatementContext differentiates from other interfaces.
	IsDivideStatementContext()
}

type DivideStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideStatementContext() *DivideStatementContext {
	var p = new(DivideStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideStatement
	return p
}

func (*DivideStatementContext) IsDivideStatementContext() {}

func NewDivideStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideStatementContext {
	var p = new(DivideStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideStatement

	return p
}

func (s *DivideStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideStatementContext) DIVIDE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDIVIDE, 0)
}

func (s *DivideStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideStatementContext) DivideIntoStatement() IDivideIntoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideIntoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideIntoStatementContext)
}

func (s *DivideStatementContext) DivideIntoGivingStatement() IDivideIntoGivingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideIntoGivingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideIntoGivingStatementContext)
}

func (s *DivideStatementContext) DivideByGivingStatement() IDivideByGivingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideByGivingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideByGivingStatementContext)
}

func (s *DivideStatementContext) DivideRemainder() IDivideRemainderContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideRemainderContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideRemainderContext)
}

func (s *DivideStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *DivideStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *DivideStatementContext) END_DIVIDE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_DIVIDE, 0)
}

func (s *DivideStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideStatement(s)
	}
}

func (s *DivideStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideStatement(s)
	}
}

func (s *DivideStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideStatement() (localctx IDivideStatementContext) {
	this := p
	_ = this

	localctx = NewDivideStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, Cobol85ParserRULE_divideStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4064)
		p.Match(Cobol85ParserDIVIDE)
	}
	p.SetState(4067)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 557, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4065)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4066)
			p.Literal()
		}

	}
	p.SetState(4072)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4069)
			p.DivideIntoStatement()
		}

	case 2:
		{
			p.SetState(4070)
			p.DivideIntoGivingStatement()
		}

	case 3:
		{
			p.SetState(4071)
			p.DivideByGivingStatement()
		}

	}
	p.SetState(4075)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREMAINDER {
		{
			p.SetState(4074)
			p.DivideRemainder()
		}

	}
	p.SetState(4078)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 560, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4077)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(4081)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 561, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4080)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(4084)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 562, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4083)
			p.Match(Cobol85ParserEND_DIVIDE)
		}

	}

	return localctx
}

// IDivideIntoStatementContext is an interface to support dynamic dispatch.
type IDivideIntoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoStatementContext differentiates from other interfaces.
	IsDivideIntoStatementContext()
}

type DivideIntoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoStatementContext() *DivideIntoStatementContext {
	var p = new(DivideIntoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideIntoStatement
	return p
}

func (*DivideIntoStatementContext) IsDivideIntoStatementContext() {}

func NewDivideIntoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoStatementContext {
	var p = new(DivideIntoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideIntoStatement

	return p
}

func (s *DivideIntoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *DivideIntoStatementContext) AllDivideInto() []IDivideIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDivideIntoContext); ok {
			len++
		}
	}

	tst := make([]IDivideIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDivideIntoContext); ok {
			tst[i] = t.(IDivideIntoContext)
			i++
		}
	}

	return tst
}

func (s *DivideIntoStatementContext) DivideInto(i int) IDivideIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideIntoContext)
}

func (s *DivideIntoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideIntoStatement(s)
	}
}

func (s *DivideIntoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideIntoStatement(s)
	}
}

func (s *DivideIntoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideIntoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideIntoStatement() (localctx IDivideIntoStatementContext) {
	this := p
	_ = this

	localctx = NewDivideIntoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, Cobol85ParserRULE_divideIntoStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4086)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(4088)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4087)
			p.DivideInto()
		}

		p.SetState(4090)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDivideIntoGivingStatementContext is an interface to support dynamic dispatch.
type IDivideIntoGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoGivingStatementContext differentiates from other interfaces.
	IsDivideIntoGivingStatementContext()
}

type DivideIntoGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoGivingStatementContext() *DivideIntoGivingStatementContext {
	var p = new(DivideIntoGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideIntoGivingStatement
	return p
}

func (*DivideIntoGivingStatementContext) IsDivideIntoGivingStatementContext() {}

func NewDivideIntoGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoGivingStatementContext {
	var p = new(DivideIntoGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideIntoGivingStatement

	return p
}

func (s *DivideIntoGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoGivingStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *DivideIntoGivingStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideIntoGivingStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideIntoGivingStatementContext) DivideGivingPhrase() IDivideGivingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideGivingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideGivingPhraseContext)
}

func (s *DivideIntoGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideIntoGivingStatement(s)
	}
}

func (s *DivideIntoGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideIntoGivingStatement(s)
	}
}

func (s *DivideIntoGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideIntoGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideIntoGivingStatement() (localctx IDivideIntoGivingStatementContext) {
	this := p
	_ = this

	localctx = NewDivideIntoGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, Cobol85ParserRULE_divideIntoGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4092)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(4095)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 564, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4093)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4094)
			p.Literal()
		}

	}
	p.SetState(4098)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(4097)
			p.DivideGivingPhrase()
		}

	}

	return localctx
}

// IDivideByGivingStatementContext is an interface to support dynamic dispatch.
type IDivideByGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideByGivingStatementContext differentiates from other interfaces.
	IsDivideByGivingStatementContext()
}

type DivideByGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideByGivingStatementContext() *DivideByGivingStatementContext {
	var p = new(DivideByGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideByGivingStatement
	return p
}

func (*DivideByGivingStatementContext) IsDivideByGivingStatementContext() {}

func NewDivideByGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideByGivingStatementContext {
	var p = new(DivideByGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideByGivingStatement

	return p
}

func (s *DivideByGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideByGivingStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *DivideByGivingStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideByGivingStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *DivideByGivingStatementContext) DivideGivingPhrase() IDivideGivingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideGivingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideGivingPhraseContext)
}

func (s *DivideByGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideByGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideByGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideByGivingStatement(s)
	}
}

func (s *DivideByGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideByGivingStatement(s)
	}
}

func (s *DivideByGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideByGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideByGivingStatement() (localctx IDivideByGivingStatementContext) {
	this := p
	_ = this

	localctx = NewDivideByGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, Cobol85ParserRULE_divideByGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4100)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4103)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 566, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4101)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4102)
			p.Literal()
		}

	}
	p.SetState(4106)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGIVING {
		{
			p.SetState(4105)
			p.DivideGivingPhrase()
		}

	}

	return localctx
}

// IDivideGivingPhraseContext is an interface to support dynamic dispatch.
type IDivideGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideGivingPhraseContext differentiates from other interfaces.
	IsDivideGivingPhraseContext()
}

type DivideGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideGivingPhraseContext() *DivideGivingPhraseContext {
	var p = new(DivideGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideGivingPhrase
	return p
}

func (*DivideGivingPhraseContext) IsDivideGivingPhraseContext() {}

func NewDivideGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideGivingPhraseContext {
	var p = new(DivideGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideGivingPhrase

	return p
}

func (s *DivideGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *DivideGivingPhraseContext) AllDivideGiving() []IDivideGivingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDivideGivingContext); ok {
			len++
		}
	}

	tst := make([]IDivideGivingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDivideGivingContext); ok {
			tst[i] = t.(IDivideGivingContext)
			i++
		}
	}

	return tst
}

func (s *DivideGivingPhraseContext) DivideGiving(i int) IDivideGivingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDivideGivingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDivideGivingContext)
}

func (s *DivideGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideGivingPhrase(s)
	}
}

func (s *DivideGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideGivingPhrase(s)
	}
}

func (s *DivideGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideGivingPhrase() (localctx IDivideGivingPhraseContext) {
	this := p
	_ = this

	localctx = NewDivideGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, Cobol85ParserRULE_divideGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4108)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4110)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4109)
			p.DivideGiving()
		}

		p.SetState(4112)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IDivideIntoContext is an interface to support dynamic dispatch.
type IDivideIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideIntoContext differentiates from other interfaces.
	IsDivideIntoContext()
}

type DivideIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideIntoContext() *DivideIntoContext {
	var p = new(DivideIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideInto
	return p
}

func (*DivideIntoContext) IsDivideIntoContext() {}

func NewDivideIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideIntoContext {
	var p = new(DivideIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideInto

	return p
}

func (s *DivideIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideIntoContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideIntoContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *DivideIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideInto(s)
	}
}

func (s *DivideIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideInto(s)
	}
}

func (s *DivideIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideInto() (localctx IDivideIntoContext) {
	this := p
	_ = this

	localctx = NewDivideIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, Cobol85ParserRULE_divideInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4114)
		p.Identifier()
	}
	p.SetState(4116)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4115)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IDivideGivingContext is an interface to support dynamic dispatch.
type IDivideGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideGivingContext differentiates from other interfaces.
	IsDivideGivingContext()
}

type DivideGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideGivingContext() *DivideGivingContext {
	var p = new(DivideGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideGiving
	return p
}

func (*DivideGivingContext) IsDivideGivingContext() {}

func NewDivideGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideGivingContext {
	var p = new(DivideGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideGiving

	return p
}

func (s *DivideGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideGivingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *DivideGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideGiving(s)
	}
}

func (s *DivideGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideGiving(s)
	}
}

func (s *DivideGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideGiving() (localctx IDivideGivingContext) {
	this := p
	_ = this

	localctx = NewDivideGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, Cobol85ParserRULE_divideGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4118)
		p.Identifier()
	}
	p.SetState(4120)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4119)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IDivideRemainderContext is an interface to support dynamic dispatch.
type IDivideRemainderContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDivideRemainderContext differentiates from other interfaces.
	IsDivideRemainderContext()
}

type DivideRemainderContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDivideRemainderContext() *DivideRemainderContext {
	var p = new(DivideRemainderContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_divideRemainder
	return p
}

func (*DivideRemainderContext) IsDivideRemainderContext() {}

func NewDivideRemainderContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DivideRemainderContext {
	var p = new(DivideRemainderContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_divideRemainder

	return p
}

func (s *DivideRemainderContext) GetParser() antlr.Parser { return s.parser }

func (s *DivideRemainderContext) REMAINDER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMAINDER, 0)
}

func (s *DivideRemainderContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DivideRemainderContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DivideRemainderContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DivideRemainderContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDivideRemainder(s)
	}
}

func (s *DivideRemainderContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDivideRemainder(s)
	}
}

func (s *DivideRemainderContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDivideRemainder(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DivideRemainder() (localctx IDivideRemainderContext) {
	this := p
	_ = this

	localctx = NewDivideRemainderContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, Cobol85ParserRULE_divideRemainder)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4122)
		p.Match(Cobol85ParserREMAINDER)
	}
	{
		p.SetState(4123)
		p.Identifier()
	}

	return localctx
}

// IEnableStatementContext is an interface to support dynamic dispatch.
type IEnableStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnableStatementContext differentiates from other interfaces.
	IsEnableStatementContext()
}

type EnableStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnableStatementContext() *EnableStatementContext {
	var p = new(EnableStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_enableStatement
	return p
}

func (*EnableStatementContext) IsEnableStatementContext() {}

func NewEnableStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnableStatementContext {
	var p = new(EnableStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_enableStatement

	return p
}

func (s *EnableStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EnableStatementContext) ENABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENABLE, 0)
}

func (s *EnableStatementContext) CdName() ICdNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *EnableStatementContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *EnableStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *EnableStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *EnableStatementContext) TERMINAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINAL, 0)
}

func (s *EnableStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *EnableStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EnableStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EnableStatementContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *EnableStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnableStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnableStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnableStatement(s)
	}
}

func (s *EnableStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnableStatement(s)
	}
}

func (s *EnableStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnableStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnableStatement() (localctx IEnableStatementContext) {
	this := p
	_ = this

	localctx = NewEnableStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, Cobol85ParserRULE_enableStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4125)
		p.Match(Cobol85ParserENABLE)
	}
	p.SetState(4133)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		{
			p.SetState(4126)
			p.Match(Cobol85ParserINPUT)
		}
		p.SetState(4128)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTERMINAL {
			{
				p.SetState(4127)
				p.Match(Cobol85ParserTERMINAL)
			}

		}

	case Cobol85ParserI_O:
		{
			p.SetState(4130)
			p.Match(Cobol85ParserI_O)
		}
		{
			p.SetState(4131)
			p.Match(Cobol85ParserTERMINAL)
		}

	case Cobol85ParserOUTPUT:
		{
			p.SetState(4132)
			p.Match(Cobol85ParserOUTPUT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(4135)
		p.CdName()
	}
	p.SetState(4137)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4136)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4139)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4142)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 574, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4140)
			p.Literal()
		}

	case 2:
		{
			p.SetState(4141)
			p.Identifier()
		}

	}

	return localctx
}

// IEntryStatementContext is an interface to support dynamic dispatch.
type IEntryStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEntryStatementContext differentiates from other interfaces.
	IsEntryStatementContext()
}

type EntryStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEntryStatementContext() *EntryStatementContext {
	var p = new(EntryStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_entryStatement
	return p
}

func (*EntryStatementContext) IsEntryStatementContext() {}

func NewEntryStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EntryStatementContext {
	var p = new(EntryStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_entryStatement

	return p
}

func (s *EntryStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EntryStatementContext) ENTRY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY, 0)
}

func (s *EntryStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EntryStatementContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *EntryStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *EntryStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EntryStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EntryStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EntryStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEntryStatement(s)
	}
}

func (s *EntryStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEntryStatement(s)
	}
}

func (s *EntryStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEntryStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EntryStatement() (localctx IEntryStatementContext) {
	this := p
	_ = this

	localctx = NewEntryStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, Cobol85ParserRULE_entryStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4144)
		p.Match(Cobol85ParserENTRY)
	}
	{
		p.SetState(4145)
		p.Literal()
	}
	p.SetState(4152)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserUSING {
		{
			p.SetState(4146)
			p.Match(Cobol85ParserUSING)
		}
		p.SetState(4148)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
			{
				p.SetState(4147)
				p.Identifier()
			}

			p.SetState(4150)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IEvaluateStatementContext is an interface to support dynamic dispatch.
type IEvaluateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateStatementContext differentiates from other interfaces.
	IsEvaluateStatementContext()
}

type EvaluateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateStatementContext() *EvaluateStatementContext {
	var p = new(EvaluateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateStatement
	return p
}

func (*EvaluateStatementContext) IsEvaluateStatementContext() {}

func NewEvaluateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateStatementContext {
	var p = new(EvaluateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateStatement

	return p
}

func (s *EvaluateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateStatementContext) EVALUATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVALUATE, 0)
}

func (s *EvaluateStatementContext) EvaluateSelect() IEvaluateSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateSelectContext)
}

func (s *EvaluateStatementContext) AllEvaluateAlsoSelect() []IEvaluateAlsoSelectContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvaluateAlsoSelectContext); ok {
			len++
		}
	}

	tst := make([]IEvaluateAlsoSelectContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvaluateAlsoSelectContext); ok {
			tst[i] = t.(IEvaluateAlsoSelectContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateStatementContext) EvaluateAlsoSelect(i int) IEvaluateAlsoSelectContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateAlsoSelectContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateAlsoSelectContext)
}

func (s *EvaluateStatementContext) AllEvaluateWhenPhrase() []IEvaluateWhenPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvaluateWhenPhraseContext); ok {
			len++
		}
	}

	tst := make([]IEvaluateWhenPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvaluateWhenPhraseContext); ok {
			tst[i] = t.(IEvaluateWhenPhraseContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateStatementContext) EvaluateWhenPhrase(i int) IEvaluateWhenPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateWhenPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenPhraseContext)
}

func (s *EvaluateStatementContext) EvaluateWhenOther() IEvaluateWhenOtherContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateWhenOtherContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenOtherContext)
}

func (s *EvaluateStatementContext) END_EVALUATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_EVALUATE, 0)
}

func (s *EvaluateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateStatement(s)
	}
}

func (s *EvaluateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateStatement(s)
	}
}

func (s *EvaluateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateStatement() (localctx IEvaluateStatementContext) {
	this := p
	_ = this

	localctx = NewEvaluateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, Cobol85ParserRULE_evaluateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4154)
		p.Match(Cobol85ParserEVALUATE)
	}
	{
		p.SetState(4155)
		p.EvaluateSelect()
	}
	p.SetState(4159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserALSO {
		{
			p.SetState(4156)
			p.EvaluateAlsoSelect()
		}

		p.SetState(4161)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4163)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4162)
				p.EvaluateWhenPhrase()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4165)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 578, p.GetParserRuleContext())
	}
	p.SetState(4168)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 579, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4167)
			p.EvaluateWhenOther()
		}

	}
	p.SetState(4171)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 580, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4170)
			p.Match(Cobol85ParserEND_EVALUATE)
		}

	}

	return localctx
}

// IEvaluateSelectContext is an interface to support dynamic dispatch.
type IEvaluateSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateSelectContext differentiates from other interfaces.
	IsEvaluateSelectContext()
}

type EvaluateSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateSelectContext() *EvaluateSelectContext {
	var p = new(EvaluateSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateSelect
	return p
}

func (*EvaluateSelectContext) IsEvaluateSelectContext() {}

func NewEvaluateSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateSelectContext {
	var p = new(EvaluateSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateSelect

	return p
}

func (s *EvaluateSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateSelectContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateSelectContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EvaluateSelectContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *EvaluateSelectContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvaluateSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateSelect(s)
	}
}

func (s *EvaluateSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateSelect(s)
	}
}

func (s *EvaluateSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateSelect() (localctx IEvaluateSelectContext) {
	this := p
	_ = this

	localctx = NewEvaluateSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, Cobol85ParserRULE_evaluateSelect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4177)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 581, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4173)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4174)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4175)
			p.ArithmeticExpression()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4176)
			p.Condition()
		}

	}

	return localctx
}

// IEvaluateAlsoSelectContext is an interface to support dynamic dispatch.
type IEvaluateAlsoSelectContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateAlsoSelectContext differentiates from other interfaces.
	IsEvaluateAlsoSelectContext()
}

type EvaluateAlsoSelectContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateAlsoSelectContext() *EvaluateAlsoSelectContext {
	var p = new(EvaluateAlsoSelectContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoSelect
	return p
}

func (*EvaluateAlsoSelectContext) IsEvaluateAlsoSelectContext() {}

func NewEvaluateAlsoSelectContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateAlsoSelectContext {
	var p = new(EvaluateAlsoSelectContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoSelect

	return p
}

func (s *EvaluateAlsoSelectContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateAlsoSelectContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *EvaluateAlsoSelectContext) EvaluateSelect() IEvaluateSelectContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateSelectContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateSelectContext)
}

func (s *EvaluateAlsoSelectContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateAlsoSelectContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateAlsoSelectContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateAlsoSelect(s)
	}
}

func (s *EvaluateAlsoSelectContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateAlsoSelect(s)
	}
}

func (s *EvaluateAlsoSelectContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateAlsoSelect(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateAlsoSelect() (localctx IEvaluateAlsoSelectContext) {
	this := p
	_ = this

	localctx = NewEvaluateAlsoSelectContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, Cobol85ParserRULE_evaluateAlsoSelect)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4179)
		p.Match(Cobol85ParserALSO)
	}
	{
		p.SetState(4180)
		p.EvaluateSelect()
	}

	return localctx
}

// IEvaluateWhenPhraseContext is an interface to support dynamic dispatch.
type IEvaluateWhenPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenPhraseContext differentiates from other interfaces.
	IsEvaluateWhenPhraseContext()
}

type EvaluateWhenPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenPhraseContext() *EvaluateWhenPhraseContext {
	var p = new(EvaluateWhenPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenPhrase
	return p
}

func (*EvaluateWhenPhraseContext) IsEvaluateWhenPhraseContext() {}

func NewEvaluateWhenPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenPhraseContext {
	var p = new(EvaluateWhenPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenPhrase

	return p
}

func (s *EvaluateWhenPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenPhraseContext) AllEvaluateWhen() []IEvaluateWhenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvaluateWhenContext); ok {
			len++
		}
	}

	tst := make([]IEvaluateWhenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvaluateWhenContext); ok {
			tst[i] = t.(IEvaluateWhenContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateWhenPhraseContext) EvaluateWhen(i int) IEvaluateWhenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateWhenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateWhenContext)
}

func (s *EvaluateWhenPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateWhenPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EvaluateWhenPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhenPhrase(s)
	}
}

func (s *EvaluateWhenPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhenPhrase(s)
	}
}

func (s *EvaluateWhenPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateWhenPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateWhenPhrase() (localctx IEvaluateWhenPhraseContext) {
	this := p
	_ = this

	localctx = NewEvaluateWhenPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, Cobol85ParserRULE_evaluateWhenPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4183)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4182)
				p.EvaluateWhen()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4185)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 582, p.GetParserRuleContext())
	}
	p.SetState(4190)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4187)
				p.Statement()
			}

		}
		p.SetState(4192)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 583, p.GetParserRuleContext())
	}

	return localctx
}

// IEvaluateWhenContext is an interface to support dynamic dispatch.
type IEvaluateWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenContext differentiates from other interfaces.
	IsEvaluateWhenContext()
}

type EvaluateWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenContext() *EvaluateWhenContext {
	var p = new(EvaluateWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhen
	return p
}

func (*EvaluateWhenContext) IsEvaluateWhenContext() {}

func NewEvaluateWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenContext {
	var p = new(EvaluateWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhen

	return p
}

func (s *EvaluateWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *EvaluateWhenContext) EvaluateCondition() IEvaluateConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateConditionContext)
}

func (s *EvaluateWhenContext) AllEvaluateAlsoCondition() []IEvaluateAlsoConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IEvaluateAlsoConditionContext); ok {
			len++
		}
	}

	tst := make([]IEvaluateAlsoConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IEvaluateAlsoConditionContext); ok {
			tst[i] = t.(IEvaluateAlsoConditionContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateWhenContext) EvaluateAlsoCondition(i int) IEvaluateAlsoConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateAlsoConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateAlsoConditionContext)
}

func (s *EvaluateWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhen(s)
	}
}

func (s *EvaluateWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhen(s)
	}
}

func (s *EvaluateWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateWhen() (localctx IEvaluateWhenContext) {
	this := p
	_ = this

	localctx = NewEvaluateWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, Cobol85ParserRULE_evaluateWhen)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4193)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4194)
		p.EvaluateCondition()
	}
	p.SetState(4198)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserALSO {
		{
			p.SetState(4195)
			p.EvaluateAlsoCondition()
		}

		p.SetState(4200)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEvaluateConditionContext is an interface to support dynamic dispatch.
type IEvaluateConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateConditionContext differentiates from other interfaces.
	IsEvaluateConditionContext()
}

type EvaluateConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateConditionContext() *EvaluateConditionContext {
	var p = new(EvaluateConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateCondition
	return p
}

func (*EvaluateConditionContext) IsEvaluateConditionContext() {}

func NewEvaluateConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateConditionContext {
	var p = new(EvaluateConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateCondition

	return p
}

func (s *EvaluateConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateConditionContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *EvaluateConditionContext) EvaluateValue() IEvaluateValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateValueContext)
}

func (s *EvaluateConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *EvaluateConditionContext) EvaluateThrough() IEvaluateThroughContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateThroughContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateThroughContext)
}

func (s *EvaluateConditionContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *EvaluateConditionContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *EvaluateConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateCondition(s)
	}
}

func (s *EvaluateConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateCondition(s)
	}
}

func (s *EvaluateConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateCondition() (localctx IEvaluateConditionContext) {
	this := p
	_ = this

	localctx = NewEvaluateConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, Cobol85ParserRULE_evaluateCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4211)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 587, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4201)
			p.Match(Cobol85ParserANY)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4203)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNOT {
			{
				p.SetState(4202)
				p.Match(Cobol85ParserNOT)
			}

		}
		{
			p.SetState(4205)
			p.EvaluateValue()
		}
		p.SetState(4207)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
			{
				p.SetState(4206)
				p.EvaluateThrough()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4209)
			p.Condition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4210)
			p.BooleanLiteral()
		}

	}

	return localctx
}

// IEvaluateThroughContext is an interface to support dynamic dispatch.
type IEvaluateThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateThroughContext differentiates from other interfaces.
	IsEvaluateThroughContext()
}

type EvaluateThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateThroughContext() *EvaluateThroughContext {
	var p = new(EvaluateThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateThrough
	return p
}

func (*EvaluateThroughContext) IsEvaluateThroughContext() {}

func NewEvaluateThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateThroughContext {
	var p = new(EvaluateThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateThrough

	return p
}

func (s *EvaluateThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateThroughContext) EvaluateValue() IEvaluateValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateValueContext)
}

func (s *EvaluateThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *EvaluateThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *EvaluateThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateThrough(s)
	}
}

func (s *EvaluateThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateThrough(s)
	}
}

func (s *EvaluateThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateThrough() (localctx IEvaluateThroughContext) {
	this := p
	_ = this

	localctx = NewEvaluateThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, Cobol85ParserRULE_evaluateThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4213)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4214)
		p.EvaluateValue()
	}

	return localctx
}

// IEvaluateAlsoConditionContext is an interface to support dynamic dispatch.
type IEvaluateAlsoConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateAlsoConditionContext differentiates from other interfaces.
	IsEvaluateAlsoConditionContext()
}

type EvaluateAlsoConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateAlsoConditionContext() *EvaluateAlsoConditionContext {
	var p = new(EvaluateAlsoConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoCondition
	return p
}

func (*EvaluateAlsoConditionContext) IsEvaluateAlsoConditionContext() {}

func NewEvaluateAlsoConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateAlsoConditionContext {
	var p = new(EvaluateAlsoConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateAlsoCondition

	return p
}

func (s *EvaluateAlsoConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateAlsoConditionContext) ALSO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALSO, 0)
}

func (s *EvaluateAlsoConditionContext) EvaluateCondition() IEvaluateConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEvaluateConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEvaluateConditionContext)
}

func (s *EvaluateAlsoConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateAlsoConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateAlsoConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateAlsoCondition(s)
	}
}

func (s *EvaluateAlsoConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateAlsoCondition(s)
	}
}

func (s *EvaluateAlsoConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateAlsoCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateAlsoCondition() (localctx IEvaluateAlsoConditionContext) {
	this := p
	_ = this

	localctx = NewEvaluateAlsoConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, Cobol85ParserRULE_evaluateAlsoCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4216)
		p.Match(Cobol85ParserALSO)
	}
	{
		p.SetState(4217)
		p.EvaluateCondition()
	}

	return localctx
}

// IEvaluateWhenOtherContext is an interface to support dynamic dispatch.
type IEvaluateWhenOtherContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateWhenOtherContext differentiates from other interfaces.
	IsEvaluateWhenOtherContext()
}

type EvaluateWhenOtherContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateWhenOtherContext() *EvaluateWhenOtherContext {
	var p = new(EvaluateWhenOtherContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenOther
	return p
}

func (*EvaluateWhenOtherContext) IsEvaluateWhenOtherContext() {}

func NewEvaluateWhenOtherContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateWhenOtherContext {
	var p = new(EvaluateWhenOtherContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateWhenOther

	return p
}

func (s *EvaluateWhenOtherContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateWhenOtherContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *EvaluateWhenOtherContext) OTHER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOTHER, 0)
}

func (s *EvaluateWhenOtherContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *EvaluateWhenOtherContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *EvaluateWhenOtherContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateWhenOtherContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateWhenOtherContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateWhenOther(s)
	}
}

func (s *EvaluateWhenOtherContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateWhenOther(s)
	}
}

func (s *EvaluateWhenOtherContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateWhenOther(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateWhenOther() (localctx IEvaluateWhenOtherContext) {
	this := p
	_ = this

	localctx = NewEvaluateWhenOtherContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, Cobol85ParserRULE_evaluateWhenOther)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4219)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(4220)
		p.Match(Cobol85ParserOTHER)
	}
	p.SetState(4224)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 588, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4221)
				p.Statement()
			}

		}
		p.SetState(4226)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 588, p.GetParserRuleContext())
	}

	return localctx
}

// IEvaluateValueContext is an interface to support dynamic dispatch.
type IEvaluateValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEvaluateValueContext differentiates from other interfaces.
	IsEvaluateValueContext()
}

type EvaluateValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEvaluateValueContext() *EvaluateValueContext {
	var p = new(EvaluateValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_evaluateValue
	return p
}

func (*EvaluateValueContext) IsEvaluateValueContext() {}

func NewEvaluateValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EvaluateValueContext {
	var p = new(EvaluateValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_evaluateValue

	return p
}

func (s *EvaluateValueContext) GetParser() antlr.Parser { return s.parser }

func (s *EvaluateValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *EvaluateValueContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *EvaluateValueContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *EvaluateValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EvaluateValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EvaluateValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEvaluateValue(s)
	}
}

func (s *EvaluateValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEvaluateValue(s)
	}
}

func (s *EvaluateValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEvaluateValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EvaluateValue() (localctx IEvaluateValueContext) {
	this := p
	_ = this

	localctx = NewEvaluateValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, Cobol85ParserRULE_evaluateValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4230)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 589, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4227)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4228)
			p.Literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4229)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IExecCicsStatementContext is an interface to support dynamic dispatch.
type IExecCicsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecCicsStatementContext differentiates from other interfaces.
	IsExecCicsStatementContext()
}

type ExecCicsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecCicsStatementContext() *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execCicsStatement
	return p
}

func (*ExecCicsStatementContext) IsExecCicsStatementContext() {}

func NewExecCicsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecCicsStatementContext {
	var p = new(ExecCicsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execCicsStatement

	return p
}

func (s *ExecCicsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecCicsStatementContext) AllEXECCICSLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECCICSLINE)
}

func (s *ExecCicsStatementContext) EXECCICSLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECCICSLINE, i)
}

func (s *ExecCicsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecCicsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecCicsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecCicsStatement(s)
	}
}

func (s *ExecCicsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExecCicsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExecCicsStatement() (localctx IExecCicsStatementContext) {
	this := p
	_ = this

	localctx = NewExecCicsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, Cobol85ParserRULE_execCicsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4233)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4232)
				p.Match(Cobol85ParserEXECCICSLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4235)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 590, p.GetParserRuleContext())
	}

	return localctx
}

// IExecSqlStatementContext is an interface to support dynamic dispatch.
type IExecSqlStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecSqlStatementContext differentiates from other interfaces.
	IsExecSqlStatementContext()
}

type ExecSqlStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlStatementContext() *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execSqlStatement
	return p
}

func (*ExecSqlStatementContext) IsExecSqlStatementContext() {}

func NewExecSqlStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlStatementContext {
	var p = new(ExecSqlStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execSqlStatement

	return p
}

func (s *ExecSqlStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlStatementContext) AllEXECSQLLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLLINE)
}

func (s *ExecSqlStatementContext) EXECSQLLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLLINE, i)
}

func (s *ExecSqlStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecSqlStatement(s)
	}
}

func (s *ExecSqlStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExecSqlStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExecSqlStatement() (localctx IExecSqlStatementContext) {
	this := p
	_ = this

	localctx = NewExecSqlStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, Cobol85ParserRULE_execSqlStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4238)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4237)
				p.Match(Cobol85ParserEXECSQLLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4240)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 591, p.GetParserRuleContext())
	}

	return localctx
}

// IExecSqlImsStatementContext is an interface to support dynamic dispatch.
type IExecSqlImsStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExecSqlImsStatementContext differentiates from other interfaces.
	IsExecSqlImsStatementContext()
}

type ExecSqlImsStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecSqlImsStatementContext() *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_execSqlImsStatement
	return p
}

func (*ExecSqlImsStatementContext) IsExecSqlImsStatementContext() {}

func NewExecSqlImsStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecSqlImsStatementContext {
	var p = new(ExecSqlImsStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_execSqlImsStatement

	return p
}

func (s *ExecSqlImsStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecSqlImsStatementContext) AllEXECSQLIMSLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserEXECSQLIMSLINE)
}

func (s *ExecSqlImsStatementContext) EXECSQLIMSLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXECSQLIMSLINE, i)
}

func (s *ExecSqlImsStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecSqlImsStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecSqlImsStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExecSqlImsStatement(s)
	}
}

func (s *ExecSqlImsStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExecSqlImsStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExecSqlImsStatement() (localctx IExecSqlImsStatementContext) {
	this := p
	_ = this

	localctx = NewExecSqlImsStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, Cobol85ParserRULE_execSqlImsStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4243)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4242)
				p.Match(Cobol85ParserEXECSQLIMSLINE)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4245)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 592, p.GetParserRuleContext())
	}

	return localctx
}

// IExhibitStatementContext is an interface to support dynamic dispatch.
type IExhibitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExhibitStatementContext differentiates from other interfaces.
	IsExhibitStatementContext()
}

type ExhibitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExhibitStatementContext() *ExhibitStatementContext {
	var p = new(ExhibitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exhibitStatement
	return p
}

func (*ExhibitStatementContext) IsExhibitStatementContext() {}

func NewExhibitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExhibitStatementContext {
	var p = new(ExhibitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exhibitStatement

	return p
}

func (s *ExhibitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExhibitStatementContext) EXHIBIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXHIBIT, 0)
}

func (s *ExhibitStatementContext) NAMED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNAMED, 0)
}

func (s *ExhibitStatementContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANGED, 0)
}

func (s *ExhibitStatementContext) AllExhibitOperand() []IExhibitOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExhibitOperandContext); ok {
			len++
		}
	}

	tst := make([]IExhibitOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExhibitOperandContext); ok {
			tst[i] = t.(IExhibitOperandContext)
			i++
		}
	}

	return tst
}

func (s *ExhibitStatementContext) ExhibitOperand(i int) IExhibitOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExhibitOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExhibitOperandContext)
}

func (s *ExhibitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExhibitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExhibitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExhibitStatement(s)
	}
}

func (s *ExhibitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExhibitStatement(s)
	}
}

func (s *ExhibitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExhibitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExhibitStatement() (localctx IExhibitStatementContext) {
	this := p
	_ = this

	localctx = NewExhibitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, Cobol85ParserRULE_exhibitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4247)
		p.Match(Cobol85ParserEXHIBIT)
	}
	p.SetState(4249)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 593, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4248)
			p.Match(Cobol85ParserNAMED)
		}

	}
	p.SetState(4252)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 594, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4251)
			p.Match(Cobol85ParserCHANGED)
		}

	}
	p.SetState(4255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(4254)
			p.ExhibitOperand()
		}

		p.SetState(4257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IExhibitOperandContext is an interface to support dynamic dispatch.
type IExhibitOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExhibitOperandContext differentiates from other interfaces.
	IsExhibitOperandContext()
}

type ExhibitOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExhibitOperandContext() *ExhibitOperandContext {
	var p = new(ExhibitOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exhibitOperand
	return p
}

func (*ExhibitOperandContext) IsExhibitOperandContext() {}

func NewExhibitOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExhibitOperandContext {
	var p = new(ExhibitOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exhibitOperand

	return p
}

func (s *ExhibitOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *ExhibitOperandContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExhibitOperandContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ExhibitOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExhibitOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExhibitOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExhibitOperand(s)
	}
}

func (s *ExhibitOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExhibitOperand(s)
	}
}

func (s *ExhibitOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExhibitOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExhibitOperand() (localctx IExhibitOperandContext) {
	this := p
	_ = this

	localctx = NewExhibitOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, Cobol85ParserRULE_exhibitOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4261)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 596, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4259)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4260)
			p.Literal()
		}

	}

	return localctx
}

// IExitStatementContext is an interface to support dynamic dispatch.
type IExitStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsExitStatementContext differentiates from other interfaces.
	IsExitStatementContext()
}

type ExitStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExitStatementContext() *ExitStatementContext {
	var p = new(ExitStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_exitStatement
	return p
}

func (*ExitStatementContext) IsExitStatementContext() {}

func NewExitStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExitStatementContext {
	var p = new(ExitStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_exitStatement

	return p
}

func (s *ExitStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExitStatementContext) EXIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXIT, 0)
}

func (s *ExitStatementContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *ExitStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExitStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExitStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterExitStatement(s)
	}
}

func (s *ExitStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitExitStatement(s)
	}
}

func (s *ExitStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitExitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ExitStatement() (localctx IExitStatementContext) {
	this := p
	_ = this

	localctx = NewExitStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, Cobol85ParserRULE_exitStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4263)
		p.Match(Cobol85ParserEXIT)
	}
	p.SetState(4265)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserPROGRAM {
		{
			p.SetState(4264)
			p.Match(Cobol85ParserPROGRAM)
		}

	}

	return localctx
}

// IGenerateStatementContext is an interface to support dynamic dispatch.
type IGenerateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGenerateStatementContext differentiates from other interfaces.
	IsGenerateStatementContext()
}

type GenerateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGenerateStatementContext() *GenerateStatementContext {
	var p = new(GenerateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_generateStatement
	return p
}

func (*GenerateStatementContext) IsGenerateStatementContext() {}

func NewGenerateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GenerateStatementContext {
	var p = new(GenerateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_generateStatement

	return p
}

func (s *GenerateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GenerateStatementContext) GENERATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGENERATE, 0)
}

func (s *GenerateStatementContext) ReportName() IReportNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *GenerateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GenerateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GenerateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGenerateStatement(s)
	}
}

func (s *GenerateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGenerateStatement(s)
	}
}

func (s *GenerateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGenerateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GenerateStatement() (localctx IGenerateStatementContext) {
	this := p
	_ = this

	localctx = NewGenerateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, Cobol85ParserRULE_generateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4267)
		p.Match(Cobol85ParserGENERATE)
	}
	{
		p.SetState(4268)
		p.ReportName()
	}

	return localctx
}

// IGobackStatementContext is an interface to support dynamic dispatch.
type IGobackStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGobackStatementContext differentiates from other interfaces.
	IsGobackStatementContext()
}

type GobackStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGobackStatementContext() *GobackStatementContext {
	var p = new(GobackStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_gobackStatement
	return p
}

func (*GobackStatementContext) IsGobackStatementContext() {}

func NewGobackStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GobackStatementContext {
	var p = new(GobackStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_gobackStatement

	return p
}

func (s *GobackStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GobackStatementContext) GOBACK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGOBACK, 0)
}

func (s *GobackStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GobackStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GobackStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGobackStatement(s)
	}
}

func (s *GobackStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGobackStatement(s)
	}
}

func (s *GobackStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGobackStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GobackStatement() (localctx IGobackStatementContext) {
	this := p
	_ = this

	localctx = NewGobackStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, Cobol85ParserRULE_gobackStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		p.Match(Cobol85ParserGOBACK)
	}

	return localctx
}

// IGoToStatementContext is an interface to support dynamic dispatch.
type IGoToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStatementContext differentiates from other interfaces.
	IsGoToStatementContext()
}

type GoToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStatementContext() *GoToStatementContext {
	var p = new(GoToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToStatement
	return p
}

func (*GoToStatementContext) IsGoToStatementContext() {}

func NewGoToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStatementContext {
	var p = new(GoToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToStatement

	return p
}

func (s *GoToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStatementContext) GO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGO, 0)
}

func (s *GoToStatementContext) GoToStatementSimple() IGoToStatementSimpleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoToStatementSimpleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoToStatementSimpleContext)
}

func (s *GoToStatementContext) GoToDependingOnStatement() IGoToDependingOnStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGoToDependingOnStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGoToDependingOnStatementContext)
}

func (s *GoToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *GoToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToStatement(s)
	}
}

func (s *GoToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToStatement(s)
	}
}

func (s *GoToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGoToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GoToStatement() (localctx IGoToStatementContext) {
	this := p
	_ = this

	localctx = NewGoToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, Cobol85ParserRULE_goToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4272)
		p.Match(Cobol85ParserGO)
	}
	p.SetState(4274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTO {
		{
			p.SetState(4273)
			p.Match(Cobol85ParserTO)
		}

	}
	p.SetState(4278)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 599, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4276)
			p.GoToStatementSimple()
		}

	case 2:
		{
			p.SetState(4277)
			p.GoToDependingOnStatement()
		}

	}

	return localctx
}

// IGoToStatementSimpleContext is an interface to support dynamic dispatch.
type IGoToStatementSimpleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToStatementSimpleContext differentiates from other interfaces.
	IsGoToStatementSimpleContext()
}

type GoToStatementSimpleContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToStatementSimpleContext() *GoToStatementSimpleContext {
	var p = new(GoToStatementSimpleContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToStatementSimple
	return p
}

func (*GoToStatementSimpleContext) IsGoToStatementSimpleContext() {}

func NewGoToStatementSimpleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToStatementSimpleContext {
	var p = new(GoToStatementSimpleContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToStatementSimple

	return p
}

func (s *GoToStatementSimpleContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToStatementSimpleContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *GoToStatementSimpleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToStatementSimpleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToStatementSimpleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToStatementSimple(s)
	}
}

func (s *GoToStatementSimpleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToStatementSimple(s)
	}
}

func (s *GoToStatementSimpleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGoToStatementSimple(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GoToStatementSimple() (localctx IGoToStatementSimpleContext) {
	this := p
	_ = this

	localctx = NewGoToStatementSimpleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, Cobol85ParserRULE_goToStatementSimple)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4280)
		p.ProcedureName()
	}

	return localctx
}

// IGoToDependingOnStatementContext is an interface to support dynamic dispatch.
type IGoToDependingOnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGoToDependingOnStatementContext differentiates from other interfaces.
	IsGoToDependingOnStatementContext()
}

type GoToDependingOnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGoToDependingOnStatementContext() *GoToDependingOnStatementContext {
	var p = new(GoToDependingOnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_goToDependingOnStatement
	return p
}

func (*GoToDependingOnStatementContext) IsGoToDependingOnStatementContext() {}

func NewGoToDependingOnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GoToDependingOnStatementContext {
	var p = new(GoToDependingOnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_goToDependingOnStatement

	return p
}

func (s *GoToDependingOnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *GoToDependingOnStatementContext) MORE_LABELS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORE_LABELS, 0)
}

func (s *GoToDependingOnStatementContext) AllProcedureName() []IProcedureNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureNameContext); ok {
			len++
		}
	}

	tst := make([]IProcedureNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureNameContext); ok {
			tst[i] = t.(IProcedureNameContext)
			i++
		}
	}

	return tst
}

func (s *GoToDependingOnStatementContext) ProcedureName(i int) IProcedureNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *GoToDependingOnStatementContext) DEPENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEPENDING, 0)
}

func (s *GoToDependingOnStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *GoToDependingOnStatementContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *GoToDependingOnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GoToDependingOnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GoToDependingOnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterGoToDependingOnStatement(s)
	}
}

func (s *GoToDependingOnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitGoToDependingOnStatement(s)
	}
}

func (s *GoToDependingOnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitGoToDependingOnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) GoToDependingOnStatement() (localctx IGoToDependingOnStatementContext) {
	this := p
	_ = this

	localctx = NewGoToDependingOnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, Cobol85ParserRULE_goToDependingOnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4295)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserMORE_LABELS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4282)
			p.Match(Cobol85ParserMORE_LABELS)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4284)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
			{
				p.SetState(4283)
				p.ProcedureName()
			}

			p.SetState(4286)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(4293)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserDEPENDING {
			{
				p.SetState(4288)
				p.Match(Cobol85ParserDEPENDING)
			}
			p.SetState(4290)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserON {
				{
					p.SetState(4289)
					p.Match(Cobol85ParserON)
				}

			}
			{
				p.SetState(4292)
				p.Identifier()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfStatementContext is an interface to support dynamic dispatch.
type IIfStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfStatementContext differentiates from other interfaces.
	IsIfStatementContext()
}

type IfStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfStatementContext() *IfStatementContext {
	var p = new(IfStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifStatement
	return p
}

func (*IfStatementContext) IsIfStatementContext() {}

func NewIfStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfStatementContext {
	var p = new(IfStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifStatement

	return p
}

func (s *IfStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *IfStatementContext) IF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIF, 0)
}

func (s *IfStatementContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *IfStatementContext) IfThen() IIfThenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfThenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfThenContext)
}

func (s *IfStatementContext) IfElse() IIfElseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfElseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfElseContext)
}

func (s *IfStatementContext) END_IF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_IF, 0)
}

func (s *IfStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfStatement(s)
	}
}

func (s *IfStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfStatement(s)
	}
}

func (s *IfStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIfStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IfStatement() (localctx IIfStatementContext) {
	this := p
	_ = this

	localctx = NewIfStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, Cobol85ParserRULE_ifStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4297)
		p.Match(Cobol85ParserIF)
	}
	{
		p.SetState(4298)
		p.Condition()
	}
	{
		p.SetState(4299)
		p.IfThen()
	}
	p.SetState(4301)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 604, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4300)
			p.IfElse()
		}

	}
	p.SetState(4304)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 605, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4303)
			p.Match(Cobol85ParserEND_IF)
		}

	}

	return localctx
}

// IIfThenContext is an interface to support dynamic dispatch.
type IIfThenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfThenContext differentiates from other interfaces.
	IsIfThenContext()
}

type IfThenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfThenContext() *IfThenContext {
	var p = new(IfThenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifThen
	return p
}

func (*IfThenContext) IsIfThenContext() {}

func NewIfThenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfThenContext {
	var p = new(IfThenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifThen

	return p
}

func (s *IfThenContext) GetParser() antlr.Parser { return s.parser }

func (s *IfThenContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *IfThenContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *IfThenContext) THEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHEN, 0)
}

func (s *IfThenContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfThenContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfThenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfThenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfThen(s)
	}
}

func (s *IfThenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfThen(s)
	}
}

func (s *IfThenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIfThen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IfThen() (localctx IIfThenContext) {
	this := p
	_ = this

	localctx = NewIfThenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, Cobol85ParserRULE_ifThen)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4307)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHEN {
		{
			p.SetState(4306)
			p.Match(Cobol85ParserTHEN)
		}

	}
	p.SetState(4317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4309)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4310)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ACCEPT, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(4314)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 607, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4311)
					p.Statement()
				}

			}
			p.SetState(4316)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 607, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIfElseContext is an interface to support dynamic dispatch.
type IIfElseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIfElseContext differentiates from other interfaces.
	IsIfElseContext()
}

type IfElseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfElseContext() *IfElseContext {
	var p = new(IfElseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_ifElse
	return p
}

func (*IfElseContext) IsIfElseContext() {}

func NewIfElseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfElseContext {
	var p = new(IfElseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_ifElse

	return p
}

func (s *IfElseContext) GetParser() antlr.Parser { return s.parser }

func (s *IfElseContext) ELSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserELSE, 0)
}

func (s *IfElseContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *IfElseContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *IfElseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *IfElseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *IfElseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfElseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfElseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIfElse(s)
	}
}

func (s *IfElseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIfElse(s)
	}
}

func (s *IfElseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIfElse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IfElse() (localctx IIfElseContext) {
	this := p
	_ = this

	localctx = NewIfElseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, Cobol85ParserRULE_ifElse)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4319)
		p.Match(Cobol85ParserELSE)
	}
	p.SetState(4328)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(4320)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(4321)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ACCEPT, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(4325)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 609, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(4322)
					p.Statement()
				}

			}
			p.SetState(4327)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 609, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IInitializeStatementContext is an interface to support dynamic dispatch.
type IInitializeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeStatementContext differentiates from other interfaces.
	IsInitializeStatementContext()
}

type InitializeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeStatementContext() *InitializeStatementContext {
	var p = new(InitializeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeStatement
	return p
}

func (*InitializeStatementContext) IsInitializeStatementContext() {}

func NewInitializeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeStatementContext {
	var p = new(InitializeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeStatement

	return p
}

func (s *InitializeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeStatementContext) INITIALIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIALIZE, 0)
}

func (s *InitializeStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *InitializeStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializeStatementContext) InitializeReplacingPhrase() IInitializeReplacingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializeReplacingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializeReplacingPhraseContext)
}

func (s *InitializeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeStatement(s)
	}
}

func (s *InitializeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeStatement(s)
	}
}

func (s *InitializeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitializeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitializeStatement() (localctx IInitializeStatementContext) {
	this := p
	_ = this

	localctx = NewInitializeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, Cobol85ParserRULE_initializeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4330)
		p.Match(Cobol85ParserINITIALIZE)
	}
	p.SetState(4332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4331)
			p.Identifier()
		}

		p.SetState(4334)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4337)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPLACING {
		{
			p.SetState(4336)
			p.InitializeReplacingPhrase()
		}

	}

	return localctx
}

// IInitializeReplacingPhraseContext is an interface to support dynamic dispatch.
type IInitializeReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeReplacingPhraseContext differentiates from other interfaces.
	IsInitializeReplacingPhraseContext()
}

type InitializeReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeReplacingPhraseContext() *InitializeReplacingPhraseContext {
	var p = new(InitializeReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingPhrase
	return p
}

func (*InitializeReplacingPhraseContext) IsInitializeReplacingPhraseContext() {}

func NewInitializeReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeReplacingPhraseContext {
	var p = new(InitializeReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingPhrase

	return p
}

func (s *InitializeReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *InitializeReplacingPhraseContext) AllInitializeReplacingBy() []IInitializeReplacingByContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInitializeReplacingByContext); ok {
			len++
		}
	}

	tst := make([]IInitializeReplacingByContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInitializeReplacingByContext); ok {
			tst[i] = t.(IInitializeReplacingByContext)
			i++
		}
	}

	return tst
}

func (s *InitializeReplacingPhraseContext) InitializeReplacingBy(i int) IInitializeReplacingByContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInitializeReplacingByContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInitializeReplacingByContext)
}

func (s *InitializeReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeReplacingPhrase(s)
	}
}

func (s *InitializeReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeReplacingPhrase(s)
	}
}

func (s *InitializeReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitializeReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitializeReplacingPhrase() (localctx IInitializeReplacingPhraseContext) {
	this := p
	_ = this

	localctx = NewInitializeReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, Cobol85ParserRULE_initializeReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4339)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(4341)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&51200) != 0 || _la == Cobol85ParserDBCS || _la == Cobol85ParserEGCS || (int64((_la-304)) & ^0x3f) == 0 && ((int64(1)<<(_la-304))&20483) != 0 {
		{
			p.SetState(4340)
			p.InitializeReplacingBy()
		}

		p.SetState(4343)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInitializeReplacingByContext is an interface to support dynamic dispatch.
type IInitializeReplacingByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitializeReplacingByContext differentiates from other interfaces.
	IsInitializeReplacingByContext()
}

type InitializeReplacingByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitializeReplacingByContext() *InitializeReplacingByContext {
	var p = new(InitializeReplacingByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingBy
	return p
}

func (*InitializeReplacingByContext) IsInitializeReplacingByContext() {}

func NewInitializeReplacingByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitializeReplacingByContext {
	var p = new(InitializeReplacingByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initializeReplacingBy

	return p
}

func (s *InitializeReplacingByContext) GetParser() antlr.Parser { return s.parser }

func (s *InitializeReplacingByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *InitializeReplacingByContext) ALPHABETIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC, 0)
}

func (s *InitializeReplacingByContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *InitializeReplacingByContext) ALPHANUMERIC_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC_EDITED, 0)
}

func (s *InitializeReplacingByContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *InitializeReplacingByContext) NATIONAL_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL_EDITED, 0)
}

func (s *InitializeReplacingByContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC, 0)
}

func (s *InitializeReplacingByContext) NUMERIC_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_EDITED, 0)
}

func (s *InitializeReplacingByContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *InitializeReplacingByContext) EGCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEGCS, 0)
}

func (s *InitializeReplacingByContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InitializeReplacingByContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InitializeReplacingByContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *InitializeReplacingByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitializeReplacingByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitializeReplacingByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitializeReplacingBy(s)
	}
}

func (s *InitializeReplacingByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitializeReplacingBy(s)
	}
}

func (s *InitializeReplacingByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitializeReplacingBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitializeReplacingBy() (localctx IInitializeReplacingByContext) {
	this := p
	_ = this

	localctx = NewInitializeReplacingByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, Cobol85ParserRULE_initializeReplacingBy)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4345)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&51200) != 0 || _la == Cobol85ParserDBCS || _la == Cobol85ParserEGCS || (int64((_la-304)) & ^0x3f) == 0 && ((int64(1)<<(_la-304))&20483) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4347)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDATA {
		{
			p.SetState(4346)
			p.Match(Cobol85ParserDATA)
		}

	}
	{
		p.SetState(4349)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4352)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 615, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4350)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4351)
			p.Literal()
		}

	}

	return localctx
}

// IInitiateStatementContext is an interface to support dynamic dispatch.
type IInitiateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInitiateStatementContext differentiates from other interfaces.
	IsInitiateStatementContext()
}

type InitiateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInitiateStatementContext() *InitiateStatementContext {
	var p = new(InitiateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_initiateStatement
	return p
}

func (*InitiateStatementContext) IsInitiateStatementContext() {}

func NewInitiateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InitiateStatementContext {
	var p = new(InitiateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_initiateStatement

	return p
}

func (s *InitiateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InitiateStatementContext) INITIATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIATE, 0)
}

func (s *InitiateStatementContext) AllReportName() []IReportNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReportNameContext); ok {
			len++
		}
	}

	tst := make([]IReportNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReportNameContext); ok {
			tst[i] = t.(IReportNameContext)
			i++
		}
	}

	return tst
}

func (s *InitiateStatementContext) ReportName(i int) IReportNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *InitiateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InitiateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InitiateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInitiateStatement(s)
	}
}

func (s *InitiateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInitiateStatement(s)
	}
}

func (s *InitiateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInitiateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InitiateStatement() (localctx IInitiateStatementContext) {
	this := p
	_ = this

	localctx = NewInitiateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, Cobol85ParserRULE_initiateStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4354)
		p.Match(Cobol85ParserINITIATE)
	}
	p.SetState(4356)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178969483) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4355)
			p.ReportName()
		}

		p.SetState(4358)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectStatementContext is an interface to support dynamic dispatch.
type IInspectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectStatementContext differentiates from other interfaces.
	IsInspectStatementContext()
}

type InspectStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectStatementContext() *InspectStatementContext {
	var p = new(InspectStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectStatement
	return p
}

func (*InspectStatementContext) IsInspectStatementContext() {}

func NewInspectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectStatementContext {
	var p = new(InspectStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectStatement

	return p
}

func (s *InspectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectStatementContext) INSPECT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINSPECT, 0)
}

func (s *InspectStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectStatementContext) InspectTallyingPhrase() IInspectTallyingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectTallyingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectTallyingPhraseContext)
}

func (s *InspectStatementContext) InspectReplacingPhrase() IInspectReplacingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectReplacingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingPhraseContext)
}

func (s *InspectStatementContext) InspectTallyingReplacingPhrase() IInspectTallyingReplacingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectTallyingReplacingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectTallyingReplacingPhraseContext)
}

func (s *InspectStatementContext) InspectConvertingPhrase() IInspectConvertingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectConvertingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectConvertingPhraseContext)
}

func (s *InspectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectStatement(s)
	}
}

func (s *InspectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectStatement(s)
	}
}

func (s *InspectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectStatement() (localctx IInspectStatementContext) {
	this := p
	_ = this

	localctx = NewInspectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, Cobol85ParserRULE_inspectStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4360)
		p.Match(Cobol85ParserINSPECT)
	}
	{
		p.SetState(4361)
		p.Identifier()
	}
	p.SetState(4366)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 617, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4362)
			p.InspectTallyingPhrase()
		}

	case 2:
		{
			p.SetState(4363)
			p.InspectReplacingPhrase()
		}

	case 3:
		{
			p.SetState(4364)
			p.InspectTallyingReplacingPhrase()
		}

	case 4:
		{
			p.SetState(4365)
			p.InspectConvertingPhrase()
		}

	}

	return localctx
}

// IInspectTallyingPhraseContext is an interface to support dynamic dispatch.
type IInspectTallyingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectTallyingPhraseContext differentiates from other interfaces.
	IsInspectTallyingPhraseContext()
}

type InspectTallyingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectTallyingPhraseContext() *InspectTallyingPhraseContext {
	var p = new(InspectTallyingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingPhrase
	return p
}

func (*InspectTallyingPhraseContext) IsInspectTallyingPhraseContext() {}

func NewInspectTallyingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectTallyingPhraseContext {
	var p = new(InspectTallyingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingPhrase

	return p
}

func (s *InspectTallyingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectTallyingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *InspectTallyingPhraseContext) AllInspectFor() []IInspectForContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectForContext); ok {
			len++
		}
	}

	tst := make([]IInspectForContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectForContext); ok {
			tst[i] = t.(IInspectForContext)
			i++
		}
	}

	return tst
}

func (s *InspectTallyingPhraseContext) InspectFor(i int) IInspectForContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectForContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectForContext)
}

func (s *InspectTallyingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectTallyingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectTallyingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTallyingPhrase(s)
	}
}

func (s *InspectTallyingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTallyingPhrase(s)
	}
}

func (s *InspectTallyingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectTallyingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectTallyingPhrase() (localctx IInspectTallyingPhraseContext) {
	this := p
	_ = this

	localctx = NewInspectTallyingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, Cobol85ParserRULE_inspectTallyingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4368)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(4370)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4369)
			p.InspectFor()
		}

		p.SetState(4372)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingPhraseContext is an interface to support dynamic dispatch.
type IInspectReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingPhraseContext differentiates from other interfaces.
	IsInspectReplacingPhraseContext()
}

type InspectReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingPhraseContext() *InspectReplacingPhraseContext {
	var p = new(InspectReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingPhrase
	return p
}

func (*InspectReplacingPhraseContext) IsInspectReplacingPhraseContext() {}

func NewInspectReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingPhraseContext {
	var p = new(InspectReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingPhrase

	return p
}

func (s *InspectReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *InspectReplacingPhraseContext) AllInspectReplacingCharacters() []IInspectReplacingCharactersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectReplacingCharactersContext); ok {
			len++
		}
	}

	tst := make([]IInspectReplacingCharactersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectReplacingCharactersContext); ok {
			tst[i] = t.(IInspectReplacingCharactersContext)
			i++
		}
	}

	return tst
}

func (s *InspectReplacingPhraseContext) InspectReplacingCharacters(i int) IInspectReplacingCharactersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectReplacingCharactersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingCharactersContext)
}

func (s *InspectReplacingPhraseContext) AllInspectReplacingAllLeadings() []IInspectReplacingAllLeadingsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectReplacingAllLeadingsContext); ok {
			len++
		}
	}

	tst := make([]IInspectReplacingAllLeadingsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectReplacingAllLeadingsContext); ok {
			tst[i] = t.(IInspectReplacingAllLeadingsContext)
			i++
		}
	}

	return tst
}

func (s *InspectReplacingPhraseContext) InspectReplacingAllLeadings(i int) IInspectReplacingAllLeadingsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectReplacingAllLeadingsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingAllLeadingsContext)
}

func (s *InspectReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingPhrase(s)
	}
}

func (s *InspectReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingPhrase(s)
	}
}

func (s *InspectReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingPhrase() (localctx IInspectReplacingPhraseContext) {
	this := p
	_ = this

	localctx = NewInspectReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, Cobol85ParserRULE_inspectReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4374)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(4377)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserALL || _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserFIRST || _la == Cobol85ParserLEADING {
		p.SetState(4377)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCHARACTERS:
			{
				p.SetState(4375)
				p.InspectReplacingCharacters()
			}

		case Cobol85ParserALL, Cobol85ParserFIRST, Cobol85ParserLEADING:
			{
				p.SetState(4376)
				p.InspectReplacingAllLeadings()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4379)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectTallyingReplacingPhraseContext is an interface to support dynamic dispatch.
type IInspectTallyingReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectTallyingReplacingPhraseContext differentiates from other interfaces.
	IsInspectTallyingReplacingPhraseContext()
}

type InspectTallyingReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectTallyingReplacingPhraseContext() *InspectTallyingReplacingPhraseContext {
	var p = new(InspectTallyingReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingReplacingPhrase
	return p
}

func (*InspectTallyingReplacingPhraseContext) IsInspectTallyingReplacingPhraseContext() {}

func NewInspectTallyingReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectTallyingReplacingPhraseContext {
	var p = new(InspectTallyingReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTallyingReplacingPhrase

	return p
}

func (s *InspectTallyingReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectTallyingReplacingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *InspectTallyingReplacingPhraseContext) AllInspectFor() []IInspectForContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectForContext); ok {
			len++
		}
	}

	tst := make([]IInspectForContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectForContext); ok {
			tst[i] = t.(IInspectForContext)
			i++
		}
	}

	return tst
}

func (s *InspectTallyingReplacingPhraseContext) InspectFor(i int) IInspectForContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectForContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectForContext)
}

func (s *InspectTallyingReplacingPhraseContext) AllInspectReplacingPhrase() []IInspectReplacingPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectReplacingPhraseContext); ok {
			len++
		}
	}

	tst := make([]IInspectReplacingPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectReplacingPhraseContext); ok {
			tst[i] = t.(IInspectReplacingPhraseContext)
			i++
		}
	}

	return tst
}

func (s *InspectTallyingReplacingPhraseContext) InspectReplacingPhrase(i int) IInspectReplacingPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectReplacingPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingPhraseContext)
}

func (s *InspectTallyingReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectTallyingReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectTallyingReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTallyingReplacingPhrase(s)
	}
}

func (s *InspectTallyingReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTallyingReplacingPhrase(s)
	}
}

func (s *InspectTallyingReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectTallyingReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectTallyingReplacingPhrase() (localctx IInspectTallyingReplacingPhraseContext) {
	this := p
	_ = this

	localctx = NewInspectTallyingReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, Cobol85ParserRULE_inspectTallyingReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4381)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(4383)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4382)
			p.InspectFor()
		}

		p.SetState(4385)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4388)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserREPLACING {
		{
			p.SetState(4387)
			p.InspectReplacingPhrase()
		}

		p.SetState(4390)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectConvertingPhraseContext is an interface to support dynamic dispatch.
type IInspectConvertingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectConvertingPhraseContext differentiates from other interfaces.
	IsInspectConvertingPhraseContext()
}

type InspectConvertingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectConvertingPhraseContext() *InspectConvertingPhraseContext {
	var p = new(InspectConvertingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectConvertingPhrase
	return p
}

func (*InspectConvertingPhraseContext) IsInspectConvertingPhraseContext() {}

func NewInspectConvertingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectConvertingPhraseContext {
	var p = new(InspectConvertingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectConvertingPhrase

	return p
}

func (s *InspectConvertingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectConvertingPhraseContext) CONVERTING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVERTING, 0)
}

func (s *InspectConvertingPhraseContext) InspectTo() IInspectToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectToContext)
}

func (s *InspectConvertingPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectConvertingPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectConvertingPhraseContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			len++
		}
	}

	tst := make([]IInspectBeforeAfterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectBeforeAfterContext); ok {
			tst[i] = t.(IInspectBeforeAfterContext)
			i++
		}
	}

	return tst
}

func (s *InspectConvertingPhraseContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectConvertingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectConvertingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectConvertingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectConvertingPhrase(s)
	}
}

func (s *InspectConvertingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectConvertingPhrase(s)
	}
}

func (s *InspectConvertingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectConvertingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectConvertingPhrase() (localctx IInspectConvertingPhraseContext) {
	this := p
	_ = this

	localctx = NewInspectConvertingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, Cobol85ParserRULE_inspectConvertingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4392)
		p.Match(Cobol85ParserCONVERTING)
	}
	p.SetState(4395)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 623, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4393)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4394)
			p.Literal()
		}

	}
	{
		p.SetState(4397)
		p.InspectTo()
	}
	p.SetState(4401)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4398)
			p.InspectBeforeAfter()
		}

		p.SetState(4403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectForContext is an interface to support dynamic dispatch.
type IInspectForContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectForContext differentiates from other interfaces.
	IsInspectForContext()
}

type InspectForContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectForContext() *InspectForContext {
	var p = new(InspectForContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectFor
	return p
}

func (*InspectForContext) IsInspectForContext() {}

func NewInspectForContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectForContext {
	var p = new(InspectForContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectFor

	return p
}

func (s *InspectForContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectForContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectForContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *InspectForContext) AllInspectCharacters() []IInspectCharactersContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectCharactersContext); ok {
			len++
		}
	}

	tst := make([]IInspectCharactersContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectCharactersContext); ok {
			tst[i] = t.(IInspectCharactersContext)
			i++
		}
	}

	return tst
}

func (s *InspectForContext) InspectCharacters(i int) IInspectCharactersContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectCharactersContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectCharactersContext)
}

func (s *InspectForContext) AllInspectAllLeadings() []IInspectAllLeadingsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectAllLeadingsContext); ok {
			len++
		}
	}

	tst := make([]IInspectAllLeadingsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectAllLeadingsContext); ok {
			tst[i] = t.(IInspectAllLeadingsContext)
			i++
		}
	}

	return tst
}

func (s *InspectForContext) InspectAllLeadings(i int) IInspectAllLeadingsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectAllLeadingsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectAllLeadingsContext)
}

func (s *InspectForContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectForContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectForContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectFor(s)
	}
}

func (s *InspectForContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectFor(s)
	}
}

func (s *InspectForContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectFor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectFor() (localctx IInspectForContext) {
	this := p
	_ = this

	localctx = NewInspectForContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, Cobol85ParserRULE_inspectFor)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4404)
		p.Identifier()
	}
	{
		p.SetState(4405)
		p.Match(Cobol85ParserFOR)
	}
	p.SetState(4408)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserALL || _la == Cobol85ParserCHARACTERS || _la == Cobol85ParserLEADING {
		p.SetState(4408)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserCHARACTERS:
			{
				p.SetState(4406)
				p.InspectCharacters()
			}

		case Cobol85ParserALL, Cobol85ParserLEADING:
			{
				p.SetState(4407)
				p.InspectAllLeadings()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4410)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectCharactersContext is an interface to support dynamic dispatch.
type IInspectCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectCharactersContext differentiates from other interfaces.
	IsInspectCharactersContext()
}

type InspectCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectCharactersContext() *InspectCharactersContext {
	var p = new(InspectCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectCharacters
	return p
}

func (*InspectCharactersContext) IsInspectCharactersContext() {}

func NewInspectCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectCharactersContext {
	var p = new(InspectCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectCharacters

	return p
}

func (s *InspectCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectCharactersContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *InspectCharactersContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			len++
		}
	}

	tst := make([]IInspectBeforeAfterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectBeforeAfterContext); ok {
			tst[i] = t.(IInspectBeforeAfterContext)
			i++
		}
	}

	return tst
}

func (s *InspectCharactersContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectCharacters(s)
	}
}

func (s *InspectCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectCharacters(s)
	}
}

func (s *InspectCharactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectCharacters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectCharacters() (localctx IInspectCharactersContext) {
	this := p
	_ = this

	localctx = NewInspectCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, Cobol85ParserRULE_inspectCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4412)
		p.Match(Cobol85ParserCHARACTERS)
	}
	p.SetState(4416)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4413)
			p.InspectBeforeAfter()
		}

		p.SetState(4418)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingCharactersContext is an interface to support dynamic dispatch.
type IInspectReplacingCharactersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingCharactersContext differentiates from other interfaces.
	IsInspectReplacingCharactersContext()
}

type InspectReplacingCharactersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingCharactersContext() *InspectReplacingCharactersContext {
	var p = new(InspectReplacingCharactersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingCharacters
	return p
}

func (*InspectReplacingCharactersContext) IsInspectReplacingCharactersContext() {}

func NewInspectReplacingCharactersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingCharactersContext {
	var p = new(InspectReplacingCharactersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingCharacters

	return p
}

func (s *InspectReplacingCharactersContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingCharactersContext) CHARACTERS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHARACTERS, 0)
}

func (s *InspectReplacingCharactersContext) InspectBy() IInspectByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectByContext)
}

func (s *InspectReplacingCharactersContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			len++
		}
	}

	tst := make([]IInspectBeforeAfterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectBeforeAfterContext); ok {
			tst[i] = t.(IInspectBeforeAfterContext)
			i++
		}
	}

	return tst
}

func (s *InspectReplacingCharactersContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectReplacingCharactersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingCharactersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingCharactersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingCharacters(s)
	}
}

func (s *InspectReplacingCharactersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingCharacters(s)
	}
}

func (s *InspectReplacingCharactersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingCharacters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingCharacters() (localctx IInspectReplacingCharactersContext) {
	this := p
	_ = this

	localctx = NewInspectReplacingCharactersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, Cobol85ParserRULE_inspectReplacingCharacters)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4419)
		p.Match(Cobol85ParserCHARACTERS)
	}
	{
		p.SetState(4420)
		p.InspectBy()
	}
	p.SetState(4424)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4421)
			p.InspectBeforeAfter()
		}

		p.SetState(4426)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectAllLeadingsContext is an interface to support dynamic dispatch.
type IInspectAllLeadingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectAllLeadingsContext differentiates from other interfaces.
	IsInspectAllLeadingsContext()
}

type InspectAllLeadingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectAllLeadingsContext() *InspectAllLeadingsContext {
	var p = new(InspectAllLeadingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeadings
	return p
}

func (*InspectAllLeadingsContext) IsInspectAllLeadingsContext() {}

func NewInspectAllLeadingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectAllLeadingsContext {
	var p = new(InspectAllLeadingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeadings

	return p
}

func (s *InspectAllLeadingsContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectAllLeadingsContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *InspectAllLeadingsContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *InspectAllLeadingsContext) AllInspectAllLeading() []IInspectAllLeadingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectAllLeadingContext); ok {
			len++
		}
	}

	tst := make([]IInspectAllLeadingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectAllLeadingContext); ok {
			tst[i] = t.(IInspectAllLeadingContext)
			i++
		}
	}

	return tst
}

func (s *InspectAllLeadingsContext) InspectAllLeading(i int) IInspectAllLeadingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectAllLeadingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectAllLeadingContext)
}

func (s *InspectAllLeadingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectAllLeadingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectAllLeadingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectAllLeadings(s)
	}
}

func (s *InspectAllLeadingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectAllLeadings(s)
	}
}

func (s *InspectAllLeadingsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectAllLeadings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectAllLeadings() (localctx IInspectAllLeadingsContext) {
	this := p
	_ = this

	localctx = NewInspectAllLeadingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, Cobol85ParserRULE_inspectAllLeadings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4427)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserALL || _la == Cobol85ParserLEADING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4429)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4428)
				p.InspectAllLeading()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4431)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 629, p.GetParserRuleContext())
	}

	return localctx
}

// IInspectReplacingAllLeadingsContext is an interface to support dynamic dispatch.
type IInspectReplacingAllLeadingsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingAllLeadingsContext differentiates from other interfaces.
	IsInspectReplacingAllLeadingsContext()
}

type InspectReplacingAllLeadingsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingAllLeadingsContext() *InspectReplacingAllLeadingsContext {
	var p = new(InspectReplacingAllLeadingsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeadings
	return p
}

func (*InspectReplacingAllLeadingsContext) IsInspectReplacingAllLeadingsContext() {}

func NewInspectReplacingAllLeadingsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingAllLeadingsContext {
	var p = new(InspectReplacingAllLeadingsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeadings

	return p
}

func (s *InspectReplacingAllLeadingsContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingAllLeadingsContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *InspectReplacingAllLeadingsContext) LEADING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEADING, 0)
}

func (s *InspectReplacingAllLeadingsContext) FIRST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFIRST, 0)
}

func (s *InspectReplacingAllLeadingsContext) AllInspectReplacingAllLeading() []IInspectReplacingAllLeadingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectReplacingAllLeadingContext); ok {
			len++
		}
	}

	tst := make([]IInspectReplacingAllLeadingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectReplacingAllLeadingContext); ok {
			tst[i] = t.(IInspectReplacingAllLeadingContext)
			i++
		}
	}

	return tst
}

func (s *InspectReplacingAllLeadingsContext) InspectReplacingAllLeading(i int) IInspectReplacingAllLeadingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectReplacingAllLeadingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectReplacingAllLeadingContext)
}

func (s *InspectReplacingAllLeadingsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingAllLeadingsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingAllLeadingsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingAllLeadings(s)
	}
}

func (s *InspectReplacingAllLeadingsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingAllLeadings(s)
	}
}

func (s *InspectReplacingAllLeadingsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingAllLeadings(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingAllLeadings() (localctx IInspectReplacingAllLeadingsContext) {
	this := p
	_ = this

	localctx = NewInspectReplacingAllLeadingsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, Cobol85ParserRULE_inspectReplacingAllLeadings)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4433)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserALL || _la == Cobol85ParserFIRST || _la == Cobol85ParserLEADING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4435)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4434)
				p.InspectReplacingAllLeading()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4437)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 630, p.GetParserRuleContext())
	}

	return localctx
}

// IInspectAllLeadingContext is an interface to support dynamic dispatch.
type IInspectAllLeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectAllLeadingContext differentiates from other interfaces.
	IsInspectAllLeadingContext()
}

type InspectAllLeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectAllLeadingContext() *InspectAllLeadingContext {
	var p = new(InspectAllLeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeading
	return p
}

func (*InspectAllLeadingContext) IsInspectAllLeadingContext() {}

func NewInspectAllLeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectAllLeadingContext {
	var p = new(InspectAllLeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectAllLeading

	return p
}

func (s *InspectAllLeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectAllLeadingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectAllLeadingContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectAllLeadingContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			len++
		}
	}

	tst := make([]IInspectBeforeAfterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectBeforeAfterContext); ok {
			tst[i] = t.(IInspectBeforeAfterContext)
			i++
		}
	}

	return tst
}

func (s *InspectAllLeadingContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectAllLeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectAllLeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectAllLeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectAllLeading(s)
	}
}

func (s *InspectAllLeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectAllLeading(s)
	}
}

func (s *InspectAllLeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectAllLeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectAllLeading() (localctx IInspectAllLeadingContext) {
	this := p
	_ = this

	localctx = NewInspectAllLeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, Cobol85ParserRULE_inspectAllLeading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4441)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 631, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4439)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4440)
			p.Literal()
		}

	}
	p.SetState(4446)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4443)
			p.InspectBeforeAfter()
		}

		p.SetState(4448)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectReplacingAllLeadingContext is an interface to support dynamic dispatch.
type IInspectReplacingAllLeadingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectReplacingAllLeadingContext differentiates from other interfaces.
	IsInspectReplacingAllLeadingContext()
}

type InspectReplacingAllLeadingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectReplacingAllLeadingContext() *InspectReplacingAllLeadingContext {
	var p = new(InspectReplacingAllLeadingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeading
	return p
}

func (*InspectReplacingAllLeadingContext) IsInspectReplacingAllLeadingContext() {}

func NewInspectReplacingAllLeadingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectReplacingAllLeadingContext {
	var p = new(InspectReplacingAllLeadingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectReplacingAllLeading

	return p
}

func (s *InspectReplacingAllLeadingContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectReplacingAllLeadingContext) InspectBy() IInspectByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectByContext)
}

func (s *InspectReplacingAllLeadingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectReplacingAllLeadingContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectReplacingAllLeadingContext) AllInspectBeforeAfter() []IInspectBeforeAfterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			len++
		}
	}

	tst := make([]IInspectBeforeAfterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInspectBeforeAfterContext); ok {
			tst[i] = t.(IInspectBeforeAfterContext)
			i++
		}
	}

	return tst
}

func (s *InspectReplacingAllLeadingContext) InspectBeforeAfter(i int) IInspectBeforeAfterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInspectBeforeAfterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInspectBeforeAfterContext)
}

func (s *InspectReplacingAllLeadingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectReplacingAllLeadingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectReplacingAllLeadingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectReplacingAllLeading(s)
	}
}

func (s *InspectReplacingAllLeadingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectReplacingAllLeading(s)
	}
}

func (s *InspectReplacingAllLeadingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectReplacingAllLeading(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectReplacingAllLeading() (localctx IInspectReplacingAllLeadingContext) {
	this := p
	_ = this

	localctx = NewInspectReplacingAllLeadingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, Cobol85ParserRULE_inspectReplacingAllLeading)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4451)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 633, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4449)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4450)
			p.Literal()
		}

	}
	{
		p.SetState(4453)
		p.InspectBy()
	}
	p.SetState(4457)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(4454)
			p.InspectBeforeAfter()
		}

		p.SetState(4459)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IInspectByContext is an interface to support dynamic dispatch.
type IInspectByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectByContext differentiates from other interfaces.
	IsInspectByContext()
}

type InspectByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectByContext() *InspectByContext {
	var p = new(InspectByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectBy
	return p
}

func (*InspectByContext) IsInspectByContext() {}

func NewInspectByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectByContext {
	var p = new(InspectByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectBy

	return p
}

func (s *InspectByContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *InspectByContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectByContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectBy(s)
	}
}

func (s *InspectByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectBy(s)
	}
}

func (s *InspectByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectBy() (localctx IInspectByContext) {
	this := p
	_ = this

	localctx = NewInspectByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, Cobol85ParserRULE_inspectBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4460)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4463)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 635, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4461)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4462)
			p.Literal()
		}

	}

	return localctx
}

// IInspectToContext is an interface to support dynamic dispatch.
type IInspectToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectToContext differentiates from other interfaces.
	IsInspectToContext()
}

type InspectToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectToContext() *InspectToContext {
	var p = new(InspectToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectTo
	return p
}

func (*InspectToContext) IsInspectToContext() {}

func NewInspectToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectToContext {
	var p = new(InspectToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectTo

	return p
}

func (s *InspectToContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectToContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *InspectToContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectToContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectTo(s)
	}
}

func (s *InspectToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectTo(s)
	}
}

func (s *InspectToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectTo() (localctx IInspectToContext) {
	this := p
	_ = this

	localctx = NewInspectToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, Cobol85ParserRULE_inspectTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4465)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4468)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 636, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4466)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4467)
			p.Literal()
		}

	}

	return localctx
}

// IInspectBeforeAfterContext is an interface to support dynamic dispatch.
type IInspectBeforeAfterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInspectBeforeAfterContext differentiates from other interfaces.
	IsInspectBeforeAfterContext()
}

type InspectBeforeAfterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInspectBeforeAfterContext() *InspectBeforeAfterContext {
	var p = new(InspectBeforeAfterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inspectBeforeAfter
	return p
}

func (*InspectBeforeAfterContext) IsInspectBeforeAfterContext() {}

func NewInspectBeforeAfterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InspectBeforeAfterContext {
	var p = new(InspectBeforeAfterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inspectBeforeAfter

	return p
}

func (s *InspectBeforeAfterContext) GetParser() antlr.Parser { return s.parser }

func (s *InspectBeforeAfterContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *InspectBeforeAfterContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *InspectBeforeAfterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InspectBeforeAfterContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *InspectBeforeAfterContext) INITIAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINITIAL, 0)
}

func (s *InspectBeforeAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InspectBeforeAfterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InspectBeforeAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInspectBeforeAfter(s)
	}
}

func (s *InspectBeforeAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInspectBeforeAfter(s)
	}
}

func (s *InspectBeforeAfterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInspectBeforeAfter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InspectBeforeAfter() (localctx IInspectBeforeAfterContext) {
	this := p
	_ = this

	localctx = NewInspectBeforeAfterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, Cobol85ParserRULE_inspectBeforeAfter)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4470)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4472)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINITIAL {
		{
			p.SetState(4471)
			p.Match(Cobol85ParserINITIAL)
		}

	}
	p.SetState(4476)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 638, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4474)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4475)
			p.Literal()
		}

	}

	return localctx
}

// IMergeStatementContext is an interface to support dynamic dispatch.
type IMergeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeStatementContext differentiates from other interfaces.
	IsMergeStatementContext()
}

type MergeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeStatementContext() *MergeStatementContext {
	var p = new(MergeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeStatement
	return p
}

func (*MergeStatementContext) IsMergeStatementContext() {}

func NewMergeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeStatementContext {
	var p = new(MergeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeStatement

	return p
}

func (s *MergeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeStatementContext) MERGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMERGE, 0)
}

func (s *MergeStatementContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeStatementContext) AllMergeOnKeyClause() []IMergeOnKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeOnKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]IMergeOnKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeOnKeyClauseContext); ok {
			tst[i] = t.(IMergeOnKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeOnKeyClause(i int) IMergeOnKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeOnKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeOnKeyClauseContext)
}

func (s *MergeStatementContext) MergeCollatingSequencePhrase() IMergeCollatingSequencePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeCollatingSequencePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingSequencePhraseContext)
}

func (s *MergeStatementContext) AllMergeUsing() []IMergeUsingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeUsingContext); ok {
			len++
		}
	}

	tst := make([]IMergeUsingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeUsingContext); ok {
			tst[i] = t.(IMergeUsingContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeUsing(i int) IMergeUsingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeUsingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeUsingContext)
}

func (s *MergeStatementContext) MergeOutputProcedurePhrase() IMergeOutputProcedurePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeOutputProcedurePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeOutputProcedurePhraseContext)
}

func (s *MergeStatementContext) AllMergeGivingPhrase() []IMergeGivingPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeGivingPhraseContext); ok {
			len++
		}
	}

	tst := make([]IMergeGivingPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeGivingPhraseContext); ok {
			tst[i] = t.(IMergeGivingPhraseContext)
			i++
		}
	}

	return tst
}

func (s *MergeStatementContext) MergeGivingPhrase(i int) IMergeGivingPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeGivingPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeGivingPhraseContext)
}

func (s *MergeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeStatement(s)
	}
}

func (s *MergeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeStatement(s)
	}
}

func (s *MergeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeStatement() (localctx IMergeStatementContext) {
	this := p
	_ = this

	localctx = NewMergeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, Cobol85ParserRULE_mergeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4478)
		p.Match(Cobol85ParserMERGE)
	}
	{
		p.SetState(4479)
		p.FileName()
	}
	p.SetState(4481)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4480)
				p.MergeOnKeyClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4483)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 639, p.GetParserRuleContext())
	}
	p.SetState(4486)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(4485)
			p.MergeCollatingSequencePhrase()
		}

	}
	p.SetState(4491)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserUSING {
		{
			p.SetState(4488)
			p.MergeUsing()
		}

		p.SetState(4493)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4495)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOUTPUT {
		{
			p.SetState(4494)
			p.MergeOutputProcedurePhrase()
		}

	}
	p.SetState(4500)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserGIVING {
		{
			p.SetState(4497)
			p.MergeGivingPhrase()
		}

		p.SetState(4502)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeOnKeyClauseContext is an interface to support dynamic dispatch.
type IMergeOnKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOnKeyClauseContext differentiates from other interfaces.
	IsMergeOnKeyClauseContext()
}

type MergeOnKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOnKeyClauseContext() *MergeOnKeyClauseContext {
	var p = new(MergeOnKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOnKeyClause
	return p
}

func (*MergeOnKeyClauseContext) IsMergeOnKeyClauseContext() {}

func NewMergeOnKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOnKeyClauseContext {
	var p = new(MergeOnKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOnKeyClause

	return p
}

func (s *MergeOnKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOnKeyClauseContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *MergeOnKeyClauseContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *MergeOnKeyClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *MergeOnKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *MergeOnKeyClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedDataNameContext); ok {
			tst[i] = t.(IQualifiedDataNameContext)
			i++
		}
	}

	return tst
}

func (s *MergeOnKeyClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *MergeOnKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOnKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOnKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOnKeyClause(s)
	}
}

func (s *MergeOnKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOnKeyClause(s)
	}
}

func (s *MergeOnKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeOnKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeOnKeyClause() (localctx IMergeOnKeyClauseContext) {
	this := p
	_ = this

	localctx = NewMergeOnKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, Cobol85ParserRULE_mergeOnKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4504)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(4503)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(4506)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4508)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(4507)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(4511)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178969483) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4510)
			p.QualifiedDataName()
		}

		p.SetState(4513)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeCollatingSequencePhraseContext is an interface to support dynamic dispatch.
type IMergeCollatingSequencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingSequencePhraseContext differentiates from other interfaces.
	IsMergeCollatingSequencePhraseContext()
}

type MergeCollatingSequencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingSequencePhraseContext() *MergeCollatingSequencePhraseContext {
	var p = new(MergeCollatingSequencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingSequencePhrase
	return p
}

func (*MergeCollatingSequencePhraseContext) IsMergeCollatingSequencePhraseContext() {}

func NewMergeCollatingSequencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingSequencePhraseContext {
	var p = new(MergeCollatingSequencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingSequencePhrase

	return p
}

func (s *MergeCollatingSequencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingSequencePhraseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *MergeCollatingSequencePhraseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *MergeCollatingSequencePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingSequencePhraseContext) AllAlphabetName() []IAlphabetNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			len++
		}
	}

	tst := make([]IAlphabetNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlphabetNameContext); ok {
			tst[i] = t.(IAlphabetNameContext)
			i++
		}
	}

	return tst
}

func (s *MergeCollatingSequencePhraseContext) AlphabetName(i int) IAlphabetNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingSequencePhraseContext) MergeCollatingAlphanumeric() IMergeCollatingAlphanumericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeCollatingAlphanumericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingAlphanumericContext)
}

func (s *MergeCollatingSequencePhraseContext) MergeCollatingNational() IMergeCollatingNationalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeCollatingNationalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeCollatingNationalContext)
}

func (s *MergeCollatingSequencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingSequencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingSequencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingSequencePhrase(s)
	}
}

func (s *MergeCollatingSequencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingSequencePhrase(s)
	}
}

func (s *MergeCollatingSequencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeCollatingSequencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeCollatingSequencePhrase() (localctx IMergeCollatingSequencePhraseContext) {
	this := p
	_ = this

	localctx = NewMergeCollatingSequencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, Cobol85ParserRULE_mergeCollatingSequencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4516)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(4515)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(4518)
		p.Match(Cobol85ParserSEQUENCE)
	}
	p.SetState(4520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4519)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(4523)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4522)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4525)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 649, p.GetParserRuleContext())
	}
	p.SetState(4528)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 650, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4527)
			p.MergeCollatingAlphanumeric()
		}

	}
	p.SetState(4531)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(4530)
			p.MergeCollatingNational()
		}

	}

	return localctx
}

// IMergeCollatingAlphanumericContext is an interface to support dynamic dispatch.
type IMergeCollatingAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingAlphanumericContext differentiates from other interfaces.
	IsMergeCollatingAlphanumericContext()
}

type MergeCollatingAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingAlphanumericContext() *MergeCollatingAlphanumericContext {
	var p = new(MergeCollatingAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingAlphanumeric
	return p
}

func (*MergeCollatingAlphanumericContext) IsMergeCollatingAlphanumericContext() {}

func NewMergeCollatingAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingAlphanumericContext {
	var p = new(MergeCollatingAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingAlphanumeric

	return p
}

func (s *MergeCollatingAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *MergeCollatingAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *MergeCollatingAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingAlphanumeric(s)
	}
}

func (s *MergeCollatingAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingAlphanumeric(s)
	}
}

func (s *MergeCollatingAlphanumericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeCollatingAlphanumeric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeCollatingAlphanumeric() (localctx IMergeCollatingAlphanumericContext) {
	this := p
	_ = this

	localctx = NewMergeCollatingAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, Cobol85ParserRULE_mergeCollatingAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4534)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(4533)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(4536)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	{
		p.SetState(4537)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(4538)
		p.AlphabetName()
	}

	return localctx
}

// IMergeCollatingNationalContext is an interface to support dynamic dispatch.
type IMergeCollatingNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeCollatingNationalContext differentiates from other interfaces.
	IsMergeCollatingNationalContext()
}

type MergeCollatingNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeCollatingNationalContext() *MergeCollatingNationalContext {
	var p = new(MergeCollatingNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingNational
	return p
}

func (*MergeCollatingNationalContext) IsMergeCollatingNationalContext() {}

func NewMergeCollatingNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeCollatingNationalContext {
	var p = new(MergeCollatingNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeCollatingNational

	return p
}

func (s *MergeCollatingNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeCollatingNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *MergeCollatingNationalContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *MergeCollatingNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *MergeCollatingNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeCollatingNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeCollatingNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeCollatingNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeCollatingNational(s)
	}
}

func (s *MergeCollatingNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeCollatingNational(s)
	}
}

func (s *MergeCollatingNationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeCollatingNational(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeCollatingNational() (localctx IMergeCollatingNationalContext) {
	this := p
	_ = this

	localctx = NewMergeCollatingNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, Cobol85ParserRULE_mergeCollatingNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(4540)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(4543)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(4545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4544)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4547)
		p.AlphabetName()
	}

	return localctx
}

// IMergeUsingContext is an interface to support dynamic dispatch.
type IMergeUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeUsingContext differentiates from other interfaces.
	IsMergeUsingContext()
}

type MergeUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeUsingContext() *MergeUsingContext {
	var p = new(MergeUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeUsing
	return p
}

func (*MergeUsingContext) IsMergeUsingContext() {}

func NewMergeUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeUsingContext {
	var p = new(MergeUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeUsing

	return p
}

func (s *MergeUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *MergeUsingContext) AllFileName() []IFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileNameContext); ok {
			len++
		}
	}

	tst := make([]IFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileNameContext); ok {
			tst[i] = t.(IFileNameContext)
			i++
		}
	}

	return tst
}

func (s *MergeUsingContext) FileName(i int) IFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeUsing(s)
	}
}

func (s *MergeUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeUsing(s)
	}
}

func (s *MergeUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeUsing() (localctx IMergeUsingContext) {
	this := p
	_ = this

	localctx = NewMergeUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, Cobol85ParserRULE_mergeUsing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4549)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(4551)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4550)
			p.FileName()
		}

		p.SetState(4553)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeOutputProcedurePhraseContext is an interface to support dynamic dispatch.
type IMergeOutputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOutputProcedurePhraseContext differentiates from other interfaces.
	IsMergeOutputProcedurePhraseContext()
}

type MergeOutputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOutputProcedurePhraseContext() *MergeOutputProcedurePhraseContext {
	var p = new(MergeOutputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOutputProcedurePhrase
	return p
}

func (*MergeOutputProcedurePhraseContext) IsMergeOutputProcedurePhraseContext() {}

func NewMergeOutputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOutputProcedurePhraseContext {
	var p = new(MergeOutputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOutputProcedurePhrase

	return p
}

func (s *MergeOutputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOutputProcedurePhraseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *MergeOutputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *MergeOutputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *MergeOutputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *MergeOutputProcedurePhraseContext) MergeOutputThrough() IMergeOutputThroughContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeOutputThroughContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeOutputThroughContext)
}

func (s *MergeOutputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOutputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOutputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOutputProcedurePhrase(s)
	}
}

func (s *MergeOutputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOutputProcedurePhrase(s)
	}
}

func (s *MergeOutputProcedurePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeOutputProcedurePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeOutputProcedurePhrase() (localctx IMergeOutputProcedurePhraseContext) {
	this := p
	_ = this

	localctx = NewMergeOutputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, Cobol85ParserRULE_mergeOutputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4555)
		p.Match(Cobol85ParserOUTPUT)
	}
	{
		p.SetState(4556)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(4558)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4557)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4560)
		p.ProcedureName()
	}
	p.SetState(4562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(4561)
			p.MergeOutputThrough()
		}

	}

	return localctx
}

// IMergeOutputThroughContext is an interface to support dynamic dispatch.
type IMergeOutputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeOutputThroughContext differentiates from other interfaces.
	IsMergeOutputThroughContext()
}

type MergeOutputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeOutputThroughContext() *MergeOutputThroughContext {
	var p = new(MergeOutputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeOutputThrough
	return p
}

func (*MergeOutputThroughContext) IsMergeOutputThroughContext() {}

func NewMergeOutputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeOutputThroughContext {
	var p = new(MergeOutputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeOutputThrough

	return p
}

func (s *MergeOutputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeOutputThroughContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *MergeOutputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *MergeOutputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *MergeOutputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeOutputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeOutputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeOutputThrough(s)
	}
}

func (s *MergeOutputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeOutputThrough(s)
	}
}

func (s *MergeOutputThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeOutputThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeOutputThrough() (localctx IMergeOutputThroughContext) {
	this := p
	_ = this

	localctx = NewMergeOutputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, Cobol85ParserRULE_mergeOutputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4564)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4565)
		p.ProcedureName()
	}

	return localctx
}

// IMergeGivingPhraseContext is an interface to support dynamic dispatch.
type IMergeGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeGivingPhraseContext differentiates from other interfaces.
	IsMergeGivingPhraseContext()
}

type MergeGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeGivingPhraseContext() *MergeGivingPhraseContext {
	var p = new(MergeGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeGivingPhrase
	return p
}

func (*MergeGivingPhraseContext) IsMergeGivingPhraseContext() {}

func NewMergeGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeGivingPhraseContext {
	var p = new(MergeGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeGivingPhrase

	return p
}

func (s *MergeGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *MergeGivingPhraseContext) AllMergeGiving() []IMergeGivingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMergeGivingContext); ok {
			len++
		}
	}

	tst := make([]IMergeGivingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMergeGivingContext); ok {
			tst[i] = t.(IMergeGivingContext)
			i++
		}
	}

	return tst
}

func (s *MergeGivingPhraseContext) MergeGiving(i int) IMergeGivingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMergeGivingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMergeGivingContext)
}

func (s *MergeGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeGivingPhrase(s)
	}
}

func (s *MergeGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeGivingPhrase(s)
	}
}

func (s *MergeGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeGivingPhrase() (localctx IMergeGivingPhraseContext) {
	this := p
	_ = this

	localctx = NewMergeGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, Cobol85ParserRULE_mergeGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4567)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4568)
			p.MergeGiving()
		}

		p.SetState(4571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMergeGivingContext is an interface to support dynamic dispatch.
type IMergeGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMergeGivingContext differentiates from other interfaces.
	IsMergeGivingContext()
}

type MergeGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMergeGivingContext() *MergeGivingContext {
	var p = new(MergeGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mergeGiving
	return p
}

func (*MergeGivingContext) IsMergeGivingContext() {}

func NewMergeGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MergeGivingContext {
	var p = new(MergeGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mergeGiving

	return p
}

func (s *MergeGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *MergeGivingContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *MergeGivingContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *MergeGivingContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *MergeGivingContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *MergeGivingContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *MergeGivingContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *MergeGivingContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *MergeGivingContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *MergeGivingContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *MergeGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MergeGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MergeGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMergeGiving(s)
	}
}

func (s *MergeGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMergeGiving(s)
	}
}

func (s *MergeGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMergeGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MergeGiving() (localctx IMergeGivingContext) {
	this := p
	_ = this

	localctx = NewMergeGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, Cobol85ParserRULE_mergeGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4573)
		p.FileName()
	}
	p.SetState(4583)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4574)
			p.Match(Cobol85ParserLOCK)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4575)
			p.Match(Cobol85ParserSAVE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(4576)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4577)
			p.Match(Cobol85ParserREWIND)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(4578)
			p.Match(Cobol85ParserCRUNCH)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(4579)
			p.Match(Cobol85ParserRELEASE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 659, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(4580)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(4581)
			p.Match(Cobol85ParserREMOVE)
		}
		{
			p.SetState(4582)
			p.Match(Cobol85ParserCRUNCH)
		}

	}

	return localctx
}

// IMoveStatementContext is an interface to support dynamic dispatch.
type IMoveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveStatementContext differentiates from other interfaces.
	IsMoveStatementContext()
}

type MoveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveStatementContext() *MoveStatementContext {
	var p = new(MoveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveStatement
	return p
}

func (*MoveStatementContext) IsMoveStatementContext() {}

func NewMoveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveStatementContext {
	var p = new(MoveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveStatement

	return p
}

func (s *MoveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveStatementContext) MOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMOVE, 0)
}

func (s *MoveStatementContext) MoveToStatement() IMoveToStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveToStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveToStatementContext)
}

func (s *MoveStatementContext) MoveCorrespondingToStatement() IMoveCorrespondingToStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveCorrespondingToStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveCorrespondingToStatementContext)
}

func (s *MoveStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *MoveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveStatement(s)
	}
}

func (s *MoveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveStatement(s)
	}
}

func (s *MoveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveStatement() (localctx IMoveStatementContext) {
	this := p
	_ = this

	localctx = NewMoveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, Cobol85ParserRULE_moveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4585)
		p.Match(Cobol85ParserMOVE)
	}
	p.SetState(4587)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 660, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4586)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(4591)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL_, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(4589)
			p.MoveToStatement()
		}

	case Cobol85ParserCORR, Cobol85ParserCORRESPONDING:
		{
			p.SetState(4590)
			p.MoveCorrespondingToStatement()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IMoveToStatementContext is an interface to support dynamic dispatch.
type IMoveToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveToStatementContext differentiates from other interfaces.
	IsMoveToStatementContext()
}

type MoveToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveToStatementContext() *MoveToStatementContext {
	var p = new(MoveToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveToStatement
	return p
}

func (*MoveToStatementContext) IsMoveToStatementContext() {}

func NewMoveToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveToStatementContext {
	var p = new(MoveToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveToStatement

	return p
}

func (s *MoveToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveToStatementContext) MoveToSendingArea() IMoveToSendingAreaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveToSendingAreaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveToSendingAreaContext)
}

func (s *MoveToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *MoveToStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MoveToStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveToStatement(s)
	}
}

func (s *MoveToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveToStatement(s)
	}
}

func (s *MoveToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveToStatement() (localctx IMoveToStatementContext) {
	this := p
	_ = this

	localctx = NewMoveToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, Cobol85ParserRULE_moveToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4593)
		p.MoveToSendingArea()
	}
	{
		p.SetState(4594)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4596)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4595)
			p.Identifier()
		}

		p.SetState(4598)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMoveToSendingAreaContext is an interface to support dynamic dispatch.
type IMoveToSendingAreaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveToSendingAreaContext differentiates from other interfaces.
	IsMoveToSendingAreaContext()
}

type MoveToSendingAreaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveToSendingAreaContext() *MoveToSendingAreaContext {
	var p = new(MoveToSendingAreaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveToSendingArea
	return p
}

func (*MoveToSendingAreaContext) IsMoveToSendingAreaContext() {}

func NewMoveToSendingAreaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveToSendingAreaContext {
	var p = new(MoveToSendingAreaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveToSendingArea

	return p
}

func (s *MoveToSendingAreaContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveToSendingAreaContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveToSendingAreaContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MoveToSendingAreaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveToSendingAreaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveToSendingAreaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveToSendingArea(s)
	}
}

func (s *MoveToSendingAreaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveToSendingArea(s)
	}
}

func (s *MoveToSendingAreaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveToSendingArea(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveToSendingArea() (localctx IMoveToSendingAreaContext) {
	this := p
	_ = this

	localctx = NewMoveToSendingAreaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, Cobol85ParserRULE_moveToSendingArea)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4602)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 663, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4600)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4601)
			p.Literal()
		}

	}

	return localctx
}

// IMoveCorrespondingToStatementContext is an interface to support dynamic dispatch.
type IMoveCorrespondingToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveCorrespondingToStatementContext differentiates from other interfaces.
	IsMoveCorrespondingToStatementContext()
}

type MoveCorrespondingToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveCorrespondingToStatementContext() *MoveCorrespondingToStatementContext {
	var p = new(MoveCorrespondingToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToStatement
	return p
}

func (*MoveCorrespondingToStatementContext) IsMoveCorrespondingToStatementContext() {}

func NewMoveCorrespondingToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveCorrespondingToStatementContext {
	var p = new(MoveCorrespondingToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToStatement

	return p
}

func (s *MoveCorrespondingToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveCorrespondingToStatementContext) MoveCorrespondingToSendingArea() IMoveCorrespondingToSendingAreaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMoveCorrespondingToSendingAreaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMoveCorrespondingToSendingAreaContext)
}

func (s *MoveCorrespondingToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *MoveCorrespondingToStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *MoveCorrespondingToStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *MoveCorrespondingToStatementContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *MoveCorrespondingToStatementContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveCorrespondingToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveCorrespondingToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveCorrespondingToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveCorrespondingToStatement(s)
	}
}

func (s *MoveCorrespondingToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveCorrespondingToStatement(s)
	}
}

func (s *MoveCorrespondingToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveCorrespondingToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveCorrespondingToStatement() (localctx IMoveCorrespondingToStatementContext) {
	this := p
	_ = this

	localctx = NewMoveCorrespondingToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, Cobol85ParserRULE_moveCorrespondingToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4604)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4605)
		p.MoveCorrespondingToSendingArea()
	}
	{
		p.SetState(4606)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(4608)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4607)
			p.Identifier()
		}

		p.SetState(4610)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMoveCorrespondingToSendingAreaContext is an interface to support dynamic dispatch.
type IMoveCorrespondingToSendingAreaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMoveCorrespondingToSendingAreaContext differentiates from other interfaces.
	IsMoveCorrespondingToSendingAreaContext()
}

type MoveCorrespondingToSendingAreaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMoveCorrespondingToSendingAreaContext() *MoveCorrespondingToSendingAreaContext {
	var p = new(MoveCorrespondingToSendingAreaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToSendingArea
	return p
}

func (*MoveCorrespondingToSendingAreaContext) IsMoveCorrespondingToSendingAreaContext() {}

func NewMoveCorrespondingToSendingAreaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MoveCorrespondingToSendingAreaContext {
	var p = new(MoveCorrespondingToSendingAreaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_moveCorrespondingToSendingArea

	return p
}

func (s *MoveCorrespondingToSendingAreaContext) GetParser() antlr.Parser { return s.parser }

func (s *MoveCorrespondingToSendingAreaContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MoveCorrespondingToSendingAreaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MoveCorrespondingToSendingAreaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MoveCorrespondingToSendingAreaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMoveCorrespondingToSendingArea(s)
	}
}

func (s *MoveCorrespondingToSendingAreaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMoveCorrespondingToSendingArea(s)
	}
}

func (s *MoveCorrespondingToSendingAreaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMoveCorrespondingToSendingArea(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MoveCorrespondingToSendingArea() (localctx IMoveCorrespondingToSendingAreaContext) {
	this := p
	_ = this

	localctx = NewMoveCorrespondingToSendingAreaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, Cobol85ParserRULE_moveCorrespondingToSendingArea)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4612)
		p.Identifier()
	}

	return localctx
}

// IMultiplyStatementContext is an interface to support dynamic dispatch.
type IMultiplyStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyStatementContext differentiates from other interfaces.
	IsMultiplyStatementContext()
}

type MultiplyStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyStatementContext() *MultiplyStatementContext {
	var p = new(MultiplyStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyStatement
	return p
}

func (*MultiplyStatementContext) IsMultiplyStatementContext() {}

func NewMultiplyStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyStatementContext {
	var p = new(MultiplyStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyStatement

	return p
}

func (s *MultiplyStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyStatementContext) MULTIPLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMULTIPLY, 0)
}

func (s *MultiplyStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *MultiplyStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MultiplyStatementContext) MultiplyRegular() IMultiplyRegularContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyRegularContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyRegularContext)
}

func (s *MultiplyStatementContext) MultiplyGiving() IMultiplyGivingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyGivingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingContext)
}

func (s *MultiplyStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *MultiplyStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *MultiplyStatementContext) END_MULTIPLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_MULTIPLY, 0)
}

func (s *MultiplyStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyStatement(s)
	}
}

func (s *MultiplyStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyStatement(s)
	}
}

func (s *MultiplyStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyStatement() (localctx IMultiplyStatementContext) {
	this := p
	_ = this

	localctx = NewMultiplyStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, Cobol85ParserRULE_multiplyStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4614)
		p.Match(Cobol85ParserMULTIPLY)
	}
	p.SetState(4617)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 665, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4615)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4616)
			p.Literal()
		}

	}
	{
		p.SetState(4619)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 666, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4620)
			p.MultiplyRegular()
		}

	case 2:
		{
			p.SetState(4621)
			p.MultiplyGiving()
		}

	}
	p.SetState(4625)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 667, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4624)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(4628)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 668, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4627)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(4631)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 669, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4630)
			p.Match(Cobol85ParserEND_MULTIPLY)
		}

	}

	return localctx
}

// IMultiplyRegularContext is an interface to support dynamic dispatch.
type IMultiplyRegularContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyRegularContext differentiates from other interfaces.
	IsMultiplyRegularContext()
}

type MultiplyRegularContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyRegularContext() *MultiplyRegularContext {
	var p = new(MultiplyRegularContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyRegular
	return p
}

func (*MultiplyRegularContext) IsMultiplyRegularContext() {}

func NewMultiplyRegularContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyRegularContext {
	var p = new(MultiplyRegularContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyRegular

	return p
}

func (s *MultiplyRegularContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyRegularContext) AllMultiplyRegularOperand() []IMultiplyRegularOperandContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplyRegularOperandContext); ok {
			len++
		}
	}

	tst := make([]IMultiplyRegularOperandContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplyRegularOperandContext); ok {
			tst[i] = t.(IMultiplyRegularOperandContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyRegularContext) MultiplyRegularOperand(i int) IMultiplyRegularOperandContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyRegularOperandContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyRegularOperandContext)
}

func (s *MultiplyRegularContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyRegularContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyRegularContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyRegular(s)
	}
}

func (s *MultiplyRegularContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyRegular(s)
	}
}

func (s *MultiplyRegularContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyRegular(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyRegular() (localctx IMultiplyRegularContext) {
	this := p
	_ = this

	localctx = NewMultiplyRegularContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, Cobol85ParserRULE_multiplyRegular)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4634)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4633)
			p.MultiplyRegularOperand()
		}

		p.SetState(4636)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyRegularOperandContext is an interface to support dynamic dispatch.
type IMultiplyRegularOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyRegularOperandContext differentiates from other interfaces.
	IsMultiplyRegularOperandContext()
}

type MultiplyRegularOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyRegularOperandContext() *MultiplyRegularOperandContext {
	var p = new(MultiplyRegularOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyRegularOperand
	return p
}

func (*MultiplyRegularOperandContext) IsMultiplyRegularOperandContext() {}

func NewMultiplyRegularOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyRegularOperandContext {
	var p = new(MultiplyRegularOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyRegularOperand

	return p
}

func (s *MultiplyRegularOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyRegularOperandContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyRegularOperandContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *MultiplyRegularOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyRegularOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyRegularOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyRegularOperand(s)
	}
}

func (s *MultiplyRegularOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyRegularOperand(s)
	}
}

func (s *MultiplyRegularOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyRegularOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyRegularOperand() (localctx IMultiplyRegularOperandContext) {
	this := p
	_ = this

	localctx = NewMultiplyRegularOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, Cobol85ParserRULE_multiplyRegularOperand)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4638)
		p.Identifier()
	}
	p.SetState(4640)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4639)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IMultiplyGivingContext is an interface to support dynamic dispatch.
type IMultiplyGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingContext differentiates from other interfaces.
	IsMultiplyGivingContext()
}

type MultiplyGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingContext() *MultiplyGivingContext {
	var p = new(MultiplyGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGiving
	return p
}

func (*MultiplyGivingContext) IsMultiplyGivingContext() {}

func NewMultiplyGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingContext {
	var p = new(MultiplyGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGiving

	return p
}

func (s *MultiplyGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingContext) MultiplyGivingOperand() IMultiplyGivingOperandContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyGivingOperandContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingOperandContext)
}

func (s *MultiplyGivingContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *MultiplyGivingContext) AllMultiplyGivingResult() []IMultiplyGivingResultContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultiplyGivingResultContext); ok {
			len++
		}
	}

	tst := make([]IMultiplyGivingResultContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultiplyGivingResultContext); ok {
			tst[i] = t.(IMultiplyGivingResultContext)
			i++
		}
	}

	return tst
}

func (s *MultiplyGivingContext) MultiplyGivingResult(i int) IMultiplyGivingResultContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultiplyGivingResultContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultiplyGivingResultContext)
}

func (s *MultiplyGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGiving(s)
	}
}

func (s *MultiplyGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGiving(s)
	}
}

func (s *MultiplyGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyGiving() (localctx IMultiplyGivingContext) {
	this := p
	_ = this

	localctx = NewMultiplyGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, Cobol85ParserRULE_multiplyGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4642)
		p.MultiplyGivingOperand()
	}
	{
		p.SetState(4643)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(4645)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4644)
			p.MultiplyGivingResult()
		}

		p.SetState(4647)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultiplyGivingOperandContext is an interface to support dynamic dispatch.
type IMultiplyGivingOperandContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingOperandContext differentiates from other interfaces.
	IsMultiplyGivingOperandContext()
}

type MultiplyGivingOperandContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingOperandContext() *MultiplyGivingOperandContext {
	var p = new(MultiplyGivingOperandContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingOperand
	return p
}

func (*MultiplyGivingOperandContext) IsMultiplyGivingOperandContext() {}

func NewMultiplyGivingOperandContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingOperandContext {
	var p = new(MultiplyGivingOperandContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingOperand

	return p
}

func (s *MultiplyGivingOperandContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingOperandContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyGivingOperandContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *MultiplyGivingOperandContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingOperandContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingOperandContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGivingOperand(s)
	}
}

func (s *MultiplyGivingOperandContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGivingOperand(s)
	}
}

func (s *MultiplyGivingOperandContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyGivingOperand(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyGivingOperand() (localctx IMultiplyGivingOperandContext) {
	this := p
	_ = this

	localctx = NewMultiplyGivingOperandContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, Cobol85ParserRULE_multiplyGivingOperand)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4651)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 673, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4649)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4650)
			p.Literal()
		}

	}

	return localctx
}

// IMultiplyGivingResultContext is an interface to support dynamic dispatch.
type IMultiplyGivingResultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultiplyGivingResultContext differentiates from other interfaces.
	IsMultiplyGivingResultContext()
}

type MultiplyGivingResultContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultiplyGivingResultContext() *MultiplyGivingResultContext {
	var p = new(MultiplyGivingResultContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingResult
	return p
}

func (*MultiplyGivingResultContext) IsMultiplyGivingResultContext() {}

func NewMultiplyGivingResultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultiplyGivingResultContext {
	var p = new(MultiplyGivingResultContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multiplyGivingResult

	return p
}

func (s *MultiplyGivingResultContext) GetParser() antlr.Parser { return s.parser }

func (s *MultiplyGivingResultContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *MultiplyGivingResultContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *MultiplyGivingResultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplyGivingResultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultiplyGivingResultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultiplyGivingResult(s)
	}
}

func (s *MultiplyGivingResultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultiplyGivingResult(s)
	}
}

func (s *MultiplyGivingResultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultiplyGivingResult(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultiplyGivingResult() (localctx IMultiplyGivingResultContext) {
	this := p
	_ = this

	localctx = NewMultiplyGivingResultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, Cobol85ParserRULE_multiplyGivingResult)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4653)
		p.Identifier()
	}
	p.SetState(4655)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(4654)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// IOpenStatementContext is an interface to support dynamic dispatch.
type IOpenStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenStatementContext differentiates from other interfaces.
	IsOpenStatementContext()
}

type OpenStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenStatementContext() *OpenStatementContext {
	var p = new(OpenStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openStatement
	return p
}

func (*OpenStatementContext) IsOpenStatementContext() {}

func NewOpenStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenStatementContext {
	var p = new(OpenStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openStatement

	return p
}

func (s *OpenStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenStatementContext) OPEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOPEN, 0)
}

func (s *OpenStatementContext) AllOpenInputStatement() []IOpenInputStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpenInputStatementContext); ok {
			len++
		}
	}

	tst := make([]IOpenInputStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpenInputStatementContext); ok {
			tst[i] = t.(IOpenInputStatementContext)
			i++
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenInputStatement(i int) IOpenInputStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenInputStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenInputStatementContext)
}

func (s *OpenStatementContext) AllOpenOutputStatement() []IOpenOutputStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpenOutputStatementContext); ok {
			len++
		}
	}

	tst := make([]IOpenOutputStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpenOutputStatementContext); ok {
			tst[i] = t.(IOpenOutputStatementContext)
			i++
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenOutputStatement(i int) IOpenOutputStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenOutputStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenOutputStatementContext)
}

func (s *OpenStatementContext) AllOpenIOStatement() []IOpenIOStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpenIOStatementContext); ok {
			len++
		}
	}

	tst := make([]IOpenIOStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpenIOStatementContext); ok {
			tst[i] = t.(IOpenIOStatementContext)
			i++
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenIOStatement(i int) IOpenIOStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenIOStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenIOStatementContext)
}

func (s *OpenStatementContext) AllOpenExtendStatement() []IOpenExtendStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpenExtendStatementContext); ok {
			len++
		}
	}

	tst := make([]IOpenExtendStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpenExtendStatementContext); ok {
			tst[i] = t.(IOpenExtendStatementContext)
			i++
		}
	}

	return tst
}

func (s *OpenStatementContext) OpenExtendStatement(i int) IOpenExtendStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenExtendStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenExtendStatementContext)
}

func (s *OpenStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenStatement(s)
	}
}

func (s *OpenStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenStatement(s)
	}
}

func (s *OpenStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenStatement() (localctx IOpenStatementContext) {
	this := p
	_ = this

	localctx = NewOpenStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, Cobol85ParserRULE_openStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4657)
		p.Match(Cobol85ParserOPEN)
	}
	p.SetState(4662)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&35186519572481) != 0 || _la == Cobol85ParserOUTPUT {
		p.SetState(4662)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserINPUT:
			{
				p.SetState(4658)
				p.OpenInputStatement()
			}

		case Cobol85ParserOUTPUT:
			{
				p.SetState(4659)
				p.OpenOutputStatement()
			}

		case Cobol85ParserI_O:
			{
				p.SetState(4660)
				p.OpenIOStatement()
			}

		case Cobol85ParserEXTEND:
			{
				p.SetState(4661)
				p.OpenExtendStatement()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(4664)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenInputStatementContext is an interface to support dynamic dispatch.
type IOpenInputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenInputStatementContext differentiates from other interfaces.
	IsOpenInputStatementContext()
}

type OpenInputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenInputStatementContext() *OpenInputStatementContext {
	var p = new(OpenInputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openInputStatement
	return p
}

func (*OpenInputStatementContext) IsOpenInputStatementContext() {}

func NewOpenInputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenInputStatementContext {
	var p = new(OpenInputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openInputStatement

	return p
}

func (s *OpenInputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenInputStatementContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *OpenInputStatementContext) AllOpenInput() []IOpenInputContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpenInputContext); ok {
			len++
		}
	}

	tst := make([]IOpenInputContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpenInputContext); ok {
			tst[i] = t.(IOpenInputContext)
			i++
		}
	}

	return tst
}

func (s *OpenInputStatementContext) OpenInput(i int) IOpenInputContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenInputContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenInputContext)
}

func (s *OpenInputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenInputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenInputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenInputStatement(s)
	}
}

func (s *OpenInputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenInputStatement(s)
	}
}

func (s *OpenInputStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenInputStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenInputStatement() (localctx IOpenInputStatementContext) {
	this := p
	_ = this

	localctx = NewOpenInputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, Cobol85ParserRULE_openInputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4666)
		p.Match(Cobol85ParserINPUT)
	}
	p.SetState(4668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4667)
			p.OpenInput()
		}

		p.SetState(4670)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenInputContext is an interface to support dynamic dispatch.
type IOpenInputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenInputContext differentiates from other interfaces.
	IsOpenInputContext()
}

type OpenInputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenInputContext() *OpenInputContext {
	var p = new(OpenInputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openInput
	return p
}

func (*OpenInputContext) IsOpenInputContext() {}

func NewOpenInputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenInputContext {
	var p = new(OpenInputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openInput

	return p
}

func (s *OpenInputContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenInputContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenInputContext) REVERSED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSED, 0)
}

func (s *OpenInputContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *OpenInputContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *OpenInputContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *OpenInputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenInputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenInputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenInput(s)
	}
}

func (s *OpenInputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenInput(s)
	}
}

func (s *OpenInputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenInput(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenInput() (localctx IOpenInputContext) {
	this := p
	_ = this

	localctx = NewOpenInputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, Cobol85ParserRULE_openInput)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4672)
		p.FileName()
	}
	p.SetState(4679)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4673)
			p.Match(Cobol85ParserREVERSED)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 679, p.GetParserRuleContext()) == 2 {
		p.SetState(4675)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(4674)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(4677)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4678)
			p.Match(Cobol85ParserREWIND)
		}

	}

	return localctx
}

// IOpenOutputStatementContext is an interface to support dynamic dispatch.
type IOpenOutputStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenOutputStatementContext differentiates from other interfaces.
	IsOpenOutputStatementContext()
}

type OpenOutputStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenOutputStatementContext() *OpenOutputStatementContext {
	var p = new(OpenOutputStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openOutputStatement
	return p
}

func (*OpenOutputStatementContext) IsOpenOutputStatementContext() {}

func NewOpenOutputStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenOutputStatementContext {
	var p = new(OpenOutputStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openOutputStatement

	return p
}

func (s *OpenOutputStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenOutputStatementContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *OpenOutputStatementContext) AllOpenOutput() []IOpenOutputContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOpenOutputContext); ok {
			len++
		}
	}

	tst := make([]IOpenOutputContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOpenOutputContext); ok {
			tst[i] = t.(IOpenOutputContext)
			i++
		}
	}

	return tst
}

func (s *OpenOutputStatementContext) OpenOutput(i int) IOpenOutputContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOpenOutputContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOpenOutputContext)
}

func (s *OpenOutputStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenOutputStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenOutputStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenOutputStatement(s)
	}
}

func (s *OpenOutputStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenOutputStatement(s)
	}
}

func (s *OpenOutputStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenOutputStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenOutputStatement() (localctx IOpenOutputStatementContext) {
	this := p
	_ = this

	localctx = NewOpenOutputStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, Cobol85ParserRULE_openOutputStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4681)
		p.Match(Cobol85ParserOUTPUT)
	}
	p.SetState(4683)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4682)
			p.OpenOutput()
		}

		p.SetState(4685)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenOutputContext is an interface to support dynamic dispatch.
type IOpenOutputContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenOutputContext differentiates from other interfaces.
	IsOpenOutputContext()
}

type OpenOutputContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenOutputContext() *OpenOutputContext {
	var p = new(OpenOutputContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openOutput
	return p
}

func (*OpenOutputContext) IsOpenOutputContext() {}

func NewOpenOutputContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenOutputContext {
	var p = new(OpenOutputContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openOutput

	return p
}

func (s *OpenOutputContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenOutputContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenOutputContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *OpenOutputContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *OpenOutputContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *OpenOutputContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenOutputContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenOutputContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenOutput(s)
	}
}

func (s *OpenOutputContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenOutput(s)
	}
}

func (s *OpenOutputContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenOutput(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenOutput() (localctx IOpenOutputContext) {
	this := p
	_ = this

	localctx = NewOpenOutputContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, Cobol85ParserRULE_openOutput)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4687)
		p.FileName()
	}
	p.SetState(4693)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 682, p.GetParserRuleContext()) == 1 {
		p.SetState(4689)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserWITH {
			{
				p.SetState(4688)
				p.Match(Cobol85ParserWITH)
			}

		}
		{
			p.SetState(4691)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(4692)
			p.Match(Cobol85ParserREWIND)
		}

	}

	return localctx
}

// IOpenIOStatementContext is an interface to support dynamic dispatch.
type IOpenIOStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenIOStatementContext differentiates from other interfaces.
	IsOpenIOStatementContext()
}

type OpenIOStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenIOStatementContext() *OpenIOStatementContext {
	var p = new(OpenIOStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openIOStatement
	return p
}

func (*OpenIOStatementContext) IsOpenIOStatementContext() {}

func NewOpenIOStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenIOStatementContext {
	var p = new(OpenIOStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openIOStatement

	return p
}

func (s *OpenIOStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenIOStatementContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *OpenIOStatementContext) AllFileName() []IFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileNameContext); ok {
			len++
		}
	}

	tst := make([]IFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileNameContext); ok {
			tst[i] = t.(IFileNameContext)
			i++
		}
	}

	return tst
}

func (s *OpenIOStatementContext) FileName(i int) IFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenIOStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenIOStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenIOStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenIOStatement(s)
	}
}

func (s *OpenIOStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenIOStatement(s)
	}
}

func (s *OpenIOStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenIOStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenIOStatement() (localctx IOpenIOStatementContext) {
	this := p
	_ = this

	localctx = NewOpenIOStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, Cobol85ParserRULE_openIOStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4695)
		p.Match(Cobol85ParserI_O)
	}
	p.SetState(4697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4696)
			p.FileName()
		}

		p.SetState(4699)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IOpenExtendStatementContext is an interface to support dynamic dispatch.
type IOpenExtendStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOpenExtendStatementContext differentiates from other interfaces.
	IsOpenExtendStatementContext()
}

type OpenExtendStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOpenExtendStatementContext() *OpenExtendStatementContext {
	var p = new(OpenExtendStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_openExtendStatement
	return p
}

func (*OpenExtendStatementContext) IsOpenExtendStatementContext() {}

func NewOpenExtendStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OpenExtendStatementContext {
	var p = new(OpenExtendStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_openExtendStatement

	return p
}

func (s *OpenExtendStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *OpenExtendStatementContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *OpenExtendStatementContext) AllFileName() []IFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileNameContext); ok {
			len++
		}
	}

	tst := make([]IFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileNameContext); ok {
			tst[i] = t.(IFileNameContext)
			i++
		}
	}

	return tst
}

func (s *OpenExtendStatementContext) FileName(i int) IFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *OpenExtendStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OpenExtendStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OpenExtendStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOpenExtendStatement(s)
	}
}

func (s *OpenExtendStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOpenExtendStatement(s)
	}
}

func (s *OpenExtendStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOpenExtendStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OpenExtendStatement() (localctx IOpenExtendStatementContext) {
	this := p
	_ = this

	localctx = NewOpenExtendStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, Cobol85ParserRULE_openExtendStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4701)
		p.Match(Cobol85ParserEXTEND)
	}
	p.SetState(4703)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4702)
			p.FileName()
		}

		p.SetState(4705)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPerformStatementContext is an interface to support dynamic dispatch.
type IPerformStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformStatementContext differentiates from other interfaces.
	IsPerformStatementContext()
}

type PerformStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformStatementContext() *PerformStatementContext {
	var p = new(PerformStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performStatement
	return p
}

func (*PerformStatementContext) IsPerformStatementContext() {}

func NewPerformStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformStatementContext {
	var p = new(PerformStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performStatement

	return p
}

func (s *PerformStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformStatementContext) PERFORM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPERFORM, 0)
}

func (s *PerformStatementContext) PerformInlineStatement() IPerformInlineStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformInlineStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformInlineStatementContext)
}

func (s *PerformStatementContext) PerformProcedureStatement() IPerformProcedureStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformProcedureStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformProcedureStatementContext)
}

func (s *PerformStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformStatement(s)
	}
}

func (s *PerformStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformStatement(s)
	}
}

func (s *PerformStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformStatement() (localctx IPerformStatementContext) {
	this := p
	_ = this

	localctx = NewPerformStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, Cobol85ParserRULE_performStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4707)
		p.Match(Cobol85ParserPERFORM)
	}
	p.SetState(4710)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 685, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4708)
			p.PerformInlineStatement()
		}

	case 2:
		{
			p.SetState(4709)
			p.PerformProcedureStatement()
		}

	}

	return localctx
}

// IPerformInlineStatementContext is an interface to support dynamic dispatch.
type IPerformInlineStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformInlineStatementContext differentiates from other interfaces.
	IsPerformInlineStatementContext()
}

type PerformInlineStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformInlineStatementContext() *PerformInlineStatementContext {
	var p = new(PerformInlineStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performInlineStatement
	return p
}

func (*PerformInlineStatementContext) IsPerformInlineStatementContext() {}

func NewPerformInlineStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformInlineStatementContext {
	var p = new(PerformInlineStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performInlineStatement

	return p
}

func (s *PerformInlineStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformInlineStatementContext) END_PERFORM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_PERFORM, 0)
}

func (s *PerformInlineStatementContext) PerformType() IPerformTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformTypeContext)
}

func (s *PerformInlineStatementContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *PerformInlineStatementContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *PerformInlineStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformInlineStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformInlineStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformInlineStatement(s)
	}
}

func (s *PerformInlineStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformInlineStatement(s)
	}
}

func (s *PerformInlineStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformInlineStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformInlineStatement() (localctx IPerformInlineStatementContext) {
	this := p
	_ = this

	localctx = NewPerformInlineStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, Cobol85ParserRULE_performInlineStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4713)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&104066617936808097) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(4712)
			p.PerformType()
		}

	}
	p.SetState(4718)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&13510798882242580) != 0 || (int64((_la-67)) & ^0x3f) == 0 && ((int64(1)<<(_la-67))&570425345) != 0 || (int64((_la-131)) & ^0x3f) == 0 && ((int64(1)<<(_la-131))&4613937818308192769) != 0 || (int64((_la-198)) & ^0x3f) == 0 && ((int64(1)<<(_la-198))&1337281096974339) != 0 || (int64((_la-294)) & ^0x3f) == 0 && ((int64(1)<<(_la-294))&562958543356225) != 0 || (int64((_la-365)) & ^0x3f) == 0 && ((int64(1)<<(_la-365))&1161937774836712961) != 0 || (int64((_la-430)) & ^0x3f) == 0 && ((int64(1)<<(_la-430))&70378206528513) != 0 || (int64((_la-500)) & ^0x3f) == 0 && ((int64(1)<<(_la-500))&4035225266124095489) != 0 {
		{
			p.SetState(4715)
			p.Statement()
		}

		p.SetState(4720)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4721)
		p.Match(Cobol85ParserEND_PERFORM)
	}

	return localctx
}

// IPerformProcedureStatementContext is an interface to support dynamic dispatch.
type IPerformProcedureStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformProcedureStatementContext differentiates from other interfaces.
	IsPerformProcedureStatementContext()
}

type PerformProcedureStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformProcedureStatementContext() *PerformProcedureStatementContext {
	var p = new(PerformProcedureStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performProcedureStatement
	return p
}

func (*PerformProcedureStatementContext) IsPerformProcedureStatementContext() {}

func NewPerformProcedureStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformProcedureStatementContext {
	var p = new(PerformProcedureStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performProcedureStatement

	return p
}

func (s *PerformProcedureStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformProcedureStatementContext) AllProcedureName() []IProcedureNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProcedureNameContext); ok {
			len++
		}
	}

	tst := make([]IProcedureNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProcedureNameContext); ok {
			tst[i] = t.(IProcedureNameContext)
			i++
		}
	}

	return tst
}

func (s *PerformProcedureStatementContext) ProcedureName(i int) IProcedureNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *PerformProcedureStatementContext) PerformType() IPerformTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformTypeContext)
}

func (s *PerformProcedureStatementContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *PerformProcedureStatementContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *PerformProcedureStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformProcedureStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformProcedureStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformProcedureStatement(s)
	}
}

func (s *PerformProcedureStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformProcedureStatement(s)
	}
}

func (s *PerformProcedureStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformProcedureStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformProcedureStatement() (localctx IPerformProcedureStatementContext) {
	this := p
	_ = this

	localctx = NewPerformProcedureStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, Cobol85ParserRULE_performProcedureStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4723)
		p.ProcedureName()
	}
	p.SetState(4726)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(4724)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4725)
			p.ProcedureName()
		}

	}
	p.SetState(4729)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 689, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4728)
			p.PerformType()
		}

	}

	return localctx
}

// IPerformTypeContext is an interface to support dynamic dispatch.
type IPerformTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTypeContext differentiates from other interfaces.
	IsPerformTypeContext()
}

type PerformTypeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTypeContext() *PerformTypeContext {
	var p = new(PerformTypeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performType
	return p
}

func (*PerformTypeContext) IsPerformTypeContext() {}

func NewPerformTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTypeContext {
	var p = new(PerformTypeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performType

	return p
}

func (s *PerformTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTypeContext) PerformTimes() IPerformTimesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformTimesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformTimesContext)
}

func (s *PerformTypeContext) PerformUntil() IPerformUntilContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformUntilContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformUntilContext)
}

func (s *PerformTypeContext) PerformVarying() IPerformVaryingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformVaryingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingContext)
}

func (s *PerformTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformType(s)
	}
}

func (s *PerformTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformType(s)
	}
}

func (s *PerformTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformType() (localctx IPerformTypeContext) {
	this := p
	_ = this

	localctx = NewPerformTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, Cobol85ParserRULE_performType)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4734)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 690, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4731)
			p.PerformTimes()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4732)
			p.PerformUntil()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4733)
			p.PerformVarying()
		}

	}

	return localctx
}

// IPerformTimesContext is an interface to support dynamic dispatch.
type IPerformTimesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTimesContext differentiates from other interfaces.
	IsPerformTimesContext()
}

type PerformTimesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTimesContext() *PerformTimesContext {
	var p = new(PerformTimesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performTimes
	return p
}

func (*PerformTimesContext) IsPerformTimesContext() {}

func NewPerformTimesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTimesContext {
	var p = new(PerformTimesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performTimes

	return p
}

func (s *PerformTimesContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTimesContext) TIMES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMES, 0)
}

func (s *PerformTimesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformTimesContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *PerformTimesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTimesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTimesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformTimes(s)
	}
}

func (s *PerformTimesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformTimes(s)
	}
}

func (s *PerformTimesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformTimes(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformTimes() (localctx IPerformTimesContext) {
	this := p
	_ = this

	localctx = NewPerformTimesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, Cobol85ParserRULE_performTimes)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4738)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 691, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4736)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4737)
			p.IntegerLiteral()
		}

	}
	{
		p.SetState(4740)
		p.Match(Cobol85ParserTIMES)
	}

	return localctx
}

// IPerformUntilContext is an interface to support dynamic dispatch.
type IPerformUntilContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformUntilContext differentiates from other interfaces.
	IsPerformUntilContext()
}

type PerformUntilContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformUntilContext() *PerformUntilContext {
	var p = new(PerformUntilContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performUntil
	return p
}

func (*PerformUntilContext) IsPerformUntilContext() {}

func NewPerformUntilContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformUntilContext {
	var p = new(PerformUntilContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performUntil

	return p
}

func (s *PerformUntilContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformUntilContext) UNTIL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNTIL, 0)
}

func (s *PerformUntilContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *PerformUntilContext) PerformTestClause() IPerformTestClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformTestClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformTestClauseContext)
}

func (s *PerformUntilContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformUntilContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformUntilContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformUntil(s)
	}
}

func (s *PerformUntilContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformUntil(s)
	}
}

func (s *PerformUntilContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformUntil(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformUntil() (localctx IPerformUntilContext) {
	this := p
	_ = this

	localctx = NewPerformUntilContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, Cobol85ParserRULE_performUntil)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTEST || _la == Cobol85ParserWITH {
		{
			p.SetState(4742)
			p.PerformTestClause()
		}

	}
	{
		p.SetState(4745)
		p.Match(Cobol85ParserUNTIL)
	}
	{
		p.SetState(4746)
		p.Condition()
	}

	return localctx
}

// IPerformVaryingContext is an interface to support dynamic dispatch.
type IPerformVaryingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingContext differentiates from other interfaces.
	IsPerformVaryingContext()
}

type PerformVaryingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingContext() *PerformVaryingContext {
	var p = new(PerformVaryingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVarying
	return p
}

func (*PerformVaryingContext) IsPerformVaryingContext() {}

func NewPerformVaryingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingContext {
	var p = new(PerformVaryingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVarying

	return p
}

func (s *PerformVaryingContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingContext) PerformTestClause() IPerformTestClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformTestClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformTestClauseContext)
}

func (s *PerformVaryingContext) PerformVaryingClause() IPerformVaryingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformVaryingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingClauseContext)
}

func (s *PerformVaryingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVarying(s)
	}
}

func (s *PerformVaryingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVarying(s)
	}
}

func (s *PerformVaryingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformVarying(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformVarying() (localctx IPerformVaryingContext) {
	this := p
	_ = this

	localctx = NewPerformVaryingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, Cobol85ParserRULE_performVarying)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4755)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTEST, Cobol85ParserWITH:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4748)
			p.PerformTestClause()
		}
		{
			p.SetState(4749)
			p.PerformVaryingClause()
		}

	case Cobol85ParserVARYING:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4751)
			p.PerformVaryingClause()
		}
		p.SetState(4753)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 693, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4752)
				p.PerformTestClause()
			}

		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IPerformVaryingClauseContext is an interface to support dynamic dispatch.
type IPerformVaryingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingClauseContext differentiates from other interfaces.
	IsPerformVaryingClauseContext()
}

type PerformVaryingClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingClauseContext() *PerformVaryingClauseContext {
	var p = new(PerformVaryingClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVaryingClause
	return p
}

func (*PerformVaryingClauseContext) IsPerformVaryingClauseContext() {}

func NewPerformVaryingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingClauseContext {
	var p = new(PerformVaryingClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVaryingClause

	return p
}

func (s *PerformVaryingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingClauseContext) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *PerformVaryingClauseContext) PerformVaryingPhrase() IPerformVaryingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformVaryingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingPhraseContext)
}

func (s *PerformVaryingClauseContext) AllPerformAfter() []IPerformAfterContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPerformAfterContext); ok {
			len++
		}
	}

	tst := make([]IPerformAfterContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPerformAfterContext); ok {
			tst[i] = t.(IPerformAfterContext)
			i++
		}
	}

	return tst
}

func (s *PerformVaryingClauseContext) PerformAfter(i int) IPerformAfterContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformAfterContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformAfterContext)
}

func (s *PerformVaryingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVaryingClause(s)
	}
}

func (s *PerformVaryingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVaryingClause(s)
	}
}

func (s *PerformVaryingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformVaryingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformVaryingClause() (localctx IPerformVaryingClauseContext) {
	this := p
	_ = this

	localctx = NewPerformVaryingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, Cobol85ParserRULE_performVaryingClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4757)
		p.Match(Cobol85ParserVARYING)
	}
	{
		p.SetState(4758)
		p.PerformVaryingPhrase()
	}
	p.SetState(4762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAFTER {
		{
			p.SetState(4759)
			p.PerformAfter()
		}

		p.SetState(4764)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPerformVaryingPhraseContext is an interface to support dynamic dispatch.
type IPerformVaryingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformVaryingPhraseContext differentiates from other interfaces.
	IsPerformVaryingPhraseContext()
}

type PerformVaryingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformVaryingPhraseContext() *PerformVaryingPhraseContext {
	var p = new(PerformVaryingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performVaryingPhrase
	return p
}

func (*PerformVaryingPhraseContext) IsPerformVaryingPhraseContext() {}

func NewPerformVaryingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformVaryingPhraseContext {
	var p = new(PerformVaryingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performVaryingPhrase

	return p
}

func (s *PerformVaryingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformVaryingPhraseContext) PerformFrom() IPerformFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformFromContext)
}

func (s *PerformVaryingPhraseContext) PerformBy() IPerformByContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformByContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformByContext)
}

func (s *PerformVaryingPhraseContext) PerformUntil() IPerformUntilContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformUntilContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformUntilContext)
}

func (s *PerformVaryingPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformVaryingPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformVaryingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformVaryingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformVaryingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformVaryingPhrase(s)
	}
}

func (s *PerformVaryingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformVaryingPhrase(s)
	}
}

func (s *PerformVaryingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformVaryingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformVaryingPhrase() (localctx IPerformVaryingPhraseContext) {
	this := p
	_ = this

	localctx = NewPerformVaryingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, Cobol85ParserRULE_performVaryingPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4767)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 696, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4765)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4766)
			p.Literal()
		}

	}
	{
		p.SetState(4769)
		p.PerformFrom()
	}
	{
		p.SetState(4770)
		p.PerformBy()
	}
	{
		p.SetState(4771)
		p.PerformUntil()
	}

	return localctx
}

// IPerformAfterContext is an interface to support dynamic dispatch.
type IPerformAfterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformAfterContext differentiates from other interfaces.
	IsPerformAfterContext()
}

type PerformAfterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformAfterContext() *PerformAfterContext {
	var p = new(PerformAfterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performAfter
	return p
}

func (*PerformAfterContext) IsPerformAfterContext() {}

func NewPerformAfterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformAfterContext {
	var p = new(PerformAfterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performAfter

	return p
}

func (s *PerformAfterContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformAfterContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *PerformAfterContext) PerformVaryingPhrase() IPerformVaryingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPerformVaryingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPerformVaryingPhraseContext)
}

func (s *PerformAfterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformAfterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformAfterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformAfter(s)
	}
}

func (s *PerformAfterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformAfter(s)
	}
}

func (s *PerformAfterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformAfter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformAfter() (localctx IPerformAfterContext) {
	this := p
	_ = this

	localctx = NewPerformAfterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, Cobol85ParserRULE_performAfter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4773)
		p.Match(Cobol85ParserAFTER)
	}
	{
		p.SetState(4774)
		p.PerformVaryingPhrase()
	}

	return localctx
}

// IPerformFromContext is an interface to support dynamic dispatch.
type IPerformFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformFromContext differentiates from other interfaces.
	IsPerformFromContext()
}

type PerformFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformFromContext() *PerformFromContext {
	var p = new(PerformFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performFrom
	return p
}

func (*PerformFromContext) IsPerformFromContext() {}

func NewPerformFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformFromContext {
	var p = new(PerformFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performFrom

	return p
}

func (s *PerformFromContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *PerformFromContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformFromContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformFromContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *PerformFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformFrom(s)
	}
}

func (s *PerformFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformFrom(s)
	}
}

func (s *PerformFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformFrom() (localctx IPerformFromContext) {
	this := p
	_ = this

	localctx = NewPerformFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, Cobol85ParserRULE_performFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4776)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(4780)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 697, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4777)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4778)
			p.Literal()
		}

	case 3:
		{
			p.SetState(4779)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IPerformByContext is an interface to support dynamic dispatch.
type IPerformByContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformByContext differentiates from other interfaces.
	IsPerformByContext()
}

type PerformByContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformByContext() *PerformByContext {
	var p = new(PerformByContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performBy
	return p
}

func (*PerformByContext) IsPerformByContext() {}

func NewPerformByContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformByContext {
	var p = new(PerformByContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performBy

	return p
}

func (s *PerformByContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformByContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *PerformByContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PerformByContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *PerformByContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *PerformByContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformByContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformByContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformBy(s)
	}
}

func (s *PerformByContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformBy(s)
	}
}

func (s *PerformByContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformBy(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformBy() (localctx IPerformByContext) {
	this := p
	_ = this

	localctx = NewPerformByContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, Cobol85ParserRULE_performBy)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4782)
		p.Match(Cobol85ParserBY)
	}
	p.SetState(4786)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 698, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4783)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(4784)
			p.Literal()
		}

	case 3:
		{
			p.SetState(4785)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IPerformTestClauseContext is an interface to support dynamic dispatch.
type IPerformTestClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPerformTestClauseContext differentiates from other interfaces.
	IsPerformTestClauseContext()
}

type PerformTestClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPerformTestClauseContext() *PerformTestClauseContext {
	var p = new(PerformTestClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_performTestClause
	return p
}

func (*PerformTestClauseContext) IsPerformTestClauseContext() {}

func NewPerformTestClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PerformTestClauseContext {
	var p = new(PerformTestClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_performTestClause

	return p
}

func (s *PerformTestClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PerformTestClauseContext) TEST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTEST, 0)
}

func (s *PerformTestClauseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *PerformTestClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *PerformTestClauseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *PerformTestClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PerformTestClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PerformTestClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPerformTestClause(s)
	}
}

func (s *PerformTestClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPerformTestClause(s)
	}
}

func (s *PerformTestClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPerformTestClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PerformTestClause() (localctx IPerformTestClauseContext) {
	this := p
	_ = this

	localctx = NewPerformTestClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, Cobol85ParserRULE_performTestClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4789)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4788)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4791)
		p.Match(Cobol85ParserTEST)
	}
	{
		p.SetState(4792)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IPurgeStatementContext is an interface to support dynamic dispatch.
type IPurgeStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPurgeStatementContext differentiates from other interfaces.
	IsPurgeStatementContext()
}

type PurgeStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPurgeStatementContext() *PurgeStatementContext {
	var p = new(PurgeStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_purgeStatement
	return p
}

func (*PurgeStatementContext) IsPurgeStatementContext() {}

func NewPurgeStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PurgeStatementContext {
	var p = new(PurgeStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_purgeStatement

	return p
}

func (s *PurgeStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PurgeStatementContext) PURGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPURGE, 0)
}

func (s *PurgeStatementContext) AllCdName() []ICdNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICdNameContext); ok {
			len++
		}
	}

	tst := make([]ICdNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICdNameContext); ok {
			tst[i] = t.(ICdNameContext)
			i++
		}
	}

	return tst
}

func (s *PurgeStatementContext) CdName(i int) ICdNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *PurgeStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PurgeStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PurgeStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPurgeStatement(s)
	}
}

func (s *PurgeStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPurgeStatement(s)
	}
}

func (s *PurgeStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPurgeStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PurgeStatement() (localctx IPurgeStatementContext) {
	this := p
	_ = this

	localctx = NewPurgeStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, Cobol85ParserRULE_purgeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4794)
		p.Match(Cobol85ParserPURGE)
	}
	p.SetState(4796)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(4795)
			p.CdName()
		}

		p.SetState(4798)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IReadStatementContext is an interface to support dynamic dispatch.
type IReadStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadStatementContext differentiates from other interfaces.
	IsReadStatementContext()
}

type ReadStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadStatementContext() *ReadStatementContext {
	var p = new(ReadStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readStatement
	return p
}

func (*ReadStatementContext) IsReadStatementContext() {}

func NewReadStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadStatementContext {
	var p = new(ReadStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readStatement

	return p
}

func (s *ReadStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadStatementContext) READ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAD, 0)
}

func (s *ReadStatementContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ReadStatementContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *ReadStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *ReadStatementContext) ReadInto() IReadIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadIntoContext)
}

func (s *ReadStatementContext) ReadWith() IReadWithContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadWithContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadWithContext)
}

func (s *ReadStatementContext) ReadKey() IReadKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReadKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReadKeyContext)
}

func (s *ReadStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *ReadStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *ReadStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtEndPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *ReadStatementContext) NotAtEndPhrase() INotAtEndPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotAtEndPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotAtEndPhraseContext)
}

func (s *ReadStatementContext) END_READ() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_READ, 0)
}

func (s *ReadStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadStatement(s)
	}
}

func (s *ReadStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadStatement(s)
	}
}

func (s *ReadStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadStatement() (localctx IReadStatementContext) {
	this := p
	_ = this

	localctx = NewReadStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, Cobol85ParserRULE_readStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4800)
		p.Match(Cobol85ParserREAD)
	}
	{
		p.SetState(4801)
		p.FileName()
	}
	p.SetState(4803)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNEXT {
		{
			p.SetState(4802)
			p.Match(Cobol85ParserNEXT)
		}

	}
	p.SetState(4806)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(4805)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4809)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4808)
			p.ReadInto()
		}

	}
	p.SetState(4812)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 704, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4811)
			p.ReadWith()
		}

	}
	p.SetState(4815)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(4814)
			p.ReadKey()
		}

	}
	p.SetState(4818)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 706, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4817)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4821)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 707, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4820)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4824)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4823)
			p.AtEndPhrase()
		}

	}
	p.SetState(4827)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 709, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4826)
			p.NotAtEndPhrase()
		}

	}
	p.SetState(4830)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 710, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4829)
			p.Match(Cobol85ParserEND_READ)
		}

	}

	return localctx
}

// IReadIntoContext is an interface to support dynamic dispatch.
type IReadIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadIntoContext differentiates from other interfaces.
	IsReadIntoContext()
}

type ReadIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadIntoContext() *ReadIntoContext {
	var p = new(ReadIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readInto
	return p
}

func (*ReadIntoContext) IsReadIntoContext() {}

func NewReadIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadIntoContext {
	var p = new(ReadIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readInto

	return p
}

func (s *ReadIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReadIntoContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReadIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadInto(s)
	}
}

func (s *ReadIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadInto(s)
	}
}

func (s *ReadIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadInto() (localctx IReadIntoContext) {
	this := p
	_ = this

	localctx = NewReadIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, Cobol85ParserRULE_readInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4832)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(4833)
		p.Identifier()
	}

	return localctx
}

// IReadWithContext is an interface to support dynamic dispatch.
type IReadWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadWithContext differentiates from other interfaces.
	IsReadWithContext()
}

type ReadWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadWithContext() *ReadWithContext {
	var p = new(ReadWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readWith
	return p
}

func (*ReadWithContext) IsReadWithContext() {}

func NewReadWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadWithContext {
	var p = new(ReadWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readWith

	return p
}

func (s *ReadWithContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadWithContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *ReadWithContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ReadWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReadWithContext) KEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEPT, 0)
}

func (s *ReadWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReadWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadWith(s)
	}
}

func (s *ReadWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadWith(s)
	}
}

func (s *ReadWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadWith() (localctx IReadWithContext) {
	this := p
	_ = this

	localctx = NewReadWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, Cobol85ParserRULE_readWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4835)
			p.Match(Cobol85ParserWITH)
		}

	}
	p.SetState(4841)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserKEPT, Cobol85ParserNO:
		{
			p.SetState(4838)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserKEPT || _la == Cobol85ParserNO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(4839)
			p.Match(Cobol85ParserLOCK)
		}

	case Cobol85ParserWAIT:
		{
			p.SetState(4840)
			p.Match(Cobol85ParserWAIT)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReadKeyContext is an interface to support dynamic dispatch.
type IReadKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReadKeyContext differentiates from other interfaces.
	IsReadKeyContext()
}

type ReadKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReadKeyContext() *ReadKeyContext {
	var p = new(ReadKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_readKey
	return p
}

func (*ReadKeyContext) IsReadKeyContext() {}

func NewReadKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReadKeyContext {
	var p = new(ReadKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_readKey

	return p
}

func (s *ReadKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *ReadKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *ReadKeyContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReadKeyContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ReadKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReadKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReadKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReadKey(s)
	}
}

func (s *ReadKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReadKey(s)
	}
}

func (s *ReadKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReadKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReadKey() (localctx IReadKeyContext) {
	this := p
	_ = this

	localctx = NewReadKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, Cobol85ParserRULE_readKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4843)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(4845)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(4844)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(4847)
		p.QualifiedDataName()
	}

	return localctx
}

// IReceiveStatementContext is an interface to support dynamic dispatch.
type IReceiveStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveStatementContext differentiates from other interfaces.
	IsReceiveStatementContext()
}

type ReceiveStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveStatementContext() *ReceiveStatementContext {
	var p = new(ReceiveStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveStatement
	return p
}

func (*ReceiveStatementContext) IsReceiveStatementContext() {}

func NewReceiveStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveStatementContext {
	var p = new(ReceiveStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveStatement

	return p
}

func (s *ReceiveStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveStatementContext) RECEIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVE, 0)
}

func (s *ReceiveStatementContext) ReceiveFromStatement() IReceiveFromStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveFromStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveFromStatementContext)
}

func (s *ReceiveStatementContext) ReceiveIntoStatement() IReceiveIntoStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveIntoStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveIntoStatementContext)
}

func (s *ReceiveStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *ReceiveStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *ReceiveStatementContext) END_RECEIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_RECEIVE, 0)
}

func (s *ReceiveStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveStatement(s)
	}
}

func (s *ReceiveStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveStatement(s)
	}
}

func (s *ReceiveStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveStatement() (localctx IReceiveStatementContext) {
	this := p
	_ = this

	localctx = NewReceiveStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, Cobol85ParserRULE_receiveStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4849)
		p.Match(Cobol85ParserRECEIVE)
	}
	p.SetState(4852)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 714, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4850)
			p.ReceiveFromStatement()
		}

	case 2:
		{
			p.SetState(4851)
			p.ReceiveIntoStatement()
		}

	}
	p.SetState(4855)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 715, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4854)
			p.OnExceptionClause()
		}

	}
	p.SetState(4858)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 716, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4857)
			p.NotOnExceptionClause()
		}

	}
	p.SetState(4861)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 717, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4860)
			p.Match(Cobol85ParserEND_RECEIVE)
		}

	}

	return localctx
}

// IReceiveFromStatementContext is an interface to support dynamic dispatch.
type IReceiveFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveFromStatementContext differentiates from other interfaces.
	IsReceiveFromStatementContext()
}

type ReceiveFromStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveFromStatementContext() *ReceiveFromStatementContext {
	var p = new(ReceiveFromStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveFromStatement
	return p
}

func (*ReceiveFromStatementContext) IsReceiveFromStatementContext() {}

func NewReceiveFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFromStatementContext {
	var p = new(ReceiveFromStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveFromStatement

	return p
}

func (s *ReceiveFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFromStatementContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveFromStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ReceiveFromStatementContext) ReceiveFrom() IReceiveFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveFromContext)
}

func (s *ReceiveFromStatementContext) AllReceiveBefore() []IReceiveBeforeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReceiveBeforeContext); ok {
			len++
		}
	}

	tst := make([]IReceiveBeforeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReceiveBeforeContext); ok {
			tst[i] = t.(IReceiveBeforeContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveBefore(i int) IReceiveBeforeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveBeforeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveBeforeContext)
}

func (s *ReceiveFromStatementContext) AllReceiveWith() []IReceiveWithContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReceiveWithContext); ok {
			len++
		}
	}

	tst := make([]IReceiveWithContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReceiveWithContext); ok {
			tst[i] = t.(IReceiveWithContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveWith(i int) IReceiveWithContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveWithContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveWithContext)
}

func (s *ReceiveFromStatementContext) AllReceiveThread() []IReceiveThreadContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReceiveThreadContext); ok {
			len++
		}
	}

	tst := make([]IReceiveThreadContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReceiveThreadContext); ok {
			tst[i] = t.(IReceiveThreadContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveThread(i int) IReceiveThreadContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveThreadContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveThreadContext)
}

func (s *ReceiveFromStatementContext) AllReceiveSize() []IReceiveSizeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReceiveSizeContext); ok {
			len++
		}
	}

	tst := make([]IReceiveSizeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReceiveSizeContext); ok {
			tst[i] = t.(IReceiveSizeContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveSize(i int) IReceiveSizeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveSizeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveSizeContext)
}

func (s *ReceiveFromStatementContext) AllReceiveStatus() []IReceiveStatusContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReceiveStatusContext); ok {
			len++
		}
	}

	tst := make([]IReceiveStatusContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReceiveStatusContext); ok {
			tst[i] = t.(IReceiveStatusContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveFromStatementContext) ReceiveStatus(i int) IReceiveStatusContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveStatusContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveStatusContext)
}

func (s *ReceiveFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveFromStatement(s)
	}
}

func (s *ReceiveFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveFromStatement(s)
	}
}

func (s *ReceiveFromStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveFromStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveFromStatement() (localctx IReceiveFromStatementContext) {
	this := p
	_ = this

	localctx = NewReceiveFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, Cobol85ParserRULE_receiveFromStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4863)
		p.DataName()
	}
	{
		p.SetState(4864)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(4865)
		p.ReceiveFrom()
	}
	p.SetState(4873)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 719, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(4871)
			p.GetErrorHandler().Sync(p)

			switch p.GetTokenStream().LA(1) {
			case Cobol85ParserBEFORE:
				{
					p.SetState(4866)
					p.ReceiveBefore()
				}

			case Cobol85ParserNO, Cobol85ParserWITH:
				{
					p.SetState(4867)
					p.ReceiveWith()
				}

			case Cobol85ParserTHREAD:
				{
					p.SetState(4868)
					p.ReceiveThread()
				}

			case Cobol85ParserSIZE:
				{
					p.SetState(4869)
					p.ReceiveSize()
				}

			case Cobol85ParserSTATUS:
				{
					p.SetState(4870)
					p.ReceiveStatus()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

		}
		p.SetState(4875)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 719, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveFromContext is an interface to support dynamic dispatch.
type IReceiveFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveFromContext differentiates from other interfaces.
	IsReceiveFromContext()
}

type ReceiveFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveFromContext() *ReceiveFromContext {
	var p = new(ReceiveFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveFrom
	return p
}

func (*ReceiveFromContext) IsReceiveFromContext() {}

func NewReceiveFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveFromContext {
	var p = new(ReceiveFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveFrom

	return p
}

func (s *ReceiveFromContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveFromContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *ReceiveFromContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveFromContext) LAST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLAST, 0)
}

func (s *ReceiveFromContext) ANY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserANY, 0)
}

func (s *ReceiveFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveFrom(s)
	}
}

func (s *ReceiveFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveFrom(s)
	}
}

func (s *ReceiveFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveFrom() (localctx IReceiveFromContext) {
	this := p
	_ = this

	localctx = NewReceiveFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, Cobol85ParserRULE_receiveFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(4882)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserTHREAD:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4876)
			p.Match(Cobol85ParserTHREAD)
		}
		{
			p.SetState(4877)
			p.DataName()
		}

	case Cobol85ParserLAST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4878)
			p.Match(Cobol85ParserLAST)
		}
		{
			p.SetState(4879)
			p.Match(Cobol85ParserTHREAD)
		}

	case Cobol85ParserANY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4880)
			p.Match(Cobol85ParserANY)
		}
		{
			p.SetState(4881)
			p.Match(Cobol85ParserTHREAD)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IReceiveIntoStatementContext is an interface to support dynamic dispatch.
type IReceiveIntoStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveIntoStatementContext differentiates from other interfaces.
	IsReceiveIntoStatementContext()
}

type ReceiveIntoStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveIntoStatementContext() *ReceiveIntoStatementContext {
	var p = new(ReceiveIntoStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveIntoStatement
	return p
}

func (*ReceiveIntoStatementContext) IsReceiveIntoStatementContext() {}

func NewReceiveIntoStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveIntoStatementContext {
	var p = new(ReceiveIntoStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveIntoStatement

	return p
}

func (s *ReceiveIntoStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveIntoStatementContext) CdName() ICdNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICdNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICdNameContext)
}

func (s *ReceiveIntoStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveIntoStatementContext) MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMESSAGE, 0)
}

func (s *ReceiveIntoStatementContext) SEGMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEGMENT, 0)
}

func (s *ReceiveIntoStatementContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReceiveIntoStatementContext) ReceiveNoData() IReceiveNoDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveNoDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveNoDataContext)
}

func (s *ReceiveIntoStatementContext) ReceiveWithData() IReceiveWithDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReceiveWithDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReceiveWithDataContext)
}

func (s *ReceiveIntoStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveIntoStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveIntoStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveIntoStatement(s)
	}
}

func (s *ReceiveIntoStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveIntoStatement(s)
	}
}

func (s *ReceiveIntoStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveIntoStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveIntoStatement() (localctx IReceiveIntoStatementContext) {
	this := p
	_ = this

	localctx = NewReceiveIntoStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 836, Cobol85ParserRULE_receiveIntoStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4884)
		p.CdName()
	}
	{
		p.SetState(4885)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserMESSAGE || _la == Cobol85ParserSEGMENT) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(4887)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4886)
			p.Match(Cobol85ParserINTO)
		}

	}
	{
		p.SetState(4889)
		p.Identifier()
	}
	p.SetState(4891)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNO {
		{
			p.SetState(4890)
			p.ReceiveNoData()
		}

	}
	p.SetState(4894)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 723, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4893)
			p.ReceiveWithData()
		}

	}

	return localctx
}

// IReceiveNoDataContext is an interface to support dynamic dispatch.
type IReceiveNoDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveNoDataContext differentiates from other interfaces.
	IsReceiveNoDataContext()
}

type ReceiveNoDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveNoDataContext() *ReceiveNoDataContext {
	var p = new(ReceiveNoDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveNoData
	return p
}

func (*ReceiveNoDataContext) IsReceiveNoDataContext() {}

func NewReceiveNoDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveNoDataContext {
	var p = new(ReceiveNoDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveNoData

	return p
}

func (s *ReceiveNoDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveNoDataContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReceiveNoDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *ReceiveNoDataContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveNoDataContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ReceiveNoDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveNoDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveNoDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveNoData(s)
	}
}

func (s *ReceiveNoDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveNoData(s)
	}
}

func (s *ReceiveNoDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveNoData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveNoData() (localctx IReceiveNoDataContext) {
	this := p
	_ = this

	localctx = NewReceiveNoDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 838, Cobol85ParserRULE_receiveNoData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4896)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4897)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(4901)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 724, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4898)
				p.Statement()
			}

		}
		p.SetState(4903)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 724, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveWithDataContext is an interface to support dynamic dispatch.
type IReceiveWithDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveWithDataContext differentiates from other interfaces.
	IsReceiveWithDataContext()
}

type ReceiveWithDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveWithDataContext() *ReceiveWithDataContext {
	var p = new(ReceiveWithDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveWithData
	return p
}

func (*ReceiveWithDataContext) IsReceiveWithDataContext() {}

func NewReceiveWithDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveWithDataContext {
	var p = new(ReceiveWithDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveWithData

	return p
}

func (s *ReceiveWithDataContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveWithDataContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReceiveWithDataContext) DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATA, 0)
}

func (s *ReceiveWithDataContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *ReceiveWithDataContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *ReceiveWithDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveWithDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveWithDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveWithData(s)
	}
}

func (s *ReceiveWithDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveWithData(s)
	}
}

func (s *ReceiveWithDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveWithData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveWithData() (localctx IReceiveWithDataContext) {
	this := p
	_ = this

	localctx = NewReceiveWithDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 840, Cobol85ParserRULE_receiveWithData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4904)
		p.Match(Cobol85ParserWITH)
	}
	{
		p.SetState(4905)
		p.Match(Cobol85ParserDATA)
	}
	p.SetState(4909)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 725, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(4906)
				p.Statement()
			}

		}
		p.SetState(4911)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 725, p.GetParserRuleContext())
	}

	return localctx
}

// IReceiveBeforeContext is an interface to support dynamic dispatch.
type IReceiveBeforeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveBeforeContext differentiates from other interfaces.
	IsReceiveBeforeContext()
}

type ReceiveBeforeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveBeforeContext() *ReceiveBeforeContext {
	var p = new(ReceiveBeforeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveBefore
	return p
}

func (*ReceiveBeforeContext) IsReceiveBeforeContext() {}

func NewReceiveBeforeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveBeforeContext {
	var p = new(ReceiveBeforeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveBefore

	return p
}

func (s *ReceiveBeforeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveBeforeContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *ReceiveBeforeContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *ReceiveBeforeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveBeforeContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *ReceiveBeforeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveBeforeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveBeforeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveBefore(s)
	}
}

func (s *ReceiveBeforeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveBefore(s)
	}
}

func (s *ReceiveBeforeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveBefore(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveBefore() (localctx IReceiveBeforeContext) {
	this := p
	_ = this

	localctx = NewReceiveBeforeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 842, Cobol85ParserRULE_receiveBefore)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4912)
		p.Match(Cobol85ParserBEFORE)
	}
	p.SetState(4914)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 726, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4913)
			p.Match(Cobol85ParserTIME)
		}

	}
	p.SetState(4918)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 727, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4916)
			p.NumericLiteral()
		}

	case 2:
		{
			p.SetState(4917)
			p.Identifier()
		}

	}

	return localctx
}

// IReceiveWithContext is an interface to support dynamic dispatch.
type IReceiveWithContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveWithContext differentiates from other interfaces.
	IsReceiveWithContext()
}

type ReceiveWithContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveWithContext() *ReceiveWithContext {
	var p = new(ReceiveWithContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveWith
	return p
}

func (*ReceiveWithContext) IsReceiveWithContext() {}

func NewReceiveWithContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveWithContext {
	var p = new(ReceiveWithContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveWith

	return p
}

func (s *ReceiveWithContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveWithContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *ReceiveWithContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *ReceiveWithContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *ReceiveWithContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveWithContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveWithContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveWith(s)
	}
}

func (s *ReceiveWithContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveWith(s)
	}
}

func (s *ReceiveWithContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveWith(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveWith() (localctx IReceiveWithContext) {
	this := p
	_ = this

	localctx = NewReceiveWithContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 844, Cobol85ParserRULE_receiveWith)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(4920)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(4923)
		p.Match(Cobol85ParserNO)
	}
	{
		p.SetState(4924)
		p.Match(Cobol85ParserWAIT)
	}

	return localctx
}

// IReceiveThreadContext is an interface to support dynamic dispatch.
type IReceiveThreadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveThreadContext differentiates from other interfaces.
	IsReceiveThreadContext()
}

type ReceiveThreadContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveThreadContext() *ReceiveThreadContext {
	var p = new(ReceiveThreadContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveThread
	return p
}

func (*ReceiveThreadContext) IsReceiveThreadContext() {}

func NewReceiveThreadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveThreadContext {
	var p = new(ReceiveThreadContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveThread

	return p
}

func (s *ReceiveThreadContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveThreadContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *ReceiveThreadContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *ReceiveThreadContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveThreadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveThreadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveThreadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveThread(s)
	}
}

func (s *ReceiveThreadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveThread(s)
	}
}

func (s *ReceiveThreadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveThread(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveThread() (localctx IReceiveThreadContext) {
	this := p
	_ = this

	localctx = NewReceiveThreadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 846, Cobol85ParserRULE_receiveThread)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4926)
		p.Match(Cobol85ParserTHREAD)
	}
	p.SetState(4928)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4927)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(4930)
		p.DataName()
	}

	return localctx
}

// IReceiveSizeContext is an interface to support dynamic dispatch.
type IReceiveSizeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveSizeContext differentiates from other interfaces.
	IsReceiveSizeContext()
}

type ReceiveSizeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveSizeContext() *ReceiveSizeContext {
	var p = new(ReceiveSizeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveSize
	return p
}

func (*ReceiveSizeContext) IsReceiveSizeContext() {}

func NewReceiveSizeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveSizeContext {
	var p = new(ReceiveSizeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveSize

	return p
}

func (s *ReceiveSizeContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveSizeContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *ReceiveSizeContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *ReceiveSizeContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveSizeContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveSizeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveSizeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveSizeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveSize(s)
	}
}

func (s *ReceiveSizeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveSize(s)
	}
}

func (s *ReceiveSizeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveSize(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveSize() (localctx IReceiveSizeContext) {
	this := p
	_ = this

	localctx = NewReceiveSizeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 848, Cobol85ParserRULE_receiveSize)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4932)
		p.Match(Cobol85ParserSIZE)
	}
	p.SetState(4934)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4933)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(4938)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 731, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4936)
			p.NumericLiteral()
		}

	case 2:
		{
			p.SetState(4937)
			p.Identifier()
		}

	}

	return localctx
}

// IReceiveStatusContext is an interface to support dynamic dispatch.
type IReceiveStatusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReceiveStatusContext differentiates from other interfaces.
	IsReceiveStatusContext()
}

type ReceiveStatusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReceiveStatusContext() *ReceiveStatusContext {
	var p = new(ReceiveStatusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_receiveStatus
	return p
}

func (*ReceiveStatusContext) IsReceiveStatusContext() {}

func NewReceiveStatusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReceiveStatusContext {
	var p = new(ReceiveStatusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_receiveStatus

	return p
}

func (s *ReceiveStatusContext) GetParser() antlr.Parser { return s.parser }

func (s *ReceiveStatusContext) STATUS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTATUS, 0)
}

func (s *ReceiveStatusContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReceiveStatusContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *ReceiveStatusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReceiveStatusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReceiveStatusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReceiveStatus(s)
	}
}

func (s *ReceiveStatusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReceiveStatus(s)
	}
}

func (s *ReceiveStatusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReceiveStatus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReceiveStatus() (localctx IReceiveStatusContext) {
	this := p
	_ = this

	localctx = NewReceiveStatusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 850, Cobol85ParserRULE_receiveStatus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4940)
		p.Match(Cobol85ParserSTATUS)
	}
	p.SetState(4942)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(4941)
			p.Match(Cobol85ParserIN)
		}

	}

	{
		p.SetState(4944)
		p.Identifier()
	}

	return localctx
}

// IReleaseStatementContext is an interface to support dynamic dispatch.
type IReleaseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReleaseStatementContext differentiates from other interfaces.
	IsReleaseStatementContext()
}

type ReleaseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReleaseStatementContext() *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_releaseStatement
	return p
}

func (*ReleaseStatementContext) IsReleaseStatementContext() {}

func NewReleaseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReleaseStatementContext {
	var p = new(ReleaseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_releaseStatement

	return p
}

func (s *ReleaseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReleaseStatementContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *ReleaseStatementContext) RecordName() IRecordNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *ReleaseStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *ReleaseStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReleaseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReleaseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReleaseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReleaseStatement(s)
	}
}

func (s *ReleaseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReleaseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReleaseStatement() (localctx IReleaseStatementContext) {
	this := p
	_ = this

	localctx = NewReleaseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 852, Cobol85ParserRULE_releaseStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4946)
		p.Match(Cobol85ParserRELEASE)
	}
	{
		p.SetState(4947)
		p.RecordName()
	}
	p.SetState(4950)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(4948)
			p.Match(Cobol85ParserFROM)
		}
		{
			p.SetState(4949)
			p.QualifiedDataName()
		}

	}

	return localctx
}

// IReturnStatementContext is an interface to support dynamic dispatch.
type IReturnStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnStatementContext differentiates from other interfaces.
	IsReturnStatementContext()
}

type ReturnStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnStatementContext() *ReturnStatementContext {
	var p = new(ReturnStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_returnStatement
	return p
}

func (*ReturnStatementContext) IsReturnStatementContext() {}

func NewReturnStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnStatementContext {
	var p = new(ReturnStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_returnStatement

	return p
}

func (s *ReturnStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnStatementContext) RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURN, 0)
}

func (s *ReturnStatementContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *ReturnStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtEndPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *ReturnStatementContext) RECORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECORD, 0)
}

func (s *ReturnStatementContext) ReturnInto() IReturnIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnIntoContext)
}

func (s *ReturnStatementContext) NotAtEndPhrase() INotAtEndPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotAtEndPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotAtEndPhraseContext)
}

func (s *ReturnStatementContext) END_RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_RETURN, 0)
}

func (s *ReturnStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReturnStatement(s)
	}
}

func (s *ReturnStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReturnStatement(s)
	}
}

func (s *ReturnStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReturnStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReturnStatement() (localctx IReturnStatementContext) {
	this := p
	_ = this

	localctx = NewReturnStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 854, Cobol85ParserRULE_returnStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4952)
		p.Match(Cobol85ParserRETURN)
	}
	{
		p.SetState(4953)
		p.FileName()
	}
	p.SetState(4955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserRECORD {
		{
			p.SetState(4954)
			p.Match(Cobol85ParserRECORD)
		}

	}
	p.SetState(4958)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINTO {
		{
			p.SetState(4957)
			p.ReturnInto()
		}

	}
	{
		p.SetState(4960)
		p.AtEndPhrase()
	}
	p.SetState(4962)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 736, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4961)
			p.NotAtEndPhrase()
		}

	}
	p.SetState(4965)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 737, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4964)
			p.Match(Cobol85ParserEND_RETURN)
		}

	}

	return localctx
}

// IReturnIntoContext is an interface to support dynamic dispatch.
type IReturnIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReturnIntoContext differentiates from other interfaces.
	IsReturnIntoContext()
}

type ReturnIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnIntoContext() *ReturnIntoContext {
	var p = new(ReturnIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_returnInto
	return p
}

func (*ReturnIntoContext) IsReturnIntoContext() {}

func NewReturnIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnIntoContext {
	var p = new(ReturnIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_returnInto

	return p
}

func (s *ReturnIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnIntoContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *ReturnIntoContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReturnIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReturnIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReturnInto(s)
	}
}

func (s *ReturnIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReturnInto(s)
	}
}

func (s *ReturnIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReturnInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReturnInto() (localctx IReturnIntoContext) {
	this := p
	_ = this

	localctx = NewReturnIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 856, Cobol85ParserRULE_returnInto)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4967)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(4968)
		p.QualifiedDataName()
	}

	return localctx
}

// IRewriteStatementContext is an interface to support dynamic dispatch.
type IRewriteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRewriteStatementContext differentiates from other interfaces.
	IsRewriteStatementContext()
}

type RewriteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteStatementContext() *RewriteStatementContext {
	var p = new(RewriteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rewriteStatement
	return p
}

func (*RewriteStatementContext) IsRewriteStatementContext() {}

func NewRewriteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteStatementContext {
	var p = new(RewriteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rewriteStatement

	return p
}

func (s *RewriteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteStatementContext) REWRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWRITE, 0)
}

func (s *RewriteStatementContext) RecordName() IRecordNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *RewriteStatementContext) RewriteFrom() IRewriteFromContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRewriteFromContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRewriteFromContext)
}

func (s *RewriteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *RewriteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *RewriteStatementContext) END_REWRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_REWRITE, 0)
}

func (s *RewriteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RewriteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRewriteStatement(s)
	}
}

func (s *RewriteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRewriteStatement(s)
	}
}

func (s *RewriteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRewriteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RewriteStatement() (localctx IRewriteStatementContext) {
	this := p
	_ = this

	localctx = NewRewriteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 858, Cobol85ParserRULE_rewriteStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4970)
		p.Match(Cobol85ParserREWRITE)
	}
	{
		p.SetState(4971)
		p.RecordName()
	}
	p.SetState(4973)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(4972)
			p.RewriteFrom()
		}

	}
	p.SetState(4976)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 739, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4975)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(4979)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 740, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4978)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(4982)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 741, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4981)
			p.Match(Cobol85ParserEND_REWRITE)
		}

	}

	return localctx
}

// IRewriteFromContext is an interface to support dynamic dispatch.
type IRewriteFromContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRewriteFromContext differentiates from other interfaces.
	IsRewriteFromContext()
}

type RewriteFromContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRewriteFromContext() *RewriteFromContext {
	var p = new(RewriteFromContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_rewriteFrom
	return p
}

func (*RewriteFromContext) IsRewriteFromContext() {}

func NewRewriteFromContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RewriteFromContext {
	var p = new(RewriteFromContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_rewriteFrom

	return p
}

func (s *RewriteFromContext) GetParser() antlr.Parser { return s.parser }

func (s *RewriteFromContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *RewriteFromContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *RewriteFromContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RewriteFromContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RewriteFromContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRewriteFrom(s)
	}
}

func (s *RewriteFromContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRewriteFrom(s)
	}
}

func (s *RewriteFromContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRewriteFrom(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RewriteFrom() (localctx IRewriteFromContext) {
	this := p
	_ = this

	localctx = NewRewriteFromContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 860, Cobol85ParserRULE_rewriteFrom)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4984)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(4985)
		p.Identifier()
	}

	return localctx
}

// ISearchStatementContext is an interface to support dynamic dispatch.
type ISearchStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchStatementContext differentiates from other interfaces.
	IsSearchStatementContext()
}

type SearchStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchStatementContext() *SearchStatementContext {
	var p = new(SearchStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchStatement
	return p
}

func (*SearchStatementContext) IsSearchStatementContext() {}

func NewSearchStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchStatementContext {
	var p = new(SearchStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchStatement

	return p
}

func (s *SearchStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchStatementContext) SEARCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEARCH, 0)
}

func (s *SearchStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SearchStatementContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *SearchStatementContext) SearchVarying() ISearchVaryingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchVaryingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchVaryingContext)
}

func (s *SearchStatementContext) AtEndPhrase() IAtEndPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAtEndPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAtEndPhraseContext)
}

func (s *SearchStatementContext) AllSearchWhen() []ISearchWhenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISearchWhenContext); ok {
			len++
		}
	}

	tst := make([]ISearchWhenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISearchWhenContext); ok {
			tst[i] = t.(ISearchWhenContext)
			i++
		}
	}

	return tst
}

func (s *SearchStatementContext) SearchWhen(i int) ISearchWhenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchWhenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchWhenContext)
}

func (s *SearchStatementContext) END_SEARCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_SEARCH, 0)
}

func (s *SearchStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchStatement(s)
	}
}

func (s *SearchStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchStatement(s)
	}
}

func (s *SearchStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSearchStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SearchStatement() (localctx ISearchStatementContext) {
	this := p
	_ = this

	localctx = NewSearchStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 862, Cobol85ParserRULE_searchStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4987)
		p.Match(Cobol85ParserSEARCH)
	}
	p.SetState(4989)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserALL {
		{
			p.SetState(4988)
			p.Match(Cobol85ParserALL)
		}

	}
	{
		p.SetState(4991)
		p.QualifiedDataName()
	}
	p.SetState(4993)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserVARYING {
		{
			p.SetState(4992)
			p.SearchVarying()
		}

	}
	p.SetState(4996)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT || _la == Cobol85ParserEND {
		{
			p.SetState(4995)
			p.AtEndPhrase()
		}

	}
	p.SetState(4999)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(4998)
				p.SearchWhen()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5001)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 745, p.GetParserRuleContext())
	}
	p.SetState(5004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 746, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5003)
			p.Match(Cobol85ParserEND_SEARCH)
		}

	}

	return localctx
}

// ISearchVaryingContext is an interface to support dynamic dispatch.
type ISearchVaryingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchVaryingContext differentiates from other interfaces.
	IsSearchVaryingContext()
}

type SearchVaryingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchVaryingContext() *SearchVaryingContext {
	var p = new(SearchVaryingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchVarying
	return p
}

func (*SearchVaryingContext) IsSearchVaryingContext() {}

func NewSearchVaryingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchVaryingContext {
	var p = new(SearchVaryingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchVarying

	return p
}

func (s *SearchVaryingContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchVaryingContext) VARYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVARYING, 0)
}

func (s *SearchVaryingContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SearchVaryingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchVaryingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchVaryingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchVarying(s)
	}
}

func (s *SearchVaryingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchVarying(s)
	}
}

func (s *SearchVaryingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSearchVarying(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SearchVarying() (localctx ISearchVaryingContext) {
	this := p
	_ = this

	localctx = NewSearchVaryingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 864, Cobol85ParserRULE_searchVarying)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5006)
		p.Match(Cobol85ParserVARYING)
	}
	{
		p.SetState(5007)
		p.QualifiedDataName()
	}

	return localctx
}

// ISearchWhenContext is an interface to support dynamic dispatch.
type ISearchWhenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSearchWhenContext differentiates from other interfaces.
	IsSearchWhenContext()
}

type SearchWhenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchWhenContext() *SearchWhenContext {
	var p = new(SearchWhenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_searchWhen
	return p
}

func (*SearchWhenContext) IsSearchWhenContext() {}

func NewSearchWhenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchWhenContext {
	var p = new(SearchWhenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_searchWhen

	return p
}

func (s *SearchWhenContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchWhenContext) WHEN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN, 0)
}

func (s *SearchWhenContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SearchWhenContext) NEXT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEXT, 0)
}

func (s *SearchWhenContext) SENTENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSENTENCE, 0)
}

func (s *SearchWhenContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *SearchWhenContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *SearchWhenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchWhenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchWhenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSearchWhen(s)
	}
}

func (s *SearchWhenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSearchWhen(s)
	}
}

func (s *SearchWhenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSearchWhen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SearchWhen() (localctx ISearchWhenContext) {
	this := p
	_ = this

	localctx = NewSearchWhenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 866, Cobol85ParserRULE_searchWhen)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5009)
		p.Match(Cobol85ParserWHEN)
	}
	{
		p.SetState(5010)
		p.Condition()
	}
	p.SetState(5019)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNEXT:
		{
			p.SetState(5011)
			p.Match(Cobol85ParserNEXT)
		}
		{
			p.SetState(5012)
			p.Match(Cobol85ParserSENTENCE)
		}

	case Cobol85ParserACCEPT, Cobol85ParserADD, Cobol85ParserALTER, Cobol85ParserAT, Cobol85ParserCALL, Cobol85ParserCANCEL, Cobol85ParserCLOSE, Cobol85ParserCOMPUTE, Cobol85ParserCONTINUE, Cobol85ParserDELETE, Cobol85ParserDISABLE, Cobol85ParserDISPLAY, Cobol85ParserDIVIDE, Cobol85ParserELSE, Cobol85ParserENABLE, Cobol85ParserEND, Cobol85ParserEND_ACCEPT, Cobol85ParserEND_ADD, Cobol85ParserEND_CALL, Cobol85ParserEND_COMPUTE, Cobol85ParserEND_DELETE, Cobol85ParserEND_DIVIDE, Cobol85ParserEND_EVALUATE, Cobol85ParserEND_IF, Cobol85ParserEND_MULTIPLY, Cobol85ParserEND_PERFORM, Cobol85ParserEND_READ, Cobol85ParserEND_RECEIVE, Cobol85ParserEND_RETURN, Cobol85ParserEND_REWRITE, Cobol85ParserEND_SEARCH, Cobol85ParserEND_START, Cobol85ParserEND_STRING, Cobol85ParserEND_SUBTRACT, Cobol85ParserEND_UNSTRING, Cobol85ParserEND_WRITE, Cobol85ParserENTRY, Cobol85ParserEVALUATE, Cobol85ParserEXCEPTION, Cobol85ParserEXHIBIT, Cobol85ParserEXIT, Cobol85ParserGENERATE, Cobol85ParserGOBACK, Cobol85ParserGO, Cobol85ParserIF, Cobol85ParserINITIALIZE, Cobol85ParserINITIATE, Cobol85ParserINSPECT, Cobol85ParserINVALID, Cobol85ParserMERGE, Cobol85ParserMOVE, Cobol85ParserMULTIPLY, Cobol85ParserNOT, Cobol85ParserON, Cobol85ParserOPEN, Cobol85ParserPERFORM, Cobol85ParserPURGE, Cobol85ParserREAD, Cobol85ParserRECEIVE, Cobol85ParserRELEASE, Cobol85ParserRETURN, Cobol85ParserREWRITE, Cobol85ParserSEARCH, Cobol85ParserSEND, Cobol85ParserSET, Cobol85ParserSORT, Cobol85ParserSTART, Cobol85ParserSTOP, Cobol85ParserSTRING, Cobol85ParserSUBTRACT, Cobol85ParserTERMINATE, Cobol85ParserUNSTRING, Cobol85ParserWHEN, Cobol85ParserWITH, Cobol85ParserWRITE, Cobol85ParserDOT_FS, Cobol85ParserEXECCICSLINE, Cobol85ParserEXECSQLIMSLINE, Cobol85ParserEXECSQLLINE:
		p.SetState(5016)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5013)
					p.Statement()
				}

			}
			p.SetState(5018)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 747, p.GetParserRuleContext())
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISendStatementContext is an interface to support dynamic dispatch.
type ISendStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementContext differentiates from other interfaces.
	IsSendStatementContext()
}

type SendStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementContext() *SendStatementContext {
	var p = new(SendStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatement
	return p
}

func (*SendStatementContext) IsSendStatementContext() {}

func NewSendStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementContext {
	var p = new(SendStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatement

	return p
}

func (s *SendStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementContext) SEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEND, 0)
}

func (s *SendStatementContext) SendStatementSync() ISendStatementSyncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStatementSyncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStatementSyncContext)
}

func (s *SendStatementContext) SendStatementAsync() ISendStatementAsyncContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendStatementAsyncContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendStatementAsyncContext)
}

func (s *SendStatementContext) OnExceptionClause() IOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnExceptionClauseContext)
}

func (s *SendStatementContext) NotOnExceptionClause() INotOnExceptionClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnExceptionClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnExceptionClauseContext)
}

func (s *SendStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatement(s)
	}
}

func (s *SendStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatement(s)
	}
}

func (s *SendStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendStatement() (localctx ISendStatementContext) {
	this := p
	_ = this

	localctx = NewSendStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 868, Cobol85ParserRULE_sendStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5021)
		p.Match(Cobol85ParserSEND)
	}
	p.SetState(5024)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserALL, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFALSE, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNULL_, Cobol85ParserNULLS, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUE, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO, Cobol85ParserZERO_FILL, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5022)
			p.SendStatementSync()
		}

	case Cobol85ParserTO:
		{
			p.SetState(5023)
			p.SendStatementAsync()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	p.SetState(5027)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 750, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5026)
			p.OnExceptionClause()
		}

	}
	p.SetState(5030)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 751, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5029)
			p.NotOnExceptionClause()
		}

	}

	return localctx
}

// ISendStatementSyncContext is an interface to support dynamic dispatch.
type ISendStatementSyncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementSyncContext differentiates from other interfaces.
	IsSendStatementSyncContext()
}

type SendStatementSyncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementSyncContext() *SendStatementSyncContext {
	var p = new(SendStatementSyncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatementSync
	return p
}

func (*SendStatementSyncContext) IsSendStatementSyncContext() {}

func NewSendStatementSyncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementSyncContext {
	var p = new(SendStatementSyncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatementSync

	return p
}

func (s *SendStatementSyncContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementSyncContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendStatementSyncContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SendStatementSyncContext) SendFromPhrase() ISendFromPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendFromPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendFromPhraseContext)
}

func (s *SendStatementSyncContext) SendWithPhrase() ISendWithPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendWithPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendWithPhraseContext)
}

func (s *SendStatementSyncContext) SendReplacingPhrase() ISendReplacingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendReplacingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendReplacingPhraseContext)
}

func (s *SendStatementSyncContext) SendAdvancingPhrase() ISendAdvancingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendAdvancingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingPhraseContext)
}

func (s *SendStatementSyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementSyncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementSyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatementSync(s)
	}
}

func (s *SendStatementSyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatementSync(s)
	}
}

func (s *SendStatementSyncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendStatementSync(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendStatementSync() (localctx ISendStatementSyncContext) {
	this := p
	_ = this

	localctx = NewSendStatementSyncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 870, Cobol85ParserRULE_sendStatementSync)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5034)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 752, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5032)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5033)
			p.Literal()
		}

	}
	p.SetState(5037)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(5036)
			p.SendFromPhrase()
		}

	}
	p.SetState(5040)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 754, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5039)
			p.SendWithPhrase()
		}

	}
	p.SetState(5043)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserREPLACING {
		{
			p.SetState(5042)
			p.SendReplacingPhrase()
		}

	}
	p.SetState(5046)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(5045)
			p.SendAdvancingPhrase()
		}

	}

	return localctx
}

// ISendStatementAsyncContext is an interface to support dynamic dispatch.
type ISendStatementAsyncContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendStatementAsyncContext differentiates from other interfaces.
	IsSendStatementAsyncContext()
}

type SendStatementAsyncContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendStatementAsyncContext() *SendStatementAsyncContext {
	var p = new(SendStatementAsyncContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendStatementAsync
	return p
}

func (*SendStatementAsyncContext) IsSendStatementAsyncContext() {}

func NewSendStatementAsyncContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendStatementAsyncContext {
	var p = new(SendStatementAsyncContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendStatementAsync

	return p
}

func (s *SendStatementAsyncContext) GetParser() antlr.Parser { return s.parser }

func (s *SendStatementAsyncContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *SendStatementAsyncContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendStatementAsyncContext) TOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTOP, 0)
}

func (s *SendStatementAsyncContext) BOTTOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOTTOM, 0)
}

func (s *SendStatementAsyncContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendStatementAsyncContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendStatementAsyncContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendStatementAsync(s)
	}
}

func (s *SendStatementAsyncContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendStatementAsync(s)
	}
}

func (s *SendStatementAsyncContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendStatementAsync(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendStatementAsync() (localctx ISendStatementAsyncContext) {
	this := p
	_ = this

	localctx = NewSendStatementAsyncContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 872, Cobol85ParserRULE_sendStatementAsync)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5048)
		p.Match(Cobol85ParserTO)
	}
	{
		p.SetState(5049)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserBOTTOM || _la == Cobol85ParserTOP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5050)
		p.Identifier()
	}

	return localctx
}

// ISendFromPhraseContext is an interface to support dynamic dispatch.
type ISendFromPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendFromPhraseContext differentiates from other interfaces.
	IsSendFromPhraseContext()
}

type SendFromPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendFromPhraseContext() *SendFromPhraseContext {
	var p = new(SendFromPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendFromPhrase
	return p
}

func (*SendFromPhraseContext) IsSendFromPhraseContext() {}

func NewSendFromPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendFromPhraseContext {
	var p = new(SendFromPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendFromPhrase

	return p
}

func (s *SendFromPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendFromPhraseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SendFromPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendFromPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendFromPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendFromPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendFromPhrase(s)
	}
}

func (s *SendFromPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendFromPhrase(s)
	}
}

func (s *SendFromPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendFromPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendFromPhrase() (localctx ISendFromPhraseContext) {
	this := p
	_ = this

	localctx = NewSendFromPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 874, Cobol85ParserRULE_sendFromPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5052)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5053)
		p.Identifier()
	}

	return localctx
}

// ISendWithPhraseContext is an interface to support dynamic dispatch.
type ISendWithPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendWithPhraseContext differentiates from other interfaces.
	IsSendWithPhraseContext()
}

type SendWithPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendWithPhraseContext() *SendWithPhraseContext {
	var p = new(SendWithPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendWithPhrase
	return p
}

func (*SendWithPhraseContext) IsSendWithPhraseContext() {}

func NewSendWithPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendWithPhraseContext {
	var p = new(SendWithPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendWithPhrase

	return p
}

func (s *SendWithPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendWithPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SendWithPhraseContext) EGI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEGI, 0)
}

func (s *SendWithPhraseContext) EMI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMI, 0)
}

func (s *SendWithPhraseContext) ESI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESI, 0)
}

func (s *SendWithPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendWithPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendWithPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendWithPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendWithPhrase(s)
	}
}

func (s *SendWithPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendWithPhrase(s)
	}
}

func (s *SendWithPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendWithPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendWithPhrase() (localctx ISendWithPhraseContext) {
	this := p
	_ = this

	localctx = NewSendWithPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 876, Cobol85ParserRULE_sendWithPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5055)
		p.Match(Cobol85ParserWITH)
	}
	p.SetState(5060)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserEGI:
		{
			p.SetState(5056)
			p.Match(Cobol85ParserEGI)
		}

	case Cobol85ParserEMI:
		{
			p.SetState(5057)
			p.Match(Cobol85ParserEMI)
		}

	case Cobol85ParserESI:
		{
			p.SetState(5058)
			p.Match(Cobol85ParserESI)
		}

	case Cobol85ParserABORT, Cobol85ParserADDRESS, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDATE, Cobol85ParserDAY, Cobol85ParserDAY_OF_WEEK, Cobol85ParserDEBUG_CONTENTS, Cobol85ParserDEBUG_ITEM, Cobol85ParserDEBUG_LINE, Cobol85ParserDEBUG_NAME, Cobol85ParserDEBUG_SUB_1, Cobol85ParserDEBUG_SUB_2, Cobol85ParserDEBUG_SUB_3, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTION, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLINAGE_COUNTER, Cobol85ParserLINE_COUNTER, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPAGE_COUNTER, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserRETURN_CODE, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHIFT_IN, Cobol85ParserSHIFT_OUT, Cobol85ParserSHORT_DATE, Cobol85ParserSORT_CONTROL, Cobol85ParserSORT_CORE_SIZE, Cobol85ParserSORT_FILE_SIZE, Cobol85ParserSORT_MESSAGE, Cobol85ParserSORT_MODE_SIZE, Cobol85ParserSORT_RETURN, Cobol85ParserSYMBOL, Cobol85ParserTALLY, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIME, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserWHEN_COMPILED, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5059)
			p.Identifier()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISendReplacingPhraseContext is an interface to support dynamic dispatch.
type ISendReplacingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendReplacingPhraseContext differentiates from other interfaces.
	IsSendReplacingPhraseContext()
}

type SendReplacingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendReplacingPhraseContext() *SendReplacingPhraseContext {
	var p = new(SendReplacingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendReplacingPhrase
	return p
}

func (*SendReplacingPhraseContext) IsSendReplacingPhraseContext() {}

func NewSendReplacingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendReplacingPhraseContext {
	var p = new(SendReplacingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendReplacingPhrase

	return p
}

func (s *SendReplacingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendReplacingPhraseContext) REPLACING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREPLACING, 0)
}

func (s *SendReplacingPhraseContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *SendReplacingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendReplacingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendReplacingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendReplacingPhrase(s)
	}
}

func (s *SendReplacingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendReplacingPhrase(s)
	}
}

func (s *SendReplacingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendReplacingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendReplacingPhrase() (localctx ISendReplacingPhraseContext) {
	this := p
	_ = this

	localctx = NewSendReplacingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 878, Cobol85ParserRULE_sendReplacingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5062)
		p.Match(Cobol85ParserREPLACING)
	}
	p.SetState(5064)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE {
		{
			p.SetState(5063)
			p.Match(Cobol85ParserLINE)
		}

	}

	return localctx
}

// ISendAdvancingPhraseContext is an interface to support dynamic dispatch.
type ISendAdvancingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingPhraseContext differentiates from other interfaces.
	IsSendAdvancingPhraseContext()
}

type SendAdvancingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingPhraseContext() *SendAdvancingPhraseContext {
	var p = new(SendAdvancingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPhrase
	return p
}

func (*SendAdvancingPhraseContext) IsSendAdvancingPhraseContext() {}

func NewSendAdvancingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingPhraseContext {
	var p = new(SendAdvancingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPhrase

	return p
}

func (s *SendAdvancingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingPhraseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *SendAdvancingPhraseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *SendAdvancingPhraseContext) SendAdvancingPage() ISendAdvancingPageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendAdvancingPageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingPageContext)
}

func (s *SendAdvancingPhraseContext) SendAdvancingLines() ISendAdvancingLinesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendAdvancingLinesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingLinesContext)
}

func (s *SendAdvancingPhraseContext) SendAdvancingMnemonic() ISendAdvancingMnemonicContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISendAdvancingMnemonicContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISendAdvancingMnemonicContext)
}

func (s *SendAdvancingPhraseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *SendAdvancingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingPhrase(s)
	}
}

func (s *SendAdvancingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingPhrase(s)
	}
}

func (s *SendAdvancingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingPhrase() (localctx ISendAdvancingPhraseContext) {
	this := p
	_ = this

	localctx = NewSendAdvancingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 880, Cobol85ParserRULE_sendAdvancingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5066)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5068)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserADVANCING {
		{
			p.SetState(5067)
			p.Match(Cobol85ParserADVANCING)
		}

	}
	p.SetState(5073)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 760, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5070)
			p.SendAdvancingPage()
		}

	case 2:
		{
			p.SetState(5071)
			p.SendAdvancingLines()
		}

	case 3:
		{
			p.SetState(5072)
			p.SendAdvancingMnemonic()
		}

	}

	return localctx
}

// ISendAdvancingPageContext is an interface to support dynamic dispatch.
type ISendAdvancingPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingPageContext differentiates from other interfaces.
	IsSendAdvancingPageContext()
}

type SendAdvancingPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingPageContext() *SendAdvancingPageContext {
	var p = new(SendAdvancingPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPage
	return p
}

func (*SendAdvancingPageContext) IsSendAdvancingPageContext() {}

func NewSendAdvancingPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingPageContext {
	var p = new(SendAdvancingPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingPage

	return p
}

func (s *SendAdvancingPageContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *SendAdvancingPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingPage(s)
	}
}

func (s *SendAdvancingPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingPage(s)
	}
}

func (s *SendAdvancingPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingPage() (localctx ISendAdvancingPageContext) {
	this := p
	_ = this

	localctx = NewSendAdvancingPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 882, Cobol85ParserRULE_sendAdvancingPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5075)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// ISendAdvancingLinesContext is an interface to support dynamic dispatch.
type ISendAdvancingLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingLinesContext differentiates from other interfaces.
	IsSendAdvancingLinesContext()
}

type SendAdvancingLinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingLinesContext() *SendAdvancingLinesContext {
	var p = new(SendAdvancingLinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingLines
	return p
}

func (*SendAdvancingLinesContext) IsSendAdvancingLinesContext() {}

func NewSendAdvancingLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingLinesContext {
	var p = new(SendAdvancingLinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingLines

	return p
}

func (s *SendAdvancingLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingLinesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SendAdvancingLinesContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SendAdvancingLinesContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *SendAdvancingLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *SendAdvancingLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingLines(s)
	}
}

func (s *SendAdvancingLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingLines(s)
	}
}

func (s *SendAdvancingLinesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingLines(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingLines() (localctx ISendAdvancingLinesContext) {
	this := p
	_ = this

	localctx = NewSendAdvancingLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 884, Cobol85ParserRULE_sendAdvancingLines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5079)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 761, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5077)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5078)
			p.Literal()
		}

	}
	p.SetState(5082)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		{
			p.SetState(5081)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// ISendAdvancingMnemonicContext is an interface to support dynamic dispatch.
type ISendAdvancingMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSendAdvancingMnemonicContext differentiates from other interfaces.
	IsSendAdvancingMnemonicContext()
}

type SendAdvancingMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySendAdvancingMnemonicContext() *SendAdvancingMnemonicContext {
	var p = new(SendAdvancingMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingMnemonic
	return p
}

func (*SendAdvancingMnemonicContext) IsSendAdvancingMnemonicContext() {}

func NewSendAdvancingMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SendAdvancingMnemonicContext {
	var p = new(SendAdvancingMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sendAdvancingMnemonic

	return p
}

func (s *SendAdvancingMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *SendAdvancingMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *SendAdvancingMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SendAdvancingMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SendAdvancingMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSendAdvancingMnemonic(s)
	}
}

func (s *SendAdvancingMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSendAdvancingMnemonic(s)
	}
}

func (s *SendAdvancingMnemonicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSendAdvancingMnemonic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SendAdvancingMnemonic() (localctx ISendAdvancingMnemonicContext) {
	this := p
	_ = this

	localctx = NewSendAdvancingMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 886, Cobol85ParserRULE_sendAdvancingMnemonic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5084)
		p.MnemonicName()
	}

	return localctx
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setStatement
	return p
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSET, 0)
}

func (s *SetStatementContext) SetUpDownByStatement() ISetUpDownByStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetUpDownByStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetUpDownByStatementContext)
}

func (s *SetStatementContext) AllSetToStatement() []ISetToStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetToStatementContext); ok {
			len++
		}
	}

	tst := make([]ISetToStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetToStatementContext); ok {
			tst[i] = t.(ISetToStatementContext)
			i++
		}
	}

	return tst
}

func (s *SetStatementContext) SetToStatement(i int) ISetToStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetToStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetToStatementContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetStatement() (localctx ISetStatementContext) {
	this := p
	_ = this

	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 888, Cobol85ParserRULE_setStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5086)
		p.Match(Cobol85ParserSET)
	}
	p.SetState(5093)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 764, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5088)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
			{
				p.SetState(5087)
				p.SetToStatement()
			}

			p.SetState(5090)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		{
			p.SetState(5092)
			p.SetUpDownByStatement()
		}

	}

	return localctx
}

// ISetToStatementContext is an interface to support dynamic dispatch.
type ISetToStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToStatementContext differentiates from other interfaces.
	IsSetToStatementContext()
}

type SetToStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToStatementContext() *SetToStatementContext {
	var p = new(SetToStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setToStatement
	return p
}

func (*SetToStatementContext) IsSetToStatementContext() {}

func NewSetToStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToStatementContext {
	var p = new(SetToStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setToStatement

	return p
}

func (s *SetToStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToStatementContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *SetToStatementContext) AllSetTo() []ISetToContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetToContext); ok {
			len++
		}
	}

	tst := make([]ISetToContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetToContext); ok {
			tst[i] = t.(ISetToContext)
			i++
		}
	}

	return tst
}

func (s *SetToStatementContext) SetTo(i int) ISetToContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetToContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetToContext)
}

func (s *SetToStatementContext) AllSetToValue() []ISetToValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetToValueContext); ok {
			len++
		}
	}

	tst := make([]ISetToValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetToValueContext); ok {
			tst[i] = t.(ISetToValueContext)
			i++
		}
	}

	return tst
}

func (s *SetToStatementContext) SetToValue(i int) ISetToValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetToValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetToValueContext)
}

func (s *SetToStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetToStatement(s)
	}
}

func (s *SetToStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetToStatement(s)
	}
}

func (s *SetToStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetToStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetToStatement() (localctx ISetToStatementContext) {
	this := p
	_ = this

	localctx = NewSetToStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 890, Cobol85ParserRULE_setToStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5096)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5095)
			p.SetTo()
		}

		p.SetState(5098)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5100)
		p.Match(Cobol85ParserTO)
	}
	p.SetState(5102)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5101)
				p.SetToValue()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5104)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 766, p.GetParserRuleContext())
	}

	return localctx
}

// ISetUpDownByStatementContext is an interface to support dynamic dispatch.
type ISetUpDownByStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetUpDownByStatementContext differentiates from other interfaces.
	IsSetUpDownByStatementContext()
}

type SetUpDownByStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetUpDownByStatementContext() *SetUpDownByStatementContext {
	var p = new(SetUpDownByStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setUpDownByStatement
	return p
}

func (*SetUpDownByStatementContext) IsSetUpDownByStatementContext() {}

func NewSetUpDownByStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetUpDownByStatementContext {
	var p = new(SetUpDownByStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setUpDownByStatement

	return p
}

func (s *SetUpDownByStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetUpDownByStatementContext) SetByValue() ISetByValueContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetByValueContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetByValueContext)
}

func (s *SetUpDownByStatementContext) UP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUP, 0)
}

func (s *SetUpDownByStatementContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *SetUpDownByStatementContext) DOWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOWN, 0)
}

func (s *SetUpDownByStatementContext) AllSetTo() []ISetToContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetToContext); ok {
			len++
		}
	}

	tst := make([]ISetToContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetToContext); ok {
			tst[i] = t.(ISetToContext)
			i++
		}
	}

	return tst
}

func (s *SetUpDownByStatementContext) SetTo(i int) ISetToContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetToContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetToContext)
}

func (s *SetUpDownByStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetUpDownByStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetUpDownByStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetUpDownByStatement(s)
	}
}

func (s *SetUpDownByStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetUpDownByStatement(s)
	}
}

func (s *SetUpDownByStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetUpDownByStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetUpDownByStatement() (localctx ISetUpDownByStatementContext) {
	this := p
	_ = this

	localctx = NewSetUpDownByStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 892, Cobol85ParserRULE_setUpDownByStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5107)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5106)
			p.SetTo()
		}

		p.SetState(5109)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5115)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserUP:
		{
			p.SetState(5111)
			p.Match(Cobol85ParserUP)
		}
		{
			p.SetState(5112)
			p.Match(Cobol85ParserBY)
		}

	case Cobol85ParserDOWN:
		{
			p.SetState(5113)
			p.Match(Cobol85ParserDOWN)
		}
		{
			p.SetState(5114)
			p.Match(Cobol85ParserBY)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}
	{
		p.SetState(5117)
		p.SetByValue()
	}

	return localctx
}

// ISetToContext is an interface to support dynamic dispatch.
type ISetToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToContext differentiates from other interfaces.
	IsSetToContext()
}

type SetToContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToContext() *SetToContext {
	var p = new(SetToContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setTo
	return p
}

func (*SetToContext) IsSetToContext() {}

func NewSetToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToContext {
	var p = new(SetToContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setTo

	return p
}

func (s *SetToContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetTo(s)
	}
}

func (s *SetToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetTo(s)
	}
}

func (s *SetToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetTo() (localctx ISetToContext) {
	this := p
	_ = this

	localctx = NewSetToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 894, Cobol85ParserRULE_setTo)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5119)
		p.Identifier()
	}

	return localctx
}

// ISetToValueContext is an interface to support dynamic dispatch.
type ISetToValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetToValueContext differentiates from other interfaces.
	IsSetToValueContext()
}

type SetToValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetToValueContext() *SetToValueContext {
	var p = new(SetToValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setToValue
	return p
}

func (*SetToValueContext) IsSetToValueContext() {}

func NewSetToValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetToValueContext {
	var p = new(SetToValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setToValue

	return p
}

func (s *SetToValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetToValueContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *SetToValueContext) OFF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOFF, 0)
}

func (s *SetToValueContext) ENTRY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY, 0)
}

func (s *SetToValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetToValueContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetToValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetToValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetToValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetToValue(s)
	}
}

func (s *SetToValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetToValue(s)
	}
}

func (s *SetToValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetToValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetToValue() (localctx ISetToValueContext) {
	this := p
	_ = this

	localctx = NewSetToValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 896, Cobol85ParserRULE_setToValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5130)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 770, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5121)
			p.Match(Cobol85ParserON)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5122)
			p.Match(Cobol85ParserOFF)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5123)
			p.Match(Cobol85ParserENTRY)
		}
		p.SetState(5126)
		p.GetErrorHandler().Sync(p)
		switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 769, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5124)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(5125)
				p.Literal()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5128)
			p.Identifier()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5129)
			p.Literal()
		}

	}

	return localctx
}

// ISetByValueContext is an interface to support dynamic dispatch.
type ISetByValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSetByValueContext differentiates from other interfaces.
	IsSetByValueContext()
}

type SetByValueContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetByValueContext() *SetByValueContext {
	var p = new(SetByValueContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_setByValue
	return p
}

func (*SetByValueContext) IsSetByValueContext() {}

func NewSetByValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetByValueContext {
	var p = new(SetByValueContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_setByValue

	return p
}

func (s *SetByValueContext) GetParser() antlr.Parser { return s.parser }

func (s *SetByValueContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetByValueContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SetByValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetByValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetByValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSetByValue(s)
	}
}

func (s *SetByValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSetByValue(s)
	}
}

func (s *SetByValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSetByValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SetByValue() (localctx ISetByValueContext) {
	this := p
	_ = this

	localctx = NewSetByValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 898, Cobol85ParserRULE_setByValue)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5134)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 771, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5132)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5133)
			p.Literal()
		}

	}

	return localctx
}

// ISortStatementContext is an interface to support dynamic dispatch.
type ISortStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortStatementContext differentiates from other interfaces.
	IsSortStatementContext()
}

type SortStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortStatementContext() *SortStatementContext {
	var p = new(SortStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortStatement
	return p
}

func (*SortStatementContext) IsSortStatementContext() {}

func NewSortStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortStatementContext {
	var p = new(SortStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortStatement

	return p
}

func (s *SortStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SortStatementContext) SORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT, 0)
}

func (s *SortStatementContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortStatementContext) AllSortOnKeyClause() []ISortOnKeyClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortOnKeyClauseContext); ok {
			len++
		}
	}

	tst := make([]ISortOnKeyClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortOnKeyClauseContext); ok {
			tst[i] = t.(ISortOnKeyClauseContext)
			i++
		}
	}

	return tst
}

func (s *SortStatementContext) SortOnKeyClause(i int) ISortOnKeyClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortOnKeyClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortOnKeyClauseContext)
}

func (s *SortStatementContext) SortDuplicatesPhrase() ISortDuplicatesPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortDuplicatesPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortDuplicatesPhraseContext)
}

func (s *SortStatementContext) SortCollatingSequencePhrase() ISortCollatingSequencePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortCollatingSequencePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortCollatingSequencePhraseContext)
}

func (s *SortStatementContext) SortInputProcedurePhrase() ISortInputProcedurePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortInputProcedurePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortInputProcedurePhraseContext)
}

func (s *SortStatementContext) AllSortUsing() []ISortUsingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortUsingContext); ok {
			len++
		}
	}

	tst := make([]ISortUsingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortUsingContext); ok {
			tst[i] = t.(ISortUsingContext)
			i++
		}
	}

	return tst
}

func (s *SortStatementContext) SortUsing(i int) ISortUsingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortUsingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortUsingContext)
}

func (s *SortStatementContext) SortOutputProcedurePhrase() ISortOutputProcedurePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortOutputProcedurePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortOutputProcedurePhraseContext)
}

func (s *SortStatementContext) AllSortGivingPhrase() []ISortGivingPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortGivingPhraseContext); ok {
			len++
		}
	}

	tst := make([]ISortGivingPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortGivingPhraseContext); ok {
			tst[i] = t.(ISortGivingPhraseContext)
			i++
		}
	}

	return tst
}

func (s *SortStatementContext) SortGivingPhrase(i int) ISortGivingPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortGivingPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortGivingPhraseContext)
}

func (s *SortStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortStatement(s)
	}
}

func (s *SortStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortStatement(s)
	}
}

func (s *SortStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortStatement() (localctx ISortStatementContext) {
	this := p
	_ = this

	localctx = NewSortStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 900, Cobol85ParserRULE_sortStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5136)
		p.Match(Cobol85ParserSORT)
	}
	{
		p.SetState(5137)
		p.FileName()
	}
	p.SetState(5139)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5138)
				p.SortOnKeyClause()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5141)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 772, p.GetParserRuleContext())
	}
	p.SetState(5144)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 773, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5143)
			p.SortDuplicatesPhrase()
		}

	}
	p.SetState(5147)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING || _la == Cobol85ParserSEQUENCE {
		{
			p.SetState(5146)
			p.SortCollatingSequencePhrase()
		}

	}
	p.SetState(5150)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserINPUT {
		{
			p.SetState(5149)
			p.SortInputProcedurePhrase()
		}

	}
	p.SetState(5155)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserUSING {
		{
			p.SetState(5152)
			p.SortUsing()
		}

		p.SetState(5157)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5159)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserOUTPUT {
		{
			p.SetState(5158)
			p.SortOutputProcedurePhrase()
		}

	}
	p.SetState(5164)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserGIVING {
		{
			p.SetState(5161)
			p.SortGivingPhrase()
		}

		p.SetState(5166)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortOnKeyClauseContext is an interface to support dynamic dispatch.
type ISortOnKeyClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOnKeyClauseContext differentiates from other interfaces.
	IsSortOnKeyClauseContext()
}

type SortOnKeyClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOnKeyClauseContext() *SortOnKeyClauseContext {
	var p = new(SortOnKeyClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOnKeyClause
	return p
}

func (*SortOnKeyClauseContext) IsSortOnKeyClauseContext() {}

func NewSortOnKeyClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOnKeyClauseContext {
	var p = new(SortOnKeyClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOnKeyClause

	return p
}

func (s *SortOnKeyClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOnKeyClauseContext) ASCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCENDING, 0)
}

func (s *SortOnKeyClauseContext) DESCENDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDESCENDING, 0)
}

func (s *SortOnKeyClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *SortOnKeyClauseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *SortOnKeyClauseContext) AllQualifiedDataName() []IQualifiedDataNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedDataNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedDataNameContext); ok {
			tst[i] = t.(IQualifiedDataNameContext)
			i++
		}
	}

	return tst
}

func (s *SortOnKeyClauseContext) QualifiedDataName(i int) IQualifiedDataNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SortOnKeyClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOnKeyClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOnKeyClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOnKeyClause(s)
	}
}

func (s *SortOnKeyClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOnKeyClause(s)
	}
}

func (s *SortOnKeyClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortOnKeyClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortOnKeyClause() (localctx ISortOnKeyClauseContext) {
	this := p
	_ = this

	localctx = NewSortOnKeyClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 902, Cobol85ParserRULE_sortOnKeyClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5168)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5167)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5170)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASCENDING || _la == Cobol85ParserDESCENDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5172)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5171)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5175)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178969483) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5174)
			p.QualifiedDataName()
		}

		p.SetState(5177)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortDuplicatesPhraseContext is an interface to support dynamic dispatch.
type ISortDuplicatesPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortDuplicatesPhraseContext differentiates from other interfaces.
	IsSortDuplicatesPhraseContext()
}

type SortDuplicatesPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortDuplicatesPhraseContext() *SortDuplicatesPhraseContext {
	var p = new(SortDuplicatesPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortDuplicatesPhrase
	return p
}

func (*SortDuplicatesPhraseContext) IsSortDuplicatesPhraseContext() {}

func NewSortDuplicatesPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortDuplicatesPhraseContext {
	var p = new(SortDuplicatesPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortDuplicatesPhrase

	return p
}

func (s *SortDuplicatesPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortDuplicatesPhraseContext) DUPLICATES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDUPLICATES, 0)
}

func (s *SortDuplicatesPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SortDuplicatesPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *SortDuplicatesPhraseContext) ORDER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDER, 0)
}

func (s *SortDuplicatesPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortDuplicatesPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortDuplicatesPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortDuplicatesPhrase(s)
	}
}

func (s *SortDuplicatesPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortDuplicatesPhrase(s)
	}
}

func (s *SortDuplicatesPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortDuplicatesPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortDuplicatesPhrase() (localctx ISortDuplicatesPhraseContext) {
	this := p
	_ = this

	localctx = NewSortDuplicatesPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 904, Cobol85ParserRULE_sortDuplicatesPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5180)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5179)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5182)
		p.Match(Cobol85ParserDUPLICATES)
	}
	p.SetState(5184)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5183)
			p.Match(Cobol85ParserIN)
		}

	}
	p.SetState(5187)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserORDER {
		{
			p.SetState(5186)
			p.Match(Cobol85ParserORDER)
		}

	}

	return localctx
}

// ISortCollatingSequencePhraseContext is an interface to support dynamic dispatch.
type ISortCollatingSequencePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingSequencePhraseContext differentiates from other interfaces.
	IsSortCollatingSequencePhraseContext()
}

type SortCollatingSequencePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingSequencePhraseContext() *SortCollatingSequencePhraseContext {
	var p = new(SortCollatingSequencePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingSequencePhrase
	return p
}

func (*SortCollatingSequencePhraseContext) IsSortCollatingSequencePhraseContext() {}

func NewSortCollatingSequencePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingSequencePhraseContext {
	var p = new(SortCollatingSequencePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingSequencePhrase

	return p
}

func (s *SortCollatingSequencePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingSequencePhraseContext) SEQUENCE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSEQUENCE, 0)
}

func (s *SortCollatingSequencePhraseContext) COLLATING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLLATING, 0)
}

func (s *SortCollatingSequencePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingSequencePhraseContext) AllAlphabetName() []IAlphabetNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			len++
		}
	}

	tst := make([]IAlphabetNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlphabetNameContext); ok {
			tst[i] = t.(IAlphabetNameContext)
			i++
		}
	}

	return tst
}

func (s *SortCollatingSequencePhraseContext) AlphabetName(i int) IAlphabetNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingSequencePhraseContext) SortCollatingAlphanumeric() ISortCollatingAlphanumericContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortCollatingAlphanumericContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortCollatingAlphanumericContext)
}

func (s *SortCollatingSequencePhraseContext) SortCollatingNational() ISortCollatingNationalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortCollatingNationalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortCollatingNationalContext)
}

func (s *SortCollatingSequencePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingSequencePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingSequencePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingSequencePhrase(s)
	}
}

func (s *SortCollatingSequencePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingSequencePhrase(s)
	}
}

func (s *SortCollatingSequencePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortCollatingSequencePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortCollatingSequencePhrase() (localctx ISortCollatingSequencePhraseContext) {
	this := p
	_ = this

	localctx = NewSortCollatingSequencePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 906, Cobol85ParserRULE_sortCollatingSequencePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5190)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOLLATING {
		{
			p.SetState(5189)
			p.Match(Cobol85ParserCOLLATING)
		}

	}
	{
		p.SetState(5192)
		p.Match(Cobol85ParserSEQUENCE)
	}
	p.SetState(5194)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5193)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5197)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(5196)
				p.AlphabetName()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(5199)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 787, p.GetParserRuleContext())
	}
	p.SetState(5202)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 788, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5201)
			p.SortCollatingAlphanumeric()
		}

	}
	p.SetState(5205)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR || _la == Cobol85ParserNATIONAL {
		{
			p.SetState(5204)
			p.SortCollatingNational()
		}

	}

	return localctx
}

// ISortCollatingAlphanumericContext is an interface to support dynamic dispatch.
type ISortCollatingAlphanumericContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingAlphanumericContext differentiates from other interfaces.
	IsSortCollatingAlphanumericContext()
}

type SortCollatingAlphanumericContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingAlphanumericContext() *SortCollatingAlphanumericContext {
	var p = new(SortCollatingAlphanumericContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingAlphanumeric
	return p
}

func (*SortCollatingAlphanumericContext) IsSortCollatingAlphanumericContext() {}

func NewSortCollatingAlphanumericContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingAlphanumericContext {
	var p = new(SortCollatingAlphanumericContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingAlphanumeric

	return p
}

func (s *SortCollatingAlphanumericContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingAlphanumericContext) ALPHANUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHANUMERIC, 0)
}

func (s *SortCollatingAlphanumericContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingAlphanumericContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingAlphanumericContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SortCollatingAlphanumericContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingAlphanumericContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingAlphanumericContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingAlphanumeric(s)
	}
}

func (s *SortCollatingAlphanumericContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingAlphanumeric(s)
	}
}

func (s *SortCollatingAlphanumericContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortCollatingAlphanumeric(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortCollatingAlphanumeric() (localctx ISortCollatingAlphanumericContext) {
	this := p
	_ = this

	localctx = NewSortCollatingAlphanumericContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 908, Cobol85ParserRULE_sortCollatingAlphanumeric)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5208)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5207)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5210)
		p.Match(Cobol85ParserALPHANUMERIC)
	}
	{
		p.SetState(5211)
		p.Match(Cobol85ParserIS)
	}
	{
		p.SetState(5212)
		p.AlphabetName()
	}

	return localctx
}

// ISortCollatingNationalContext is an interface to support dynamic dispatch.
type ISortCollatingNationalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortCollatingNationalContext differentiates from other interfaces.
	IsSortCollatingNationalContext()
}

type SortCollatingNationalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortCollatingNationalContext() *SortCollatingNationalContext {
	var p = new(SortCollatingNationalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortCollatingNational
	return p
}

func (*SortCollatingNationalContext) IsSortCollatingNationalContext() {}

func NewSortCollatingNationalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortCollatingNationalContext {
	var p = new(SortCollatingNationalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortCollatingNational

	return p
}

func (s *SortCollatingNationalContext) GetParser() antlr.Parser { return s.parser }

func (s *SortCollatingNationalContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *SortCollatingNationalContext) AlphabetName() IAlphabetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlphabetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlphabetNameContext)
}

func (s *SortCollatingNationalContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *SortCollatingNationalContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortCollatingNationalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortCollatingNationalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortCollatingNationalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortCollatingNational(s)
	}
}

func (s *SortCollatingNationalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortCollatingNational(s)
	}
}

func (s *SortCollatingNationalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortCollatingNational(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortCollatingNational() (localctx ISortCollatingNationalContext) {
	this := p
	_ = this

	localctx = NewSortCollatingNationalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 910, Cobol85ParserRULE_sortCollatingNational)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5215)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5214)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5217)
		p.Match(Cobol85ParserNATIONAL)
	}
	p.SetState(5219)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5218)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5221)
		p.AlphabetName()
	}

	return localctx
}

// ISortInputProcedurePhraseContext is an interface to support dynamic dispatch.
type ISortInputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortInputProcedurePhraseContext differentiates from other interfaces.
	IsSortInputProcedurePhraseContext()
}

type SortInputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortInputProcedurePhraseContext() *SortInputProcedurePhraseContext {
	var p = new(SortInputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortInputProcedurePhrase
	return p
}

func (*SortInputProcedurePhraseContext) IsSortInputProcedurePhraseContext() {}

func NewSortInputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortInputProcedurePhraseContext {
	var p = new(SortInputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortInputProcedurePhrase

	return p
}

func (s *SortInputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortInputProcedurePhraseContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *SortInputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *SortInputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortInputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortInputProcedurePhraseContext) SortInputThrough() ISortInputThroughContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortInputThroughContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortInputThroughContext)
}

func (s *SortInputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortInputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortInputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortInputProcedurePhrase(s)
	}
}

func (s *SortInputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortInputProcedurePhrase(s)
	}
}

func (s *SortInputProcedurePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortInputProcedurePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortInputProcedurePhrase() (localctx ISortInputProcedurePhraseContext) {
	this := p
	_ = this

	localctx = NewSortInputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 912, Cobol85ParserRULE_sortInputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5223)
		p.Match(Cobol85ParserINPUT)
	}
	{
		p.SetState(5224)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5226)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5225)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5228)
		p.ProcedureName()
	}
	p.SetState(5230)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(5229)
			p.SortInputThrough()
		}

	}

	return localctx
}

// ISortInputThroughContext is an interface to support dynamic dispatch.
type ISortInputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortInputThroughContext differentiates from other interfaces.
	IsSortInputThroughContext()
}

type SortInputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortInputThroughContext() *SortInputThroughContext {
	var p = new(SortInputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortInputThrough
	return p
}

func (*SortInputThroughContext) IsSortInputThroughContext() {}

func NewSortInputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortInputThroughContext {
	var p = new(SortInputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortInputThrough

	return p
}

func (s *SortInputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *SortInputThroughContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortInputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *SortInputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *SortInputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortInputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortInputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortInputThrough(s)
	}
}

func (s *SortInputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortInputThrough(s)
	}
}

func (s *SortInputThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortInputThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortInputThrough() (localctx ISortInputThroughContext) {
	this := p
	_ = this

	localctx = NewSortInputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 914, Cobol85ParserRULE_sortInputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5232)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5233)
		p.ProcedureName()
	}

	return localctx
}

// ISortUsingContext is an interface to support dynamic dispatch.
type ISortUsingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortUsingContext differentiates from other interfaces.
	IsSortUsingContext()
}

type SortUsingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortUsingContext() *SortUsingContext {
	var p = new(SortUsingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortUsing
	return p
}

func (*SortUsingContext) IsSortUsingContext() {}

func NewSortUsingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortUsingContext {
	var p = new(SortUsingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortUsing

	return p
}

func (s *SortUsingContext) GetParser() antlr.Parser { return s.parser }

func (s *SortUsingContext) USING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSING, 0)
}

func (s *SortUsingContext) AllFileName() []IFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileNameContext); ok {
			len++
		}
	}

	tst := make([]IFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileNameContext); ok {
			tst[i] = t.(IFileNameContext)
			i++
		}
	}

	return tst
}

func (s *SortUsingContext) FileName(i int) IFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortUsingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortUsing(s)
	}
}

func (s *SortUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortUsing(s)
	}
}

func (s *SortUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortUsing() (localctx ISortUsingContext) {
	this := p
	_ = this

	localctx = NewSortUsingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 916, Cobol85ParserRULE_sortUsing)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5235)
		p.Match(Cobol85ParserUSING)
	}
	p.SetState(5237)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(5236)
			p.FileName()
		}

		p.SetState(5239)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortOutputProcedurePhraseContext is an interface to support dynamic dispatch.
type ISortOutputProcedurePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOutputProcedurePhraseContext differentiates from other interfaces.
	IsSortOutputProcedurePhraseContext()
}

type SortOutputProcedurePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOutputProcedurePhraseContext() *SortOutputProcedurePhraseContext {
	var p = new(SortOutputProcedurePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOutputProcedurePhrase
	return p
}

func (*SortOutputProcedurePhraseContext) IsSortOutputProcedurePhraseContext() {}

func NewSortOutputProcedurePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOutputProcedurePhraseContext {
	var p = new(SortOutputProcedurePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOutputProcedurePhrase

	return p
}

func (s *SortOutputProcedurePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOutputProcedurePhraseContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *SortOutputProcedurePhraseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *SortOutputProcedurePhraseContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortOutputProcedurePhraseContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *SortOutputProcedurePhraseContext) SortOutputThrough() ISortOutputThroughContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortOutputThroughContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortOutputThroughContext)
}

func (s *SortOutputProcedurePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOutputProcedurePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOutputProcedurePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOutputProcedurePhrase(s)
	}
}

func (s *SortOutputProcedurePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOutputProcedurePhrase(s)
	}
}

func (s *SortOutputProcedurePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortOutputProcedurePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortOutputProcedurePhrase() (localctx ISortOutputProcedurePhraseContext) {
	this := p
	_ = this

	localctx = NewSortOutputProcedurePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 918, Cobol85ParserRULE_sortOutputProcedurePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5241)
		p.Match(Cobol85ParserOUTPUT)
	}
	{
		p.SetState(5242)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5244)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5243)
			p.Match(Cobol85ParserIS)
		}

	}
	{
		p.SetState(5246)
		p.ProcedureName()
	}
	p.SetState(5248)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU {
		{
			p.SetState(5247)
			p.SortOutputThrough()
		}

	}

	return localctx
}

// ISortOutputThroughContext is an interface to support dynamic dispatch.
type ISortOutputThroughContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortOutputThroughContext differentiates from other interfaces.
	IsSortOutputThroughContext()
}

type SortOutputThroughContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortOutputThroughContext() *SortOutputThroughContext {
	var p = new(SortOutputThroughContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortOutputThrough
	return p
}

func (*SortOutputThroughContext) IsSortOutputThroughContext() {}

func NewSortOutputThroughContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortOutputThroughContext {
	var p = new(SortOutputThroughContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortOutputThrough

	return p
}

func (s *SortOutputThroughContext) GetParser() antlr.Parser { return s.parser }

func (s *SortOutputThroughContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *SortOutputThroughContext) THROUGH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHROUGH, 0)
}

func (s *SortOutputThroughContext) THRU() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHRU, 0)
}

func (s *SortOutputThroughContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortOutputThroughContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortOutputThroughContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortOutputThrough(s)
	}
}

func (s *SortOutputThroughContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortOutputThrough(s)
	}
}

func (s *SortOutputThroughContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortOutputThrough(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortOutputThrough() (localctx ISortOutputThroughContext) {
	this := p
	_ = this

	localctx = NewSortOutputThroughContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 920, Cobol85ParserRULE_sortOutputThrough)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5250)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserTHROUGH || _la == Cobol85ParserTHRU) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5251)
		p.ProcedureName()
	}

	return localctx
}

// ISortGivingPhraseContext is an interface to support dynamic dispatch.
type ISortGivingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortGivingPhraseContext differentiates from other interfaces.
	IsSortGivingPhraseContext()
}

type SortGivingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortGivingPhraseContext() *SortGivingPhraseContext {
	var p = new(SortGivingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortGivingPhrase
	return p
}

func (*SortGivingPhraseContext) IsSortGivingPhraseContext() {}

func NewSortGivingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortGivingPhraseContext {
	var p = new(SortGivingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortGivingPhrase

	return p
}

func (s *SortGivingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortGivingPhraseContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *SortGivingPhraseContext) AllSortGiving() []ISortGivingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortGivingContext); ok {
			len++
		}
	}

	tst := make([]ISortGivingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortGivingContext); ok {
			tst[i] = t.(ISortGivingContext)
			i++
		}
	}

	return tst
}

func (s *SortGivingPhraseContext) SortGiving(i int) ISortGivingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortGivingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortGivingContext)
}

func (s *SortGivingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortGivingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortGivingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortGivingPhrase(s)
	}
}

func (s *SortGivingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortGivingPhrase(s)
	}
}

func (s *SortGivingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortGivingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortGivingPhrase() (localctx ISortGivingPhraseContext) {
	this := p
	_ = this

	localctx = NewSortGivingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 922, Cobol85ParserRULE_sortGivingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5253)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(5255)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
		{
			p.SetState(5254)
			p.SortGiving()
		}

		p.SetState(5257)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISortGivingContext is an interface to support dynamic dispatch.
type ISortGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSortGivingContext differentiates from other interfaces.
	IsSortGivingContext()
}

type SortGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortGivingContext() *SortGivingContext {
	var p = new(SortGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sortGiving
	return p
}

func (*SortGivingContext) IsSortGivingContext() {}

func NewSortGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortGivingContext {
	var p = new(SortGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sortGiving

	return p
}

func (s *SortGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SortGivingContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *SortGivingContext) LOCK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCK, 0)
}

func (s *SortGivingContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *SortGivingContext) NO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO, 0)
}

func (s *SortGivingContext) REWIND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREWIND, 0)
}

func (s *SortGivingContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *SortGivingContext) RELEASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRELEASE, 0)
}

func (s *SortGivingContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *SortGivingContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *SortGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SortGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSortGiving(s)
	}
}

func (s *SortGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSortGiving(s)
	}
}

func (s *SortGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSortGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SortGiving() (localctx ISortGivingContext) {
	this := p
	_ = this

	localctx = NewSortGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 924, Cobol85ParserRULE_sortGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5259)
		p.FileName()
	}
	p.SetState(5269)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5260)
			p.Match(Cobol85ParserLOCK)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5261)
			p.Match(Cobol85ParserSAVE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(5262)
			p.Match(Cobol85ParserNO)
		}
		{
			p.SetState(5263)
			p.Match(Cobol85ParserREWIND)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 4 {
		{
			p.SetState(5264)
			p.Match(Cobol85ParserCRUNCH)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 5 {
		{
			p.SetState(5265)
			p.Match(Cobol85ParserRELEASE)
		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 799, p.GetParserRuleContext()) == 6 {
		{
			p.SetState(5266)
			p.Match(Cobol85ParserWITH)
		}
		{
			p.SetState(5267)
			p.Match(Cobol85ParserREMOVE)
		}
		{
			p.SetState(5268)
			p.Match(Cobol85ParserCRUNCH)
		}

	}

	return localctx
}

// IStartStatementContext is an interface to support dynamic dispatch.
type IStartStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartStatementContext differentiates from other interfaces.
	IsStartStatementContext()
}

type StartStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartStatementContext() *StartStatementContext {
	var p = new(StartStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startStatement
	return p
}

func (*StartStatementContext) IsStartStatementContext() {}

func NewStartStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartStatementContext {
	var p = new(StartStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startStatement

	return p
}

func (s *StartStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StartStatementContext) START() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTART, 0)
}

func (s *StartStatementContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *StartStatementContext) StartKey() IStartKeyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartKeyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartKeyContext)
}

func (s *StartStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *StartStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *StartStatementContext) END_START() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_START, 0)
}

func (s *StartStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartStatement(s)
	}
}

func (s *StartStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartStatement(s)
	}
}

func (s *StartStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStartStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StartStatement() (localctx IStartStatementContext) {
	this := p
	_ = this

	localctx = NewStartStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 926, Cobol85ParserRULE_startStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5271)
		p.Match(Cobol85ParserSTART)
	}
	{
		p.SetState(5272)
		p.FileName()
	}
	p.SetState(5274)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5273)
			p.StartKey()
		}

	}
	p.SetState(5277)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 801, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5276)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(5280)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 802, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5279)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(5283)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 803, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5282)
			p.Match(Cobol85ParserEND_START)
		}

	}

	return localctx
}

// IStartKeyContext is an interface to support dynamic dispatch.
type IStartKeyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStartKeyContext differentiates from other interfaces.
	IsStartKeyContext()
}

type StartKeyContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartKeyContext() *StartKeyContext {
	var p = new(StartKeyContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_startKey
	return p
}

func (*StartKeyContext) IsStartKeyContext() {}

func NewStartKeyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartKeyContext {
	var p = new(StartKeyContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_startKey

	return p
}

func (s *StartKeyContext) GetParser() antlr.Parser { return s.parser }

func (s *StartKeyContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *StartKeyContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *StartKeyContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *StartKeyContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *StartKeyContext) GREATER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGREATER, 0)
}

func (s *StartKeyContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *StartKeyContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *StartKeyContext) LESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESS, 0)
}

func (s *StartKeyContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *StartKeyContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *StartKeyContext) MORETHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANOREQUAL, 0)
}

func (s *StartKeyContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *StartKeyContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *StartKeyContext) THAN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHAN, 0)
}

func (s *StartKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartKeyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStartKey(s)
	}
}

func (s *StartKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStartKey(s)
	}
}

func (s *StartKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStartKey(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StartKey() (localctx IStartKeyContext) {
	this := p
	_ = this

	localctx = NewStartKeyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 928, Cobol85ParserRULE_startKey)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5285)
		p.Match(Cobol85ParserKEY)
	}
	p.SetState(5287)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5286)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5316)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 810, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5289)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5291)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5290)
				p.Match(Cobol85ParserTO)
			}

		}

	case 2:
		{
			p.SetState(5293)
			p.Match(Cobol85ParserEQUALCHAR)
		}

	case 3:
		{
			p.SetState(5294)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5296)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5295)
				p.Match(Cobol85ParserTHAN)
			}

		}

	case 4:
		{
			p.SetState(5298)
			p.Match(Cobol85ParserMORETHANCHAR)
		}

	case 5:
		{
			p.SetState(5299)
			p.Match(Cobol85ParserNOT)
		}
		{
			p.SetState(5300)
			p.Match(Cobol85ParserLESS)
		}
		p.SetState(5302)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5301)
				p.Match(Cobol85ParserTHAN)
			}

		}

	case 6:
		{
			p.SetState(5304)
			p.Match(Cobol85ParserNOT)
		}
		{
			p.SetState(5305)
			p.Match(Cobol85ParserLESSTHANCHAR)
		}

	case 7:
		{
			p.SetState(5306)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5308)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5307)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5310)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5311)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5313)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5312)
				p.Match(Cobol85ParserTO)
			}

		}

	case 8:
		{
			p.SetState(5315)
			p.Match(Cobol85ParserMORETHANOREQUAL)
		}

	}
	{
		p.SetState(5318)
		p.QualifiedDataName()
	}

	return localctx
}

// IStopStatementContext is an interface to support dynamic dispatch.
type IStopStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStopStatementContext differentiates from other interfaces.
	IsStopStatementContext()
}

type StopStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStopStatementContext() *StopStatementContext {
	var p = new(StopStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stopStatement
	return p
}

func (*StopStatementContext) IsStopStatementContext() {}

func NewStopStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StopStatementContext {
	var p = new(StopStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stopStatement

	return p
}

func (s *StopStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StopStatementContext) STOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTOP, 0)
}

func (s *StopStatementContext) RUN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRUN, 0)
}

func (s *StopStatementContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StopStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StopStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StopStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStopStatement(s)
	}
}

func (s *StopStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStopStatement(s)
	}
}

func (s *StopStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStopStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StopStatement() (localctx IStopStatementContext) {
	this := p
	_ = this

	localctx = NewStopStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 930, Cobol85ParserRULE_stopStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5320)
		p.Match(Cobol85ParserSTOP)
	}
	p.SetState(5323)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserRUN:
		{
			p.SetState(5321)
			p.Match(Cobol85ParserRUN)
		}

	case Cobol85ParserALL, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserFALSE, Cobol85ParserHIGH_VALUE, Cobol85ParserHIGH_VALUES, Cobol85ParserLOW_VALUE, Cobol85ParserLOW_VALUES, Cobol85ParserNULL_, Cobol85ParserNULLS, Cobol85ParserQUOTE, Cobol85ParserQUOTES, Cobol85ParserSPACE, Cobol85ParserSPACES, Cobol85ParserTRUE, Cobol85ParserZERO, Cobol85ParserZEROS, Cobol85ParserZEROES, Cobol85ParserNONNUMERICLITERAL, Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL, Cobol85ParserNUMERICLITERAL:
		{
			p.SetState(5322)
			p.Literal()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringStatementContext is an interface to support dynamic dispatch.
type IStringStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringStatementContext differentiates from other interfaces.
	IsStringStatementContext()
}

type StringStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringStatementContext() *StringStatementContext {
	var p = new(StringStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringStatement
	return p
}

func (*StringStatementContext) IsStringStatementContext() {}

func NewStringStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringStatementContext {
	var p = new(StringStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringStatement

	return p
}

func (s *StringStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StringStatementContext) STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTRING, 0)
}

func (s *StringStatementContext) StringIntoPhrase() IStringIntoPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringIntoPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringIntoPhraseContext)
}

func (s *StringStatementContext) AllStringSendingPhrase() []IStringSendingPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringSendingPhraseContext); ok {
			len++
		}
	}

	tst := make([]IStringSendingPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringSendingPhraseContext); ok {
			tst[i] = t.(IStringSendingPhraseContext)
			i++
		}
	}

	return tst
}

func (s *StringStatementContext) StringSendingPhrase(i int) IStringSendingPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringSendingPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringSendingPhraseContext)
}

func (s *StringStatementContext) StringWithPointerPhrase() IStringWithPointerPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringWithPointerPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringWithPointerPhraseContext)
}

func (s *StringStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnOverflowPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *StringStatementContext) NotOnOverflowPhrase() INotOnOverflowPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnOverflowPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnOverflowPhraseContext)
}

func (s *StringStatementContext) END_STRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_STRING, 0)
}

func (s *StringStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringStatement(s)
	}
}

func (s *StringStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringStatement(s)
	}
}

func (s *StringStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringStatement() (localctx IStringStatementContext) {
	this := p
	_ = this

	localctx = NewStringStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 932, Cobol85ParserRULE_stringStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5325)
		p.Match(Cobol85ParserSTRING)
	}
	p.SetState(5327)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(5326)
			p.StringSendingPhrase()
		}

		p.SetState(5329)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5331)
		p.StringIntoPhrase()
	}
	p.SetState(5333)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 813, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5332)
			p.StringWithPointerPhrase()
		}

	}
	p.SetState(5336)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 814, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5335)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(5339)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 815, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5338)
			p.NotOnOverflowPhrase()
		}

	}
	p.SetState(5342)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 816, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5341)
			p.Match(Cobol85ParserEND_STRING)
		}

	}

	return localctx
}

// IStringSendingPhraseContext is an interface to support dynamic dispatch.
type IStringSendingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSendingPhraseContext differentiates from other interfaces.
	IsStringSendingPhraseContext()
}

type StringSendingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSendingPhraseContext() *StringSendingPhraseContext {
	var p = new(StringSendingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringSendingPhrase
	return p
}

func (*StringSendingPhraseContext) IsStringSendingPhraseContext() {}

func NewStringSendingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSendingPhraseContext {
	var p = new(StringSendingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringSendingPhrase

	return p
}

func (s *StringSendingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSendingPhraseContext) StringDelimitedByPhrase() IStringDelimitedByPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringDelimitedByPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringDelimitedByPhraseContext)
}

func (s *StringSendingPhraseContext) StringForPhrase() IStringForPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringForPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringForPhraseContext)
}

func (s *StringSendingPhraseContext) AllStringSending() []IStringSendingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStringSendingContext); ok {
			len++
		}
	}

	tst := make([]IStringSendingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStringSendingContext); ok {
			tst[i] = t.(IStringSendingContext)
			i++
		}
	}

	return tst
}

func (s *StringSendingPhraseContext) StringSending(i int) IStringSendingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringSendingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringSendingContext)
}

func (s *StringSendingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSendingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSendingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringSendingPhrase(s)
	}
}

func (s *StringSendingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringSendingPhrase(s)
	}
}

func (s *StringSendingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringSendingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringSendingPhrase() (localctx IStringSendingPhraseContext) {
	this := p
	_ = this

	localctx = NewStringSendingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 934, Cobol85ParserRULE_stringSendingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5345)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(5344)
			p.StringSending()
		}

		p.SetState(5347)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(5351)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserDELIMITED:
		{
			p.SetState(5349)
			p.StringDelimitedByPhrase()
		}

	case Cobol85ParserFOR:
		{
			p.SetState(5350)
			p.StringForPhrase()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IStringSendingContext is an interface to support dynamic dispatch.
type IStringSendingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringSendingContext differentiates from other interfaces.
	IsStringSendingContext()
}

type StringSendingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringSendingContext() *StringSendingContext {
	var p = new(StringSendingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringSending
	return p
}

func (*StringSendingContext) IsStringSendingContext() {}

func NewStringSendingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringSendingContext {
	var p = new(StringSendingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringSending

	return p
}

func (s *StringSendingContext) GetParser() antlr.Parser { return s.parser }

func (s *StringSendingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringSendingContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringSendingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringSendingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringSendingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringSending(s)
	}
}

func (s *StringSendingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringSending(s)
	}
}

func (s *StringSendingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringSending(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringSending() (localctx IStringSendingContext) {
	this := p
	_ = this

	localctx = NewStringSendingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 936, Cobol85ParserRULE_stringSending)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5355)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 819, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5353)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5354)
			p.Literal()
		}

	}

	return localctx
}

// IStringDelimitedByPhraseContext is an interface to support dynamic dispatch.
type IStringDelimitedByPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringDelimitedByPhraseContext differentiates from other interfaces.
	IsStringDelimitedByPhraseContext()
}

type StringDelimitedByPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringDelimitedByPhraseContext() *StringDelimitedByPhraseContext {
	var p = new(StringDelimitedByPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringDelimitedByPhrase
	return p
}

func (*StringDelimitedByPhraseContext) IsStringDelimitedByPhraseContext() {}

func NewStringDelimitedByPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringDelimitedByPhraseContext {
	var p = new(StringDelimitedByPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringDelimitedByPhrase

	return p
}

func (s *StringDelimitedByPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringDelimitedByPhraseContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITED, 0)
}

func (s *StringDelimitedByPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *StringDelimitedByPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringDelimitedByPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringDelimitedByPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *StringDelimitedByPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringDelimitedByPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringDelimitedByPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringDelimitedByPhrase(s)
	}
}

func (s *StringDelimitedByPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringDelimitedByPhrase(s)
	}
}

func (s *StringDelimitedByPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringDelimitedByPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringDelimitedByPhrase() (localctx IStringDelimitedByPhraseContext) {
	this := p
	_ = this

	localctx = NewStringDelimitedByPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 938, Cobol85ParserRULE_stringDelimitedByPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5357)
		p.Match(Cobol85ParserDELIMITED)
	}
	p.SetState(5359)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(5358)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(5364)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 821, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5361)
			p.Match(Cobol85ParserSIZE)
		}

	case 2:
		{
			p.SetState(5362)
			p.Identifier()
		}

	case 3:
		{
			p.SetState(5363)
			p.Literal()
		}

	}

	return localctx
}

// IStringForPhraseContext is an interface to support dynamic dispatch.
type IStringForPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringForPhraseContext differentiates from other interfaces.
	IsStringForPhraseContext()
}

type StringForPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringForPhraseContext() *StringForPhraseContext {
	var p = new(StringForPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringForPhrase
	return p
}

func (*StringForPhraseContext) IsStringForPhraseContext() {}

func NewStringForPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringForPhraseContext {
	var p = new(StringForPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringForPhrase

	return p
}

func (s *StringForPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringForPhraseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *StringForPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringForPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *StringForPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringForPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringForPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringForPhrase(s)
	}
}

func (s *StringForPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringForPhrase(s)
	}
}

func (s *StringForPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringForPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringForPhrase() (localctx IStringForPhraseContext) {
	this := p
	_ = this

	localctx = NewStringForPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 940, Cobol85ParserRULE_stringForPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5366)
		p.Match(Cobol85ParserFOR)
	}
	p.SetState(5369)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 822, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5367)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5368)
			p.Literal()
		}

	}

	return localctx
}

// IStringIntoPhraseContext is an interface to support dynamic dispatch.
type IStringIntoPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringIntoPhraseContext differentiates from other interfaces.
	IsStringIntoPhraseContext()
}

type StringIntoPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringIntoPhraseContext() *StringIntoPhraseContext {
	var p = new(StringIntoPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringIntoPhrase
	return p
}

func (*StringIntoPhraseContext) IsStringIntoPhraseContext() {}

func NewStringIntoPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringIntoPhraseContext {
	var p = new(StringIntoPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringIntoPhrase

	return p
}

func (s *StringIntoPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringIntoPhraseContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *StringIntoPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *StringIntoPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringIntoPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringIntoPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringIntoPhrase(s)
	}
}

func (s *StringIntoPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringIntoPhrase(s)
	}
}

func (s *StringIntoPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringIntoPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringIntoPhrase() (localctx IStringIntoPhraseContext) {
	this := p
	_ = this

	localctx = NewStringIntoPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 942, Cobol85ParserRULE_stringIntoPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5371)
		p.Match(Cobol85ParserINTO)
	}
	{
		p.SetState(5372)
		p.Identifier()
	}

	return localctx
}

// IStringWithPointerPhraseContext is an interface to support dynamic dispatch.
type IStringWithPointerPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsStringWithPointerPhraseContext differentiates from other interfaces.
	IsStringWithPointerPhraseContext()
}

type StringWithPointerPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringWithPointerPhraseContext() *StringWithPointerPhraseContext {
	var p = new(StringWithPointerPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_stringWithPointerPhrase
	return p
}

func (*StringWithPointerPhraseContext) IsStringWithPointerPhraseContext() {}

func NewStringWithPointerPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringWithPointerPhraseContext {
	var p = new(StringWithPointerPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_stringWithPointerPhrase

	return p
}

func (s *StringWithPointerPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *StringWithPointerPhraseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *StringWithPointerPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *StringWithPointerPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *StringWithPointerPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringWithPointerPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringWithPointerPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterStringWithPointerPhrase(s)
	}
}

func (s *StringWithPointerPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitStringWithPointerPhrase(s)
	}
}

func (s *StringWithPointerPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitStringWithPointerPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) StringWithPointerPhrase() (localctx IStringWithPointerPhraseContext) {
	this := p
	_ = this

	localctx = NewStringWithPointerPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 944, Cobol85ParserRULE_stringWithPointerPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5375)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5374)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5377)
		p.Match(Cobol85ParserPOINTER)
	}
	{
		p.SetState(5378)
		p.QualifiedDataName()
	}

	return localctx
}

// ISubtractStatementContext is an interface to support dynamic dispatch.
type ISubtractStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractStatementContext differentiates from other interfaces.
	IsSubtractStatementContext()
}

type SubtractStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractStatementContext() *SubtractStatementContext {
	var p = new(SubtractStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractStatement
	return p
}

func (*SubtractStatementContext) IsSubtractStatementContext() {}

func NewSubtractStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractStatementContext {
	var p = new(SubtractStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractStatement

	return p
}

func (s *SubtractStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractStatementContext) SUBTRACT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUBTRACT, 0)
}

func (s *SubtractStatementContext) SubtractFromStatement() ISubtractFromStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractFromStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractFromStatementContext)
}

func (s *SubtractStatementContext) SubtractFromGivingStatement() ISubtractFromGivingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractFromGivingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractFromGivingStatementContext)
}

func (s *SubtractStatementContext) SubtractCorrespondingStatement() ISubtractCorrespondingStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractCorrespondingStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractCorrespondingStatementContext)
}

func (s *SubtractStatementContext) OnSizeErrorPhrase() IOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnSizeErrorPhraseContext)
}

func (s *SubtractStatementContext) NotOnSizeErrorPhrase() INotOnSizeErrorPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnSizeErrorPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnSizeErrorPhraseContext)
}

func (s *SubtractStatementContext) END_SUBTRACT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_SUBTRACT, 0)
}

func (s *SubtractStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractStatement(s)
	}
}

func (s *SubtractStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractStatement(s)
	}
}

func (s *SubtractStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractStatement() (localctx ISubtractStatementContext) {
	this := p
	_ = this

	localctx = NewSubtractStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 946, Cobol85ParserRULE_subtractStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5380)
		p.Match(Cobol85ParserSUBTRACT)
	}
	p.SetState(5384)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 824, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5381)
			p.SubtractFromStatement()
		}

	case 2:
		{
			p.SetState(5382)
			p.SubtractFromGivingStatement()
		}

	case 3:
		{
			p.SetState(5383)
			p.SubtractCorrespondingStatement()
		}

	}
	p.SetState(5387)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 825, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5386)
			p.OnSizeErrorPhrase()
		}

	}
	p.SetState(5390)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 826, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5389)
			p.NotOnSizeErrorPhrase()
		}

	}
	p.SetState(5393)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 827, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5392)
			p.Match(Cobol85ParserEND_SUBTRACT)
		}

	}

	return localctx
}

// ISubtractFromStatementContext is an interface to support dynamic dispatch.
type ISubtractFromStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractFromStatementContext differentiates from other interfaces.
	IsSubtractFromStatementContext()
}

type SubtractFromStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractFromStatementContext() *SubtractFromStatementContext {
	var p = new(SubtractFromStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractFromStatement
	return p
}

func (*SubtractFromStatementContext) IsSubtractFromStatementContext() {}

func NewSubtractFromStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractFromStatementContext {
	var p = new(SubtractFromStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractFromStatement

	return p
}

func (s *SubtractFromStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractFromStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractFromStatementContext) AllSubtractSubtrahend() []ISubtractSubtrahendContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubtractSubtrahendContext); ok {
			len++
		}
	}

	tst := make([]ISubtractSubtrahendContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubtractSubtrahendContext); ok {
			tst[i] = t.(ISubtractSubtrahendContext)
			i++
		}
	}

	return tst
}

func (s *SubtractFromStatementContext) SubtractSubtrahend(i int) ISubtractSubtrahendContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractSubtrahendContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractSubtrahendContext)
}

func (s *SubtractFromStatementContext) AllSubtractMinuend() []ISubtractMinuendContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubtractMinuendContext); ok {
			len++
		}
	}

	tst := make([]ISubtractMinuendContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubtractMinuendContext); ok {
			tst[i] = t.(ISubtractMinuendContext)
			i++
		}
	}

	return tst
}

func (s *SubtractFromStatementContext) SubtractMinuend(i int) ISubtractMinuendContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractMinuendContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendContext)
}

func (s *SubtractFromStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractFromStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractFromStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractFromStatement(s)
	}
}

func (s *SubtractFromStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractFromStatement(s)
	}
}

func (s *SubtractFromStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractFromStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractFromStatement() (localctx ISubtractFromStatementContext) {
	this := p
	_ = this

	localctx = NewSubtractFromStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 948, Cobol85ParserRULE_subtractFromStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5396)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(5395)
			p.SubtractSubtrahend()
		}

		p.SetState(5398)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5400)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(5402)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5401)
			p.SubtractMinuend()
		}

		p.SetState(5404)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtractFromGivingStatementContext is an interface to support dynamic dispatch.
type ISubtractFromGivingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractFromGivingStatementContext differentiates from other interfaces.
	IsSubtractFromGivingStatementContext()
}

type SubtractFromGivingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractFromGivingStatementContext() *SubtractFromGivingStatementContext {
	var p = new(SubtractFromGivingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractFromGivingStatement
	return p
}

func (*SubtractFromGivingStatementContext) IsSubtractFromGivingStatementContext() {}

func NewSubtractFromGivingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractFromGivingStatementContext {
	var p = new(SubtractFromGivingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractFromGivingStatement

	return p
}

func (s *SubtractFromGivingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractFromGivingStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractFromGivingStatementContext) SubtractMinuendGiving() ISubtractMinuendGivingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractMinuendGivingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendGivingContext)
}

func (s *SubtractFromGivingStatementContext) GIVING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGIVING, 0)
}

func (s *SubtractFromGivingStatementContext) AllSubtractSubtrahend() []ISubtractSubtrahendContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubtractSubtrahendContext); ok {
			len++
		}
	}

	tst := make([]ISubtractSubtrahendContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubtractSubtrahendContext); ok {
			tst[i] = t.(ISubtractSubtrahendContext)
			i++
		}
	}

	return tst
}

func (s *SubtractFromGivingStatementContext) SubtractSubtrahend(i int) ISubtractSubtrahendContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractSubtrahendContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractSubtrahendContext)
}

func (s *SubtractFromGivingStatementContext) AllSubtractGiving() []ISubtractGivingContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubtractGivingContext); ok {
			len++
		}
	}

	tst := make([]ISubtractGivingContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubtractGivingContext); ok {
			tst[i] = t.(ISubtractGivingContext)
			i++
		}
	}

	return tst
}

func (s *SubtractFromGivingStatementContext) SubtractGiving(i int) ISubtractGivingContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractGivingContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractGivingContext)
}

func (s *SubtractFromGivingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractFromGivingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractFromGivingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractFromGivingStatement(s)
	}
}

func (s *SubtractFromGivingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractFromGivingStatement(s)
	}
}

func (s *SubtractFromGivingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractFromGivingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractFromGivingStatement() (localctx ISubtractFromGivingStatementContext) {
	this := p
	_ = this

	localctx = NewSubtractFromGivingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 950, Cobol85ParserRULE_subtractFromGivingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5407)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-551)) & ^0x3f) == 0 && ((int64(1)<<(_la-551))&127) != 0 {
		{
			p.SetState(5406)
			p.SubtractSubtrahend()
		}

		p.SetState(5409)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5411)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5412)
		p.SubtractMinuendGiving()
	}
	{
		p.SetState(5413)
		p.Match(Cobol85ParserGIVING)
	}
	p.SetState(5415)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5414)
			p.SubtractGiving()
		}

		p.SetState(5417)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISubtractCorrespondingStatementContext is an interface to support dynamic dispatch.
type ISubtractCorrespondingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractCorrespondingStatementContext differentiates from other interfaces.
	IsSubtractCorrespondingStatementContext()
}

type SubtractCorrespondingStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractCorrespondingStatementContext() *SubtractCorrespondingStatementContext {
	var p = new(SubtractCorrespondingStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractCorrespondingStatement
	return p
}

func (*SubtractCorrespondingStatementContext) IsSubtractCorrespondingStatementContext() {}

func NewSubtractCorrespondingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractCorrespondingStatementContext {
	var p = new(SubtractCorrespondingStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractCorrespondingStatement

	return p
}

func (s *SubtractCorrespondingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractCorrespondingStatementContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubtractCorrespondingStatementContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *SubtractCorrespondingStatementContext) SubtractMinuendCorresponding() ISubtractMinuendCorrespondingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubtractMinuendCorrespondingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubtractMinuendCorrespondingContext)
}

func (s *SubtractCorrespondingStatementContext) CORRESPONDING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORRESPONDING, 0)
}

func (s *SubtractCorrespondingStatementContext) CORR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCORR, 0)
}

func (s *SubtractCorrespondingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractCorrespondingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractCorrespondingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractCorrespondingStatement(s)
	}
}

func (s *SubtractCorrespondingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractCorrespondingStatement(s)
	}
}

func (s *SubtractCorrespondingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractCorrespondingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractCorrespondingStatement() (localctx ISubtractCorrespondingStatementContext) {
	this := p
	_ = this

	localctx = NewSubtractCorrespondingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 952, Cobol85ParserRULE_subtractCorrespondingStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5419)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserCORR || _la == Cobol85ParserCORRESPONDING) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5420)
		p.QualifiedDataName()
	}
	{
		p.SetState(5421)
		p.Match(Cobol85ParserFROM)
	}
	{
		p.SetState(5422)
		p.SubtractMinuendCorresponding()
	}

	return localctx
}

// ISubtractSubtrahendContext is an interface to support dynamic dispatch.
type ISubtractSubtrahendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractSubtrahendContext differentiates from other interfaces.
	IsSubtractSubtrahendContext()
}

type SubtractSubtrahendContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractSubtrahendContext() *SubtractSubtrahendContext {
	var p = new(SubtractSubtrahendContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractSubtrahend
	return p
}

func (*SubtractSubtrahendContext) IsSubtractSubtrahendContext() {}

func NewSubtractSubtrahendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractSubtrahendContext {
	var p = new(SubtractSubtrahendContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractSubtrahend

	return p
}

func (s *SubtractSubtrahendContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractSubtrahendContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractSubtrahendContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SubtractSubtrahendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractSubtrahendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractSubtrahendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractSubtrahend(s)
	}
}

func (s *SubtractSubtrahendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractSubtrahend(s)
	}
}

func (s *SubtractSubtrahendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractSubtrahend(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractSubtrahend() (localctx ISubtractSubtrahendContext) {
	this := p
	_ = this

	localctx = NewSubtractSubtrahendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 954, Cobol85ParserRULE_subtractSubtrahend)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5426)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 832, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5424)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5425)
			p.Literal()
		}

	}

	return localctx
}

// ISubtractMinuendContext is an interface to support dynamic dispatch.
type ISubtractMinuendContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendContext differentiates from other interfaces.
	IsSubtractMinuendContext()
}

type SubtractMinuendContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendContext() *SubtractMinuendContext {
	var p = new(SubtractMinuendContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuend
	return p
}

func (*SubtractMinuendContext) IsSubtractMinuendContext() {}

func NewSubtractMinuendContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendContext {
	var p = new(SubtractMinuendContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuend

	return p
}

func (s *SubtractMinuendContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractMinuendContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractMinuendContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuend(s)
	}
}

func (s *SubtractMinuendContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuend(s)
	}
}

func (s *SubtractMinuendContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractMinuend(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractMinuend() (localctx ISubtractMinuendContext) {
	this := p
	_ = this

	localctx = NewSubtractMinuendContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 956, Cobol85ParserRULE_subtractMinuend)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5428)
		p.Identifier()
	}
	p.SetState(5430)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5429)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ISubtractMinuendGivingContext is an interface to support dynamic dispatch.
type ISubtractMinuendGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendGivingContext differentiates from other interfaces.
	IsSubtractMinuendGivingContext()
}

type SubtractMinuendGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendGivingContext() *SubtractMinuendGivingContext {
	var p = new(SubtractMinuendGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendGiving
	return p
}

func (*SubtractMinuendGivingContext) IsSubtractMinuendGivingContext() {}

func NewSubtractMinuendGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendGivingContext {
	var p = new(SubtractMinuendGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendGiving

	return p
}

func (s *SubtractMinuendGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendGivingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractMinuendGivingContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SubtractMinuendGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuendGiving(s)
	}
}

func (s *SubtractMinuendGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuendGiving(s)
	}
}

func (s *SubtractMinuendGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractMinuendGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractMinuendGiving() (localctx ISubtractMinuendGivingContext) {
	this := p
	_ = this

	localctx = NewSubtractMinuendGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 958, Cobol85ParserRULE_subtractMinuendGiving)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5434)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 834, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5432)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5433)
			p.Literal()
		}

	}

	return localctx
}

// ISubtractGivingContext is an interface to support dynamic dispatch.
type ISubtractGivingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractGivingContext differentiates from other interfaces.
	IsSubtractGivingContext()
}

type SubtractGivingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractGivingContext() *SubtractGivingContext {
	var p = new(SubtractGivingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractGiving
	return p
}

func (*SubtractGivingContext) IsSubtractGivingContext() {}

func NewSubtractGivingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractGivingContext {
	var p = new(SubtractGivingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractGiving

	return p
}

func (s *SubtractGivingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractGivingContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SubtractGivingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractGivingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractGivingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractGivingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractGiving(s)
	}
}

func (s *SubtractGivingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractGiving(s)
	}
}

func (s *SubtractGivingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractGiving(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractGiving() (localctx ISubtractGivingContext) {
	this := p
	_ = this

	localctx = NewSubtractGivingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 960, Cobol85ParserRULE_subtractGiving)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5436)
		p.Identifier()
	}
	p.SetState(5438)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5437)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ISubtractMinuendCorrespondingContext is an interface to support dynamic dispatch.
type ISubtractMinuendCorrespondingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubtractMinuendCorrespondingContext differentiates from other interfaces.
	IsSubtractMinuendCorrespondingContext()
}

type SubtractMinuendCorrespondingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubtractMinuendCorrespondingContext() *SubtractMinuendCorrespondingContext {
	var p = new(SubtractMinuendCorrespondingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendCorresponding
	return p
}

func (*SubtractMinuendCorrespondingContext) IsSubtractMinuendCorrespondingContext() {}

func NewSubtractMinuendCorrespondingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubtractMinuendCorrespondingContext {
	var p = new(SubtractMinuendCorrespondingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subtractMinuendCorresponding

	return p
}

func (s *SubtractMinuendCorrespondingContext) GetParser() antlr.Parser { return s.parser }

func (s *SubtractMinuendCorrespondingContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *SubtractMinuendCorrespondingContext) ROUNDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserROUNDED, 0)
}

func (s *SubtractMinuendCorrespondingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubtractMinuendCorrespondingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubtractMinuendCorrespondingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubtractMinuendCorresponding(s)
	}
}

func (s *SubtractMinuendCorrespondingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubtractMinuendCorresponding(s)
	}
}

func (s *SubtractMinuendCorrespondingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubtractMinuendCorresponding(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SubtractMinuendCorresponding() (localctx ISubtractMinuendCorrespondingContext) {
	this := p
	_ = this

	localctx = NewSubtractMinuendCorrespondingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 962, Cobol85ParserRULE_subtractMinuendCorresponding)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5440)
		p.QualifiedDataName()
	}
	p.SetState(5442)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserROUNDED {
		{
			p.SetState(5441)
			p.Match(Cobol85ParserROUNDED)
		}

	}

	return localctx
}

// ITerminateStatementContext is an interface to support dynamic dispatch.
type ITerminateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTerminateStatementContext differentiates from other interfaces.
	IsTerminateStatementContext()
}

type TerminateStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminateStatementContext() *TerminateStatementContext {
	var p = new(TerminateStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_terminateStatement
	return p
}

func (*TerminateStatementContext) IsTerminateStatementContext() {}

func NewTerminateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminateStatementContext {
	var p = new(TerminateStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_terminateStatement

	return p
}

func (s *TerminateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminateStatementContext) TERMINATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTERMINATE, 0)
}

func (s *TerminateStatementContext) ReportName() IReportNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReportNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReportNameContext)
}

func (s *TerminateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TerminateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTerminateStatement(s)
	}
}

func (s *TerminateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTerminateStatement(s)
	}
}

func (s *TerminateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTerminateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TerminateStatement() (localctx ITerminateStatementContext) {
	this := p
	_ = this

	localctx = NewTerminateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 964, Cobol85ParserRULE_terminateStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5444)
		p.Match(Cobol85ParserTERMINATE)
	}
	{
		p.SetState(5445)
		p.ReportName()
	}

	return localctx
}

// IUnstringStatementContext is an interface to support dynamic dispatch.
type IUnstringStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringStatementContext differentiates from other interfaces.
	IsUnstringStatementContext()
}

type UnstringStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringStatementContext() *UnstringStatementContext {
	var p = new(UnstringStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringStatement
	return p
}

func (*UnstringStatementContext) IsUnstringStatementContext() {}

func NewUnstringStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringStatementContext {
	var p = new(UnstringStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringStatement

	return p
}

func (s *UnstringStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringStatementContext) UNSTRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNSTRING, 0)
}

func (s *UnstringStatementContext) UnstringSendingPhrase() IUnstringSendingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringSendingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringSendingPhraseContext)
}

func (s *UnstringStatementContext) UnstringIntoPhrase() IUnstringIntoPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringIntoPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringIntoPhraseContext)
}

func (s *UnstringStatementContext) UnstringWithPointerPhrase() IUnstringWithPointerPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringWithPointerPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringWithPointerPhraseContext)
}

func (s *UnstringStatementContext) UnstringTallyingPhrase() IUnstringTallyingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringTallyingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringTallyingPhraseContext)
}

func (s *UnstringStatementContext) OnOverflowPhrase() IOnOverflowPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnOverflowPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnOverflowPhraseContext)
}

func (s *UnstringStatementContext) NotOnOverflowPhrase() INotOnOverflowPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotOnOverflowPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotOnOverflowPhraseContext)
}

func (s *UnstringStatementContext) END_UNSTRING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_UNSTRING, 0)
}

func (s *UnstringStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringStatement(s)
	}
}

func (s *UnstringStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringStatement(s)
	}
}

func (s *UnstringStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringStatement() (localctx IUnstringStatementContext) {
	this := p
	_ = this

	localctx = NewUnstringStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 966, Cobol85ParserRULE_unstringStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5447)
		p.Match(Cobol85ParserUNSTRING)
	}
	{
		p.SetState(5448)
		p.UnstringSendingPhrase()
	}
	{
		p.SetState(5449)
		p.UnstringIntoPhrase()
	}
	p.SetState(5451)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 837, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5450)
			p.UnstringWithPointerPhrase()
		}

	}
	p.SetState(5454)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserTALLYING {
		{
			p.SetState(5453)
			p.UnstringTallyingPhrase()
		}

	}
	p.SetState(5457)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 839, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5456)
			p.OnOverflowPhrase()
		}

	}
	p.SetState(5460)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 840, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5459)
			p.NotOnOverflowPhrase()
		}

	}
	p.SetState(5463)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 841, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5462)
			p.Match(Cobol85ParserEND_UNSTRING)
		}

	}

	return localctx
}

// IUnstringSendingPhraseContext is an interface to support dynamic dispatch.
type IUnstringSendingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringSendingPhraseContext differentiates from other interfaces.
	IsUnstringSendingPhraseContext()
}

type UnstringSendingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringSendingPhraseContext() *UnstringSendingPhraseContext {
	var p = new(UnstringSendingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringSendingPhrase
	return p
}

func (*UnstringSendingPhraseContext) IsUnstringSendingPhraseContext() {}

func NewUnstringSendingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringSendingPhraseContext {
	var p = new(UnstringSendingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringSendingPhrase

	return p
}

func (s *UnstringSendingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringSendingPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringSendingPhraseContext) UnstringDelimitedByPhrase() IUnstringDelimitedByPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringDelimitedByPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringDelimitedByPhraseContext)
}

func (s *UnstringSendingPhraseContext) AllUnstringOrAllPhrase() []IUnstringOrAllPhraseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnstringOrAllPhraseContext); ok {
			len++
		}
	}

	tst := make([]IUnstringOrAllPhraseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnstringOrAllPhraseContext); ok {
			tst[i] = t.(IUnstringOrAllPhraseContext)
			i++
		}
	}

	return tst
}

func (s *UnstringSendingPhraseContext) UnstringOrAllPhrase(i int) IUnstringOrAllPhraseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringOrAllPhraseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringOrAllPhraseContext)
}

func (s *UnstringSendingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringSendingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringSendingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringSendingPhrase(s)
	}
}

func (s *UnstringSendingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringSendingPhrase(s)
	}
}

func (s *UnstringSendingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringSendingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringSendingPhrase() (localctx IUnstringSendingPhraseContext) {
	this := p
	_ = this

	localctx = NewUnstringSendingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 968, Cobol85ParserRULE_unstringSendingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5465)
		p.Identifier()
	}
	p.SetState(5473)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDELIMITED {
		{
			p.SetState(5466)
			p.UnstringDelimitedByPhrase()
		}
		p.SetState(5470)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserOR {
			{
				p.SetState(5467)
				p.UnstringOrAllPhrase()
			}

			p.SetState(5472)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IUnstringDelimitedByPhraseContext is an interface to support dynamic dispatch.
type IUnstringDelimitedByPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringDelimitedByPhraseContext differentiates from other interfaces.
	IsUnstringDelimitedByPhraseContext()
}

type UnstringDelimitedByPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringDelimitedByPhraseContext() *UnstringDelimitedByPhraseContext {
	var p = new(UnstringDelimitedByPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringDelimitedByPhrase
	return p
}

func (*UnstringDelimitedByPhraseContext) IsUnstringDelimitedByPhraseContext() {}

func NewUnstringDelimitedByPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringDelimitedByPhraseContext {
	var p = new(UnstringDelimitedByPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringDelimitedByPhrase

	return p
}

func (s *UnstringDelimitedByPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringDelimitedByPhraseContext) DELIMITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITED, 0)
}

func (s *UnstringDelimitedByPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringDelimitedByPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *UnstringDelimitedByPhraseContext) BY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBY, 0)
}

func (s *UnstringDelimitedByPhraseContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UnstringDelimitedByPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringDelimitedByPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringDelimitedByPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringDelimitedByPhrase(s)
	}
}

func (s *UnstringDelimitedByPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringDelimitedByPhrase(s)
	}
}

func (s *UnstringDelimitedByPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringDelimitedByPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringDelimitedByPhrase() (localctx IUnstringDelimitedByPhraseContext) {
	this := p
	_ = this

	localctx = NewUnstringDelimitedByPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 970, Cobol85ParserRULE_unstringDelimitedByPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5475)
		p.Match(Cobol85ParserDELIMITED)
	}
	p.SetState(5477)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserBY {
		{
			p.SetState(5476)
			p.Match(Cobol85ParserBY)
		}

	}
	p.SetState(5480)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 845, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5479)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(5484)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 846, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5482)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5483)
			p.Literal()
		}

	}

	return localctx
}

// IUnstringOrAllPhraseContext is an interface to support dynamic dispatch.
type IUnstringOrAllPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringOrAllPhraseContext differentiates from other interfaces.
	IsUnstringOrAllPhraseContext()
}

type UnstringOrAllPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringOrAllPhraseContext() *UnstringOrAllPhraseContext {
	var p = new(UnstringOrAllPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringOrAllPhrase
	return p
}

func (*UnstringOrAllPhraseContext) IsUnstringOrAllPhraseContext() {}

func NewUnstringOrAllPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringOrAllPhraseContext {
	var p = new(UnstringOrAllPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringOrAllPhrase

	return p
}

func (s *UnstringOrAllPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringOrAllPhraseContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *UnstringOrAllPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringOrAllPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *UnstringOrAllPhraseContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UnstringOrAllPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringOrAllPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringOrAllPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringOrAllPhrase(s)
	}
}

func (s *UnstringOrAllPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringOrAllPhrase(s)
	}
}

func (s *UnstringOrAllPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringOrAllPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringOrAllPhrase() (localctx IUnstringOrAllPhraseContext) {
	this := p
	_ = this

	localctx = NewUnstringOrAllPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 972, Cobol85ParserRULE_unstringOrAllPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5486)
		p.Match(Cobol85ParserOR)
	}
	p.SetState(5488)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 847, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5487)
			p.Match(Cobol85ParserALL)
		}

	}
	p.SetState(5492)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 848, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5490)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5491)
			p.Literal()
		}

	}

	return localctx
}

// IUnstringIntoPhraseContext is an interface to support dynamic dispatch.
type IUnstringIntoPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringIntoPhraseContext differentiates from other interfaces.
	IsUnstringIntoPhraseContext()
}

type UnstringIntoPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringIntoPhraseContext() *UnstringIntoPhraseContext {
	var p = new(UnstringIntoPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringIntoPhrase
	return p
}

func (*UnstringIntoPhraseContext) IsUnstringIntoPhraseContext() {}

func NewUnstringIntoPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringIntoPhraseContext {
	var p = new(UnstringIntoPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringIntoPhrase

	return p
}

func (s *UnstringIntoPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringIntoPhraseContext) INTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTO, 0)
}

func (s *UnstringIntoPhraseContext) AllUnstringInto() []IUnstringIntoContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUnstringIntoContext); ok {
			len++
		}
	}

	tst := make([]IUnstringIntoContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUnstringIntoContext); ok {
			tst[i] = t.(IUnstringIntoContext)
			i++
		}
	}

	return tst
}

func (s *UnstringIntoPhraseContext) UnstringInto(i int) IUnstringIntoContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringIntoContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringIntoContext)
}

func (s *UnstringIntoPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringIntoPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringIntoPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringIntoPhrase(s)
	}
}

func (s *UnstringIntoPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringIntoPhrase(s)
	}
}

func (s *UnstringIntoPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringIntoPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringIntoPhrase() (localctx IUnstringIntoPhraseContext) {
	this := p
	_ = this

	localctx = NewUnstringIntoPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 974, Cobol85ParserRULE_unstringIntoPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5494)
		p.Match(Cobol85ParserINTO)
	}
	p.SetState(5496)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821858) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423728639) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178961289) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428515) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&130978249457673) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103776312507334817) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5495)
			p.UnstringInto()
		}

		p.SetState(5498)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUnstringIntoContext is an interface to support dynamic dispatch.
type IUnstringIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringIntoContext differentiates from other interfaces.
	IsUnstringIntoContext()
}

type UnstringIntoContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringIntoContext() *UnstringIntoContext {
	var p = new(UnstringIntoContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringInto
	return p
}

func (*UnstringIntoContext) IsUnstringIntoContext() {}

func NewUnstringIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringIntoContext {
	var p = new(UnstringIntoContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringInto

	return p
}

func (s *UnstringIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringIntoContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringIntoContext) UnstringDelimiterIn() IUnstringDelimiterInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringDelimiterInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringDelimiterInContext)
}

func (s *UnstringIntoContext) UnstringCountIn() IUnstringCountInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnstringCountInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnstringCountInContext)
}

func (s *UnstringIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringInto(s)
	}
}

func (s *UnstringIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringInto(s)
	}
}

func (s *UnstringIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringInto() (localctx IUnstringIntoContext) {
	this := p
	_ = this

	localctx = NewUnstringIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 976, Cobol85ParserRULE_unstringInto)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5500)
		p.Identifier()
	}
	p.SetState(5502)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserDELIMITER {
		{
			p.SetState(5501)
			p.UnstringDelimiterIn()
		}

	}
	p.SetState(5505)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserCOUNT {
		{
			p.SetState(5504)
			p.UnstringCountIn()
		}

	}

	return localctx
}

// IUnstringDelimiterInContext is an interface to support dynamic dispatch.
type IUnstringDelimiterInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringDelimiterInContext differentiates from other interfaces.
	IsUnstringDelimiterInContext()
}

type UnstringDelimiterInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringDelimiterInContext() *UnstringDelimiterInContext {
	var p = new(UnstringDelimiterInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringDelimiterIn
	return p
}

func (*UnstringDelimiterInContext) IsUnstringDelimiterInContext() {}

func NewUnstringDelimiterInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringDelimiterInContext {
	var p = new(UnstringDelimiterInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringDelimiterIn

	return p
}

func (s *UnstringDelimiterInContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringDelimiterInContext) DELIMITER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDELIMITER, 0)
}

func (s *UnstringDelimiterInContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringDelimiterInContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringDelimiterInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringDelimiterInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringDelimiterInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringDelimiterIn(s)
	}
}

func (s *UnstringDelimiterInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringDelimiterIn(s)
	}
}

func (s *UnstringDelimiterInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringDelimiterIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringDelimiterIn() (localctx IUnstringDelimiterInContext) {
	this := p
	_ = this

	localctx = NewUnstringDelimiterInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 978, Cobol85ParserRULE_unstringDelimiterIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5507)
		p.Match(Cobol85ParserDELIMITER)
	}
	p.SetState(5509)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5508)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5511)
		p.Identifier()
	}

	return localctx
}

// IUnstringCountInContext is an interface to support dynamic dispatch.
type IUnstringCountInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringCountInContext differentiates from other interfaces.
	IsUnstringCountInContext()
}

type UnstringCountInContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringCountInContext() *UnstringCountInContext {
	var p = new(UnstringCountInContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringCountIn
	return p
}

func (*UnstringCountInContext) IsUnstringCountInContext() {}

func NewUnstringCountInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringCountInContext {
	var p = new(UnstringCountInContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringCountIn

	return p
}

func (s *UnstringCountInContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringCountInContext) COUNT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOUNT, 0)
}

func (s *UnstringCountInContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UnstringCountInContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringCountInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringCountInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringCountInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringCountIn(s)
	}
}

func (s *UnstringCountInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringCountIn(s)
	}
}

func (s *UnstringCountInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringCountIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringCountIn() (localctx IUnstringCountInContext) {
	this := p
	_ = this

	localctx = NewUnstringCountInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 980, Cobol85ParserRULE_unstringCountIn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5513)
		p.Match(Cobol85ParserCOUNT)
	}
	p.SetState(5515)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5514)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5517)
		p.Identifier()
	}

	return localctx
}

// IUnstringWithPointerPhraseContext is an interface to support dynamic dispatch.
type IUnstringWithPointerPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringWithPointerPhraseContext differentiates from other interfaces.
	IsUnstringWithPointerPhraseContext()
}

type UnstringWithPointerPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringWithPointerPhraseContext() *UnstringWithPointerPhraseContext {
	var p = new(UnstringWithPointerPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringWithPointerPhrase
	return p
}

func (*UnstringWithPointerPhraseContext) IsUnstringWithPointerPhraseContext() {}

func NewUnstringWithPointerPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringWithPointerPhraseContext {
	var p = new(UnstringWithPointerPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringWithPointerPhrase

	return p
}

func (s *UnstringWithPointerPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringWithPointerPhraseContext) POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOINTER, 0)
}

func (s *UnstringWithPointerPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringWithPointerPhraseContext) WITH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWITH, 0)
}

func (s *UnstringWithPointerPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringWithPointerPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringWithPointerPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringWithPointerPhrase(s)
	}
}

func (s *UnstringWithPointerPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringWithPointerPhrase(s)
	}
}

func (s *UnstringWithPointerPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringWithPointerPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringWithPointerPhrase() (localctx IUnstringWithPointerPhraseContext) {
	this := p
	_ = this

	localctx = NewUnstringWithPointerPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 982, Cobol85ParserRULE_unstringWithPointerPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5520)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserWITH {
		{
			p.SetState(5519)
			p.Match(Cobol85ParserWITH)
		}

	}
	{
		p.SetState(5522)
		p.Match(Cobol85ParserPOINTER)
	}
	{
		p.SetState(5523)
		p.QualifiedDataName()
	}

	return localctx
}

// IUnstringTallyingPhraseContext is an interface to support dynamic dispatch.
type IUnstringTallyingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUnstringTallyingPhraseContext differentiates from other interfaces.
	IsUnstringTallyingPhraseContext()
}

type UnstringTallyingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnstringTallyingPhraseContext() *UnstringTallyingPhraseContext {
	var p = new(UnstringTallyingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_unstringTallyingPhrase
	return p
}

func (*UnstringTallyingPhraseContext) IsUnstringTallyingPhraseContext() {}

func NewUnstringTallyingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnstringTallyingPhraseContext {
	var p = new(UnstringTallyingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_unstringTallyingPhrase

	return p
}

func (s *UnstringTallyingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *UnstringTallyingPhraseContext) TALLYING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLYING, 0)
}

func (s *UnstringTallyingPhraseContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *UnstringTallyingPhraseContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *UnstringTallyingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnstringTallyingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnstringTallyingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUnstringTallyingPhrase(s)
	}
}

func (s *UnstringTallyingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUnstringTallyingPhrase(s)
	}
}

func (s *UnstringTallyingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUnstringTallyingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UnstringTallyingPhrase() (localctx IUnstringTallyingPhraseContext) {
	this := p
	_ = this

	localctx = NewUnstringTallyingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 984, Cobol85ParserRULE_unstringTallyingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5525)
		p.Match(Cobol85ParserTALLYING)
	}
	p.SetState(5527)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIN {
		{
			p.SetState(5526)
			p.Match(Cobol85ParserIN)
		}

	}
	{
		p.SetState(5529)
		p.QualifiedDataName()
	}

	return localctx
}

// IUseStatementContext is an interface to support dynamic dispatch.
type IUseStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseStatementContext differentiates from other interfaces.
	IsUseStatementContext()
}

type UseStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseStatementContext() *UseStatementContext {
	var p = new(UseStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useStatement
	return p
}

func (*UseStatementContext) IsUseStatementContext() {}

func NewUseStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseStatementContext {
	var p = new(UseStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useStatement

	return p
}

func (s *UseStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UseStatementContext) USE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUSE, 0)
}

func (s *UseStatementContext) UseAfterClause() IUseAfterClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseAfterClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseAfterClauseContext)
}

func (s *UseStatementContext) UseDebugClause() IUseDebugClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDebugClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDebugClauseContext)
}

func (s *UseStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseStatement(s)
	}
}

func (s *UseStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseStatement(s)
	}
}

func (s *UseStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseStatement() (localctx IUseStatementContext) {
	this := p
	_ = this

	localctx = NewUseStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 986, Cobol85ParserRULE_useStatement)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5531)
		p.Match(Cobol85ParserUSE)
	}
	p.SetState(5534)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserAFTER, Cobol85ParserGLOBAL:
		{
			p.SetState(5532)
			p.UseAfterClause()
		}

	case Cobol85ParserDEBUGGING, Cobol85ParserFOR:
		{
			p.SetState(5533)
			p.UseDebugClause()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUseAfterClauseContext is an interface to support dynamic dispatch.
type IUseAfterClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseAfterClauseContext differentiates from other interfaces.
	IsUseAfterClauseContext()
}

type UseAfterClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAfterClauseContext() *UseAfterClauseContext {
	var p = new(UseAfterClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useAfterClause
	return p
}

func (*UseAfterClauseContext) IsUseAfterClauseContext() {}

func NewUseAfterClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAfterClauseContext {
	var p = new(UseAfterClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useAfterClause

	return p
}

func (s *UseAfterClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAfterClauseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *UseAfterClauseContext) PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURE, 0)
}

func (s *UseAfterClauseContext) UseAfterOn() IUseAfterOnContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseAfterOnContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseAfterOnContext)
}

func (s *UseAfterClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *UseAfterClauseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *UseAfterClauseContext) GLOBAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGLOBAL, 0)
}

func (s *UseAfterClauseContext) STANDARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSTANDARD, 0)
}

func (s *UseAfterClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *UseAfterClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAfterClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAfterClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseAfterClause(s)
	}
}

func (s *UseAfterClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseAfterClause(s)
	}
}

func (s *UseAfterClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseAfterClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseAfterClause() (localctx IUseAfterClauseContext) {
	this := p
	_ = this

	localctx = NewUseAfterClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 988, Cobol85ParserRULE_useAfterClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5537)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserGLOBAL {
		{
			p.SetState(5536)
			p.Match(Cobol85ParserGLOBAL)
		}

	}
	{
		p.SetState(5539)
		p.Match(Cobol85ParserAFTER)
	}
	p.SetState(5541)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserSTANDARD {
		{
			p.SetState(5540)
			p.Match(Cobol85ParserSTANDARD)
		}

	}
	{
		p.SetState(5543)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserERROR || _la == Cobol85ParserEXCEPTION) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5544)
		p.Match(Cobol85ParserPROCEDURE)
	}
	p.SetState(5546)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5545)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5548)
		p.UseAfterOn()
	}

	return localctx
}

// IUseAfterOnContext is an interface to support dynamic dispatch.
type IUseAfterOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseAfterOnContext differentiates from other interfaces.
	IsUseAfterOnContext()
}

type UseAfterOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseAfterOnContext() *UseAfterOnContext {
	var p = new(UseAfterOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useAfterOn
	return p
}

func (*UseAfterOnContext) IsUseAfterOnContext() {}

func NewUseAfterOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseAfterOnContext {
	var p = new(UseAfterOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useAfterOn

	return p
}

func (s *UseAfterOnContext) GetParser() antlr.Parser { return s.parser }

func (s *UseAfterOnContext) INPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINPUT, 0)
}

func (s *UseAfterOnContext) OUTPUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOUTPUT, 0)
}

func (s *UseAfterOnContext) I_O() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserI_O, 0)
}

func (s *UseAfterOnContext) EXTEND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTEND, 0)
}

func (s *UseAfterOnContext) AllFileName() []IFileNameContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFileNameContext); ok {
			len++
		}
	}

	tst := make([]IFileNameContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFileNameContext); ok {
			tst[i] = t.(IFileNameContext)
			i++
		}
	}

	return tst
}

func (s *UseAfterOnContext) FileName(i int) IFileNameContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *UseAfterOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseAfterOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseAfterOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseAfterOn(s)
	}
}

func (s *UseAfterOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseAfterOn(s)
	}
}

func (s *UseAfterOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseAfterOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseAfterOn() (localctx IUseAfterOnContext) {
	this := p
	_ = this

	localctx = NewUseAfterOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 990, Cobol85ParserRULE_useAfterOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5559)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserINPUT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5550)
			p.Match(Cobol85ParserINPUT)
		}

	case Cobol85ParserOUTPUT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5551)
			p.Match(Cobol85ParserOUTPUT)
		}

	case Cobol85ParserI_O:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5552)
			p.Match(Cobol85ParserI_O)
		}

	case Cobol85ParserEXTEND:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5553)
			p.Match(Cobol85ParserEXTEND)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 5)
		p.SetState(5555)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER {
			{
				p.SetState(5554)
				p.FileName()
			}

			p.SetState(5557)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IUseDebugClauseContext is an interface to support dynamic dispatch.
type IUseDebugClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDebugClauseContext differentiates from other interfaces.
	IsUseDebugClauseContext()
}

type UseDebugClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDebugClauseContext() *UseDebugClauseContext {
	var p = new(UseDebugClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useDebugClause
	return p
}

func (*UseDebugClauseContext) IsUseDebugClauseContext() {}

func NewUseDebugClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDebugClauseContext {
	var p = new(UseDebugClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useDebugClause

	return p
}

func (s *UseDebugClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDebugClauseContext) DEBUGGING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUGGING, 0)
}

func (s *UseDebugClauseContext) FOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOR, 0)
}

func (s *UseDebugClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *UseDebugClauseContext) AllUseDebugOn() []IUseDebugOnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUseDebugOnContext); ok {
			len++
		}
	}

	tst := make([]IUseDebugOnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUseDebugOnContext); ok {
			tst[i] = t.(IUseDebugOnContext)
			i++
		}
	}

	return tst
}

func (s *UseDebugClauseContext) UseDebugOn(i int) IUseDebugOnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUseDebugOnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUseDebugOnContext)
}

func (s *UseDebugClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDebugClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDebugClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseDebugClause(s)
	}
}

func (s *UseDebugClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseDebugClause(s)
	}
}

func (s *UseDebugClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseDebugClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseDebugClause() (localctx IUseDebugClauseContext) {
	this := p
	_ = this

	localctx = NewUseDebugClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 992, Cobol85ParserRULE_useDebugClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5562)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFOR {
		{
			p.SetState(5561)
			p.Match(Cobol85ParserFOR)
		}

	}
	{
		p.SetState(5564)
		p.Match(Cobol85ParserDEBUGGING)
	}
	p.SetState(5566)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5565)
			p.Match(Cobol85ParserON)
		}

	}
	p.SetState(5569)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822338) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || (int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&47) != 0 {
		{
			p.SetState(5568)
			p.UseDebugOn()
		}

		p.SetState(5571)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IUseDebugOnContext is an interface to support dynamic dispatch.
type IUseDebugOnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsUseDebugOnContext differentiates from other interfaces.
	IsUseDebugOnContext()
}

type UseDebugOnContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUseDebugOnContext() *UseDebugOnContext {
	var p = new(UseDebugOnContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_useDebugOn
	return p
}

func (*UseDebugOnContext) IsUseDebugOnContext() {}

func NewUseDebugOnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UseDebugOnContext {
	var p = new(UseDebugOnContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_useDebugOn

	return p
}

func (s *UseDebugOnContext) GetParser() antlr.Parser { return s.parser }

func (s *UseDebugOnContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *UseDebugOnContext) PROCEDURES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCEDURES, 0)
}

func (s *UseDebugOnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UseDebugOnContext) REFERENCES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREFERENCES, 0)
}

func (s *UseDebugOnContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *UseDebugOnContext) ProcedureName() IProcedureNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureNameContext)
}

func (s *UseDebugOnContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *UseDebugOnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UseDebugOnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UseDebugOnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterUseDebugOn(s)
	}
}

func (s *UseDebugOnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitUseDebugOn(s)
	}
}

func (s *UseDebugOnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitUseDebugOn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) UseDebugOn() (localctx IUseDebugOnContext) {
	this := p
	_ = this

	localctx = NewUseDebugOnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 994, Cobol85ParserRULE_useDebugOn)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5585)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 867, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5573)
			p.Match(Cobol85ParserALL)
		}
		{
			p.SetState(5574)
			p.Match(Cobol85ParserPROCEDURES)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5575)
			p.Match(Cobol85ParserALL)
		}
		p.SetState(5577)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserREFERENCES {
			{
				p.SetState(5576)
				p.Match(Cobol85ParserREFERENCES)
			}

		}
		p.SetState(5580)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(5579)
				p.Match(Cobol85ParserOF)
			}

		}
		{
			p.SetState(5582)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5583)
			p.ProcedureName()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5584)
			p.FileName()
		}

	}

	return localctx
}

// IWriteStatementContext is an interface to support dynamic dispatch.
type IWriteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteStatementContext differentiates from other interfaces.
	IsWriteStatementContext()
}

type WriteStatementContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteStatementContext() *WriteStatementContext {
	var p = new(WriteStatementContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeStatement
	return p
}

func (*WriteStatementContext) IsWriteStatementContext() {}

func NewWriteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteStatementContext {
	var p = new(WriteStatementContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeStatement

	return p
}

func (s *WriteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteStatementContext) WRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWRITE, 0)
}

func (s *WriteStatementContext) RecordName() IRecordNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRecordNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRecordNameContext)
}

func (s *WriteStatementContext) WriteFromPhrase() IWriteFromPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteFromPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteFromPhraseContext)
}

func (s *WriteStatementContext) WriteAdvancingPhrase() IWriteAdvancingPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteAdvancingPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingPhraseContext)
}

func (s *WriteStatementContext) WriteAtEndOfPagePhrase() IWriteAtEndOfPagePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteAtEndOfPagePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteAtEndOfPagePhraseContext)
}

func (s *WriteStatementContext) WriteNotAtEndOfPagePhrase() IWriteNotAtEndOfPagePhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteNotAtEndOfPagePhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteNotAtEndOfPagePhraseContext)
}

func (s *WriteStatementContext) InvalidKeyPhrase() IInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvalidKeyPhraseContext)
}

func (s *WriteStatementContext) NotInvalidKeyPhrase() INotInvalidKeyPhraseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotInvalidKeyPhraseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotInvalidKeyPhraseContext)
}

func (s *WriteStatementContext) END_WRITE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_WRITE, 0)
}

func (s *WriteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteStatement(s)
	}
}

func (s *WriteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteStatement(s)
	}
}

func (s *WriteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteStatement() (localctx IWriteStatementContext) {
	this := p
	_ = this

	localctx = NewWriteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 996, Cobol85ParserRULE_writeStatement)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5587)
		p.Match(Cobol85ParserWRITE)
	}
	{
		p.SetState(5588)
		p.RecordName()
	}
	p.SetState(5590)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserFROM {
		{
			p.SetState(5589)
			p.WriteFromPhrase()
		}

	}
	p.SetState(5593)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE {
		{
			p.SetState(5592)
			p.WriteAdvancingPhrase()
		}

	}
	p.SetState(5596)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 870, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5595)
			p.WriteAtEndOfPagePhrase()
		}

	}
	p.SetState(5599)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 871, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5598)
			p.WriteNotAtEndOfPagePhrase()
		}

	}
	p.SetState(5602)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 872, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5601)
			p.InvalidKeyPhrase()
		}

	}
	p.SetState(5605)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 873, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5604)
			p.NotInvalidKeyPhrase()
		}

	}
	p.SetState(5608)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 874, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5607)
			p.Match(Cobol85ParserEND_WRITE)
		}

	}

	return localctx
}

// IWriteFromPhraseContext is an interface to support dynamic dispatch.
type IWriteFromPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteFromPhraseContext differentiates from other interfaces.
	IsWriteFromPhraseContext()
}

type WriteFromPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteFromPhraseContext() *WriteFromPhraseContext {
	var p = new(WriteFromPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeFromPhrase
	return p
}

func (*WriteFromPhraseContext) IsWriteFromPhraseContext() {}

func NewWriteFromPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteFromPhraseContext {
	var p = new(WriteFromPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeFromPhrase

	return p
}

func (s *WriteFromPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteFromPhraseContext) FROM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFROM, 0)
}

func (s *WriteFromPhraseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteFromPhraseContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WriteFromPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteFromPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteFromPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteFromPhrase(s)
	}
}

func (s *WriteFromPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteFromPhrase(s)
	}
}

func (s *WriteFromPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteFromPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteFromPhrase() (localctx IWriteFromPhraseContext) {
	this := p
	_ = this

	localctx = NewWriteFromPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 998, Cobol85ParserRULE_writeFromPhrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5610)
		p.Match(Cobol85ParserFROM)
	}
	p.SetState(5613)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 875, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5611)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5612)
			p.Literal()
		}

	}

	return localctx
}

// IWriteAdvancingPhraseContext is an interface to support dynamic dispatch.
type IWriteAdvancingPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingPhraseContext differentiates from other interfaces.
	IsWriteAdvancingPhraseContext()
}

type WriteAdvancingPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingPhraseContext() *WriteAdvancingPhraseContext {
	var p = new(WriteAdvancingPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPhrase
	return p
}

func (*WriteAdvancingPhraseContext) IsWriteAdvancingPhraseContext() {}

func NewWriteAdvancingPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingPhraseContext {
	var p = new(WriteAdvancingPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPhrase

	return p
}

func (s *WriteAdvancingPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingPhraseContext) BEFORE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEFORE, 0)
}

func (s *WriteAdvancingPhraseContext) AFTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAFTER, 0)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingPage() IWriteAdvancingPageContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteAdvancingPageContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingPageContext)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingLines() IWriteAdvancingLinesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteAdvancingLinesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingLinesContext)
}

func (s *WriteAdvancingPhraseContext) WriteAdvancingMnemonic() IWriteAdvancingMnemonicContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWriteAdvancingMnemonicContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWriteAdvancingMnemonicContext)
}

func (s *WriteAdvancingPhraseContext) ADVANCING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADVANCING, 0)
}

func (s *WriteAdvancingPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingPhrase(s)
	}
}

func (s *WriteAdvancingPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingPhrase(s)
	}
}

func (s *WriteAdvancingPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingPhrase() (localctx IWriteAdvancingPhraseContext) {
	this := p
	_ = this

	localctx = NewWriteAdvancingPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1000, Cobol85ParserRULE_writeAdvancingPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5615)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAFTER || _la == Cobol85ParserBEFORE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5617)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserADVANCING {
		{
			p.SetState(5616)
			p.Match(Cobol85ParserADVANCING)
		}

	}
	p.SetState(5622)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 877, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5619)
			p.WriteAdvancingPage()
		}

	case 2:
		{
			p.SetState(5620)
			p.WriteAdvancingLines()
		}

	case 3:
		{
			p.SetState(5621)
			p.WriteAdvancingMnemonic()
		}

	}

	return localctx
}

// IWriteAdvancingPageContext is an interface to support dynamic dispatch.
type IWriteAdvancingPageContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingPageContext differentiates from other interfaces.
	IsWriteAdvancingPageContext()
}

type WriteAdvancingPageContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingPageContext() *WriteAdvancingPageContext {
	var p = new(WriteAdvancingPageContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPage
	return p
}

func (*WriteAdvancingPageContext) IsWriteAdvancingPageContext() {}

func NewWriteAdvancingPageContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingPageContext {
	var p = new(WriteAdvancingPageContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingPage

	return p
}

func (s *WriteAdvancingPageContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingPageContext) PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE, 0)
}

func (s *WriteAdvancingPageContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingPageContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingPageContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingPage(s)
	}
}

func (s *WriteAdvancingPageContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingPage(s)
	}
}

func (s *WriteAdvancingPageContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingPage(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingPage() (localctx IWriteAdvancingPageContext) {
	this := p
	_ = this

	localctx = NewWriteAdvancingPageContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1002, Cobol85ParserRULE_writeAdvancingPage)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5624)
		p.Match(Cobol85ParserPAGE)
	}

	return localctx
}

// IWriteAdvancingLinesContext is an interface to support dynamic dispatch.
type IWriteAdvancingLinesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingLinesContext differentiates from other interfaces.
	IsWriteAdvancingLinesContext()
}

type WriteAdvancingLinesContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingLinesContext() *WriteAdvancingLinesContext {
	var p = new(WriteAdvancingLinesContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingLines
	return p
}

func (*WriteAdvancingLinesContext) IsWriteAdvancingLinesContext() {}

func NewWriteAdvancingLinesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingLinesContext {
	var p = new(WriteAdvancingLinesContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingLines

	return p
}

func (s *WriteAdvancingLinesContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingLinesContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WriteAdvancingLinesContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *WriteAdvancingLinesContext) LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE, 0)
}

func (s *WriteAdvancingLinesContext) LINES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINES, 0)
}

func (s *WriteAdvancingLinesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingLinesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingLinesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingLines(s)
	}
}

func (s *WriteAdvancingLinesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingLines(s)
	}
}

func (s *WriteAdvancingLinesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingLines(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingLines() (localctx IWriteAdvancingLinesContext) {
	this := p
	_ = this

	localctx = NewWriteAdvancingLinesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1004, Cobol85ParserRULE_writeAdvancingLines)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5628)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 878, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5626)
			p.Identifier()
		}

	case 2:
		{
			p.SetState(5627)
			p.Literal()
		}

	}
	p.SetState(5631)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserLINE || _la == Cobol85ParserLINES {
		{
			p.SetState(5630)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserLINE || _la == Cobol85ParserLINES) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IWriteAdvancingMnemonicContext is an interface to support dynamic dispatch.
type IWriteAdvancingMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAdvancingMnemonicContext differentiates from other interfaces.
	IsWriteAdvancingMnemonicContext()
}

type WriteAdvancingMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAdvancingMnemonicContext() *WriteAdvancingMnemonicContext {
	var p = new(WriteAdvancingMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingMnemonic
	return p
}

func (*WriteAdvancingMnemonicContext) IsWriteAdvancingMnemonicContext() {}

func NewWriteAdvancingMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAdvancingMnemonicContext {
	var p = new(WriteAdvancingMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAdvancingMnemonic

	return p
}

func (s *WriteAdvancingMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAdvancingMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *WriteAdvancingMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAdvancingMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAdvancingMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAdvancingMnemonic(s)
	}
}

func (s *WriteAdvancingMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAdvancingMnemonic(s)
	}
}

func (s *WriteAdvancingMnemonicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAdvancingMnemonic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAdvancingMnemonic() (localctx IWriteAdvancingMnemonicContext) {
	this := p
	_ = this

	localctx = NewWriteAdvancingMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1006, Cobol85ParserRULE_writeAdvancingMnemonic)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5633)
		p.MnemonicName()
	}

	return localctx
}

// IWriteAtEndOfPagePhraseContext is an interface to support dynamic dispatch.
type IWriteAtEndOfPagePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteAtEndOfPagePhraseContext differentiates from other interfaces.
	IsWriteAtEndOfPagePhraseContext()
}

type WriteAtEndOfPagePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteAtEndOfPagePhraseContext() *WriteAtEndOfPagePhraseContext {
	var p = new(WriteAtEndOfPagePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeAtEndOfPagePhrase
	return p
}

func (*WriteAtEndOfPagePhraseContext) IsWriteAtEndOfPagePhraseContext() {}

func NewWriteAtEndOfPagePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteAtEndOfPagePhraseContext {
	var p = new(WriteAtEndOfPagePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeAtEndOfPagePhrase

	return p
}

func (s *WriteAtEndOfPagePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteAtEndOfPagePhraseContext) END_OF_PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_OF_PAGE, 0)
}

func (s *WriteAtEndOfPagePhraseContext) EOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOP, 0)
}

func (s *WriteAtEndOfPagePhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *WriteAtEndOfPagePhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WriteAtEndOfPagePhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WriteAtEndOfPagePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteAtEndOfPagePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteAtEndOfPagePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteAtEndOfPagePhrase(s)
	}
}

func (s *WriteAtEndOfPagePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteAtEndOfPagePhrase(s)
	}
}

func (s *WriteAtEndOfPagePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteAtEndOfPagePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteAtEndOfPagePhrase() (localctx IWriteAtEndOfPagePhraseContext) {
	this := p
	_ = this

	localctx = NewWriteAtEndOfPagePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1008, Cobol85ParserRULE_writeAtEndOfPagePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5636)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5635)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5638)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEND_OF_PAGE || _la == Cobol85ParserEOP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5642)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 881, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5639)
				p.Statement()
			}

		}
		p.SetState(5644)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 881, p.GetParserRuleContext())
	}

	return localctx
}

// IWriteNotAtEndOfPagePhraseContext is an interface to support dynamic dispatch.
type IWriteNotAtEndOfPagePhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWriteNotAtEndOfPagePhraseContext differentiates from other interfaces.
	IsWriteNotAtEndOfPagePhraseContext()
}

type WriteNotAtEndOfPagePhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWriteNotAtEndOfPagePhraseContext() *WriteNotAtEndOfPagePhraseContext {
	var p = new(WriteNotAtEndOfPagePhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_writeNotAtEndOfPagePhrase
	return p
}

func (*WriteNotAtEndOfPagePhraseContext) IsWriteNotAtEndOfPagePhraseContext() {}

func NewWriteNotAtEndOfPagePhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WriteNotAtEndOfPagePhraseContext {
	var p = new(WriteNotAtEndOfPagePhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_writeNotAtEndOfPagePhrase

	return p
}

func (s *WriteNotAtEndOfPagePhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *WriteNotAtEndOfPagePhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) END_OF_PAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND_OF_PAGE, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) EOP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOP, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *WriteNotAtEndOfPagePhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *WriteNotAtEndOfPagePhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *WriteNotAtEndOfPagePhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WriteNotAtEndOfPagePhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WriteNotAtEndOfPagePhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterWriteNotAtEndOfPagePhrase(s)
	}
}

func (s *WriteNotAtEndOfPagePhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitWriteNotAtEndOfPagePhrase(s)
	}
}

func (s *WriteNotAtEndOfPagePhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitWriteNotAtEndOfPagePhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) WriteNotAtEndOfPagePhrase() (localctx IWriteNotAtEndOfPagePhraseContext) {
	this := p
	_ = this

	localctx = NewWriteNotAtEndOfPagePhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1010, Cobol85ParserRULE_writeNotAtEndOfPagePhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5645)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5647)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5646)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5649)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserEND_OF_PAGE || _la == Cobol85ParserEOP) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5653)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 883, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5650)
				p.Statement()
			}

		}
		p.SetState(5655)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 883, p.GetParserRuleContext())
	}

	return localctx
}

// IAtEndPhraseContext is an interface to support dynamic dispatch.
type IAtEndPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtEndPhraseContext differentiates from other interfaces.
	IsAtEndPhraseContext()
}

type AtEndPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtEndPhraseContext() *AtEndPhraseContext {
	var p = new(AtEndPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_atEndPhrase
	return p
}

func (*AtEndPhraseContext) IsAtEndPhraseContext() {}

func NewAtEndPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtEndPhraseContext {
	var p = new(AtEndPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_atEndPhrase

	return p
}

func (s *AtEndPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *AtEndPhraseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *AtEndPhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *AtEndPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *AtEndPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *AtEndPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtEndPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtEndPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAtEndPhrase(s)
	}
}

func (s *AtEndPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAtEndPhrase(s)
	}
}

func (s *AtEndPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAtEndPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AtEndPhrase() (localctx IAtEndPhraseContext) {
	this := p
	_ = this

	localctx = NewAtEndPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1012, Cobol85ParserRULE_atEndPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5657)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5656)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5659)
		p.Match(Cobol85ParserEND)
	}
	p.SetState(5663)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 885, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5660)
				p.Statement()
			}

		}
		p.SetState(5665)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 885, p.GetParserRuleContext())
	}

	return localctx
}

// INotAtEndPhraseContext is an interface to support dynamic dispatch.
type INotAtEndPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotAtEndPhraseContext differentiates from other interfaces.
	IsNotAtEndPhraseContext()
}

type NotAtEndPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotAtEndPhraseContext() *NotAtEndPhraseContext {
	var p = new(NotAtEndPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notAtEndPhrase
	return p
}

func (*NotAtEndPhraseContext) IsNotAtEndPhraseContext() {}

func NewNotAtEndPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotAtEndPhraseContext {
	var p = new(NotAtEndPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notAtEndPhrase

	return p
}

func (s *NotAtEndPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotAtEndPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotAtEndPhraseContext) END() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEND, 0)
}

func (s *NotAtEndPhraseContext) AT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAT, 0)
}

func (s *NotAtEndPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *NotAtEndPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotAtEndPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotAtEndPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotAtEndPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotAtEndPhrase(s)
	}
}

func (s *NotAtEndPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotAtEndPhrase(s)
	}
}

func (s *NotAtEndPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotAtEndPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotAtEndPhrase() (localctx INotAtEndPhraseContext) {
	this := p
	_ = this

	localctx = NewNotAtEndPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1014, Cobol85ParserRULE_notAtEndPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5666)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserAT {
		{
			p.SetState(5667)
			p.Match(Cobol85ParserAT)
		}

	}
	{
		p.SetState(5670)
		p.Match(Cobol85ParserEND)
	}
	p.SetState(5674)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5671)
				p.Statement()
			}

		}
		p.SetState(5676)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 887, p.GetParserRuleContext())
	}

	return localctx
}

// IInvalidKeyPhraseContext is an interface to support dynamic dispatch.
type IInvalidKeyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInvalidKeyPhraseContext differentiates from other interfaces.
	IsInvalidKeyPhraseContext()
}

type InvalidKeyPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvalidKeyPhraseContext() *InvalidKeyPhraseContext {
	var p = new(InvalidKeyPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_invalidKeyPhrase
	return p
}

func (*InvalidKeyPhraseContext) IsInvalidKeyPhraseContext() {}

func NewInvalidKeyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvalidKeyPhraseContext {
	var p = new(InvalidKeyPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_invalidKeyPhrase

	return p
}

func (s *InvalidKeyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *InvalidKeyPhraseContext) INVALID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVALID, 0)
}

func (s *InvalidKeyPhraseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *InvalidKeyPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *InvalidKeyPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *InvalidKeyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvalidKeyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InvalidKeyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInvalidKeyPhrase(s)
	}
}

func (s *InvalidKeyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInvalidKeyPhrase(s)
	}
}

func (s *InvalidKeyPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInvalidKeyPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InvalidKeyPhrase() (localctx IInvalidKeyPhraseContext) {
	this := p
	_ = this

	localctx = NewInvalidKeyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1016, Cobol85ParserRULE_invalidKeyPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5677)
		p.Match(Cobol85ParserINVALID)
	}
	p.SetState(5679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5678)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5684)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 889, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5681)
				p.Statement()
			}

		}
		p.SetState(5686)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 889, p.GetParserRuleContext())
	}

	return localctx
}

// INotInvalidKeyPhraseContext is an interface to support dynamic dispatch.
type INotInvalidKeyPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotInvalidKeyPhraseContext differentiates from other interfaces.
	IsNotInvalidKeyPhraseContext()
}

type NotInvalidKeyPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotInvalidKeyPhraseContext() *NotInvalidKeyPhraseContext {
	var p = new(NotInvalidKeyPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notInvalidKeyPhrase
	return p
}

func (*NotInvalidKeyPhraseContext) IsNotInvalidKeyPhraseContext() {}

func NewNotInvalidKeyPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotInvalidKeyPhraseContext {
	var p = new(NotInvalidKeyPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notInvalidKeyPhrase

	return p
}

func (s *NotInvalidKeyPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotInvalidKeyPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotInvalidKeyPhraseContext) INVALID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINVALID, 0)
}

func (s *NotInvalidKeyPhraseContext) KEY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEY, 0)
}

func (s *NotInvalidKeyPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *NotInvalidKeyPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotInvalidKeyPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotInvalidKeyPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotInvalidKeyPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotInvalidKeyPhrase(s)
	}
}

func (s *NotInvalidKeyPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotInvalidKeyPhrase(s)
	}
}

func (s *NotInvalidKeyPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotInvalidKeyPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotInvalidKeyPhrase() (localctx INotInvalidKeyPhraseContext) {
	this := p
	_ = this

	localctx = NewNotInvalidKeyPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1018, Cobol85ParserRULE_notInvalidKeyPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5687)
		p.Match(Cobol85ParserNOT)
	}
	{
		p.SetState(5688)
		p.Match(Cobol85ParserINVALID)
	}
	p.SetState(5690)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserKEY {
		{
			p.SetState(5689)
			p.Match(Cobol85ParserKEY)
		}

	}
	p.SetState(5695)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 891, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5692)
				p.Statement()
			}

		}
		p.SetState(5697)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 891, p.GetParserRuleContext())
	}

	return localctx
}

// IOnOverflowPhraseContext is an interface to support dynamic dispatch.
type IOnOverflowPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnOverflowPhraseContext differentiates from other interfaces.
	IsOnOverflowPhraseContext()
}

type OnOverflowPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnOverflowPhraseContext() *OnOverflowPhraseContext {
	var p = new(OnOverflowPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onOverflowPhrase
	return p
}

func (*OnOverflowPhraseContext) IsOnOverflowPhraseContext() {}

func NewOnOverflowPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnOverflowPhraseContext {
	var p = new(OnOverflowPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onOverflowPhrase

	return p
}

func (s *OnOverflowPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnOverflowPhraseContext) OVERFLOW() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERFLOW, 0)
}

func (s *OnOverflowPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnOverflowPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *OnOverflowPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnOverflowPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnOverflowPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnOverflowPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnOverflowPhrase(s)
	}
}

func (s *OnOverflowPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnOverflowPhrase(s)
	}
}

func (s *OnOverflowPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOnOverflowPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OnOverflowPhrase() (localctx IOnOverflowPhraseContext) {
	this := p
	_ = this

	localctx = NewOnOverflowPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1020, Cobol85ParserRULE_onOverflowPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5699)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5698)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5701)
		p.Match(Cobol85ParserOVERFLOW)
	}
	p.SetState(5705)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 893, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5702)
				p.Statement()
			}

		}
		p.SetState(5707)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 893, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnOverflowPhraseContext is an interface to support dynamic dispatch.
type INotOnOverflowPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnOverflowPhraseContext differentiates from other interfaces.
	IsNotOnOverflowPhraseContext()
}

type NotOnOverflowPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnOverflowPhraseContext() *NotOnOverflowPhraseContext {
	var p = new(NotOnOverflowPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnOverflowPhrase
	return p
}

func (*NotOnOverflowPhraseContext) IsNotOnOverflowPhraseContext() {}

func NewNotOnOverflowPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnOverflowPhraseContext {
	var p = new(NotOnOverflowPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnOverflowPhrase

	return p
}

func (s *NotOnOverflowPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnOverflowPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnOverflowPhraseContext) OVERFLOW() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERFLOW, 0)
}

func (s *NotOnOverflowPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnOverflowPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *NotOnOverflowPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnOverflowPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnOverflowPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnOverflowPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnOverflowPhrase(s)
	}
}

func (s *NotOnOverflowPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnOverflowPhrase(s)
	}
}

func (s *NotOnOverflowPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotOnOverflowPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotOnOverflowPhrase() (localctx INotOnOverflowPhraseContext) {
	this := p
	_ = this

	localctx = NewNotOnOverflowPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1022, Cobol85ParserRULE_notOnOverflowPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5708)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5710)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5709)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5712)
		p.Match(Cobol85ParserOVERFLOW)
	}
	p.SetState(5716)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 895, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5713)
				p.Statement()
			}

		}
		p.SetState(5718)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 895, p.GetParserRuleContext())
	}

	return localctx
}

// IOnSizeErrorPhraseContext is an interface to support dynamic dispatch.
type IOnSizeErrorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnSizeErrorPhraseContext differentiates from other interfaces.
	IsOnSizeErrorPhraseContext()
}

type OnSizeErrorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnSizeErrorPhraseContext() *OnSizeErrorPhraseContext {
	var p = new(OnSizeErrorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onSizeErrorPhrase
	return p
}

func (*OnSizeErrorPhraseContext) IsOnSizeErrorPhraseContext() {}

func NewOnSizeErrorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnSizeErrorPhraseContext {
	var p = new(OnSizeErrorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onSizeErrorPhrase

	return p
}

func (s *OnSizeErrorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnSizeErrorPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *OnSizeErrorPhraseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *OnSizeErrorPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnSizeErrorPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *OnSizeErrorPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnSizeErrorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnSizeErrorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnSizeErrorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnSizeErrorPhrase(s)
	}
}

func (s *OnSizeErrorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnSizeErrorPhrase(s)
	}
}

func (s *OnSizeErrorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOnSizeErrorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OnSizeErrorPhrase() (localctx IOnSizeErrorPhraseContext) {
	this := p
	_ = this

	localctx = NewOnSizeErrorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1024, Cobol85ParserRULE_onSizeErrorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5720)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5719)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5722)
		p.Match(Cobol85ParserSIZE)
	}
	{
		p.SetState(5723)
		p.Match(Cobol85ParserERROR)
	}
	p.SetState(5727)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5724)
				p.Statement()
			}

		}
		p.SetState(5729)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 897, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnSizeErrorPhraseContext is an interface to support dynamic dispatch.
type INotOnSizeErrorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnSizeErrorPhraseContext differentiates from other interfaces.
	IsNotOnSizeErrorPhraseContext()
}

type NotOnSizeErrorPhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnSizeErrorPhraseContext() *NotOnSizeErrorPhraseContext {
	var p = new(NotOnSizeErrorPhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnSizeErrorPhrase
	return p
}

func (*NotOnSizeErrorPhraseContext) IsNotOnSizeErrorPhraseContext() {}

func NewNotOnSizeErrorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnSizeErrorPhraseContext {
	var p = new(NotOnSizeErrorPhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnSizeErrorPhrase

	return p
}

func (s *NotOnSizeErrorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnSizeErrorPhraseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnSizeErrorPhraseContext) SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSIZE, 0)
}

func (s *NotOnSizeErrorPhraseContext) ERROR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERROR, 0)
}

func (s *NotOnSizeErrorPhraseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnSizeErrorPhraseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *NotOnSizeErrorPhraseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnSizeErrorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnSizeErrorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnSizeErrorPhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnSizeErrorPhrase(s)
	}
}

func (s *NotOnSizeErrorPhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnSizeErrorPhrase(s)
	}
}

func (s *NotOnSizeErrorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotOnSizeErrorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotOnSizeErrorPhrase() (localctx INotOnSizeErrorPhraseContext) {
	this := p
	_ = this

	localctx = NewNotOnSizeErrorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1026, Cobol85ParserRULE_notOnSizeErrorPhrase)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5730)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5732)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5731)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5734)
		p.Match(Cobol85ParserSIZE)
	}
	{
		p.SetState(5735)
		p.Match(Cobol85ParserERROR)
	}
	p.SetState(5739)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 899, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5736)
				p.Statement()
			}

		}
		p.SetState(5741)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 899, p.GetParserRuleContext())
	}

	return localctx
}

// IOnExceptionClauseContext is an interface to support dynamic dispatch.
type IOnExceptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsOnExceptionClauseContext differentiates from other interfaces.
	IsOnExceptionClauseContext()
}

type OnExceptionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnExceptionClauseContext() *OnExceptionClauseContext {
	var p = new(OnExceptionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_onExceptionClause
	return p
}

func (*OnExceptionClauseContext) IsOnExceptionClauseContext() {}

func NewOnExceptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnExceptionClauseContext {
	var p = new(OnExceptionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_onExceptionClause

	return p
}

func (s *OnExceptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OnExceptionClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *OnExceptionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *OnExceptionClauseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *OnExceptionClauseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *OnExceptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnExceptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnExceptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterOnExceptionClause(s)
	}
}

func (s *OnExceptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitOnExceptionClause(s)
	}
}

func (s *OnExceptionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitOnExceptionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) OnExceptionClause() (localctx IOnExceptionClauseContext) {
	this := p
	_ = this

	localctx = NewOnExceptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1028, Cobol85ParserRULE_onExceptionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5743)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5742)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5745)
		p.Match(Cobol85ParserEXCEPTION)
	}
	p.SetState(5749)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5746)
				p.Statement()
			}

		}
		p.SetState(5751)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 901, p.GetParserRuleContext())
	}

	return localctx
}

// INotOnExceptionClauseContext is an interface to support dynamic dispatch.
type INotOnExceptionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNotOnExceptionClauseContext differentiates from other interfaces.
	IsNotOnExceptionClauseContext()
}

type NotOnExceptionClauseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotOnExceptionClauseContext() *NotOnExceptionClauseContext {
	var p = new(NotOnExceptionClauseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_notOnExceptionClause
	return p
}

func (*NotOnExceptionClauseContext) IsNotOnExceptionClauseContext() {}

func NewNotOnExceptionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotOnExceptionClauseContext {
	var p = new(NotOnExceptionClauseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_notOnExceptionClause

	return p
}

func (s *NotOnExceptionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *NotOnExceptionClauseContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *NotOnExceptionClauseContext) EXCEPTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCEPTION, 0)
}

func (s *NotOnExceptionClauseContext) ON() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserON, 0)
}

func (s *NotOnExceptionClauseContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *NotOnExceptionClauseContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *NotOnExceptionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotOnExceptionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotOnExceptionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNotOnExceptionClause(s)
	}
}

func (s *NotOnExceptionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNotOnExceptionClause(s)
	}
}

func (s *NotOnExceptionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNotOnExceptionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NotOnExceptionClause() (localctx INotOnExceptionClauseContext) {
	this := p
	_ = this

	localctx = NewNotOnExceptionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1030, Cobol85ParserRULE_notOnExceptionClause)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5752)
		p.Match(Cobol85ParserNOT)
	}
	p.SetState(5754)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserON {
		{
			p.SetState(5753)
			p.Match(Cobol85ParserON)
		}

	}
	{
		p.SetState(5756)
		p.Match(Cobol85ParserEXCEPTION)
	}
	p.SetState(5760)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 903, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5757)
				p.Statement()
			}

		}
		p.SetState(5762)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 903, p.GetParserRuleContext())
	}

	return localctx
}

// IArithmeticExpressionContext is an interface to support dynamic dispatch.
type IArithmeticExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArithmeticExpressionContext differentiates from other interfaces.
	IsArithmeticExpressionContext()
}

type ArithmeticExpressionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArithmeticExpressionContext() *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_arithmeticExpression
	return p
}

func (*ArithmeticExpressionContext) IsArithmeticExpressionContext() {}

func NewArithmeticExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArithmeticExpressionContext {
	var p = new(ArithmeticExpressionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_arithmeticExpression

	return p
}

func (s *ArithmeticExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ArithmeticExpressionContext) MultDivs() IMultDivsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultDivsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultDivsContext)
}

func (s *ArithmeticExpressionContext) AllPlusMinus() []IPlusMinusContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPlusMinusContext); ok {
			len++
		}
	}

	tst := make([]IPlusMinusContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPlusMinusContext); ok {
			tst[i] = t.(IPlusMinusContext)
			i++
		}
	}

	return tst
}

func (s *ArithmeticExpressionContext) PlusMinus(i int) IPlusMinusContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPlusMinusContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPlusMinusContext)
}

func (s *ArithmeticExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArithmeticExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArithmeticExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitArithmeticExpression(s)
	}
}

func (s *ArithmeticExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitArithmeticExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ArithmeticExpression() (localctx IArithmeticExpressionContext) {
	this := p
	_ = this

	localctx = NewArithmeticExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1032, Cobol85ParserRULE_arithmeticExpression)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5763)
		p.MultDivs()
	}
	p.SetState(5767)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 904, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5764)
				p.PlusMinus()
			}

		}
		p.SetState(5769)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 904, p.GetParserRuleContext())
	}

	return localctx
}

// IPlusMinusContext is an interface to support dynamic dispatch.
type IPlusMinusContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPlusMinusContext differentiates from other interfaces.
	IsPlusMinusContext()
}

type PlusMinusContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPlusMinusContext() *PlusMinusContext {
	var p = new(PlusMinusContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_plusMinus
	return p
}

func (*PlusMinusContext) IsPlusMinusContext() {}

func NewPlusMinusContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PlusMinusContext {
	var p = new(PlusMinusContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_plusMinus

	return p
}

func (s *PlusMinusContext) GetParser() antlr.Parser { return s.parser }

func (s *PlusMinusContext) MultDivs() IMultDivsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultDivsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultDivsContext)
}

func (s *PlusMinusContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PlusMinusContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PlusMinusContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PlusMinusContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PlusMinusContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPlusMinus(s)
	}
}

func (s *PlusMinusContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPlusMinus(s)
	}
}

func (s *PlusMinusContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPlusMinus(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) PlusMinus() (localctx IPlusMinusContext) {
	this := p
	_ = this

	localctx = NewPlusMinusContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1034, Cobol85ParserRULE_plusMinus)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5770)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5771)
		p.MultDivs()
	}

	return localctx
}

// IMultDivsContext is an interface to support dynamic dispatch.
type IMultDivsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultDivsContext differentiates from other interfaces.
	IsMultDivsContext()
}

type MultDivsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivsContext() *MultDivsContext {
	var p = new(MultDivsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multDivs
	return p
}

func (*MultDivsContext) IsMultDivsContext() {}

func NewMultDivsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivsContext {
	var p = new(MultDivsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multDivs

	return p
}

func (s *MultDivsContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivsContext) Powers() IPowersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowersContext)
}

func (s *MultDivsContext) AllMultDiv() []IMultDivContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMultDivContext); ok {
			len++
		}
	}

	tst := make([]IMultDivContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMultDivContext); ok {
			tst[i] = t.(IMultDivContext)
			i++
		}
	}

	return tst
}

func (s *MultDivsContext) MultDiv(i int) IMultDivContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMultDivContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMultDivContext)
}

func (s *MultDivsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultDivs(s)
	}
}

func (s *MultDivsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultDivs(s)
	}
}

func (s *MultDivsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultDivs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultDivs() (localctx IMultDivsContext) {
	this := p
	_ = this

	localctx = NewMultDivsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1036, Cobol85ParserRULE_multDivs)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5773)
		p.Powers()
	}
	p.SetState(5777)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserASTERISKCHAR || _la == Cobol85ParserSLASHCHAR {
		{
			p.SetState(5774)
			p.MultDiv()
		}

		p.SetState(5779)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IMultDivContext is an interface to support dynamic dispatch.
type IMultDivContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMultDivContext differentiates from other interfaces.
	IsMultDivContext()
}

type MultDivContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMultDivContext() *MultDivContext {
	var p = new(MultDivContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_multDiv
	return p
}

func (*MultDivContext) IsMultDivContext() {}

func NewMultDivContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MultDivContext {
	var p = new(MultDivContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_multDiv

	return p
}

func (s *MultDivContext) GetParser() antlr.Parser { return s.parser }

func (s *MultDivContext) Powers() IPowersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowersContext)
}

func (s *MultDivContext) ASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASTERISKCHAR, 0)
}

func (s *MultDivContext) SLASHCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSLASHCHAR, 0)
}

func (s *MultDivContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultDivContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MultDivContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMultDiv(s)
	}
}

func (s *MultDivContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMultDiv(s)
	}
}

func (s *MultDivContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMultDiv(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MultDiv() (localctx IMultDivContext) {
	this := p
	_ = this

	localctx = NewMultDivContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1038, Cobol85ParserRULE_multDiv)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5780)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserASTERISKCHAR || _la == Cobol85ParserSLASHCHAR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5781)
		p.Powers()
	}

	return localctx
}

// IPowersContext is an interface to support dynamic dispatch.
type IPowersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowersContext differentiates from other interfaces.
	IsPowersContext()
}

type PowersContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowersContext() *PowersContext {
	var p = new(PowersContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_powers
	return p
}

func (*PowersContext) IsPowersContext() {}

func NewPowersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowersContext {
	var p = new(PowersContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_powers

	return p
}

func (s *PowersContext) GetParser() antlr.Parser { return s.parser }

func (s *PowersContext) Basis() IBasisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasisContext)
}

func (s *PowersContext) AllPower() []IPowerContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPowerContext); ok {
			len++
		}
	}

	tst := make([]IPowerContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPowerContext); ok {
			tst[i] = t.(IPowerContext)
			i++
		}
	}

	return tst
}

func (s *PowersContext) Power(i int) IPowerContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPowerContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPowerContext)
}

func (s *PowersContext) PLUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPLUSCHAR, 0)
}

func (s *PowersContext) MINUSCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMINUSCHAR, 0)
}

func (s *PowersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPowers(s)
	}
}

func (s *PowersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPowers(s)
	}
}

func (s *PowersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPowers(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Powers() (localctx IPowersContext) {
	this := p
	_ = this

	localctx = NewPowersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1040, Cobol85ParserRULE_powers)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5784)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR {
		{
			p.SetState(5783)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserMINUSCHAR || _la == Cobol85ParserPLUSCHAR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5786)
		p.Basis()
	}
	p.SetState(5790)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserDOUBLEASTERISKCHAR {
		{
			p.SetState(5787)
			p.Power()
		}

		p.SetState(5792)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IPowerContext is an interface to support dynamic dispatch.
type IPowerContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPowerContext differentiates from other interfaces.
	IsPowerContext()
}

type PowerContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPowerContext() *PowerContext {
	var p = new(PowerContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_power
	return p
}

func (*PowerContext) IsPowerContext() {}

func NewPowerContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PowerContext {
	var p = new(PowerContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_power

	return p
}

func (s *PowerContext) GetParser() antlr.Parser { return s.parser }

func (s *PowerContext) DOUBLEASTERISKCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLEASTERISKCHAR, 0)
}

func (s *PowerContext) Basis() IBasisContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBasisContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBasisContext)
}

func (s *PowerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PowerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterPower(s)
	}
}

func (s *PowerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitPower(s)
	}
}

func (s *PowerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitPower(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Power() (localctx IPowerContext) {
	this := p
	_ = this

	localctx = NewPowerContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1042, Cobol85ParserRULE_power)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5793)
		p.Match(Cobol85ParserDOUBLEASTERISKCHAR)
	}
	{
		p.SetState(5794)
		p.Basis()
	}

	return localctx
}

// IBasisContext is an interface to support dynamic dispatch.
type IBasisContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasisContext differentiates from other interfaces.
	IsBasisContext()
}

type BasisContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasisContext() *BasisContext {
	var p = new(BasisContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_basis
	return p
}

func (*BasisContext) IsBasisContext() {}

func NewBasisContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasisContext {
	var p = new(BasisContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_basis

	return p
}

func (s *BasisContext) GetParser() antlr.Parser { return s.parser }

func (s *BasisContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *BasisContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *BasisContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *BasisContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *BasisContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *BasisContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasisContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasisContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBasis(s)
	}
}

func (s *BasisContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBasis(s)
	}
}

func (s *BasisContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBasis(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Basis() (localctx IBasisContext) {
	this := p
	_ = this

	localctx = NewBasisContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1044, Cobol85ParserRULE_basis)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5802)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 908, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5796)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5797)
			p.ArithmeticExpression()
		}
		{
			p.SetState(5798)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5800)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5801)
			p.Literal()
		}

	}

	return localctx
}

// IConditionContext is an interface to support dynamic dispatch.
type IConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionContext differentiates from other interfaces.
	IsConditionContext()
}

type ConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionContext() *ConditionContext {
	var p = new(ConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_condition
	return p
}

func (*ConditionContext) IsConditionContext() {}

func NewConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionContext {
	var p = new(ConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_condition

	return p
}

func (s *ConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionContext) CombinableCondition() ICombinableConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICombinableConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICombinableConditionContext)
}

func (s *ConditionContext) AllAndOrCondition() []IAndOrConditionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAndOrConditionContext); ok {
			len++
		}
	}

	tst := make([]IAndOrConditionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAndOrConditionContext); ok {
			tst[i] = t.(IAndOrConditionContext)
			i++
		}
	}

	return tst
}

func (s *ConditionContext) AndOrCondition(i int) IAndOrConditionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAndOrConditionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAndOrConditionContext)
}

func (s *ConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCondition(s)
	}
}

func (s *ConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCondition(s)
	}
}

func (s *ConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Condition() (localctx IConditionContext) {
	this := p
	_ = this

	localctx = NewConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1046, Cobol85ParserRULE_condition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5804)
		p.CombinableCondition()
	}
	p.SetState(5808)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == Cobol85ParserAND || _la == Cobol85ParserOR {
		{
			p.SetState(5805)
			p.AndOrCondition()
		}

		p.SetState(5810)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IAndOrConditionContext is an interface to support dynamic dispatch.
type IAndOrConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAndOrConditionContext differentiates from other interfaces.
	IsAndOrConditionContext()
}

type AndOrConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAndOrConditionContext() *AndOrConditionContext {
	var p = new(AndOrConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_andOrCondition
	return p
}

func (*AndOrConditionContext) IsAndOrConditionContext() {}

func NewAndOrConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AndOrConditionContext {
	var p = new(AndOrConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_andOrCondition

	return p
}

func (s *AndOrConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *AndOrConditionContext) AND() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAND, 0)
}

func (s *AndOrConditionContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *AndOrConditionContext) CombinableCondition() ICombinableConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICombinableConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICombinableConditionContext)
}

func (s *AndOrConditionContext) AllAbbreviation() []IAbbreviationContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAbbreviationContext); ok {
			len++
		}
	}

	tst := make([]IAbbreviationContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAbbreviationContext); ok {
			tst[i] = t.(IAbbreviationContext)
			i++
		}
	}

	return tst
}

func (s *AndOrConditionContext) Abbreviation(i int) IAbbreviationContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbreviationContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbreviationContext)
}

func (s *AndOrConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndOrConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AndOrConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAndOrCondition(s)
	}
}

func (s *AndOrConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAndOrCondition(s)
	}
}

func (s *AndOrConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAndOrCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AndOrCondition() (localctx IAndOrConditionContext) {
	this := p
	_ = this

	localctx = NewAndOrConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1048, Cobol85ParserRULE_andOrCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5811)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserAND || _la == Cobol85ParserOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(5818)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 911, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5812)
			p.CombinableCondition()
		}

	case 2:
		p.SetState(5814)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(5813)
					p.Abbreviation()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(5816)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 910, p.GetParserRuleContext())
		}

	}

	return localctx
}

// ICombinableConditionContext is an interface to support dynamic dispatch.
type ICombinableConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCombinableConditionContext differentiates from other interfaces.
	IsCombinableConditionContext()
}

type CombinableConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCombinableConditionContext() *CombinableConditionContext {
	var p = new(CombinableConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_combinableCondition
	return p
}

func (*CombinableConditionContext) IsCombinableConditionContext() {}

func NewCombinableConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CombinableConditionContext {
	var p = new(CombinableConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_combinableCondition

	return p
}

func (s *CombinableConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *CombinableConditionContext) SimpleCondition() ISimpleConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleConditionContext)
}

func (s *CombinableConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *CombinableConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CombinableConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CombinableConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCombinableCondition(s)
	}
}

func (s *CombinableConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCombinableCondition(s)
	}
}

func (s *CombinableConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCombinableCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CombinableCondition() (localctx ICombinableConditionContext) {
	this := p
	_ = this

	localctx = NewCombinableConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1050, Cobol85ParserRULE_combinableCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5821)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5820)
			p.Match(Cobol85ParserNOT)
		}

	}
	{
		p.SetState(5823)
		p.SimpleCondition()
	}

	return localctx
}

// ISimpleConditionContext is an interface to support dynamic dispatch.
type ISimpleConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSimpleConditionContext differentiates from other interfaces.
	IsSimpleConditionContext()
}

type SimpleConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleConditionContext() *SimpleConditionContext {
	var p = new(SimpleConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_simpleCondition
	return p
}

func (*SimpleConditionContext) IsSimpleConditionContext() {}

func NewSimpleConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleConditionContext {
	var p = new(SimpleConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_simpleCondition

	return p
}

func (s *SimpleConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleConditionContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *SimpleConditionContext) Condition() IConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionContext)
}

func (s *SimpleConditionContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *SimpleConditionContext) RelationCondition() IRelationConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationConditionContext)
}

func (s *SimpleConditionContext) ClassCondition() IClassConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassConditionContext)
}

func (s *SimpleConditionContext) ConditionNameReference() IConditionNameReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionNameReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionNameReferenceContext)
}

func (s *SimpleConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSimpleCondition(s)
	}
}

func (s *SimpleConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSimpleCondition(s)
	}
}

func (s *SimpleConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSimpleCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SimpleCondition() (localctx ISimpleConditionContext) {
	this := p
	_ = this

	localctx = NewSimpleConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1052, Cobol85ParserRULE_simpleCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5832)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 913, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5825)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5826)
			p.Condition()
		}
		{
			p.SetState(5827)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5829)
			p.RelationCondition()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5830)
			p.ClassCondition()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5831)
			p.ConditionNameReference()
		}

	}

	return localctx
}

// IClassConditionContext is an interface to support dynamic dispatch.
type IClassConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassConditionContext differentiates from other interfaces.
	IsClassConditionContext()
}

type ClassConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassConditionContext() *ClassConditionContext {
	var p = new(ClassConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_classCondition
	return p
}

func (*ClassConditionContext) IsClassConditionContext() {}

func NewClassConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassConditionContext {
	var p = new(ClassConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_classCondition

	return p
}

func (s *ClassConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassConditionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ClassConditionContext) NUMERIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC, 0)
}

func (s *ClassConditionContext) ALPHABETIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC, 0)
}

func (s *ClassConditionContext) ALPHABETIC_LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC_LOWER, 0)
}

func (s *ClassConditionContext) ALPHABETIC_UPPER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALPHABETIC_UPPER, 0)
}

func (s *ClassConditionContext) DBCS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDBCS, 0)
}

func (s *ClassConditionContext) KANJI() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKANJI, 0)
}

func (s *ClassConditionContext) ClassName() IClassNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IClassNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IClassNameContext)
}

func (s *ClassConditionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *ClassConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *ClassConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassCondition(s)
	}
}

func (s *ClassConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassCondition(s)
	}
}

func (s *ClassConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassCondition() (localctx IClassConditionContext) {
	this := p
	_ = this

	localctx = NewClassConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1054, Cobol85ParserRULE_classCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5834)
		p.Identifier()
	}
	p.SetState(5836)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5835)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5839)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5838)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5848)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNUMERIC:
		{
			p.SetState(5841)
			p.Match(Cobol85ParserNUMERIC)
		}

	case Cobol85ParserALPHABETIC:
		{
			p.SetState(5842)
			p.Match(Cobol85ParserALPHABETIC)
		}

	case Cobol85ParserALPHABETIC_LOWER:
		{
			p.SetState(5843)
			p.Match(Cobol85ParserALPHABETIC_LOWER)
		}

	case Cobol85ParserALPHABETIC_UPPER:
		{
			p.SetState(5844)
			p.Match(Cobol85ParserALPHABETIC_UPPER)
		}

	case Cobol85ParserDBCS:
		{
			p.SetState(5845)
			p.Match(Cobol85ParserDBCS)
		}

	case Cobol85ParserKANJI:
		{
			p.SetState(5846)
			p.Match(Cobol85ParserKANJI)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		{
			p.SetState(5847)
			p.ClassName()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IConditionNameReferenceContext is an interface to support dynamic dispatch.
type IConditionNameReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameReferenceContext differentiates from other interfaces.
	IsConditionNameReferenceContext()
}

type ConditionNameReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameReferenceContext() *ConditionNameReferenceContext {
	var p = new(ConditionNameReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionNameReference
	return p
}

func (*ConditionNameReferenceContext) IsConditionNameReferenceContext() {}

func NewConditionNameReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameReferenceContext {
	var p = new(ConditionNameReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionNameReference

	return p
}

func (s *ConditionNameReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameReferenceContext) ConditionName() IConditionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *ConditionNameReferenceContext) AllInData() []IInDataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInDataContext); ok {
			len++
		}
	}

	tst := make([]IInDataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInDataContext); ok {
			tst[i] = t.(IInDataContext)
			i++
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) InData(i int) IInDataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInDataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInDataContext)
}

func (s *ConditionNameReferenceContext) InFile() IInFileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInFileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *ConditionNameReferenceContext) AllConditionNameSubscriptReference() []IConditionNameSubscriptReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IConditionNameSubscriptReferenceContext); ok {
			len++
		}
	}

	tst := make([]IConditionNameSubscriptReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IConditionNameSubscriptReferenceContext); ok {
			tst[i] = t.(IConditionNameSubscriptReferenceContext)
			i++
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) ConditionNameSubscriptReference(i int) IConditionNameSubscriptReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionNameSubscriptReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionNameSubscriptReferenceContext)
}

func (s *ConditionNameReferenceContext) AllInMnemonic() []IInMnemonicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInMnemonicContext); ok {
			len++
		}
	}

	tst := make([]IInMnemonicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInMnemonicContext); ok {
			tst[i] = t.(IInMnemonicContext)
			i++
		}
	}

	return tst
}

func (s *ConditionNameReferenceContext) InMnemonic(i int) IInMnemonicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInMnemonicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInMnemonicContext)
}

func (s *ConditionNameReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionNameReference(s)
	}
}

func (s *ConditionNameReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionNameReference(s)
	}
}

func (s *ConditionNameReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConditionNameReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConditionNameReference() (localctx IConditionNameReferenceContext) {
	this := p
	_ = this

	localctx = NewConditionNameReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1056, Cobol85ParserRULE_conditionNameReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5850)
		p.ConditionName()
	}
	p.SetState(5872)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 921, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5854)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 917, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(5851)
					p.InData()
				}

			}
			p.SetState(5856)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 917, p.GetParserRuleContext())
		}
		p.SetState(5858)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(5857)
				p.InFile()
			}

		}
		p.SetState(5863)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserLPARENCHAR {
			{
				p.SetState(5860)
				p.ConditionNameSubscriptReference()
			}

			p.SetState(5865)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.SetState(5869)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(5866)
				p.InMnemonic()
			}

			p.SetState(5871)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	}

	return localctx
}

// IConditionNameSubscriptReferenceContext is an interface to support dynamic dispatch.
type IConditionNameSubscriptReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameSubscriptReferenceContext differentiates from other interfaces.
	IsConditionNameSubscriptReferenceContext()
}

type ConditionNameSubscriptReferenceContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameSubscriptReferenceContext() *ConditionNameSubscriptReferenceContext {
	var p = new(ConditionNameSubscriptReferenceContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionNameSubscriptReference
	return p
}

func (*ConditionNameSubscriptReferenceContext) IsConditionNameSubscriptReferenceContext() {}

func NewConditionNameSubscriptReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameSubscriptReferenceContext {
	var p = new(ConditionNameSubscriptReferenceContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionNameSubscriptReference

	return p
}

func (s *ConditionNameSubscriptReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameSubscriptReferenceContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *ConditionNameSubscriptReferenceContext) AllSubscript_() []ISubscript_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubscript_Context); ok {
			len++
		}
	}

	tst := make([]ISubscript_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubscript_Context); ok {
			tst[i] = t.(ISubscript_Context)
			i++
		}
	}

	return tst
}

func (s *ConditionNameSubscriptReferenceContext) Subscript_(i int) ISubscript_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscript_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscript_Context)
}

func (s *ConditionNameSubscriptReferenceContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *ConditionNameSubscriptReferenceContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *ConditionNameSubscriptReferenceContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *ConditionNameSubscriptReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameSubscriptReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameSubscriptReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionNameSubscriptReference(s)
	}
}

func (s *ConditionNameSubscriptReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionNameSubscriptReference(s)
	}
}

func (s *ConditionNameSubscriptReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConditionNameSubscriptReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConditionNameSubscriptReference() (localctx IConditionNameSubscriptReferenceContext) {
	this := p
	_ = this

	localctx = NewConditionNameSubscriptReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1058, Cobol85ParserRULE_conditionNameSubscriptReference)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5874)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(5875)
		p.Subscript_()
	}
	p.SetState(5882)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&-8651221362832473951) != 0 || (int64((_la-542)) & ^0x3f) == 0 && ((int64(1)<<(_la-542))&65059) != 0 {
		p.SetState(5877)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserCOMMACHAR {
			{
				p.SetState(5876)
				p.Match(Cobol85ParserCOMMACHAR)
			}

		}
		{
			p.SetState(5879)
			p.Subscript_()
		}

		p.SetState(5884)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5885)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IRelationConditionContext is an interface to support dynamic dispatch.
type IRelationConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationConditionContext differentiates from other interfaces.
	IsRelationConditionContext()
}

type RelationConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationConditionContext() *RelationConditionContext {
	var p = new(RelationConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCondition
	return p
}

func (*RelationConditionContext) IsRelationConditionContext() {}

func NewRelationConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationConditionContext {
	var p = new(RelationConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCondition

	return p
}

func (s *RelationConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationConditionContext) RelationSignCondition() IRelationSignConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationSignConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationSignConditionContext)
}

func (s *RelationConditionContext) RelationArithmeticComparison() IRelationArithmeticComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationArithmeticComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationArithmeticComparisonContext)
}

func (s *RelationConditionContext) RelationCombinedComparison() IRelationCombinedComparisonContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationCombinedComparisonContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationCombinedComparisonContext)
}

func (s *RelationConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCondition(s)
	}
}

func (s *RelationConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCondition(s)
	}
}

func (s *RelationConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationCondition() (localctx IRelationConditionContext) {
	this := p
	_ = this

	localctx = NewRelationConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1060, Cobol85ParserRULE_relationCondition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5890)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 924, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5887)
			p.RelationSignCondition()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5888)
			p.RelationArithmeticComparison()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5889)
			p.RelationCombinedComparison()
		}

	}

	return localctx
}

// IRelationSignConditionContext is an interface to support dynamic dispatch.
type IRelationSignConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationSignConditionContext differentiates from other interfaces.
	IsRelationSignConditionContext()
}

type RelationSignConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationSignConditionContext() *RelationSignConditionContext {
	var p = new(RelationSignConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationSignCondition
	return p
}

func (*RelationSignConditionContext) IsRelationSignConditionContext() {}

func NewRelationSignConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationSignConditionContext {
	var p = new(RelationSignConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationSignCondition

	return p
}

func (s *RelationSignConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationSignConditionContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationSignConditionContext) POSITIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPOSITIVE, 0)
}

func (s *RelationSignConditionContext) NEGATIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNEGATIVE, 0)
}

func (s *RelationSignConditionContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *RelationSignConditionContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelationSignConditionContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *RelationSignConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationSignConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationSignConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationSignCondition(s)
	}
}

func (s *RelationSignConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationSignCondition(s)
	}
}

func (s *RelationSignConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationSignCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationSignCondition() (localctx IRelationSignConditionContext) {
	this := p
	_ = this

	localctx = NewRelationSignConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1062, Cobol85ParserRULE_relationSignCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5892)
		p.ArithmeticExpression()
	}
	p.SetState(5894)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserIS {
		{
			p.SetState(5893)
			p.Match(Cobol85ParserIS)
		}

	}
	p.SetState(5897)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserNOT {
		{
			p.SetState(5896)
			p.Match(Cobol85ParserNOT)
		}

	}
	{
		p.SetState(5899)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserNEGATIVE || _la == Cobol85ParserPOSITIVE || _la == Cobol85ParserZERO) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IRelationArithmeticComparisonContext is an interface to support dynamic dispatch.
type IRelationArithmeticComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationArithmeticComparisonContext differentiates from other interfaces.
	IsRelationArithmeticComparisonContext()
}

type RelationArithmeticComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationArithmeticComparisonContext() *RelationArithmeticComparisonContext {
	var p = new(RelationArithmeticComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationArithmeticComparison
	return p
}

func (*RelationArithmeticComparisonContext) IsRelationArithmeticComparisonContext() {}

func NewRelationArithmeticComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationArithmeticComparisonContext {
	var p = new(RelationArithmeticComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationArithmeticComparison

	return p
}

func (s *RelationArithmeticComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationArithmeticComparisonContext) AllArithmeticExpression() []IArithmeticExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			len++
		}
	}

	tst := make([]IArithmeticExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArithmeticExpressionContext); ok {
			tst[i] = t.(IArithmeticExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationArithmeticComparisonContext) ArithmeticExpression(i int) IArithmeticExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationArithmeticComparisonContext) RelationalOperator() IRelationalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationArithmeticComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationArithmeticComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationArithmeticComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationArithmeticComparison(s)
	}
}

func (s *RelationArithmeticComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationArithmeticComparison(s)
	}
}

func (s *RelationArithmeticComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationArithmeticComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationArithmeticComparison() (localctx IRelationArithmeticComparisonContext) {
	this := p
	_ = this

	localctx = NewRelationArithmeticComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1064, Cobol85ParserRULE_relationArithmeticComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5901)
		p.ArithmeticExpression()
	}
	{
		p.SetState(5902)
		p.RelationalOperator()
	}
	{
		p.SetState(5903)
		p.ArithmeticExpression()
	}

	return localctx
}

// IRelationCombinedComparisonContext is an interface to support dynamic dispatch.
type IRelationCombinedComparisonContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationCombinedComparisonContext differentiates from other interfaces.
	IsRelationCombinedComparisonContext()
}

type RelationCombinedComparisonContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationCombinedComparisonContext() *RelationCombinedComparisonContext {
	var p = new(RelationCombinedComparisonContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCombinedComparison
	return p
}

func (*RelationCombinedComparisonContext) IsRelationCombinedComparisonContext() {}

func NewRelationCombinedComparisonContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationCombinedComparisonContext {
	var p = new(RelationCombinedComparisonContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCombinedComparison

	return p
}

func (s *RelationCombinedComparisonContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationCombinedComparisonContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationCombinedComparisonContext) RelationalOperator() IRelationalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *RelationCombinedComparisonContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *RelationCombinedComparisonContext) RelationCombinedCondition() IRelationCombinedConditionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationCombinedConditionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationCombinedConditionContext)
}

func (s *RelationCombinedComparisonContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *RelationCombinedComparisonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCombinedComparisonContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationCombinedComparisonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCombinedComparison(s)
	}
}

func (s *RelationCombinedComparisonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCombinedComparison(s)
	}
}

func (s *RelationCombinedComparisonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationCombinedComparison(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationCombinedComparison() (localctx IRelationCombinedComparisonContext) {
	this := p
	_ = this

	localctx = NewRelationCombinedComparisonContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1066, Cobol85ParserRULE_relationCombinedComparison)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5905)
		p.ArithmeticExpression()
	}
	{
		p.SetState(5906)
		p.RelationalOperator()
	}
	{
		p.SetState(5907)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(5908)
		p.RelationCombinedCondition()
	}
	{
		p.SetState(5909)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IRelationCombinedConditionContext is an interface to support dynamic dispatch.
type IRelationCombinedConditionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationCombinedConditionContext differentiates from other interfaces.
	IsRelationCombinedConditionContext()
}

type RelationCombinedConditionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationCombinedConditionContext() *RelationCombinedConditionContext {
	var p = new(RelationCombinedConditionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationCombinedCondition
	return p
}

func (*RelationCombinedConditionContext) IsRelationCombinedConditionContext() {}

func NewRelationCombinedConditionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationCombinedConditionContext {
	var p = new(RelationCombinedConditionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationCombinedCondition

	return p
}

func (s *RelationCombinedConditionContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationCombinedConditionContext) AllArithmeticExpression() []IArithmeticExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			len++
		}
	}

	tst := make([]IArithmeticExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArithmeticExpressionContext); ok {
			tst[i] = t.(IArithmeticExpressionContext)
			i++
		}
	}

	return tst
}

func (s *RelationCombinedConditionContext) ArithmeticExpression(i int) IArithmeticExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *RelationCombinedConditionContext) AllAND() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserAND)
}

func (s *RelationCombinedConditionContext) AND(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAND, i)
}

func (s *RelationCombinedConditionContext) AllOR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserOR)
}

func (s *RelationCombinedConditionContext) OR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, i)
}

func (s *RelationCombinedConditionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationCombinedConditionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationCombinedConditionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationCombinedCondition(s)
	}
}

func (s *RelationCombinedConditionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationCombinedCondition(s)
	}
}

func (s *RelationCombinedConditionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationCombinedCondition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationCombinedCondition() (localctx IRelationCombinedConditionContext) {
	this := p
	_ = this

	localctx = NewRelationCombinedConditionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1068, Cobol85ParserRULE_relationCombinedCondition)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5911)
		p.ArithmeticExpression()
	}
	p.SetState(5914)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserAND || _la == Cobol85ParserOR {
		{
			p.SetState(5912)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserAND || _la == Cobol85ParserOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5913)
			p.ArithmeticExpression()
		}

		p.SetState(5916)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IRelationalOperatorContext is an interface to support dynamic dispatch.
type IRelationalOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRelationalOperatorContext differentiates from other interfaces.
	IsRelationalOperatorContext()
}

type RelationalOperatorContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelationalOperatorContext() *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_relationalOperator
	return p
}

func (*RelationalOperatorContext) IsRelationalOperatorContext() {}

func NewRelationalOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelationalOperatorContext {
	var p = new(RelationalOperatorContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_relationalOperator

	return p
}

func (s *RelationalOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *RelationalOperatorContext) NOTEQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOTEQUALCHAR, 0)
}

func (s *RelationalOperatorContext) GREATER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGREATER, 0)
}

func (s *RelationalOperatorContext) OR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOR, 0)
}

func (s *RelationalOperatorContext) EQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUAL, 0)
}

func (s *RelationalOperatorContext) MORETHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANOREQUAL, 0)
}

func (s *RelationalOperatorContext) LESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESS, 0)
}

func (s *RelationalOperatorContext) LESSTHANOREQUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANOREQUAL, 0)
}

func (s *RelationalOperatorContext) IS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIS, 0)
}

func (s *RelationalOperatorContext) ARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserARE, 0)
}

func (s *RelationalOperatorContext) MORETHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMORETHANCHAR, 0)
}

func (s *RelationalOperatorContext) LESSTHANCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLESSTHANCHAR, 0)
}

func (s *RelationalOperatorContext) EQUALCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEQUALCHAR, 0)
}

func (s *RelationalOperatorContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *RelationalOperatorContext) THAN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHAN, 0)
}

func (s *RelationalOperatorContext) TO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTO, 0)
}

func (s *RelationalOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelationalOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RelationalOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRelationalOperator(s)
	}
}

func (s *RelationalOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRelationalOperator(s)
	}
}

func (s *RelationalOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRelationalOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RelationalOperator() (localctx IRelationalOperatorContext) {
	this := p
	_ = this

	localctx = NewRelationalOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1070, Cobol85ParserRULE_relationalOperator)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5919)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserIS {
		{
			p.SetState(5918)
			_la = p.GetTokenStream().LA(1)

			if !(_la == Cobol85ParserARE || _la == Cobol85ParserIS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(5962)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 938, p.GetParserRuleContext()) {
	case 1:
		p.SetState(5922)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserNOT {
			{
				p.SetState(5921)
				p.Match(Cobol85ParserNOT)
			}

		}
		p.SetState(5939)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case Cobol85ParserGREATER:
			{
				p.SetState(5924)
				p.Match(Cobol85ParserGREATER)
			}
			p.SetState(5926)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTHAN {
				{
					p.SetState(5925)
					p.Match(Cobol85ParserTHAN)
				}

			}

		case Cobol85ParserMORETHANCHAR:
			{
				p.SetState(5928)
				p.Match(Cobol85ParserMORETHANCHAR)
			}

		case Cobol85ParserLESS:
			{
				p.SetState(5929)
				p.Match(Cobol85ParserLESS)
			}
			p.SetState(5931)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTHAN {
				{
					p.SetState(5930)
					p.Match(Cobol85ParserTHAN)
				}

			}

		case Cobol85ParserLESSTHANCHAR:
			{
				p.SetState(5933)
				p.Match(Cobol85ParserLESSTHANCHAR)
			}

		case Cobol85ParserEQUAL:
			{
				p.SetState(5934)
				p.Match(Cobol85ParserEQUAL)
			}
			p.SetState(5936)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == Cobol85ParserTO {
				{
					p.SetState(5935)
					p.Match(Cobol85ParserTO)
				}

			}

		case Cobol85ParserEQUALCHAR:
			{
				p.SetState(5938)
				p.Match(Cobol85ParserEQUALCHAR)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		{
			p.SetState(5941)
			p.Match(Cobol85ParserNOTEQUALCHAR)
		}

	case 3:
		{
			p.SetState(5942)
			p.Match(Cobol85ParserGREATER)
		}
		p.SetState(5944)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5943)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5946)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5947)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5949)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5948)
				p.Match(Cobol85ParserTO)
			}

		}

	case 4:
		{
			p.SetState(5951)
			p.Match(Cobol85ParserMORETHANOREQUAL)
		}

	case 5:
		{
			p.SetState(5952)
			p.Match(Cobol85ParserLESS)
		}
		p.SetState(5954)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTHAN {
			{
				p.SetState(5953)
				p.Match(Cobol85ParserTHAN)
			}

		}
		{
			p.SetState(5956)
			p.Match(Cobol85ParserOR)
		}
		{
			p.SetState(5957)
			p.Match(Cobol85ParserEQUAL)
		}
		p.SetState(5959)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserTO {
			{
				p.SetState(5958)
				p.Match(Cobol85ParserTO)
			}

		}

	case 6:
		{
			p.SetState(5961)
			p.Match(Cobol85ParserLESSTHANOREQUAL)
		}

	}

	return localctx
}

// IAbbreviationContext is an interface to support dynamic dispatch.
type IAbbreviationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAbbreviationContext differentiates from other interfaces.
	IsAbbreviationContext()
}

type AbbreviationContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAbbreviationContext() *AbbreviationContext {
	var p = new(AbbreviationContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_abbreviation
	return p
}

func (*AbbreviationContext) IsAbbreviationContext() {}

func NewAbbreviationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AbbreviationContext {
	var p = new(AbbreviationContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_abbreviation

	return p
}

func (s *AbbreviationContext) GetParser() antlr.Parser { return s.parser }

func (s *AbbreviationContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *AbbreviationContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *AbbreviationContext) Abbreviation() IAbbreviationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAbbreviationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAbbreviationContext)
}

func (s *AbbreviationContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *AbbreviationContext) NOT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNOT, 0)
}

func (s *AbbreviationContext) RelationalOperator() IRelationalOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelationalOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelationalOperatorContext)
}

func (s *AbbreviationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AbbreviationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AbbreviationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAbbreviation(s)
	}
}

func (s *AbbreviationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAbbreviation(s)
	}
}

func (s *AbbreviationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAbbreviation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Abbreviation() (localctx IAbbreviationContext) {
	this := p
	_ = this

	localctx = NewAbbreviationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1072, Cobol85ParserRULE_abbreviation)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5965)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 939, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5964)
			p.Match(Cobol85ParserNOT)
		}

	}
	p.SetState(5968)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == Cobol85ParserARE || _la == Cobol85ParserEQUAL || _la == Cobol85ParserGREATER || (int64((_la-254)) & ^0x3f) == 0 && ((int64(1)<<(_la-254))&288230376151842817) != 0 || (int64((_la-536)) & ^0x3f) == 0 && ((int64(1)<<(_la-536))&1841) != 0 {
		{
			p.SetState(5967)
			p.RelationalOperator()
		}

	}
	p.SetState(5976)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 941, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5970)
			p.ArithmeticExpression()
		}

	case 2:
		{
			p.SetState(5971)
			p.Match(Cobol85ParserLPARENCHAR)
		}
		{
			p.SetState(5972)
			p.ArithmeticExpression()
		}
		{
			p.SetState(5973)
			p.Abbreviation()
		}
		{
			p.SetState(5974)
			p.Match(Cobol85ParserRPARENCHAR)
		}

	}

	return localctx
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_identifier
	return p
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *IdentifierContext) TableCall() ITableCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *IdentifierContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *IdentifierContext) SpecialRegister() ISpecialRegisterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISpecialRegisterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISpecialRegisterContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Identifier() (localctx IIdentifierContext) {
	this := p
	_ = this

	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1074, Cobol85ParserRULE_identifier)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(5982)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 942, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5978)
			p.QualifiedDataName()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5979)
			p.TableCall()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5980)
			p.FunctionCall()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5981)
			p.SpecialRegister()
		}

	}

	return localctx
}

// ITableCallContext is an interface to support dynamic dispatch.
type ITableCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTableCallContext differentiates from other interfaces.
	IsTableCallContext()
}

type TableCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableCallContext() *TableCallContext {
	var p = new(TableCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_tableCall
	return p
}

func (*TableCallContext) IsTableCallContext() {}

func NewTableCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableCallContext {
	var p = new(TableCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_tableCall

	return p
}

func (s *TableCallContext) GetParser() antlr.Parser { return s.parser }

func (s *TableCallContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *TableCallContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserLPARENCHAR)
}

func (s *TableCallContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, i)
}

func (s *TableCallContext) AllSubscript_() []ISubscript_Context {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubscript_Context); ok {
			len++
		}
	}

	tst := make([]ISubscript_Context, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubscript_Context); ok {
			tst[i] = t.(ISubscript_Context)
			i++
		}
	}

	return tst
}

func (s *TableCallContext) Subscript_(i int) ISubscript_Context {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubscript_Context); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubscript_Context)
}

func (s *TableCallContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserRPARENCHAR)
}

func (s *TableCallContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, i)
}

func (s *TableCallContext) ReferenceModifier() IReferenceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceModifierContext)
}

func (s *TableCallContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *TableCallContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *TableCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTableCall(s)
	}
}

func (s *TableCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTableCall(s)
	}
}

func (s *TableCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTableCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TableCall() (localctx ITableCallContext) {
	this := p
	_ = this

	localctx = NewTableCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1076, Cobol85ParserRULE_tableCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5984)
		p.QualifiedDataName()
	}
	p.SetState(6000)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5985)
				p.Match(Cobol85ParserLPARENCHAR)
			}
			{
				p.SetState(5986)
				p.Subscript_()
			}
			p.SetState(5993)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&-8651221362832473951) != 0 || (int64((_la-542)) & ^0x3f) == 0 && ((int64(1)<<(_la-542))&65059) != 0 {
				p.SetState(5988)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85ParserCOMMACHAR {
					{
						p.SetState(5987)
						p.Match(Cobol85ParserCOMMACHAR)
					}

				}
				{
					p.SetState(5990)
					p.Subscript_()
				}

				p.SetState(5995)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(5996)
				p.Match(Cobol85ParserRPARENCHAR)
			}

		}
		p.SetState(6002)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 945, p.GetParserRuleContext())
	}
	p.SetState(6004)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 946, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6003)
			p.ReferenceModifier()
		}

	}

	return localctx
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_functionCall
	return p
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) FUNCTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION, 0)
}

func (s *FunctionCallContext) FunctionName() IFunctionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionNameContext)
}

func (s *FunctionCallContext) AllLPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserLPARENCHAR)
}

func (s *FunctionCallContext) LPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, i)
}

func (s *FunctionCallContext) AllArgument() []IArgumentContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IArgumentContext); ok {
			len++
		}
	}

	tst := make([]IArgumentContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IArgumentContext); ok {
			tst[i] = t.(IArgumentContext)
			i++
		}
	}

	return tst
}

func (s *FunctionCallContext) Argument(i int) IArgumentContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArgumentContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArgumentContext)
}

func (s *FunctionCallContext) AllRPARENCHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserRPARENCHAR)
}

func (s *FunctionCallContext) RPARENCHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, i)
}

func (s *FunctionCallContext) ReferenceModifier() IReferenceModifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferenceModifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferenceModifierContext)
}

func (s *FunctionCallContext) AllCOMMACHAR() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMACHAR)
}

func (s *FunctionCallContext) COMMACHAR(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMACHAR, i)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FunctionCall() (localctx IFunctionCallContext) {
	this := p
	_ = this

	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1078, Cobol85ParserRULE_functionCall)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6006)
		p.Match(Cobol85ParserFUNCTION)
	}
	{
		p.SetState(6007)
		p.FunctionName()
	}
	p.SetState(6023)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 949, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(6008)
				p.Match(Cobol85ParserLPARENCHAR)
			}
			{
				p.SetState(6009)
				p.Argument()
			}
			p.SetState(6016)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&-8651221362832473951) != 0 || (int64((_la-542)) & ^0x3f) == 0 && ((int64(1)<<(_la-542))&65059) != 0 {
				p.SetState(6011)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if _la == Cobol85ParserCOMMACHAR {
					{
						p.SetState(6010)
						p.Match(Cobol85ParserCOMMACHAR)
					}

				}
				{
					p.SetState(6013)
					p.Argument()
				}

				p.SetState(6018)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(6019)
				p.Match(Cobol85ParserRPARENCHAR)
			}

		}
		p.SetState(6025)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 949, p.GetParserRuleContext())
	}
	p.SetState(6027)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 950, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(6026)
			p.ReferenceModifier()
		}

	}

	return localctx
}

// IReferenceModifierContext is an interface to support dynamic dispatch.
type IReferenceModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReferenceModifierContext differentiates from other interfaces.
	IsReferenceModifierContext()
}

type ReferenceModifierContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferenceModifierContext() *ReferenceModifierContext {
	var p = new(ReferenceModifierContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_referenceModifier
	return p
}

func (*ReferenceModifierContext) IsReferenceModifierContext() {}

func NewReferenceModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferenceModifierContext {
	var p = new(ReferenceModifierContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_referenceModifier

	return p
}

func (s *ReferenceModifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferenceModifierContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *ReferenceModifierContext) CharacterPosition() ICharacterPositionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharacterPositionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharacterPositionContext)
}

func (s *ReferenceModifierContext) COLONCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOLONCHAR, 0)
}

func (s *ReferenceModifierContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *ReferenceModifierContext) Length() ILengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILengthContext)
}

func (s *ReferenceModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferenceModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferenceModifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReferenceModifier(s)
	}
}

func (s *ReferenceModifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReferenceModifier(s)
	}
}

func (s *ReferenceModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReferenceModifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReferenceModifier() (localctx IReferenceModifierContext) {
	this := p
	_ = this

	localctx = NewReferenceModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1080, Cobol85ParserRULE_referenceModifier)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6029)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	{
		p.SetState(6030)
		p.CharacterPosition()
	}
	{
		p.SetState(6031)
		p.Match(Cobol85ParserCOLONCHAR)
	}
	p.SetState(6033)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if (int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135822370) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8213661102500741635) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194964618422267) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202427199037528969) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874440372879459) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&1819828109721609) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&572150674022301857) != 0 || (int64((_la-542)) & ^0x3f) == 0 && ((int64(1)<<(_la-542))&65059) != 0 {
		{
			p.SetState(6032)
			p.Length()
		}

	}
	{
		p.SetState(6035)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// ICharacterPositionContext is an interface to support dynamic dispatch.
type ICharacterPositionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharacterPositionContext differentiates from other interfaces.
	IsCharacterPositionContext()
}

type CharacterPositionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharacterPositionContext() *CharacterPositionContext {
	var p = new(CharacterPositionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_characterPosition
	return p
}

func (*CharacterPositionContext) IsCharacterPositionContext() {}

func NewCharacterPositionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharacterPositionContext {
	var p = new(CharacterPositionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_characterPosition

	return p
}

func (s *CharacterPositionContext) GetParser() antlr.Parser { return s.parser }

func (s *CharacterPositionContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *CharacterPositionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharacterPositionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharacterPositionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCharacterPosition(s)
	}
}

func (s *CharacterPositionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCharacterPosition(s)
	}
}

func (s *CharacterPositionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCharacterPosition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CharacterPosition() (localctx ICharacterPositionContext) {
	this := p
	_ = this

	localctx = NewCharacterPositionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1082, Cobol85ParserRULE_characterPosition)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6037)
		p.ArithmeticExpression()
	}

	return localctx
}

// ILengthContext is an interface to support dynamic dispatch.
type ILengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLengthContext differentiates from other interfaces.
	IsLengthContext()
}

type LengthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLengthContext() *LengthContext {
	var p = new(LengthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_length
	return p
}

func (*LengthContext) IsLengthContext() {}

func NewLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LengthContext {
	var p = new(LengthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_length

	return p
}

func (s *LengthContext) GetParser() antlr.Parser { return s.parser }

func (s *LengthContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *LengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLength(s)
	}
}

func (s *LengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLength(s)
	}
}

func (s *LengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Length() (localctx ILengthContext) {
	this := p
	_ = this

	localctx = NewLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1084, Cobol85ParserRULE_length)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6039)
		p.ArithmeticExpression()
	}

	return localctx
}

// ISubscript_Context is an interface to support dynamic dispatch.
type ISubscript_Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSubscript_Context differentiates from other interfaces.
	IsSubscript_Context()
}

type Subscript_Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubscript_Context() *Subscript_Context {
	var p = new(Subscript_Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_subscript_
	return p
}

func (*Subscript_Context) IsSubscript_Context() {}

func NewSubscript_Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Subscript_Context {
	var p = new(Subscript_Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_subscript_

	return p
}

func (s *Subscript_Context) GetParser() antlr.Parser { return s.parser }

func (s *Subscript_Context) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *Subscript_Context) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *Subscript_Context) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *Subscript_Context) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *Subscript_Context) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *Subscript_Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Subscript_Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Subscript_Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSubscript_(s)
	}
}

func (s *Subscript_Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSubscript_(s)
	}
}

func (s *Subscript_Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSubscript_(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Subscript_() (localctx ISubscript_Context) {
	this := p
	_ = this

	localctx = NewSubscript_Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1086, Cobol85ParserRULE_subscript_)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6052)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 954, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6041)
			p.Match(Cobol85ParserALL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6042)
			p.IntegerLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6043)
			p.QualifiedDataName()
		}
		p.SetState(6045)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 952, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6044)
				p.IntegerLiteral()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6047)
			p.IndexName()
		}
		p.SetState(6049)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 953, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6048)
				p.IntegerLiteral()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6051)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IArgumentContext is an interface to support dynamic dispatch.
type IArgumentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsArgumentContext differentiates from other interfaces.
	IsArgumentContext()
}

type ArgumentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArgumentContext() *ArgumentContext {
	var p = new(ArgumentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_argument
	return p
}

func (*ArgumentContext) IsArgumentContext() {}

func NewArgumentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArgumentContext {
	var p = new(ArgumentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_argument

	return p
}

func (s *ArgumentContext) GetParser() antlr.Parser { return s.parser }

func (s *ArgumentContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *ArgumentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ArgumentContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ArgumentContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ArgumentContext) IndexName() IIndexNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexNameContext)
}

func (s *ArgumentContext) ArithmeticExpression() IArithmeticExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArithmeticExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArithmeticExpressionContext)
}

func (s *ArgumentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArgumentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArgumentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterArgument(s)
	}
}

func (s *ArgumentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitArgument(s)
	}
}

func (s *ArgumentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitArgument(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Argument() (localctx IArgumentContext) {
	this := p
	_ = this

	localctx = NewArgumentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1088, Cobol85ParserRULE_argument)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6065)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 957, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6054)
			p.Literal()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6055)
			p.Identifier()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6056)
			p.QualifiedDataName()
		}
		p.SetState(6058)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 955, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6057)
				p.IntegerLiteral()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6060)
			p.IndexName()
		}
		p.SetState(6062)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 956, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6061)
				p.IntegerLiteral()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6064)
			p.ArithmeticExpression()
		}

	}

	return localctx
}

// IQualifiedDataNameContext is an interface to support dynamic dispatch.
type IQualifiedDataNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameContext differentiates from other interfaces.
	IsQualifiedDataNameContext()
}

type QualifiedDataNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameContext() *QualifiedDataNameContext {
	var p = new(QualifiedDataNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataName
	return p
}

func (*QualifiedDataNameContext) IsQualifiedDataNameContext() {}

func NewQualifiedDataNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameContext {
	var p = new(QualifiedDataNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataName

	return p
}

func (s *QualifiedDataNameContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameContext) QualifiedDataNameFormat1() IQualifiedDataNameFormat1Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameFormat1Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat1Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat2() IQualifiedDataNameFormat2Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameFormat2Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat2Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat3() IQualifiedDataNameFormat3Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameFormat3Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat3Context)
}

func (s *QualifiedDataNameContext) QualifiedDataNameFormat4() IQualifiedDataNameFormat4Context {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameFormat4Context); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameFormat4Context)
}

func (s *QualifiedDataNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataName(s)
	}
}

func (s *QualifiedDataNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataName(s)
	}
}

func (s *QualifiedDataNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataName() (localctx IQualifiedDataNameContext) {
	this := p
	_ = this

	localctx = NewQualifiedDataNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1090, Cobol85ParserRULE_qualifiedDataName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6071)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 958, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6067)
			p.QualifiedDataNameFormat1()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6068)
			p.QualifiedDataNameFormat2()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6069)
			p.QualifiedDataNameFormat3()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6070)
			p.QualifiedDataNameFormat4()
		}

	}

	return localctx
}

// IQualifiedDataNameFormat1Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat1Context differentiates from other interfaces.
	IsQualifiedDataNameFormat1Context()
}

type QualifiedDataNameFormat1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat1Context() *QualifiedDataNameFormat1Context {
	var p = new(QualifiedDataNameFormat1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat1
	return p
}

func (*QualifiedDataNameFormat1Context) IsQualifiedDataNameFormat1Context() {}

func NewQualifiedDataNameFormat1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat1Context {
	var p = new(QualifiedDataNameFormat1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat1

	return p
}

func (s *QualifiedDataNameFormat1Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat1Context) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *QualifiedDataNameFormat1Context) ConditionName() IConditionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConditionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConditionNameContext)
}

func (s *QualifiedDataNameFormat1Context) InFile() IInFileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInFileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *QualifiedDataNameFormat1Context) AllQualifiedInData() []IQualifiedInDataContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifiedInDataContext); ok {
			len++
		}
	}

	tst := make([]IQualifiedInDataContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifiedInDataContext); ok {
			tst[i] = t.(IQualifiedInDataContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedDataNameFormat1Context) QualifiedInData(i int) IQualifiedInDataContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedInDataContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedInDataContext)
}

func (s *QualifiedDataNameFormat1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat1(s)
	}
}

func (s *QualifiedDataNameFormat1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat1(s)
	}
}

func (s *QualifiedDataNameFormat1Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat1(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat1() (localctx IQualifiedDataNameFormat1Context) {
	this := p
	_ = this

	localctx = NewQualifiedDataNameFormat1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1092, Cobol85ParserRULE_qualifiedDataNameFormat1)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6075)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 959, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6073)
			p.DataName()
		}

	case 2:
		{
			p.SetState(6074)
			p.ConditionName()
		}

	}
	p.SetState(6086)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 962, p.GetParserRuleContext()) == 1 {
		p.SetState(6078)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(6077)
					p.QualifiedInData()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(6080)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 960, p.GetParserRuleContext())
		}
		p.SetState(6083)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 961, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(6082)
				p.InFile()
			}

		}

	} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 962, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(6085)
			p.InFile()
		}

	}

	return localctx
}

// IQualifiedDataNameFormat2Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat2Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat2Context differentiates from other interfaces.
	IsQualifiedDataNameFormat2Context()
}

type QualifiedDataNameFormat2Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat2Context() *QualifiedDataNameFormat2Context {
	var p = new(QualifiedDataNameFormat2Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat2
	return p
}

func (*QualifiedDataNameFormat2Context) IsQualifiedDataNameFormat2Context() {}

func NewQualifiedDataNameFormat2Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat2Context {
	var p = new(QualifiedDataNameFormat2Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat2

	return p
}

func (s *QualifiedDataNameFormat2Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat2Context) ParagraphName() IParagraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *QualifiedDataNameFormat2Context) InSection() IInSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInSectionContext)
}

func (s *QualifiedDataNameFormat2Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat2Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat2Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat2(s)
	}
}

func (s *QualifiedDataNameFormat2Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat2(s)
	}
}

func (s *QualifiedDataNameFormat2Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat2(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat2() (localctx IQualifiedDataNameFormat2Context) {
	this := p
	_ = this

	localctx = NewQualifiedDataNameFormat2Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1094, Cobol85ParserRULE_qualifiedDataNameFormat2)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6088)
		p.ParagraphName()
	}
	{
		p.SetState(6089)
		p.InSection()
	}

	return localctx
}

// IQualifiedDataNameFormat3Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat3Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat3Context differentiates from other interfaces.
	IsQualifiedDataNameFormat3Context()
}

type QualifiedDataNameFormat3Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat3Context() *QualifiedDataNameFormat3Context {
	var p = new(QualifiedDataNameFormat3Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat3
	return p
}

func (*QualifiedDataNameFormat3Context) IsQualifiedDataNameFormat3Context() {}

func NewQualifiedDataNameFormat3Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat3Context {
	var p = new(QualifiedDataNameFormat3Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat3

	return p
}

func (s *QualifiedDataNameFormat3Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat3Context) TextName() ITextNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextNameContext)
}

func (s *QualifiedDataNameFormat3Context) InLibrary() IInLibraryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInLibraryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInLibraryContext)
}

func (s *QualifiedDataNameFormat3Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat3Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat3Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat3(s)
	}
}

func (s *QualifiedDataNameFormat3Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat3(s)
	}
}

func (s *QualifiedDataNameFormat3Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat3(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat3() (localctx IQualifiedDataNameFormat3Context) {
	this := p
	_ = this

	localctx = NewQualifiedDataNameFormat3Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1096, Cobol85ParserRULE_qualifiedDataNameFormat3)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6091)
		p.TextName()
	}
	{
		p.SetState(6092)
		p.InLibrary()
	}

	return localctx
}

// IQualifiedDataNameFormat4Context is an interface to support dynamic dispatch.
type IQualifiedDataNameFormat4Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedDataNameFormat4Context differentiates from other interfaces.
	IsQualifiedDataNameFormat4Context()
}

type QualifiedDataNameFormat4Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedDataNameFormat4Context() *QualifiedDataNameFormat4Context {
	var p = new(QualifiedDataNameFormat4Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat4
	return p
}

func (*QualifiedDataNameFormat4Context) IsQualifiedDataNameFormat4Context() {}

func NewQualifiedDataNameFormat4Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedDataNameFormat4Context {
	var p = new(QualifiedDataNameFormat4Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedDataNameFormat4

	return p
}

func (s *QualifiedDataNameFormat4Context) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedDataNameFormat4Context) LINAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE_COUNTER, 0)
}

func (s *QualifiedDataNameFormat4Context) InFile() IInFileContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInFileContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInFileContext)
}

func (s *QualifiedDataNameFormat4Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedDataNameFormat4Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedDataNameFormat4Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedDataNameFormat4(s)
	}
}

func (s *QualifiedDataNameFormat4Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedDataNameFormat4(s)
	}
}

func (s *QualifiedDataNameFormat4Context) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedDataNameFormat4(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedDataNameFormat4() (localctx IQualifiedDataNameFormat4Context) {
	this := p
	_ = this

	localctx = NewQualifiedDataNameFormat4Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1098, Cobol85ParserRULE_qualifiedDataNameFormat4)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6094)
		p.Match(Cobol85ParserLINAGE_COUNTER)
	}
	{
		p.SetState(6095)
		p.InFile()
	}

	return localctx
}

// IQualifiedInDataContext is an interface to support dynamic dispatch.
type IQualifiedInDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQualifiedInDataContext differentiates from other interfaces.
	IsQualifiedInDataContext()
}

type QualifiedInDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedInDataContext() *QualifiedInDataContext {
	var p = new(QualifiedInDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_qualifiedInData
	return p
}

func (*QualifiedInDataContext) IsQualifiedInDataContext() {}

func NewQualifiedInDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedInDataContext {
	var p = new(QualifiedInDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_qualifiedInData

	return p
}

func (s *QualifiedInDataContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedInDataContext) InData() IInDataContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInDataContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInDataContext)
}

func (s *QualifiedInDataContext) InTable() IInTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInTableContext)
}

func (s *QualifiedInDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedInDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedInDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterQualifiedInData(s)
	}
}

func (s *QualifiedInDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitQualifiedInData(s)
	}
}

func (s *QualifiedInDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitQualifiedInData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) QualifiedInData() (localctx IQualifiedInDataContext) {
	this := p
	_ = this

	localctx = NewQualifiedInDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1100, Cobol85ParserRULE_qualifiedInData)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6099)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 963, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6097)
			p.InData()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6098)
			p.InTable()
		}

	}

	return localctx
}

// IInDataContext is an interface to support dynamic dispatch.
type IInDataContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInDataContext differentiates from other interfaces.
	IsInDataContext()
}

type InDataContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInDataContext() *InDataContext {
	var p = new(InDataContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inData
	return p
}

func (*InDataContext) IsInDataContext() {}

func NewInDataContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InDataContext {
	var p = new(InDataContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inData

	return p
}

func (s *InDataContext) GetParser() antlr.Parser { return s.parser }

func (s *InDataContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *InDataContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InDataContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InDataContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InDataContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InDataContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInData(s)
	}
}

func (s *InDataContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInData(s)
	}
}

func (s *InDataContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInData(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InData() (localctx IInDataContext) {
	this := p
	_ = this

	localctx = NewInDataContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1102, Cobol85ParserRULE_inData)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6101)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6102)
		p.DataName()
	}

	return localctx
}

// IInFileContext is an interface to support dynamic dispatch.
type IInFileContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInFileContext differentiates from other interfaces.
	IsInFileContext()
}

type InFileContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInFileContext() *InFileContext {
	var p = new(InFileContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inFile
	return p
}

func (*InFileContext) IsInFileContext() {}

func NewInFileContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InFileContext {
	var p = new(InFileContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inFile

	return p
}

func (s *InFileContext) GetParser() antlr.Parser { return s.parser }

func (s *InFileContext) FileName() IFileNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFileNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFileNameContext)
}

func (s *InFileContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InFileContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InFileContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InFileContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InFileContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInFile(s)
	}
}

func (s *InFileContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInFile(s)
	}
}

func (s *InFileContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInFile(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InFile() (localctx IInFileContext) {
	this := p
	_ = this

	localctx = NewInFileContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1104, Cobol85ParserRULE_inFile)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6104)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6105)
		p.FileName()
	}

	return localctx
}

// IInMnemonicContext is an interface to support dynamic dispatch.
type IInMnemonicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInMnemonicContext differentiates from other interfaces.
	IsInMnemonicContext()
}

type InMnemonicContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInMnemonicContext() *InMnemonicContext {
	var p = new(InMnemonicContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inMnemonic
	return p
}

func (*InMnemonicContext) IsInMnemonicContext() {}

func NewInMnemonicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InMnemonicContext {
	var p = new(InMnemonicContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inMnemonic

	return p
}

func (s *InMnemonicContext) GetParser() antlr.Parser { return s.parser }

func (s *InMnemonicContext) MnemonicName() IMnemonicNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMnemonicNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMnemonicNameContext)
}

func (s *InMnemonicContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InMnemonicContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InMnemonicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InMnemonicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InMnemonicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInMnemonic(s)
	}
}

func (s *InMnemonicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInMnemonic(s)
	}
}

func (s *InMnemonicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInMnemonic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InMnemonic() (localctx IInMnemonicContext) {
	this := p
	_ = this

	localctx = NewInMnemonicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1106, Cobol85ParserRULE_inMnemonic)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6107)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6108)
		p.MnemonicName()
	}

	return localctx
}

// IInSectionContext is an interface to support dynamic dispatch.
type IInSectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInSectionContext differentiates from other interfaces.
	IsInSectionContext()
}

type InSectionContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInSectionContext() *InSectionContext {
	var p = new(InSectionContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inSection
	return p
}

func (*InSectionContext) IsInSectionContext() {}

func NewInSectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InSectionContext {
	var p = new(InSectionContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inSection

	return p
}

func (s *InSectionContext) GetParser() antlr.Parser { return s.parser }

func (s *InSectionContext) SectionName() ISectionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISectionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *InSectionContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InSectionContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InSectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InSectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInSection(s)
	}
}

func (s *InSectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInSection(s)
	}
}

func (s *InSectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInSection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InSection() (localctx IInSectionContext) {
	this := p
	_ = this

	localctx = NewInSectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1108, Cobol85ParserRULE_inSection)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6110)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6111)
		p.SectionName()
	}

	return localctx
}

// IInLibraryContext is an interface to support dynamic dispatch.
type IInLibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInLibraryContext differentiates from other interfaces.
	IsInLibraryContext()
}

type InLibraryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInLibraryContext() *InLibraryContext {
	var p = new(InLibraryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inLibrary
	return p
}

func (*InLibraryContext) IsInLibraryContext() {}

func NewInLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InLibraryContext {
	var p = new(InLibraryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inLibrary

	return p
}

func (s *InLibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *InLibraryContext) LibraryName() ILibraryNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryNameContext)
}

func (s *InLibraryContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InLibraryContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InLibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InLibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InLibraryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInLibrary(s)
	}
}

func (s *InLibraryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInLibrary(s)
	}
}

func (s *InLibraryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInLibrary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InLibrary() (localctx IInLibraryContext) {
	this := p
	_ = this

	localctx = NewInLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1110, Cobol85ParserRULE_inLibrary)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6113)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6114)
		p.LibraryName()
	}

	return localctx
}

// IInTableContext is an interface to support dynamic dispatch.
type IInTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsInTableContext differentiates from other interfaces.
	IsInTableContext()
}

type InTableContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInTableContext() *InTableContext {
	var p = new(InTableContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_inTable
	return p
}

func (*InTableContext) IsInTableContext() {}

func NewInTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InTableContext {
	var p = new(InTableContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_inTable

	return p
}

func (s *InTableContext) GetParser() antlr.Parser { return s.parser }

func (s *InTableContext) TableCall() ITableCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableCallContext)
}

func (s *InTableContext) IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIN, 0)
}

func (s *InTableContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *InTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterInTable(s)
	}
}

func (s *InTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitInTable(s)
	}
}

func (s *InTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitInTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) InTable() (localctx IInTableContext) {
	this := p
	_ = this

	localctx = NewInTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1112, Cobol85ParserRULE_inTable)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6116)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserIN || _la == Cobol85ParserOF) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(6117)
		p.TableCall()
	}

	return localctx
}

// IAlphabetNameContext is an interface to support dynamic dispatch.
type IAlphabetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphabetNameContext differentiates from other interfaces.
	IsAlphabetNameContext()
}

type AlphabetNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphabetNameContext() *AlphabetNameContext {
	var p = new(AlphabetNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_alphabetName
	return p
}

func (*AlphabetNameContext) IsAlphabetNameContext() {}

func NewAlphabetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphabetNameContext {
	var p = new(AlphabetNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_alphabetName

	return p
}

func (s *AlphabetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphabetNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *AlphabetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphabetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphabetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAlphabetName(s)
	}
}

func (s *AlphabetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAlphabetName(s)
	}
}

func (s *AlphabetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAlphabetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AlphabetName() (localctx IAlphabetNameContext) {
	this := p
	_ = this

	localctx = NewAlphabetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1114, Cobol85ParserRULE_alphabetName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6119)
		p.CobolWord()
	}

	return localctx
}

// IAssignmentNameContext is an interface to support dynamic dispatch.
type IAssignmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAssignmentNameContext differentiates from other interfaces.
	IsAssignmentNameContext()
}

type AssignmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAssignmentNameContext() *AssignmentNameContext {
	var p = new(AssignmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_assignmentName
	return p
}

func (*AssignmentNameContext) IsAssignmentNameContext() {}

func NewAssignmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AssignmentNameContext {
	var p = new(AssignmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_assignmentName

	return p
}

func (s *AssignmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *AssignmentNameContext) SystemName() ISystemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *AssignmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AssignmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AssignmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterAssignmentName(s)
	}
}

func (s *AssignmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitAssignmentName(s)
	}
}

func (s *AssignmentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitAssignmentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) AssignmentName() (localctx IAssignmentNameContext) {
	this := p
	_ = this

	localctx = NewAssignmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1116, Cobol85ParserRULE_assignmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6121)
		p.SystemName()
	}

	return localctx
}

// IBasisNameContext is an interface to support dynamic dispatch.
type IBasisNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBasisNameContext differentiates from other interfaces.
	IsBasisNameContext()
}

type BasisNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBasisNameContext() *BasisNameContext {
	var p = new(BasisNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_basisName
	return p
}

func (*BasisNameContext) IsBasisNameContext() {}

func NewBasisNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BasisNameContext {
	var p = new(BasisNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_basisName

	return p
}

func (s *BasisNameContext) GetParser() antlr.Parser { return s.parser }

func (s *BasisNameContext) ProgramName() IProgramNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProgramNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProgramNameContext)
}

func (s *BasisNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BasisNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BasisNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBasisName(s)
	}
}

func (s *BasisNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBasisName(s)
	}
}

func (s *BasisNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBasisName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BasisName() (localctx IBasisNameContext) {
	this := p
	_ = this

	localctx = NewBasisNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1118, Cobol85ParserRULE_basisName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6123)
		p.ProgramName()
	}

	return localctx
}

// ICdNameContext is an interface to support dynamic dispatch.
type ICdNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCdNameContext differentiates from other interfaces.
	IsCdNameContext()
}

type CdNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCdNameContext() *CdNameContext {
	var p = new(CdNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cdName
	return p
}

func (*CdNameContext) IsCdNameContext() {}

func NewCdNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CdNameContext {
	var p = new(CdNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cdName

	return p
}

func (s *CdNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CdNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CdNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CdNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CdNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCdName(s)
	}
}

func (s *CdNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCdName(s)
	}
}

func (s *CdNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCdName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CdName() (localctx ICdNameContext) {
	this := p
	_ = this

	localctx = NewCdNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1120, Cobol85ParserRULE_cdName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6125)
		p.CobolWord()
	}

	return localctx
}

// IClassNameContext is an interface to support dynamic dispatch.
type IClassNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsClassNameContext differentiates from other interfaces.
	IsClassNameContext()
}

type ClassNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyClassNameContext() *ClassNameContext {
	var p = new(ClassNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_className
	return p
}

func (*ClassNameContext) IsClassNameContext() {}

func NewClassNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ClassNameContext {
	var p = new(ClassNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_className

	return p
}

func (s *ClassNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ClassNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ClassNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ClassNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ClassNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterClassName(s)
	}
}

func (s *ClassNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitClassName(s)
	}
}

func (s *ClassNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitClassName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ClassName() (localctx IClassNameContext) {
	this := p
	_ = this

	localctx = NewClassNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1122, Cobol85ParserRULE_className)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6127)
		p.CobolWord()
	}

	return localctx
}

// IComputerNameContext is an interface to support dynamic dispatch.
type IComputerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsComputerNameContext differentiates from other interfaces.
	IsComputerNameContext()
}

type ComputerNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComputerNameContext() *ComputerNameContext {
	var p = new(ComputerNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_computerName
	return p
}

func (*ComputerNameContext) IsComputerNameContext() {}

func NewComputerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComputerNameContext {
	var p = new(ComputerNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_computerName

	return p
}

func (s *ComputerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ComputerNameContext) SystemName() ISystemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *ComputerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComputerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComputerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterComputerName(s)
	}
}

func (s *ComputerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitComputerName(s)
	}
}

func (s *ComputerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitComputerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ComputerName() (localctx IComputerNameContext) {
	this := p
	_ = this

	localctx = NewComputerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1124, Cobol85ParserRULE_computerName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6129)
		p.SystemName()
	}

	return localctx
}

// IConditionNameContext is an interface to support dynamic dispatch.
type IConditionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsConditionNameContext differentiates from other interfaces.
	IsConditionNameContext()
}

type ConditionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConditionNameContext() *ConditionNameContext {
	var p = new(ConditionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_conditionName
	return p
}

func (*ConditionNameContext) IsConditionNameContext() {}

func NewConditionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConditionNameContext {
	var p = new(ConditionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_conditionName

	return p
}

func (s *ConditionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConditionNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ConditionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConditionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConditionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterConditionName(s)
	}
}

func (s *ConditionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitConditionName(s)
	}
}

func (s *ConditionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitConditionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ConditionName() (localctx IConditionNameContext) {
	this := p
	_ = this

	localctx = NewConditionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1126, Cobol85ParserRULE_conditionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6131)
		p.CobolWord()
	}

	return localctx
}

// IDataNameContext is an interface to support dynamic dispatch.
type IDataNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataNameContext differentiates from other interfaces.
	IsDataNameContext()
}

type DataNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataNameContext() *DataNameContext {
	var p = new(DataNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataName
	return p
}

func (*DataNameContext) IsDataNameContext() {}

func NewDataNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataNameContext {
	var p = new(DataNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataName

	return p
}

func (s *DataNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *DataNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataName(s)
	}
}

func (s *DataNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataName(s)
	}
}

func (s *DataNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataName() (localctx IDataNameContext) {
	this := p
	_ = this

	localctx = NewDataNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1128, Cobol85ParserRULE_dataName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6133)
		p.CobolWord()
	}

	return localctx
}

// IDataDescNameContext is an interface to support dynamic dispatch.
type IDataDescNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDataDescNameContext differentiates from other interfaces.
	IsDataDescNameContext()
}

type DataDescNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDescNameContext() *DataDescNameContext {
	var p = new(DataDescNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_dataDescName
	return p
}

func (*DataDescNameContext) IsDataDescNameContext() {}

func NewDataDescNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDescNameContext {
	var p = new(DataDescNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_dataDescName

	return p
}

func (s *DataDescNameContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDescNameContext) FILLER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFILLER, 0)
}

func (s *DataDescNameContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURSOR, 0)
}

func (s *DataDescNameContext) DataName() IDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataNameContext)
}

func (s *DataDescNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDescNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDescNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterDataDescName(s)
	}
}

func (s *DataDescNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitDataDescName(s)
	}
}

func (s *DataDescNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitDataDescName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) DataDescName() (localctx IDataDescNameContext) {
	this := p
	_ = this

	localctx = NewDataDescNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1130, Cobol85ParserRULE_dataDescName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6138)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 964, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6135)
			p.Match(Cobol85ParserFILLER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6136)
			p.Match(Cobol85ParserCURSOR)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6137)
			p.DataName()
		}

	}

	return localctx
}

// IEnvironmentNameContext is an interface to support dynamic dispatch.
type IEnvironmentNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEnvironmentNameContext differentiates from other interfaces.
	IsEnvironmentNameContext()
}

type EnvironmentNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEnvironmentNameContext() *EnvironmentNameContext {
	var p = new(EnvironmentNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_environmentName
	return p
}

func (*EnvironmentNameContext) IsEnvironmentNameContext() {}

func NewEnvironmentNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EnvironmentNameContext {
	var p = new(EnvironmentNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_environmentName

	return p
}

func (s *EnvironmentNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EnvironmentNameContext) SystemName() ISystemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *EnvironmentNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EnvironmentNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EnvironmentNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterEnvironmentName(s)
	}
}

func (s *EnvironmentNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitEnvironmentName(s)
	}
}

func (s *EnvironmentNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitEnvironmentName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) EnvironmentName() (localctx IEnvironmentNameContext) {
	this := p
	_ = this

	localctx = NewEnvironmentNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1132, Cobol85ParserRULE_environmentName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6140)
		p.SystemName()
	}

	return localctx
}

// IFileNameContext is an interface to support dynamic dispatch.
type IFileNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFileNameContext differentiates from other interfaces.
	IsFileNameContext()
}

type FileNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFileNameContext() *FileNameContext {
	var p = new(FileNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_fileName
	return p
}

func (*FileNameContext) IsFileNameContext() {}

func NewFileNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FileNameContext {
	var p = new(FileNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_fileName

	return p
}

func (s *FileNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FileNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FileNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FileNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FileNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFileName(s)
	}
}

func (s *FileNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFileName(s)
	}
}

func (s *FileNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFileName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FileName() (localctx IFileNameContext) {
	this := p
	_ = this

	localctx = NewFileNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1134, Cobol85ParserRULE_fileName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6142)
		p.CobolWord()
	}

	return localctx
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_functionName
	return p
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *FunctionNameContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *FunctionNameContext) RANDOM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRANDOM, 0)
}

func (s *FunctionNameContext) SUM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSUM, 0)
}

func (s *FunctionNameContext) WHEN_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN_COMPILED, 0)
}

func (s *FunctionNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FunctionName() (localctx IFunctionNameContext) {
	this := p
	_ = this

	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1136, Cobol85ParserRULE_functionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6150)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 965, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6144)
			p.Match(Cobol85ParserINTEGER)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6145)
			p.Match(Cobol85ParserLENGTH)
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6146)
			p.Match(Cobol85ParserRANDOM)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6147)
			p.Match(Cobol85ParserSUM)
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6148)
			p.Match(Cobol85ParserWHEN_COMPILED)
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6149)
			p.CobolWord()
		}

	}

	return localctx
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_indexName
	return p
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IndexName() (localctx IIndexNameContext) {
	this := p
	_ = this

	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1138, Cobol85ParserRULE_indexName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6152)
		p.CobolWord()
	}

	return localctx
}

// ILanguageNameContext is an interface to support dynamic dispatch.
type ILanguageNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLanguageNameContext differentiates from other interfaces.
	IsLanguageNameContext()
}

type LanguageNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLanguageNameContext() *LanguageNameContext {
	var p = new(LanguageNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_languageName
	return p
}

func (*LanguageNameContext) IsLanguageNameContext() {}

func NewLanguageNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LanguageNameContext {
	var p = new(LanguageNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_languageName

	return p
}

func (s *LanguageNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LanguageNameContext) SystemName() ISystemNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemNameContext)
}

func (s *LanguageNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LanguageNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LanguageNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLanguageName(s)
	}
}

func (s *LanguageNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLanguageName(s)
	}
}

func (s *LanguageNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLanguageName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LanguageName() (localctx ILanguageNameContext) {
	this := p
	_ = this

	localctx = NewLanguageNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1140, Cobol85ParserRULE_languageName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6154)
		p.SystemName()
	}

	return localctx
}

// ILibraryNameContext is an interface to support dynamic dispatch.
type ILibraryNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLibraryNameContext differentiates from other interfaces.
	IsLibraryNameContext()
}

type LibraryNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryNameContext() *LibraryNameContext {
	var p = new(LibraryNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_libraryName
	return p
}

func (*LibraryNameContext) IsLibraryNameContext() {}

func NewLibraryNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryNameContext {
	var p = new(LibraryNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_libraryName

	return p
}

func (s *LibraryNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *LibraryNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LibraryNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLibraryName(s)
	}
}

func (s *LibraryNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLibraryName(s)
	}
}

func (s *LibraryNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLibraryName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LibraryName() (localctx ILibraryNameContext) {
	this := p
	_ = this

	localctx = NewLibraryNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1142, Cobol85ParserRULE_libraryName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6156)
		p.CobolWord()
	}

	return localctx
}

// ILocalNameContext is an interface to support dynamic dispatch.
type ILocalNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocalNameContext differentiates from other interfaces.
	IsLocalNameContext()
}

type LocalNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalNameContext() *LocalNameContext {
	var p = new(LocalNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_localName
	return p
}

func (*LocalNameContext) IsLocalNameContext() {}

func NewLocalNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalNameContext {
	var p = new(LocalNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_localName

	return p
}

func (s *LocalNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *LocalNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LocalNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLocalName(s)
	}
}

func (s *LocalNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLocalName(s)
	}
}

func (s *LocalNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLocalName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) LocalName() (localctx ILocalNameContext) {
	this := p
	_ = this

	localctx = NewLocalNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1144, Cobol85ParserRULE_localName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6158)
		p.CobolWord()
	}

	return localctx
}

// IMnemonicNameContext is an interface to support dynamic dispatch.
type IMnemonicNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMnemonicNameContext differentiates from other interfaces.
	IsMnemonicNameContext()
}

type MnemonicNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMnemonicNameContext() *MnemonicNameContext {
	var p = new(MnemonicNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_mnemonicName
	return p
}

func (*MnemonicNameContext) IsMnemonicNameContext() {}

func NewMnemonicNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MnemonicNameContext {
	var p = new(MnemonicNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_mnemonicName

	return p
}

func (s *MnemonicNameContext) GetParser() antlr.Parser { return s.parser }

func (s *MnemonicNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *MnemonicNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MnemonicNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MnemonicNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterMnemonicName(s)
	}
}

func (s *MnemonicNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitMnemonicName(s)
	}
}

func (s *MnemonicNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitMnemonicName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) MnemonicName() (localctx IMnemonicNameContext) {
	this := p
	_ = this

	localctx = NewMnemonicNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1146, Cobol85ParserRULE_mnemonicName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6160)
		p.CobolWord()
	}

	return localctx
}

// IParagraphNameContext is an interface to support dynamic dispatch.
type IParagraphNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsParagraphNameContext differentiates from other interfaces.
	IsParagraphNameContext()
}

type ParagraphNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParagraphNameContext() *ParagraphNameContext {
	var p = new(ParagraphNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_paragraphName
	return p
}

func (*ParagraphNameContext) IsParagraphNameContext() {}

func NewParagraphNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParagraphNameContext {
	var p = new(ParagraphNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_paragraphName

	return p
}

func (s *ParagraphNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParagraphNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ParagraphNameContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *ParagraphNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParagraphNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParagraphNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterParagraphName(s)
	}
}

func (s *ParagraphNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitParagraphName(s)
	}
}

func (s *ParagraphNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitParagraphName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ParagraphName() (localctx IParagraphNameContext) {
	this := p
	_ = this

	localctx = NewParagraphNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1148, Cobol85ParserRULE_paragraphName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6164)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6162)
			p.CobolWord()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6163)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_procedureName
	return p
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) ParagraphName() IParagraphNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParagraphNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParagraphNameContext)
}

func (s *ProcedureNameContext) InSection() IInSectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInSectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInSectionContext)
}

func (s *ProcedureNameContext) SectionName() ISectionNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISectionNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISectionNameContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (s *ProcedureNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProcedureName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProcedureName() (localctx IProcedureNameContext) {
	this := p
	_ = this

	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1150, Cobol85ParserRULE_procedureName)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6171)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 968, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6166)
			p.ParagraphName()
		}
		p.SetState(6168)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserIN || _la == Cobol85ParserOF {
			{
				p.SetState(6167)
				p.InSection()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6170)
			p.SectionName()
		}

	}

	return localctx
}

// IProgramNameContext is an interface to support dynamic dispatch.
type IProgramNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsProgramNameContext differentiates from other interfaces.
	IsProgramNameContext()
}

type ProgramNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProgramNameContext() *ProgramNameContext {
	var p = new(ProgramNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_programName
	return p
}

func (*ProgramNameContext) IsProgramNameContext() {}

func NewProgramNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProgramNameContext {
	var p = new(ProgramNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_programName

	return p
}

func (s *ProgramNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProgramNameContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNONNUMERICLITERAL, 0)
}

func (s *ProgramNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ProgramNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProgramNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProgramNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterProgramName(s)
	}
}

func (s *ProgramNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitProgramName(s)
	}
}

func (s *ProgramNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitProgramName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ProgramName() (localctx IProgramNameContext) {
	this := p
	_ = this

	localctx = NewProgramNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1152, Cobol85ParserRULE_programName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6175)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNONNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6173)
			p.Match(Cobol85ParserNONNUMERICLITERAL)
		}

	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6174)
			p.CobolWord()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IRecordNameContext is an interface to support dynamic dispatch.
type IRecordNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRecordNameContext differentiates from other interfaces.
	IsRecordNameContext()
}

type RecordNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRecordNameContext() *RecordNameContext {
	var p = new(RecordNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_recordName
	return p
}

func (*RecordNameContext) IsRecordNameContext() {}

func NewRecordNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RecordNameContext {
	var p = new(RecordNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_recordName

	return p
}

func (s *RecordNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RecordNameContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *RecordNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RecordNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RecordNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRecordName(s)
	}
}

func (s *RecordNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRecordName(s)
	}
}

func (s *RecordNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRecordName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RecordName() (localctx IRecordNameContext) {
	this := p
	_ = this

	localctx = NewRecordNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1154, Cobol85ParserRULE_recordName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6177)
		p.QualifiedDataName()
	}

	return localctx
}

// IReportNameContext is an interface to support dynamic dispatch.
type IReportNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsReportNameContext differentiates from other interfaces.
	IsReportNameContext()
}

type ReportNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReportNameContext() *ReportNameContext {
	var p = new(ReportNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_reportName
	return p
}

func (*ReportNameContext) IsReportNameContext() {}

func NewReportNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReportNameContext {
	var p = new(ReportNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_reportName

	return p
}

func (s *ReportNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ReportNameContext) QualifiedDataName() IQualifiedDataNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedDataNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedDataNameContext)
}

func (s *ReportNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReportNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReportNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterReportName(s)
	}
}

func (s *ReportNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitReportName(s)
	}
}

func (s *ReportNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitReportName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ReportName() (localctx IReportNameContext) {
	this := p
	_ = this

	localctx = NewReportNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1156, Cobol85ParserRULE_reportName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6179)
		p.QualifiedDataName()
	}

	return localctx
}

// IRoutineNameContext is an interface to support dynamic dispatch.
type IRoutineNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsRoutineNameContext differentiates from other interfaces.
	IsRoutineNameContext()
}

type RoutineNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoutineNameContext() *RoutineNameContext {
	var p = new(RoutineNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_routineName
	return p
}

func (*RoutineNameContext) IsRoutineNameContext() {}

func NewRoutineNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoutineNameContext {
	var p = new(RoutineNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_routineName

	return p
}

func (s *RoutineNameContext) GetParser() antlr.Parser { return s.parser }

func (s *RoutineNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *RoutineNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoutineNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoutineNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterRoutineName(s)
	}
}

func (s *RoutineNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitRoutineName(s)
	}
}

func (s *RoutineNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitRoutineName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) RoutineName() (localctx IRoutineNameContext) {
	this := p
	_ = this

	localctx = NewRoutineNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1158, Cobol85ParserRULE_routineName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6181)
		p.CobolWord()
	}

	return localctx
}

// IScreenNameContext is an interface to support dynamic dispatch.
type IScreenNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsScreenNameContext differentiates from other interfaces.
	IsScreenNameContext()
}

type ScreenNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyScreenNameContext() *ScreenNameContext {
	var p = new(ScreenNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_screenName
	return p
}

func (*ScreenNameContext) IsScreenNameContext() {}

func NewScreenNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ScreenNameContext {
	var p = new(ScreenNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_screenName

	return p
}

func (s *ScreenNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ScreenNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *ScreenNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ScreenNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ScreenNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterScreenName(s)
	}
}

func (s *ScreenNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitScreenName(s)
	}
}

func (s *ScreenNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitScreenName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) ScreenName() (localctx IScreenNameContext) {
	this := p
	_ = this

	localctx = NewScreenNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1160, Cobol85ParserRULE_screenName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6183)
		p.CobolWord()
	}

	return localctx
}

// ISectionNameContext is an interface to support dynamic dispatch.
type ISectionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSectionNameContext differentiates from other interfaces.
	IsSectionNameContext()
}

type SectionNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySectionNameContext() *SectionNameContext {
	var p = new(SectionNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_sectionName
	return p
}

func (*SectionNameContext) IsSectionNameContext() {}

func NewSectionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SectionNameContext {
	var p = new(SectionNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_sectionName

	return p
}

func (s *SectionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SectionNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SectionNameContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *SectionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SectionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SectionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSectionName(s)
	}
}

func (s *SectionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSectionName(s)
	}
}

func (s *SectionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSectionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SectionName() (localctx ISectionNameContext) {
	this := p
	_ = this

	localctx = NewSectionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1162, Cobol85ParserRULE_sectionName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6187)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserABORT, Cobol85ParserAS, Cobol85ParserASCII, Cobol85ParserASSOCIATED_DATA, Cobol85ParserASSOCIATED_DATA_LENGTH, Cobol85ParserATTRIBUTE, Cobol85ParserAUTO, Cobol85ParserAUTO_SKIP, Cobol85ParserBACKGROUND_COLOR, Cobol85ParserBACKGROUND_COLOUR, Cobol85ParserBEEP, Cobol85ParserBELL, Cobol85ParserBINARY, Cobol85ParserBIT, Cobol85ParserBLINK, Cobol85ParserBOUNDS, Cobol85ParserCAPABLE, Cobol85ParserCCSVERSION, Cobol85ParserCHANGED, Cobol85ParserCHANNEL, Cobol85ParserCLOSE_DISPOSITION, Cobol85ParserCOBOL, Cobol85ParserCOMMITMENT, Cobol85ParserCONTROL_POINT, Cobol85ParserCONVENTION, Cobol85ParserCRUNCH, Cobol85ParserCURSOR, Cobol85ParserDEFAULT, Cobol85ParserDEFAULT_DISPLAY, Cobol85ParserDEFINITION, Cobol85ParserDFHRESP, Cobol85ParserDFHVALUE, Cobol85ParserDISK, Cobol85ParserDONTCARE, Cobol85ParserDOUBLE, Cobol85ParserEBCDIC, Cobol85ParserEMPTY_CHECK, Cobol85ParserENTER, Cobol85ParserENTRY_PROCEDURE, Cobol85ParserERASE, Cobol85ParserEOL, Cobol85ParserEOS, Cobol85ParserESCAPE, Cobol85ParserEVENT, Cobol85ParserEXCLUSIVE, Cobol85ParserEXPORT, Cobol85ParserEXTENDED, Cobol85ParserFOREGROUND_COLOR, Cobol85ParserFOREGROUND_COLOUR, Cobol85ParserFULL, Cobol85ParserFUNCTIONNAME, Cobol85ParserFUNCTION_POINTER, Cobol85ParserGRID, Cobol85ParserHIGHLIGHT, Cobol85ParserIMPLICIT, Cobol85ParserIMPORT, Cobol85ParserINTEGER, Cobol85ParserKEPT, Cobol85ParserKEYBOARD, Cobol85ParserLANGUAGE, Cobol85ParserLB, Cobol85ParserLD, Cobol85ParserLEFTLINE, Cobol85ParserLENGTH_CHECK, Cobol85ParserLIBACCESS, Cobol85ParserLIBPARAMETER, Cobol85ParserLIBRARY, Cobol85ParserLIST, Cobol85ParserLOCAL, Cobol85ParserLONG_DATE, Cobol85ParserLONG_TIME, Cobol85ParserLOWER, Cobol85ParserLOWLIGHT, Cobol85ParserMMDDYYYY, Cobol85ParserNAMED, Cobol85ParserNATIONAL, Cobol85ParserNATIONAL_EDITED, Cobol85ParserNETWORK, Cobol85ParserNO_ECHO, Cobol85ParserNUMERIC_DATE, Cobol85ParserNUMERIC_TIME, Cobol85ParserODT, Cobol85ParserORDERLY, Cobol85ParserOVERLINE, Cobol85ParserOWN, Cobol85ParserPASSWORD, Cobol85ParserPORT, Cobol85ParserPRINTER, Cobol85ParserPRIVATE, Cobol85ParserPROCESS, Cobol85ParserPROGRAM, Cobol85ParserPROMPT, Cobol85ParserREADER, Cobol85ParserREMOTE, Cobol85ParserREAL, Cobol85ParserRECEIVED, Cobol85ParserRECURSIVE, Cobol85ParserREF, Cobol85ParserREMOVE, Cobol85ParserREQUIRED, Cobol85ParserREVERSE_VIDEO, Cobol85ParserSAVE, Cobol85ParserSECURE, Cobol85ParserSHARED, Cobol85ParserSHAREDBYALL, Cobol85ParserSHAREDBYRUNUNIT, Cobol85ParserSHARING, Cobol85ParserSHORT_DATE, Cobol85ParserSYMBOL, Cobol85ParserTASK, Cobol85ParserTHREAD, Cobol85ParserTHREAD_LOCAL, Cobol85ParserTIMER, Cobol85ParserTODAYS_DATE, Cobol85ParserTODAYS_NAME, Cobol85ParserTRUNCATED, Cobol85ParserTYPEDEF, Cobol85ParserUNDERLINE, Cobol85ParserVIRTUAL, Cobol85ParserWAIT, Cobol85ParserYEAR, Cobol85ParserYYYYMMDD, Cobol85ParserYYYYDDD, Cobol85ParserZERO_FILL, Cobol85ParserIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6185)
			p.CobolWord()
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6186)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISystemNameContext is an interface to support dynamic dispatch.
type ISystemNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSystemNameContext differentiates from other interfaces.
	IsSystemNameContext()
}

type SystemNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemNameContext() *SystemNameContext {
	var p = new(SystemNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_systemName
	return p
}

func (*SystemNameContext) IsSystemNameContext() {}

func NewSystemNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemNameContext {
	var p = new(SystemNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_systemName

	return p
}

func (s *SystemNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SystemNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSystemName(s)
	}
}

func (s *SystemNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSystemName(s)
	}
}

func (s *SystemNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSystemName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SystemName() (localctx ISystemNameContext) {
	this := p
	_ = this

	localctx = NewSystemNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1164, Cobol85ParserRULE_systemName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6189)
		p.CobolWord()
	}

	return localctx
}

// ISymbolicCharacterContext is an interface to support dynamic dispatch.
type ISymbolicCharacterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSymbolicCharacterContext differentiates from other interfaces.
	IsSymbolicCharacterContext()
}

type SymbolicCharacterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySymbolicCharacterContext() *SymbolicCharacterContext {
	var p = new(SymbolicCharacterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacter
	return p
}

func (*SymbolicCharacterContext) IsSymbolicCharacterContext() {}

func NewSymbolicCharacterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SymbolicCharacterContext {
	var p = new(SymbolicCharacterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_symbolicCharacter

	return p
}

func (s *SymbolicCharacterContext) GetParser() antlr.Parser { return s.parser }

func (s *SymbolicCharacterContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *SymbolicCharacterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SymbolicCharacterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SymbolicCharacterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSymbolicCharacter(s)
	}
}

func (s *SymbolicCharacterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSymbolicCharacter(s)
	}
}

func (s *SymbolicCharacterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSymbolicCharacter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SymbolicCharacter() (localctx ISymbolicCharacterContext) {
	this := p
	_ = this

	localctx = NewSymbolicCharacterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1166, Cobol85ParserRULE_symbolicCharacter)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6191)
		p.CobolWord()
	}

	return localctx
}

// ITextNameContext is an interface to support dynamic dispatch.
type ITextNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTextNameContext differentiates from other interfaces.
	IsTextNameContext()
}

type TextNameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextNameContext() *TextNameContext {
	var p = new(TextNameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_textName
	return p
}

func (*TextNameContext) IsTextNameContext() {}

func NewTextNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextNameContext {
	var p = new(TextNameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_textName

	return p
}

func (s *TextNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TextNameContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *TextNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterTextName(s)
	}
}

func (s *TextNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitTextName(s)
	}
}

func (s *TextNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitTextName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) TextName() (localctx ITextNameContext) {
	this := p
	_ = this

	localctx = NewTextNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1168, Cobol85ParserRULE_textName)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6193)
		p.CobolWord()
	}

	return localctx
}

// ICobolWordContext is an interface to support dynamic dispatch.
type ICobolWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCobolWordContext differentiates from other interfaces.
	IsCobolWordContext()
}

type CobolWordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCobolWordContext() *CobolWordContext {
	var p = new(CobolWordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cobolWord
	return p
}

func (*CobolWordContext) IsCobolWordContext() {}

func NewCobolWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CobolWordContext {
	var p = new(CobolWordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cobolWord

	return p
}

func (s *CobolWordContext) GetParser() antlr.Parser { return s.parser }

func (s *CobolWordContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIDENTIFIER, 0)
}

func (s *CobolWordContext) COBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOBOL, 0)
}

func (s *CobolWordContext) PROGRAM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROGRAM, 0)
}

func (s *CobolWordContext) ABORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserABORT, 0)
}

func (s *CobolWordContext) AS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAS, 0)
}

func (s *CobolWordContext) ASCII() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASCII, 0)
}

func (s *CobolWordContext) ASSOCIATED_DATA() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA, 0)
}

func (s *CobolWordContext) ASSOCIATED_DATA_LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserASSOCIATED_DATA_LENGTH, 0)
}

func (s *CobolWordContext) ATTRIBUTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserATTRIBUTE, 0)
}

func (s *CobolWordContext) AUTO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO, 0)
}

func (s *CobolWordContext) AUTO_SKIP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserAUTO_SKIP, 0)
}

func (s *CobolWordContext) BACKGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOR, 0)
}

func (s *CobolWordContext) BACKGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBACKGROUND_COLOUR, 0)
}

func (s *CobolWordContext) BEEP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBEEP, 0)
}

func (s *CobolWordContext) BELL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBELL, 0)
}

func (s *CobolWordContext) BINARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBINARY, 0)
}

func (s *CobolWordContext) BIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBIT, 0)
}

func (s *CobolWordContext) BLINK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBLINK, 0)
}

func (s *CobolWordContext) BOUNDS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserBOUNDS, 0)
}

func (s *CobolWordContext) CAPABLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCAPABLE, 0)
}

func (s *CobolWordContext) CCSVERSION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCCSVERSION, 0)
}

func (s *CobolWordContext) CHANGED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANGED, 0)
}

func (s *CobolWordContext) CHANNEL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCHANNEL, 0)
}

func (s *CobolWordContext) CLOSE_DISPOSITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCLOSE_DISPOSITION, 0)
}

func (s *CobolWordContext) COMMITMENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMITMENT, 0)
}

func (s *CobolWordContext) CONTROL_POINT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONTROL_POINT, 0)
}

func (s *CobolWordContext) CONVENTION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCONVENTION, 0)
}

func (s *CobolWordContext) CRUNCH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCRUNCH, 0)
}

func (s *CobolWordContext) CURSOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCURSOR, 0)
}

func (s *CobolWordContext) DEFAULT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT, 0)
}

func (s *CobolWordContext) DEFAULT_DISPLAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFAULT_DISPLAY, 0)
}

func (s *CobolWordContext) DEFINITION() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEFINITION, 0)
}

func (s *CobolWordContext) DFHRESP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHRESP, 0)
}

func (s *CobolWordContext) DFHVALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHVALUE, 0)
}

func (s *CobolWordContext) DISK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDISK, 0)
}

func (s *CobolWordContext) DONTCARE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDONTCARE, 0)
}

func (s *CobolWordContext) DOUBLE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDOUBLE, 0)
}

func (s *CobolWordContext) EBCDIC() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEBCDIC, 0)
}

func (s *CobolWordContext) EMPTY_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEMPTY_CHECK, 0)
}

func (s *CobolWordContext) ENTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTER, 0)
}

func (s *CobolWordContext) ENTRY_PROCEDURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserENTRY_PROCEDURE, 0)
}

func (s *CobolWordContext) EOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOL, 0)
}

func (s *CobolWordContext) EOS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEOS, 0)
}

func (s *CobolWordContext) ERASE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserERASE, 0)
}

func (s *CobolWordContext) ESCAPE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserESCAPE, 0)
}

func (s *CobolWordContext) EVENT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEVENT, 0)
}

func (s *CobolWordContext) EXCLUSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXCLUSIVE, 0)
}

func (s *CobolWordContext) EXPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXPORT, 0)
}

func (s *CobolWordContext) EXTENDED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserEXTENDED, 0)
}

func (s *CobolWordContext) FOREGROUND_COLOR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOR, 0)
}

func (s *CobolWordContext) FOREGROUND_COLOUR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFOREGROUND_COLOUR, 0)
}

func (s *CobolWordContext) FULL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFULL, 0)
}

func (s *CobolWordContext) FUNCTIONNAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTIONNAME, 0)
}

func (s *CobolWordContext) FUNCTION_POINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFUNCTION_POINTER, 0)
}

func (s *CobolWordContext) GRID() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserGRID, 0)
}

func (s *CobolWordContext) HIGHLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGHLIGHT, 0)
}

func (s *CobolWordContext) IMPLICIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPLICIT, 0)
}

func (s *CobolWordContext) IMPORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserIMPORT, 0)
}

func (s *CobolWordContext) INTEGER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGER, 0)
}

func (s *CobolWordContext) KEPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEPT, 0)
}

func (s *CobolWordContext) KEYBOARD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserKEYBOARD, 0)
}

func (s *CobolWordContext) LANGUAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLANGUAGE, 0)
}

func (s *CobolWordContext) LB() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLB, 0)
}

func (s *CobolWordContext) LD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLD, 0)
}

func (s *CobolWordContext) LEFTLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEFTLINE, 0)
}

func (s *CobolWordContext) LENGTH_CHECK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH_CHECK, 0)
}

func (s *CobolWordContext) LIBACCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBACCESS, 0)
}

func (s *CobolWordContext) LIBPARAMETER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBPARAMETER, 0)
}

func (s *CobolWordContext) LIBRARY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIBRARY, 0)
}

func (s *CobolWordContext) LIST() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLIST, 0)
}

func (s *CobolWordContext) LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOCAL, 0)
}

func (s *CobolWordContext) LONG_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_DATE, 0)
}

func (s *CobolWordContext) LONG_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLONG_TIME, 0)
}

func (s *CobolWordContext) LOWER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWER, 0)
}

func (s *CobolWordContext) LOWLIGHT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOWLIGHT, 0)
}

func (s *CobolWordContext) MMDDYYYY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserMMDDYYYY, 0)
}

func (s *CobolWordContext) NAMED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNAMED, 0)
}

func (s *CobolWordContext) NATIONAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL, 0)
}

func (s *CobolWordContext) NATIONAL_EDITED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNATIONAL_EDITED, 0)
}

func (s *CobolWordContext) NETWORK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNETWORK, 0)
}

func (s *CobolWordContext) NO_ECHO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNO_ECHO, 0)
}

func (s *CobolWordContext) NUMERIC_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_DATE, 0)
}

func (s *CobolWordContext) NUMERIC_TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERIC_TIME, 0)
}

func (s *CobolWordContext) ODT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserODT, 0)
}

func (s *CobolWordContext) ORDERLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserORDERLY, 0)
}

func (s *CobolWordContext) OVERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOVERLINE, 0)
}

func (s *CobolWordContext) OWN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOWN, 0)
}

func (s *CobolWordContext) PASSWORD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPASSWORD, 0)
}

func (s *CobolWordContext) PORT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPORT, 0)
}

func (s *CobolWordContext) PRINTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRINTER, 0)
}

func (s *CobolWordContext) PRIVATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPRIVATE, 0)
}

func (s *CobolWordContext) PROCESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROCESS, 0)
}

func (s *CobolWordContext) PROMPT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPROMPT, 0)
}

func (s *CobolWordContext) READER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREADER, 0)
}

func (s *CobolWordContext) REAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREAL, 0)
}

func (s *CobolWordContext) RECEIVED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECEIVED, 0)
}

func (s *CobolWordContext) RECURSIVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRECURSIVE, 0)
}

func (s *CobolWordContext) REF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREF, 0)
}

func (s *CobolWordContext) REMOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOTE, 0)
}

func (s *CobolWordContext) REMOVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREMOVE, 0)
}

func (s *CobolWordContext) REQUIRED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREQUIRED, 0)
}

func (s *CobolWordContext) REVERSE_VIDEO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserREVERSE_VIDEO, 0)
}

func (s *CobolWordContext) SAVE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSAVE, 0)
}

func (s *CobolWordContext) SECURE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSECURE, 0)
}

func (s *CobolWordContext) SHARED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARED, 0)
}

func (s *CobolWordContext) SHAREDBYALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYALL, 0)
}

func (s *CobolWordContext) SHAREDBYRUNUNIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHAREDBYRUNUNIT, 0)
}

func (s *CobolWordContext) SHARING() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHARING, 0)
}

func (s *CobolWordContext) SHORT_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHORT_DATE, 0)
}

func (s *CobolWordContext) SYMBOL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSYMBOL, 0)
}

func (s *CobolWordContext) TASK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTASK, 0)
}

func (s *CobolWordContext) THREAD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD, 0)
}

func (s *CobolWordContext) THREAD_LOCAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTHREAD_LOCAL, 0)
}

func (s *CobolWordContext) TIMER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIMER, 0)
}

func (s *CobolWordContext) TODAYS_DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_DATE, 0)
}

func (s *CobolWordContext) TODAYS_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTODAYS_NAME, 0)
}

func (s *CobolWordContext) TRUNCATED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUNCATED, 0)
}

func (s *CobolWordContext) TYPEDEF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTYPEDEF, 0)
}

func (s *CobolWordContext) UNDERLINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserUNDERLINE, 0)
}

func (s *CobolWordContext) VIRTUAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserVIRTUAL, 0)
}

func (s *CobolWordContext) WAIT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWAIT, 0)
}

func (s *CobolWordContext) YEAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYEAR, 0)
}

func (s *CobolWordContext) YYYYMMDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYMMDD, 0)
}

func (s *CobolWordContext) YYYYDDD() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserYYYYDDD, 0)
}

func (s *CobolWordContext) ZERO_FILL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO_FILL, 0)
}

func (s *CobolWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CobolWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CobolWordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCobolWord(s)
	}
}

func (s *CobolWordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCobolWord(s)
	}
}

func (s *CobolWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCobolWord(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CobolWord() (localctx ICobolWordContext) {
	this := p
	_ = this

	localctx = NewCobolWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1170, Cobol85ParserRULE_cobolWord)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6195)
		_la = p.GetTokenStream().LA(1)

		if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&3512999431135821826) != 0 || (int64((_la-68)) & ^0x3f) == 0 && ((int64(1)<<(_la-68))&8070451912006173187) != 0 || (int64((_la-138)) & ^0x3f) == 0 && ((int64(1)<<(_la-138))&5276573893883339531) != 0 || (int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&-3098194965423761407) != 0 || (int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&-9202532752178970507) != 0 || (int64((_la-336)) & ^0x3f) == 0 && ((int64(1)<<(_la-336))&4647874433930428483) != 0 || (int64((_la-401)) & ^0x3f) == 0 && ((int64(1)<<(_la-401))&84826144769) != 0 || (int64((_la-466)) & ^0x3f) == 0 && ((int64(1)<<(_la-466))&103635575018455169) != 0 || _la == Cobol85ParserIDENTIFIER) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_literal
	return p
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) NONNUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNONNUMERICLITERAL, 0)
}

func (s *LiteralContext) FigurativeConstant() IFigurativeConstantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFigurativeConstantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFigurativeConstantContext)
}

func (s *LiteralContext) NumericLiteral() INumericLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumericLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumericLiteralContext)
}

func (s *LiteralContext) BooleanLiteral() IBooleanLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBooleanLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBooleanLiteralContext)
}

func (s *LiteralContext) CicsDfhRespLiteral() ICicsDfhRespLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICicsDfhRespLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICicsDfhRespLiteralContext)
}

func (s *LiteralContext) CicsDfhValueLiteral() ICicsDfhValueLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICicsDfhValueLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICicsDfhValueLiteralContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) Literal() (localctx ILiteralContext) {
	this := p
	_ = this

	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1172, Cobol85ParserRULE_literal)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6203)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 971, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6197)
			p.Match(Cobol85ParserNONNUMERICLITERAL)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6198)
			p.FigurativeConstant()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6199)
			p.NumericLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6200)
			p.BooleanLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6201)
			p.CicsDfhRespLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6202)
			p.CicsDfhValueLiteral()
		}

	}

	return localctx
}

// IBooleanLiteralContext is an interface to support dynamic dispatch.
type IBooleanLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBooleanLiteralContext differentiates from other interfaces.
	IsBooleanLiteralContext()
}

type BooleanLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBooleanLiteralContext() *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_booleanLiteral
	return p
}

func (*BooleanLiteralContext) IsBooleanLiteralContext() {}

func NewBooleanLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_booleanLiteral

	return p
}

func (s *BooleanLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BooleanLiteralContext) TRUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTRUE, 0)
}

func (s *BooleanLiteralContext) FALSE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserFALSE, 0)
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BooleanLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitBooleanLiteral(s)
	}
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) BooleanLiteral() (localctx IBooleanLiteralContext) {
	this := p
	_ = this

	localctx = NewBooleanLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1174, Cobol85ParserRULE_booleanLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6205)
		_la = p.GetTokenStream().LA(1)

		if !(_la == Cobol85ParserFALSE || _la == Cobol85ParserTRUE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// INumericLiteralContext is an interface to support dynamic dispatch.
type INumericLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsNumericLiteralContext differentiates from other interfaces.
	IsNumericLiteralContext()
}

type NumericLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumericLiteralContext() *NumericLiteralContext {
	var p = new(NumericLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_numericLiteral
	return p
}

func (*NumericLiteralContext) IsNumericLiteralContext() {}

func NewNumericLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumericLiteralContext {
	var p = new(NumericLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_numericLiteral

	return p
}

func (s *NumericLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumericLiteralContext) NUMERICLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNUMERICLITERAL, 0)
}

func (s *NumericLiteralContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *NumericLiteralContext) IntegerLiteral() IIntegerLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntegerLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntegerLiteralContext)
}

func (s *NumericLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumericLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumericLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitNumericLiteral(s)
	}
}

func (s *NumericLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitNumericLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) NumericLiteral() (localctx INumericLiteralContext) {
	this := p
	_ = this

	localctx = NewNumericLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1176, Cobol85ParserRULE_numericLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6210)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserNUMERICLITERAL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6207)
			p.Match(Cobol85ParserNUMERICLITERAL)
		}

	case Cobol85ParserZERO:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6208)
			p.Match(Cobol85ParserZERO)
		}

	case Cobol85ParserLEVEL_NUMBER_66, Cobol85ParserLEVEL_NUMBER_77, Cobol85ParserLEVEL_NUMBER_88, Cobol85ParserINTEGERLITERAL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6209)
			p.IntegerLiteral()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IIntegerLiteralContext is an interface to support dynamic dispatch.
type IIntegerLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsIntegerLiteralContext differentiates from other interfaces.
	IsIntegerLiteralContext()
}

type IntegerLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntegerLiteralContext() *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_integerLiteral
	return p
}

func (*IntegerLiteralContext) IsIntegerLiteralContext() {}

func NewIntegerLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntegerLiteralContext {
	var p = new(IntegerLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_integerLiteral

	return p
}

func (s *IntegerLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *IntegerLiteralContext) INTEGERLITERAL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserINTEGERLITERAL, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_66() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_66, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_77() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_77, 0)
}

func (s *IntegerLiteralContext) LEVEL_NUMBER_88() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLEVEL_NUMBER_88, 0)
}

func (s *IntegerLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntegerLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntegerLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitIntegerLiteral(s)
	}
}

func (s *IntegerLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitIntegerLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) IntegerLiteral() (localctx IIntegerLiteralContext) {
	this := p
	_ = this

	localctx = NewIntegerLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1178, Cobol85ParserRULE_integerLiteral)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6212)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-552)) & ^0x3f) == 0 && ((int64(1)<<(_la-552))&15) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICicsDfhRespLiteralContext is an interface to support dynamic dispatch.
type ICicsDfhRespLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCicsDfhRespLiteralContext differentiates from other interfaces.
	IsCicsDfhRespLiteralContext()
}

type CicsDfhRespLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCicsDfhRespLiteralContext() *CicsDfhRespLiteralContext {
	var p = new(CicsDfhRespLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cicsDfhRespLiteral
	return p
}

func (*CicsDfhRespLiteralContext) IsCicsDfhRespLiteralContext() {}

func NewCicsDfhRespLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CicsDfhRespLiteralContext {
	var p = new(CicsDfhRespLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cicsDfhRespLiteral

	return p
}

func (s *CicsDfhRespLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CicsDfhRespLiteralContext) DFHRESP() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHRESP, 0)
}

func (s *CicsDfhRespLiteralContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CicsDfhRespLiteralContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CicsDfhRespLiteralContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CicsDfhRespLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CicsDfhRespLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CicsDfhRespLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CicsDfhRespLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCicsDfhRespLiteral(s)
	}
}

func (s *CicsDfhRespLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCicsDfhRespLiteral(s)
	}
}

func (s *CicsDfhRespLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCicsDfhRespLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CicsDfhRespLiteral() (localctx ICicsDfhRespLiteralContext) {
	this := p
	_ = this

	localctx = NewCicsDfhRespLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1180, Cobol85ParserRULE_cicsDfhRespLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6214)
		p.Match(Cobol85ParserDFHRESP)
	}
	{
		p.SetState(6215)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(6218)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 973, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6216)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(6217)
			p.Literal()
		}

	}
	{
		p.SetState(6220)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// ICicsDfhValueLiteralContext is an interface to support dynamic dispatch.
type ICicsDfhValueLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCicsDfhValueLiteralContext differentiates from other interfaces.
	IsCicsDfhValueLiteralContext()
}

type CicsDfhValueLiteralContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCicsDfhValueLiteralContext() *CicsDfhValueLiteralContext {
	var p = new(CicsDfhValueLiteralContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_cicsDfhValueLiteral
	return p
}

func (*CicsDfhValueLiteralContext) IsCicsDfhValueLiteralContext() {}

func NewCicsDfhValueLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CicsDfhValueLiteralContext {
	var p = new(CicsDfhValueLiteralContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_cicsDfhValueLiteral

	return p
}

func (s *CicsDfhValueLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *CicsDfhValueLiteralContext) DFHVALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDFHVALUE, 0)
}

func (s *CicsDfhValueLiteralContext) LPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLPARENCHAR, 0)
}

func (s *CicsDfhValueLiteralContext) RPARENCHAR() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRPARENCHAR, 0)
}

func (s *CicsDfhValueLiteralContext) CobolWord() ICobolWordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICobolWordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICobolWordContext)
}

func (s *CicsDfhValueLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *CicsDfhValueLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CicsDfhValueLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CicsDfhValueLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCicsDfhValueLiteral(s)
	}
}

func (s *CicsDfhValueLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCicsDfhValueLiteral(s)
	}
}

func (s *CicsDfhValueLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCicsDfhValueLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CicsDfhValueLiteral() (localctx ICicsDfhValueLiteralContext) {
	this := p
	_ = this

	localctx = NewCicsDfhValueLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1182, Cobol85ParserRULE_cicsDfhValueLiteral)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(6222)
		p.Match(Cobol85ParserDFHVALUE)
	}
	{
		p.SetState(6223)
		p.Match(Cobol85ParserLPARENCHAR)
	}
	p.SetState(6226)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 974, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(6224)
			p.CobolWord()
		}

	case 2:
		{
			p.SetState(6225)
			p.Literal()
		}

	}
	{
		p.SetState(6228)
		p.Match(Cobol85ParserRPARENCHAR)
	}

	return localctx
}

// IFigurativeConstantContext is an interface to support dynamic dispatch.
type IFigurativeConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFigurativeConstantContext differentiates from other interfaces.
	IsFigurativeConstantContext()
}

type FigurativeConstantContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFigurativeConstantContext() *FigurativeConstantContext {
	var p = new(FigurativeConstantContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_figurativeConstant
	return p
}

func (*FigurativeConstantContext) IsFigurativeConstantContext() {}

func NewFigurativeConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FigurativeConstantContext {
	var p = new(FigurativeConstantContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_figurativeConstant

	return p
}

func (s *FigurativeConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *FigurativeConstantContext) ALL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserALL, 0)
}

func (s *FigurativeConstantContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *FigurativeConstantContext) HIGH_VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGH_VALUE, 0)
}

func (s *FigurativeConstantContext) HIGH_VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserHIGH_VALUES, 0)
}

func (s *FigurativeConstantContext) LOW_VALUE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOW_VALUE, 0)
}

func (s *FigurativeConstantContext) LOW_VALUES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLOW_VALUES, 0)
}

func (s *FigurativeConstantContext) NULL_() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNULL_, 0)
}

func (s *FigurativeConstantContext) NULLS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserNULLS, 0)
}

func (s *FigurativeConstantContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUOTE, 0)
}

func (s *FigurativeConstantContext) QUOTES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserQUOTES, 0)
}

func (s *FigurativeConstantContext) SPACE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPACE, 0)
}

func (s *FigurativeConstantContext) SPACES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSPACES, 0)
}

func (s *FigurativeConstantContext) ZERO() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZERO, 0)
}

func (s *FigurativeConstantContext) ZEROS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROS, 0)
}

func (s *FigurativeConstantContext) ZEROES() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserZEROES, 0)
}

func (s *FigurativeConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FigurativeConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FigurativeConstantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterFigurativeConstant(s)
	}
}

func (s *FigurativeConstantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitFigurativeConstant(s)
	}
}

func (s *FigurativeConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitFigurativeConstant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) FigurativeConstant() (localctx IFigurativeConstantContext) {
	this := p
	_ = this

	localctx = NewFigurativeConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1184, Cobol85ParserRULE_figurativeConstant)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6245)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserALL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6230)
			p.Match(Cobol85ParserALL)
		}
		{
			p.SetState(6231)
			p.Literal()
		}

	case Cobol85ParserHIGH_VALUE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6232)
			p.Match(Cobol85ParserHIGH_VALUE)
		}

	case Cobol85ParserHIGH_VALUES:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6233)
			p.Match(Cobol85ParserHIGH_VALUES)
		}

	case Cobol85ParserLOW_VALUE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6234)
			p.Match(Cobol85ParserLOW_VALUE)
		}

	case Cobol85ParserLOW_VALUES:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6235)
			p.Match(Cobol85ParserLOW_VALUES)
		}

	case Cobol85ParserNULL_:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6236)
			p.Match(Cobol85ParserNULL_)
		}

	case Cobol85ParserNULLS:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6237)
			p.Match(Cobol85ParserNULLS)
		}

	case Cobol85ParserQUOTE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6238)
			p.Match(Cobol85ParserQUOTE)
		}

	case Cobol85ParserQUOTES:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6239)
			p.Match(Cobol85ParserQUOTES)
		}

	case Cobol85ParserSPACE:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6240)
			p.Match(Cobol85ParserSPACE)
		}

	case Cobol85ParserSPACES:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6241)
			p.Match(Cobol85ParserSPACES)
		}

	case Cobol85ParserZERO:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6242)
			p.Match(Cobol85ParserZERO)
		}

	case Cobol85ParserZEROS:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6243)
			p.Match(Cobol85ParserZEROS)
		}

	case Cobol85ParserZEROES:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6244)
			p.Match(Cobol85ParserZEROES)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ISpecialRegisterContext is an interface to support dynamic dispatch.
type ISpecialRegisterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpecialRegisterContext differentiates from other interfaces.
	IsSpecialRegisterContext()
}

type SpecialRegisterContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpecialRegisterContext() *SpecialRegisterContext {
	var p = new(SpecialRegisterContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_specialRegister
	return p
}

func (*SpecialRegisterContext) IsSpecialRegisterContext() {}

func NewSpecialRegisterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpecialRegisterContext {
	var p = new(SpecialRegisterContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_specialRegister

	return p
}

func (s *SpecialRegisterContext) GetParser() antlr.Parser { return s.parser }

func (s *SpecialRegisterContext) ADDRESS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserADDRESS, 0)
}

func (s *SpecialRegisterContext) OF() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserOF, 0)
}

func (s *SpecialRegisterContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SpecialRegisterContext) DATE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDATE, 0)
}

func (s *SpecialRegisterContext) DAY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY, 0)
}

func (s *SpecialRegisterContext) DAY_OF_WEEK() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDAY_OF_WEEK, 0)
}

func (s *SpecialRegisterContext) DEBUG_CONTENTS() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_CONTENTS, 0)
}

func (s *SpecialRegisterContext) DEBUG_ITEM() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_ITEM, 0)
}

func (s *SpecialRegisterContext) DEBUG_LINE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_LINE, 0)
}

func (s *SpecialRegisterContext) DEBUG_NAME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_NAME, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_1() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_1, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_2() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_2, 0)
}

func (s *SpecialRegisterContext) DEBUG_SUB_3() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserDEBUG_SUB_3, 0)
}

func (s *SpecialRegisterContext) LENGTH() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLENGTH, 0)
}

func (s *SpecialRegisterContext) LINAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINAGE_COUNTER, 0)
}

func (s *SpecialRegisterContext) LINE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserLINE_COUNTER, 0)
}

func (s *SpecialRegisterContext) PAGE_COUNTER() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserPAGE_COUNTER, 0)
}

func (s *SpecialRegisterContext) RETURN_CODE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserRETURN_CODE, 0)
}

func (s *SpecialRegisterContext) SHIFT_IN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHIFT_IN, 0)
}

func (s *SpecialRegisterContext) SHIFT_OUT() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSHIFT_OUT, 0)
}

func (s *SpecialRegisterContext) SORT_CONTROL() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_CONTROL, 0)
}

func (s *SpecialRegisterContext) SORT_CORE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_CORE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_FILE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_FILE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_MESSAGE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MESSAGE, 0)
}

func (s *SpecialRegisterContext) SORT_MODE_SIZE() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_MODE_SIZE, 0)
}

func (s *SpecialRegisterContext) SORT_RETURN() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserSORT_RETURN, 0)
}

func (s *SpecialRegisterContext) TALLY() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTALLY, 0)
}

func (s *SpecialRegisterContext) TIME() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserTIME, 0)
}

func (s *SpecialRegisterContext) WHEN_COMPILED() antlr.TerminalNode {
	return s.GetToken(Cobol85ParserWHEN_COMPILED, 0)
}

func (s *SpecialRegisterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpecialRegisterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpecialRegisterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterSpecialRegister(s)
	}
}

func (s *SpecialRegisterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitSpecialRegister(s)
	}
}

func (s *SpecialRegisterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitSpecialRegister(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) SpecialRegister() (localctx ISpecialRegisterContext) {
	this := p
	_ = this

	localctx = NewSpecialRegisterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1186, Cobol85ParserRULE_specialRegister)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(6280)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case Cobol85ParserADDRESS:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(6247)
			p.Match(Cobol85ParserADDRESS)
		}
		{
			p.SetState(6248)
			p.Match(Cobol85ParserOF)
		}
		{
			p.SetState(6249)
			p.Identifier()
		}

	case Cobol85ParserDATE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(6250)
			p.Match(Cobol85ParserDATE)
		}

	case Cobol85ParserDAY:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(6251)
			p.Match(Cobol85ParserDAY)
		}

	case Cobol85ParserDAY_OF_WEEK:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(6252)
			p.Match(Cobol85ParserDAY_OF_WEEK)
		}

	case Cobol85ParserDEBUG_CONTENTS:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(6253)
			p.Match(Cobol85ParserDEBUG_CONTENTS)
		}

	case Cobol85ParserDEBUG_ITEM:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(6254)
			p.Match(Cobol85ParserDEBUG_ITEM)
		}

	case Cobol85ParserDEBUG_LINE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(6255)
			p.Match(Cobol85ParserDEBUG_LINE)
		}

	case Cobol85ParserDEBUG_NAME:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(6256)
			p.Match(Cobol85ParserDEBUG_NAME)
		}

	case Cobol85ParserDEBUG_SUB_1:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(6257)
			p.Match(Cobol85ParserDEBUG_SUB_1)
		}

	case Cobol85ParserDEBUG_SUB_2:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(6258)
			p.Match(Cobol85ParserDEBUG_SUB_2)
		}

	case Cobol85ParserDEBUG_SUB_3:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(6259)
			p.Match(Cobol85ParserDEBUG_SUB_3)
		}

	case Cobol85ParserLENGTH:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(6260)
			p.Match(Cobol85ParserLENGTH)
		}
		p.SetState(6262)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == Cobol85ParserOF {
			{
				p.SetState(6261)
				p.Match(Cobol85ParserOF)
			}

		}
		{
			p.SetState(6264)
			p.Identifier()
		}

	case Cobol85ParserLINAGE_COUNTER:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(6265)
			p.Match(Cobol85ParserLINAGE_COUNTER)
		}

	case Cobol85ParserLINE_COUNTER:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(6266)
			p.Match(Cobol85ParserLINE_COUNTER)
		}

	case Cobol85ParserPAGE_COUNTER:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(6267)
			p.Match(Cobol85ParserPAGE_COUNTER)
		}

	case Cobol85ParserRETURN_CODE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(6268)
			p.Match(Cobol85ParserRETURN_CODE)
		}

	case Cobol85ParserSHIFT_IN:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(6269)
			p.Match(Cobol85ParserSHIFT_IN)
		}

	case Cobol85ParserSHIFT_OUT:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(6270)
			p.Match(Cobol85ParserSHIFT_OUT)
		}

	case Cobol85ParserSORT_CONTROL:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(6271)
			p.Match(Cobol85ParserSORT_CONTROL)
		}

	case Cobol85ParserSORT_CORE_SIZE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(6272)
			p.Match(Cobol85ParserSORT_CORE_SIZE)
		}

	case Cobol85ParserSORT_FILE_SIZE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(6273)
			p.Match(Cobol85ParserSORT_FILE_SIZE)
		}

	case Cobol85ParserSORT_MESSAGE:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(6274)
			p.Match(Cobol85ParserSORT_MESSAGE)
		}

	case Cobol85ParserSORT_MODE_SIZE:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(6275)
			p.Match(Cobol85ParserSORT_MODE_SIZE)
		}

	case Cobol85ParserSORT_RETURN:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(6276)
			p.Match(Cobol85ParserSORT_RETURN)
		}

	case Cobol85ParserTALLY:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(6277)
			p.Match(Cobol85ParserTALLY)
		}

	case Cobol85ParserTIME:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(6278)
			p.Match(Cobol85ParserTIME)
		}

	case Cobol85ParserWHEN_COMPILED:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(6279)
			p.Match(Cobol85ParserWHEN_COMPILED)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICommentEntryContext is an interface to support dynamic dispatch.
type ICommentEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentEntryContext differentiates from other interfaces.
	IsCommentEntryContext()
}

type CommentEntryContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentEntryContext() *CommentEntryContext {
	var p = new(CommentEntryContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = Cobol85ParserRULE_commentEntry
	return p
}

func (*CommentEntryContext) IsCommentEntryContext() {}

func NewCommentEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentEntryContext {
	var p = new(CommentEntryContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = Cobol85ParserRULE_commentEntry

	return p
}

func (s *CommentEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentEntryContext) AllCOMMENTENTRYLINE() []antlr.TerminalNode {
	return s.GetTokens(Cobol85ParserCOMMENTENTRYLINE)
}

func (s *CommentEntryContext) COMMENTENTRYLINE(i int) antlr.TerminalNode {
	return s.GetToken(Cobol85ParserCOMMENTENTRYLINE, i)
}

func (s *CommentEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.EnterCommentEntry(s)
	}
}

func (s *CommentEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(Cobol85Listener); ok {
		listenerT.ExitCommentEntry(s)
	}
}

func (s *CommentEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case Cobol85Visitor:
		return t.VisitCommentEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *Cobol85Parser) CommentEntry() (localctx ICommentEntryContext) {
	this := p
	_ = this

	localctx = NewCommentEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 1188, Cobol85ParserRULE_commentEntry)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(6283)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == Cobol85ParserCOMMENTENTRYLINE {
		{
			p.SetState(6282)
			p.Match(Cobol85ParserCOMMENTENTRYLINE)
		}

		p.SetState(6285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}
